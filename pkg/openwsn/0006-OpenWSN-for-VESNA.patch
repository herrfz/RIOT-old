From 7129065a1e75bbf6a436cb851842f0441d04d6b5 Mon Sep 17 00:00:00 2001
From: Eriza Fazli <erizzaaaaa@gmail.com>
Date: Sun, 1 Mar 2015 15:34:46 +0100
Subject: [PATCH] OpenWSN for VESNA

---
 SConscript                                         |   14 +-
 SConstruct                                         |    3 +-
 bsp/boards/vesna/Makefile                          |  150 +
 bsp/boards/vesna/SConscript                        |   33 +
 bsp/boards/vesna/Systick.c                         |   11 +
 bsp/boards/vesna/Systick.h                         |    5 +
 bsp/boards/vesna/board.c                           |  112 +
 bsp/boards/vesna/board_info.h                      |   81 +
 bsp/boards/vesna/bsp_timer.c                       |  181 +
 bsp/boards/vesna/configure/stm32f10x_conf.h        |  180 +
 bsp/boards/vesna/configure/stm32f10x_it.c          |  874 ++
 bsp/boards/vesna/configure/stm32f10x_it.h          |  100 +
 bsp/boards/vesna/configure/stm32f10x_lib.h         |   77 +
 bsp/boards/vesna/debugpins.c                       |   42 +
 bsp/boards/vesna/eui64.c                           |   34 +
 bsp/boards/vesna/exti.c                            |   14 +
 bsp/boards/vesna/gpio.c                            |   44 +
 bsp/boards/vesna/gpio.h                            |   13 +
 bsp/boards/vesna/leds.c                            |  174 +
 .../Libraries/CMSIS/CM3/CoreSupport/core_cm3.c     |  784 ++
 .../Libraries/CMSIS/CM3/CoreSupport/core_cm3.h     | 1818 +++++
 .../DeviceSupport/ST/STM32F10x/Release_Notes.html  |  284 +
 .../startup/TrueSTUDIO/startup_stm32f10x_cl.s      |  473 ++
 .../startup/TrueSTUDIO/startup_stm32f10x_hd.s      |  469 ++
 .../startup/TrueSTUDIO/startup_stm32f10x_hd_vl.s   |  451 ++
 .../startup/TrueSTUDIO/startup_stm32f10x_ld.s      |  347 +
 .../startup/TrueSTUDIO/startup_stm32f10x_ld_vl.s   |  392 +
 .../startup/TrueSTUDIO/startup_stm32f10x_md.s      |  363 +
 .../startup/TrueSTUDIO/startup_stm32f10x_md_vl.s   |  408 +
 .../startup/TrueSTUDIO/startup_stm32f10x_xl.s      |  467 ++
 .../STM32F10x/startup/arm/startup_stm32f10x_cl.s   |  368 +
 .../STM32F10x/startup/arm/startup_stm32f10x_hd.s   |  358 +
 .../startup/arm/startup_stm32f10x_hd_vl.s          |  346 +
 .../STM32F10x/startup/arm/startup_stm32f10x_ld.s   |  297 +
 .../startup/arm/startup_stm32f10x_ld_vl.s          |  304 +
 .../STM32F10x/startup/arm/startup_stm32f10x_md.s   |  307 +
 .../startup/arm/startup_stm32f10x_md_vl.s          |  315 +
 .../STM32F10x/startup/arm/startup_stm32f10x_xl.s   |  358 +
 .../startup/gcc_ride7/startup_stm32f10x_cl.s       |  468 ++
 .../startup/gcc_ride7/startup_stm32f10x_hd.s       |  465 ++
 .../startup/gcc_ride7/startup_stm32f10x_hd_vl.s    |  442 ++
 .../startup/gcc_ride7/startup_stm32f10x_ld.s       |  343 +
 .../startup/gcc_ride7/startup_stm32f10x_ld_vl.s    |  383 +
 .../startup/gcc_ride7/startup_stm32f10x_md.s       |  358 +
 .../startup/gcc_ride7/startup_stm32f10x_md_vl.s    |  399 +
 .../startup/gcc_ride7/startup_stm32f10x_xl.s       |  465 ++
 .../STM32F10x/startup/iar/startup_stm32f10x_cl.s   |  507 ++
 .../STM32F10x/startup/iar/startup_stm32f10x_hd.s   |  496 ++
 .../startup/iar/startup_stm32f10x_hd_vl.s          |  461 ++
 .../STM32F10x/startup/iar/startup_stm32f10x_ld.s   |  366 +
 .../startup/iar/startup_stm32f10x_ld_vl.s          |  369 +
 .../STM32F10x/startup/iar/startup_stm32f10x_md.s   |  391 +
 .../startup/iar/startup_stm32f10x_md_vl.s          |  394 +
 .../STM32F10x/startup/iar/startup_stm32f10x_xl.s   |  496 ++
 .../CM3/DeviceSupport/ST/STM32F10x/stm32f10x.h     | 8336 ++++++++++++++++++++
 .../DeviceSupport/ST/STM32F10x/system_stm32f10x.c  | 1094 +++
 .../DeviceSupport/ST/STM32F10x/system_stm32f10x.h  |   98 +
 .../Libraries/CMSIS/CMSIS debug support.htm        |  243 +
 .../Libraries/CMSIS/CMSIS_changes.htm              |  320 +
 .../Libraries/CMSIS/Documentation/CMSIS_Core.htm   | 1337 ++++
 .../Libraries/CMSIS/License.doc                    |  Bin 0 -> 39936 bytes
 .../STM32F10x_StdPeriph_Driver/Release_Notes.html  |  342 +
 .../STM32F10x_StdPeriph_Driver/inc/misc.h          |  220 +
 .../STM32F10x_StdPeriph_Driver/inc/stm32f10x_adc.h |  483 ++
 .../STM32F10x_StdPeriph_Driver/inc/stm32f10x_bkp.h |  195 +
 .../STM32F10x_StdPeriph_Driver/inc/stm32f10x_can.h |  697 ++
 .../STM32F10x_StdPeriph_Driver/inc/stm32f10x_cec.h |  210 +
 .../STM32F10x_StdPeriph_Driver/inc/stm32f10x_crc.h |   94 +
 .../STM32F10x_StdPeriph_Driver/inc/stm32f10x_dac.h |  317 +
 .../inc/stm32f10x_dbgmcu.h                         |  119 +
 .../STM32F10x_StdPeriph_Driver/inc/stm32f10x_dma.h |  439 ++
 .../inc/stm32f10x_exti.h                           |  184 +
 .../inc/stm32f10x_flash.h                          |  426 +
 .../inc/stm32f10x_fsmc.h                           |  733 ++
 .../inc/stm32f10x_gpio.h                           |  385 +
 .../STM32F10x_StdPeriph_Driver/inc/stm32f10x_i2c.h |  684 ++
 .../inc/stm32f10x_iwdg.h                           |  140 +
 .../STM32F10x_StdPeriph_Driver/inc/stm32f10x_pwr.h |  156 +
 .../STM32F10x_StdPeriph_Driver/inc/stm32f10x_rcc.h |  727 ++
 .../STM32F10x_StdPeriph_Driver/inc/stm32f10x_rtc.h |  135 +
 .../inc/stm32f10x_sdio.h                           |  531 ++
 .../STM32F10x_StdPeriph_Driver/inc/stm32f10x_spi.h |  487 ++
 .../STM32F10x_StdPeriph_Driver/inc/stm32f10x_tim.h | 1164 +++
 .../inc/stm32f10x_usart.h                          |  412 +
 .../inc/stm32f10x_wwdg.h                           |  115 +
 .../STM32F10x_StdPeriph_Driver/src/misc.c          |  225 +
 .../STM32F10x_StdPeriph_Driver/src/stm32f10x_adc.c | 1307 +++
 .../STM32F10x_StdPeriph_Driver/src/stm32f10x_bkp.c |  308 +
 .../STM32F10x_StdPeriph_Driver/src/stm32f10x_can.c | 1415 ++++
 .../STM32F10x_StdPeriph_Driver/src/stm32f10x_cec.c |  433 +
 .../STM32F10x_StdPeriph_Driver/src/stm32f10x_crc.c |  160 +
 .../STM32F10x_StdPeriph_Driver/src/stm32f10x_dac.c |  571 ++
 .../src/stm32f10x_dbgmcu.c                         |  162 +
 .../STM32F10x_StdPeriph_Driver/src/stm32f10x_dma.c |  714 ++
 .../src/stm32f10x_exti.c                           |  269 +
 .../src/stm32f10x_flash.c                          | 1684 ++++
 .../src/stm32f10x_fsmc.c                           |  866 ++
 .../src/stm32f10x_gpio.c                           |  650 ++
 .../STM32F10x_StdPeriph_Driver/src/stm32f10x_i2c.c | 1331 ++++
 .../src/stm32f10x_iwdg.c                           |  190 +
 .../STM32F10x_StdPeriph_Driver/src/stm32f10x_pwr.c |  307 +
 .../STM32F10x_StdPeriph_Driver/src/stm32f10x_rcc.c | 1470 ++++
 .../STM32F10x_StdPeriph_Driver/src/stm32f10x_rtc.c |  359 +
 .../src/stm32f10x_sdio.c                           |  799 ++
 .../STM32F10x_StdPeriph_Driver/src/stm32f10x_spi.c |  908 +++
 .../STM32F10x_StdPeriph_Driver/src/stm32f10x_tim.c | 2890 +++++++
 .../src/stm32f10x_usart.c                          | 1058 +++
 .../src/stm32f10x_wwdg.c                           |  224 +
 .../Release_Notes.html                             | 1031 +++
 bsp/boards/vesna/nvic.c                            |  127 +
 bsp/boards/vesna/nvic.h                            |   30 +
 bsp/boards/vesna/radiotimer.c                      |  227 +
 bsp/boards/vesna/rcc.c                             |   94 +
 bsp/boards/vesna/rcc.h                             |   20 +
 bsp/boards/vesna/rtc_timer.c                       |  131 +
 bsp/boards/vesna/rtc_timer.h                       |   38 +
 bsp/boards/vesna/spi.c                             |  256 +
 bsp/boards/vesna/startup.s                         |  469 ++
 bsp/boards/vesna/stm32_flash.ld                    |  185 +
 bsp/boards/vesna/tools/debug.sh                    |   13 +
 bsp/boards/vesna/tools/flash.sh                    |   15 +
 bsp/boards/vesna/tools/openocd.cfg                 |    4 +
 bsp/boards/vesna/tools/vesna_jtag.cfg              |   13 +
 bsp/boards/vesna/uart.c                            |  142 +
 projects/vesna/.gitignore                          |    1 +
 projects/vesna/01bsp_bsp_timer/Makefile            |   50 +
 projects/vesna/01bsp_leds/Makefile                 |   50 +
 projects/vesna/01bsp_radio_tx/Makefile             |   46 +
 projects/vesna/01bsp_radiotimer/Makefile           |   50 +
 projects/vesna/01bsp_uart/Makefile                 |   13 +
 projects/vesna/02drv_opentimers/Makefile           |   49 +
 projects/vesna/03oos_openwsn/Makefile              |   47 +
 projects/vesna/SConscript                          |    5 +
 projects/vesna/SConscript.env                      |   29 +
 134 files changed, 60104 insertions(+), 8 deletions(-)
 create mode 100644 bsp/boards/vesna/Makefile
 create mode 100644 bsp/boards/vesna/SConscript
 create mode 100644 bsp/boards/vesna/Systick.c
 create mode 100644 bsp/boards/vesna/Systick.h
 create mode 100644 bsp/boards/vesna/board.c
 create mode 100644 bsp/boards/vesna/board_info.h
 create mode 100644 bsp/boards/vesna/bsp_timer.c
 create mode 100644 bsp/boards/vesna/configure/stm32f10x_conf.h
 create mode 100644 bsp/boards/vesna/configure/stm32f10x_it.c
 create mode 100644 bsp/boards/vesna/configure/stm32f10x_it.h
 create mode 100644 bsp/boards/vesna/configure/stm32f10x_lib.h
 create mode 100644 bsp/boards/vesna/debugpins.c
 create mode 100644 bsp/boards/vesna/eui64.c
 create mode 100644 bsp/boards/vesna/exti.c
 create mode 100644 bsp/boards/vesna/gpio.c
 create mode 100644 bsp/boards/vesna/gpio.h
 create mode 100644 bsp/boards/vesna/leds.c
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/CoreSupport/core_cm3.c
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/CoreSupport/core_cm3.h
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/Release_Notes.html
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_cl.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_hd.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_hd_vl.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_ld.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_ld_vl.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_md.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_md_vl.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_xl.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_cl.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_hd.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_hd_vl.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_ld.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_ld_vl.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_md.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_md_vl.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_xl.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_cl.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_hd.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_hd_vl.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_ld.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_ld_vl.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_md.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_md_vl.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_xl.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_cl.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_hd.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_hd_vl.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_ld.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_ld_vl.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_md.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_md_vl.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_xl.s
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/stm32f10x.h
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/system_stm32f10x.c
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/system_stm32f10x.h
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CMSIS debug support.htm
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CMSIS_changes.htm
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/Documentation/CMSIS_Core.htm
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/License.doc
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/Release_Notes.html
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/misc.h
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_adc.h
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_bkp.h
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_can.h
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_cec.h
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_crc.h
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_dac.h
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_dbgmcu.h
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_dma.h
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_exti.h
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_flash.h
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_fsmc.h
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_gpio.h
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_i2c.h
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_iwdg.h
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_pwr.h
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_rcc.h
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_rtc.h
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_sdio.h
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_spi.h
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_tim.h
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_usart.h
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_wwdg.h
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/misc.c
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_adc.c
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_bkp.c
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_can.c
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_cec.c
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_crc.c
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_dac.c
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_dbgmcu.c
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_dma.c
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_exti.c
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_flash.c
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_fsmc.c
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_gpio.c
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_i2c.c
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_iwdg.c
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_pwr.c
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_rcc.c
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_rtc.c
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_sdio.c
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_spi.c
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_tim.c
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_usart.c
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_wwdg.c
 create mode 100644 bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Release_Notes.html
 create mode 100644 bsp/boards/vesna/nvic.c
 create mode 100644 bsp/boards/vesna/nvic.h
 create mode 100644 bsp/boards/vesna/radiotimer.c
 create mode 100644 bsp/boards/vesna/rcc.c
 create mode 100644 bsp/boards/vesna/rcc.h
 create mode 100644 bsp/boards/vesna/rtc_timer.c
 create mode 100644 bsp/boards/vesna/rtc_timer.h
 create mode 100644 bsp/boards/vesna/spi.c
 create mode 100644 bsp/boards/vesna/startup.s
 create mode 100644 bsp/boards/vesna/stm32_flash.ld
 create mode 100755 bsp/boards/vesna/tools/debug.sh
 create mode 100755 bsp/boards/vesna/tools/flash.sh
 create mode 100644 bsp/boards/vesna/tools/openocd.cfg
 create mode 100644 bsp/boards/vesna/tools/vesna_jtag.cfg
 create mode 100644 bsp/boards/vesna/uart.c
 create mode 100644 projects/vesna/.gitignore
 create mode 100644 projects/vesna/01bsp_bsp_timer/Makefile
 create mode 100644 projects/vesna/01bsp_leds/Makefile
 create mode 100644 projects/vesna/01bsp_radio_tx/Makefile
 create mode 100644 projects/vesna/01bsp_radiotimer/Makefile
 create mode 100644 projects/vesna/01bsp_uart/Makefile
 create mode 100644 projects/vesna/02drv_opentimers/Makefile
 create mode 100644 projects/vesna/03oos_openwsn/Makefile
 create mode 100644 projects/vesna/SConscript
 create mode 100644 projects/vesna/SConscript.env

diff --git a/SConscript b/SConscript
index 27c029e..5a79df1 100644
--- a/SConscript
+++ b/SConscript
@@ -187,7 +187,7 @@ elif env['toolchain']=='iar-proj':

 elif env['toolchain']=='armgcc':

-    if env['board'] not in ['OpenMote-CC2538','iot-lab_M3']:
+    if env['board'] not in ['OpenMote-CC2538','iot-lab_M3', 'vesna']:
         raise SystemError('toolchain {0} can not be used for board {1}'.format(env['toolchain'],env['board']))

     if   env['board']=='OpenMote-CC2538':
@@ -225,7 +225,7 @@ elif env['toolchain']=='armgcc':
         env.Replace(NM           = 'arm-none-eabi-nm')
         env.Replace(SIZE         = 'arm-none-eabi-size')

-    elif env['board']=='iot-lab_M3':
+    elif env['board'] in ['iot-lab_M3', 'vesna']:

          # compiler (C)
         env.Replace(CC           = 'arm-none-eabi-gcc')
@@ -263,9 +263,9 @@ elif env['toolchain']=='armgcc':
         env.Append(LINKFLAGS     = '-mthumb')
         env.Append(LINKFLAGS     = '-mthumb-interwork')
         env.Append(LINKFLAGS     = '-nostartfiles')
-        env.Append(LINKFLAGS     = '-Tbsp/boards/iot-lab_M3/stm32_flash.ld')
-        env.Append(LINKFLAGS     = os.path.join('build','iot-lab_M3_armgcc','bsp','boards','iot-lab_M3','startup.o'))
-        env.Append(LINKFLAGS     = os.path.join('build','iot-lab_M3_armgcc','bsp','boards','iot-lab_M3','configure','stm32f10x_it.o'))
+        env.Append(LINKFLAGS     = '-Tbsp/boards/' + env['board'] + '/stm32_flash.ld')
+        env.Append(LINKFLAGS     = os.path.join('build',env['board']+'_armgcc','bsp','boards',env['board'],'startup.o'))
+        env.Append(LINKFLAGS     = os.path.join('build',env['board']+'_armgcc','bsp','boards',env['board'],'configure','stm32f10x_it.o'))
         # object manipulation
         env.Replace(OBJCOPY      = 'arm-none-eabi-objcopy')
         env.Replace(OBJDUMP      = 'arm-none-eabi-objdump')
@@ -352,9 +352,9 @@ else:

 def jtagUploadFunc(location):
     if env['toolchain']=='armgcc':
-        if env['board'] in ['iot-lab_M3']:
+        if env['board'] in ['iot-lab_M3', 'vesna']:
             return Builder(
-                action      = os.path.join('bsp','boards','iot-lab_M3','tools','flash.sh') + " $SOURCE",
+                action      = os.path.join('bsp','boards',env['board'],'tools','flash.sh') + " $SOURCE",
                 suffix      = '.phonyupload',
                 src_suffix  = '.ihex',
             )
diff --git a/SConstruct b/SConstruct
index 9a43b0b..93e412d 100644
--- a/SConstruct
+++ b/SConstruct
@@ -36,7 +36,7 @@ project:
     options, with the default value listed first.

     board          Board to build for. 'python' is for software simulation.
-                   telosb, wsn430v14, wsn430v13b, gina, z1, python, iot-lab_M3
+                   telosb, wsn430v14, wsn430v13b, gina, z1, python, iot-lab_M3, vesna

     toolchain      Toolchain implementation. The 'python' board requires gcc
                    (MinGW on Windows build host).
@@ -102,6 +102,7 @@ command_line_options = {
         'OpenMote-CC2538',
         'openmotestm',
         'iot-lab_M3',
+        'vesna',
         'agilefox',
         # misc.
         'python',
diff --git a/bsp/boards/vesna/Makefile b/bsp/boards/vesna/Makefile
new file mode 100644
index 0000000..1a025c1
--- /dev/null
+++ b/bsp/boards/vesna/Makefile
@@ -0,0 +1,150 @@
+#===============================================================================
+# Build variables
+#===============================================================================
+
+PREFIX			= arm-none-eabi-
+CC				= @$(PREFIX)gcc
+AR				= @$(PREFIX)ar
+CFLAGS			= -DHSE_VALUE=\(\(uint32_t\)16000000\) -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -ggdb -g3 -std=gnu99 -O0 -Wall -Wstrict-prototypes -mcpu=cortex-m3 $(FPU_USAGE) -mlittle-endian -mthumb -mthumb-interwork -nostartfiles
+ASFLAGS			= -ggdb -g3 -mcpu=cortex-m3 $(FPU_USAGE) -mlittle-endian
+AS				= @$(PREFIX)as
+LINK			= @$(PREFIX)gcc
+SIZE			= $(PREFIX)size
+OBJCOPY			= $(PREFIX)objcopy
+
+LINKFLAGS		= -DUSE_STDPERIPH_DRIVER -DUSE_STM32_DISCOVERY -g3 -ggdb -mcpu=cortex-m3 $(FPU_USAGE) -mlittle-endian -static -lgcc -mthumb -mthumb-interwork -nostartfiles -T$(BSP_DIR)/stm32_flash.ld
+
+FLASHER			= $(BSP_DIR)/tools/flash.sh
+FFLAGS			= $(BIN_DIR)/$(BIN)
+
+DEBUGGER		= $(BSP_DIR)/tools/debug.sh
+DFLAGS			= $(BIN_DIR)/$(ELF)
+
+#===============================================================================
+# Header files' folders
+#===============================================================================
+
+# STM32 CMSIS
+INC += -I$(BSP_DIR)/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc
+INC += -I$(BSP_DIR)/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x
+INC += -I$(BSP_DIR)/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/CoreSupport
+
+# vesna
+INC += -I$(BSP_DIR)/configure
+INC += -I$(BSP_DIR)
+
+# OpenWSN generic
+INC += -I$(OPENOS_DIR)/bsp/boards
+INC += -I$(OPENOS_DIR)/bsp/chips
+INC += -I$(OPENOS_DIR)/drivers/common
+INC += -I$(OPENOS_DIR)/openwsn
+
+# OpenOS
+INC += -I$(OPENOS_DIR)/kernel/openos
+
+# OpenWSN network
+INC += -I$(OPENOS_DIR)/openwsn/cross-layers
+INC += -I$(OPENOS_DIR)/openwsn/02a-MAClow
+INC += -I$(OPENOS_DIR)/openwsn/02b-MAChigh
+INC += -I$(OPENOS_DIR)/openwsn/02b-MAChigh
+INC += -I$(OPENOS_DIR)/openwsn/03a-IPHC
+INC += -I$(OPENOS_DIR)/openwsn/03b-IPv6
+INC += -I$(OPENOS_DIR)/openwsn/04-TRAN
+INC += -I$(OPENOS_DIR)/openwsn/07-App/rreg
+INC += -I$(OPENOS_DIR)/openwsn/07-App/rwellknown
+INC += -I$(OPENOS_DIR)/openwsn/07-App/rinfo
+INC += -I$(OPENOS_DIR)/openwsn/07-App/rleds
+INC += -I$(OPENOS_DIR)/openwsn/07-App/r6t
+INC += -I$(OPENOS_DIR)/openwsn/07-App/tcpinject
+INC += -I$(OPENOS_DIR)/openwsn/07-App/udpinject
+INC += -I$(OPENOS_DIR)/openwsn/07-App/ohlone
+INC += -I$(OPENOS_DIR)/openwsn/07-App/tcpecho
+INC += -I$(OPENOS_DIR)/openwsn/07-App/tcpprint
+INC += -I$(OPENOS_DIR)/openwsn/07-App/udpecho
+INC += -I$(OPENOS_DIR)/openwsn/07-App/udpprint
+INC += -I$(OPENOS_DIR)/openwsn/07-App/tcprand
+INC += -I$(OPENOS_DIR)/openwsn/07-App/udprand
+INC += -I$(OPENOS_DIR)/openwsn/07-App/udpstorm
+INC += -I$(OPENOS_DIR)/openwsn/07-App/udplatency
+
+# Chips
+INC += -I$(OPENOS_DIR)/bsp/chips/at86rf231
+
+#===============================================================================
+# Source files' folders
+#===============================================================================
+
+SRC_DIRS += $(OPENOS_DIR)/bsp/boards/vesna
+SRC_DIRS += $(OPENOS_DIR)/bsp/boards/vesna/configure
+SRC_DIRS += $(OPENOS_DIR)/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src
+SRC_DIRS += $(OPENOS_DIR)/bsp/chips/at86rf231
+
+#SRC_DIRS += $(OPENOS_DIR)/drivers/common
+#===============================================================================
+
+BIN = $(PROJECT).hex
+ELF = $(PROJECT).elf
+
+OPENOS_PATH	 = $(realpath $(OPENOS_DIR))
+CURRENT_PATH = $(realpath .)
+PROJECT_PATH = $(subst $(OPENOS_PATH),,$(CURRENT_PATH))
+
+BIN_ROOT_DIR = ./build/
+BIN_DIR = ./build/$(PROJECT_PATH)/
+
+OBJ_DIRS = $(addprefix $(BIN_DIR), $(SRC_DIRS))
+
+# Get source files from folders
+SRC = $(foreach sdir, $(SRC_DIRS), $(wildcard $(sdir)/*.c))
+
+# Add single source files
+SRC += $(SRC_FILES)
+OBJ_DIRS += $(addprefix $(BIN_DIR), $(dir $(SRC_FILES)))
+
+OBJ = $(patsubst %.c, $(BIN_DIR)%.o, $(SRC))
+DEP = $(OBJ:.o=.d)
+
+vpath %.c $(SRC_DIRS)
+
+.PHONY: all checkdirs clean
+
+all: checkdirs $(BIN)
+
+$(BIN): $(OBJ)
+	$(AS) $(ASFLAGS) $(INC) -c -o $(BIN_DIR)/startup.o $(BSP_DIR)/startup.s
+
+	$(LINK) $(BIN_DIR)startup.o -o $(BIN_DIR)/$(PROJECT).elf -Wl,--start-group -lm -Wl,--end-group -Wl,-Map=$(BIN_DIR)$(PROJECT).map $(LINKFLAGS) $^
+
+	$(OBJCOPY) -O ihex $(BIN_DIR)$(PROJECT).elf $(BIN_DIR)$(PROJECT).hex
+
+checkdirs: $(OBJ_DIRS)
+
+$(OBJ_DIRS):
+	@mkdir -p $@
+
+clean:
+	@rm -rf $(BIN_ROOT_DIR)
+
+flash: all
+	$(FLASHER) $(FFLAGS)
+
+debug: all
+	$(DEBUGGER) $(DFLAGS)
+
+
+-include $(DEP)
+
+define make-goal
+$1/%.o: %.c
+	$(CC) $(CFLAGS) $(ASFLAGS) $(INC) -c $$< -o $$@
+	$(CC) $(CFLAGS) $(ASFLAGS) $(INC) -MM $$< -MT $$@ -MT $$(<:.c=.o) -MF $$(patsubst %.o, %.d, $$@)
+endef
+define make-single-goal
+$1: $2
+	$(CC) $(CFLAGS) $(ASFLAGS) $(INC) -c $$< -o $$@
+	$(CC) $(CFLAGS) $(ASFLAGS) $(INC) -MM $$< -MT $$@ -MT $$(<:.c=.o) -MF $$(patsubst %.o, %.d, $$@)
+endef
+
+$(foreach bdir, $(OBJ_DIRS), $(eval $(call make-goal, $(bdir))))
+$(foreach srcfile, $(SRC_FILES), $(eval $(call make-single-goal, $(patsubst %.c,%.o,$(addprefix $(BIN_DIR), $(srcfile))), $(srcfile))))
+
diff --git a/bsp/boards/vesna/SConscript b/bsp/boards/vesna/SConscript
new file mode 100644
index 0000000..5e69ec0
--- /dev/null
+++ b/bsp/boards/vesna/SConscript
@@ -0,0 +1,33 @@
+import os
+
+Import('env')
+
+localEnv = env.Clone()
+
+# scons doesn't let us look to parent directories for source, so the
+# bsp/chips/at86rf231/radio.c is off limits from this file. To keep things
+# simple, each SConscript file in bsp/chips/* will return a list of objects
+# which can be appended to the source list. Don't forget to specify a variant_dir,
+# or else the build will occur directly in the chips directory.
+
+rf231 = localEnv.SConscript(
+    os.path.join('#','bsp','chips','at86rf231','SConscript'),
+    variant_dir = 'rf231',
+    exports     = {'env': env},
+)
+
+target   = 'libbsp'
+bsp_dir  = os.path.join('#','bsp','boards','vesna')
+source   = \
+    Glob('*.c') + \
+    Glob('*.s') + \
+    Glob('configure/*.c') + \
+    Glob('library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/*.c') + \
+    [rf231]
+
+libbsp = localEnv.Library(
+    target=target,
+    source=source,
+)
+
+Alias('libbsp', libbsp)
diff --git a/bsp/boards/vesna/Systick.c b/bsp/boards/vesna/Systick.c
new file mode 100644
index 0000000..1af37d9
--- /dev/null
+++ b/bsp/boards/vesna/Systick.c
@@ -0,0 +1,11 @@
+#include "stm32f10x_lib.h"
+
+unsigned char systik_i;
+unsigned char rtc_sig=1,rtc_play;
+
+void SysTickHandler(void);
+
+void OpenWSN_SysTick_Config(void)
+{
+  SysTick_Config(9000000);
+}
diff --git a/bsp/boards/vesna/Systick.h b/bsp/boards/vesna/Systick.h
new file mode 100644
index 0000000..b826120
--- /dev/null
+++ b/bsp/boards/vesna/Systick.h
@@ -0,0 +1,5 @@
+
+
+void SysTick_Config(void);
+extern unsigned char systik_i;
+extern unsigned char rtc_sig,rtc_play;
\ No newline at end of file
diff --git a/bsp/boards/vesna/board.c b/bsp/boards/vesna/board.c
new file mode 100644
index 0000000..6b04372
--- /dev/null
+++ b/bsp/boards/vesna/board.c
@@ -0,0 +1,112 @@
+/**
+\brief iot-lab_M3 definition of the "board" bsp module.
+
+\author Alaeddine Weslati <alaeddine.weslati@inria.fr>, January 2014.
+*/
+#include "stm32f10x_lib.h"
+#include "board.h"
+// bsp modules
+#include "leds.h"
+#include "uart.h"
+#include "spi.h"
+#include "bsp_timer.h"
+#include "radio.h"
+#include "radiotimer.h"
+#include "rcc.h"
+#include "nvic.h"
+#include "debugpins.h"
+#include "opentimers.h"
+#include "gpio.h"
+
+//=========================== main ============================================
+
+extern int mote_main(void);
+
+int main(void)
+{
+ return mote_main();
+}
+
+//=========================== public ==========================================
+
+void board_init()
+{
+  RCC_Configuration();//Configure rcc
+  NVIC_Configuration();//configure NVIC and Vector Table
+
+  //configure ALL GPIO to AIN to get lowest power
+  GPIO_Config_ALL_AIN();
+  //configuration GPIO to measure the time from sleep to 72MHz
+  GPIO_Configuration();
+
+  GPIO_InitTypeDef  GPIO_InitStructure;
+
+  //enable GPIOC and GPIOA, Clock
+  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC , ENABLE);
+  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA , ENABLE);
+
+  //Configure PA.02 as SLP_TR pin of RF
+  GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_2;
+  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
+  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
+  GPIO_Init(GPIOA, &GPIO_InitStructure);
+
+  //Configure PC.01 as RST pin of RF
+  GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_1;
+  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
+  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
+  GPIO_Init(GPIOC, &GPIO_InitStructure);
+
+  //set /RST pin high(never reset)
+  GPIO_SetBits(GPIOC, GPIO_Pin_1);
+
+  // Configure PC.04 as input floating (EXTI Line4)
+  GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_4;
+  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN_FLOATING;
+  GPIO_Init(GPIOC, &GPIO_InitStructure);
+
+  GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource4);//Connect EXTI Line4 to PC.4
+  EXTI_ClearITPendingBit(EXTI_Line4);
+
+  //Configures EXTI line 4 to generate an interrupt on rising edge
+  EXTI_InitTypeDef  EXTI_InitStructure;
+  EXTI_InitStructure.EXTI_Line    = EXTI_Line4;
+  EXTI_InitStructure.EXTI_Mode    = EXTI_Mode_Interrupt;
+  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
+  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
+  EXTI_Init(&EXTI_InitStructure);
+
+  // initialize board
+  leds_init();
+  uart_init();
+  spi_init();
+  bsp_timer_init();
+  radio_init();
+  radiotimer_init();
+  debugpins_init();
+  //enable nvic for the radio
+  NVIC_radio();
+}
+
+void board_sleep()
+{
+#if 0
+  uint16_t sleepTime = radiotimer_getPeriod() - radiotimer_getCapturedTime();
+  DBGMCU_Config(DBGMCU_STOP, ENABLE);
+
+  // Enable PWR and BKP clock
+  RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
+  // Desable the SRAM and FLITF clock in Stop mode
+  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_SRAM | RCC_AHBPeriph_FLITF, DISABLE);
+
+  PWR_EnterSTOPMode(PWR_Regulator_ON,PWR_STOPEntry_WFI);
+
+  if(sleepTime > 0)
+  opentimers_sleepTimeCompesation(sleepTime*2);
+#endif
+}
+
+void board_reset()
+{
+}
+
diff --git a/bsp/boards/vesna/board_info.h b/bsp/boards/vesna/board_info.h
new file mode 100644
index 0000000..ae5106e
--- /dev/null
+++ b/bsp/boards/vesna/board_info.h
@@ -0,0 +1,81 @@
+/**
+\brief iot-lab_M3 board information bsp module (based on openmoteSTM32 code).
+
+This module simply defines some strings describing the board, which CoAP uses
+to return the board's description.
+
+\author Thomas Watteyne <watteyne@eecs.berkeley.edu>, February 2012.
+\author Tengfei Chang <tengfei.chang@gmail.com>,  July 2012.
+\author Alaeddine Weslati <alaeddine.weslati@inria.fr>,  January 2014.
+*/
+
+#ifndef __BOARD_INFO_H
+#define __BOARD_INFO_H
+
+#include "stm32f10x_lib.h"
+#include "stdint.h"
+#include "string.h"
+
+//=========================== defines =========================================
+
+//TODO in case previous declaration fails in certain compilers. Remove this
+//one if it works with GNU GCC
+//#define PACK_START  _Pragma("pack(1)")
+//#define PACK_END    _Pragma("pack()")
+
+#define INTERRUPT_DECLARATION(); //no declaration
+#define DISABLE_INTERRUPTS()    __disable_irq();
+#define ENABLE_INTERRUPTS()     __enable_irq();
+
+//===== timer
+
+#define PORT_TIMER_WIDTH                    uint16_t
+#define PORT_RADIOTIMER_WIDTH               uint16_t
+
+#define PORT_SIGNED_INT_WIDTH               int16_t
+#define PORT_TICS_PER_MS                    32
+#define SCHEDULER_WAKEUP()                  EXTI->SWIER |= EXTI_Line1;
+#define SCHEDULER_ENABLE_INTERRUPT()        //enable in board use EXTI_Line1
+
+//===== pinout
+
+// [PA.2] radio SLP_TR_CNTL
+#define PORT_PIN_RADIO_SLP_TR_CNTL_HIGH()     GPIOA->ODR |= (1<<2);
+#define PORT_PIN_RADIO_SLP_TR_CNTL_LOW()      GPIOA->ODR &= ~(1<<2);
+// radio reset line
+// radio /RST
+#define PORT_PIN_RADIO_RESET_HIGH()       //GPIOC->ODR |= 0X0040;// nothing
+#define PORT_PIN_RADIO_RESET_LOW()        //GPIOC->ODR &= ~0X0040;// nothing
+//#define PORT_PIN_RADIO_RESET_LOW()            GPIOC->ODR &= ~(1<<1);
+
+//===== IEEE802154E timing
+// time-slot related
+#define PORT_TsSlotDuration                 491   // counter counts one extra count, see datasheet
+// execution speed related
+#define PORT_maxTxDataPrepare               66    // 2014us (measured 746us)
+#define PORT_maxRxAckPrepare                20    //  305us (measured  83us)
+#define PORT_maxRxDataPrepare               33    // 1007us (measured  84us)
+#define PORT_maxTxAckPrepare                30    //  305us (measured 219us)
+// radio speed related
+#define PORT_delayTx                        10     //  214us (measured 219us)
+#define PORT_delayRx                        0     //    0us (can not measure)
+// radio watchdog
+
+//===== adaptive_sync accuracy
+
+#define SYNC_ACCURACY                       2     // ticks
+
+//=========================== variables =======================================
+
+static const uint8_t rreg_uriquery[]        = "h=ucb";
+static const uint8_t infoBoardname[]        = "IOT-LAB_M3";
+static const uint8_t infouCName[]           = "STM32F103";
+static const uint8_t infoRadioName[]        = "AT86RF231";
+
+//=========================== prototypes ======================================
+
+//=========================== public ==========================================
+
+//=========================== private =========================================
+
+#endif
diff --git a/bsp/boards/vesna/bsp_timer.c b/bsp/boards/vesna/bsp_timer.c
new file mode 100644
index 0000000..2a0155f
--- /dev/null
+++ b/bsp/boards/vesna/bsp_timer.c
@@ -0,0 +1,181 @@
+/**
+\brief openmoteSTM32 definition of the "bsp_timer" bsp module.
+
+On openmoteSTM32, we use TIM2 for the bsp_timer module.
+
+\author Chang Tengfei <tengfei.chang@gmail.com>,  July 2012.
+*/
+#include "stm32f10x_lib.h"
+#include "string.h"
+#include "bsp_timer.h"
+#include "board.h"
+
+#include "rcc.h"
+#include "nvic.h"
+
+//=========================== defines =========================================
+
+//=========================== variables =======================================
+
+typedef struct {
+   bsp_timer_cbt    cb;
+   PORT_TIMER_WIDTH last_compare_value;
+} bsp_timer_vars_t;
+
+volatile bsp_timer_vars_t bsp_timer_vars;
+
+//=========================== prototypes ======================================
+
+//=========================== public ==========================================
+
+/**
+\brief Initialize this module.
+
+This functions starts the timer, i.e. the counter increments, but doesn't set
+any compare registers, so no interrupt will fire.
+*/
+void bsp_timer_init()
+{
+    // clear local variables
+    memset(&bsp_timer_vars,0,sizeof(bsp_timer_vars_t));
+
+    //Configure TIM2, Clock
+    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2 , ENABLE);
+
+    //Configure TIM2: Period = 0xffff, prescaler = 2303(72M/(2303+1) = 32.768KHz), CounterMode  = upCounting mode
+    TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure ;
+    TIM_TimeBaseStructure.TIM_Period        = 0xFFFF;
+    TIM_TimeBaseStructure.TIM_Prescaler     = 2303;;
+    TIM_TimeBaseStructure.TIM_ClockDivision = 0;
+    TIM_TimeBaseStructure.TIM_CounterMode   = TIM_CounterMode_Up;
+    TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
+
+    //Configure TIM2's out compare mode:  out compare mode = toggle, out compare value = 0 (useless before enable compare interrupt), enable TIM2_CH1
+    TIM_OCInitTypeDef TIM_OCInitStructure;
+    TIM_OCInitStructure.TIM_OCMode      = TIM_OCMode_Toggle;
+    TIM_OCInitStructure.TIM_Pulse       = 0;
+    TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
+    TIM_OCInitStructure.TIM_OCPolarity  = TIM_OCPolarity_High;
+    TIM_OC1Init(TIM2, &TIM_OCInitStructure);
+
+    //enable TIM2
+    TIM_Cmd(TIM2, ENABLE);
+    //disable interrupt
+    //bsp_timer_cancel_schedule();
+
+//    //Configure NVIC: Preemption Priority = 2 and Sub Priority = 1
+//    NVIC_InitTypeDef NVIC_InitStructure;
+//    NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQChannel;
+//    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
+//    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
+//    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
+//    NVIC_Init(&NVIC_InitStructure);
+}
+
+/**
+\brief Register a callback.
+
+\param cb The function to be called when a compare event happens.
+*/
+void bsp_timer_set_callback(bsp_timer_cbt cb)
+{
+   bsp_timer_vars.cb   = cb;
+   //enable nvic
+   NVIC_bsptimer();
+}
+
+/**
+\brief Reset the timer.
+
+This function does not stop the timer, it rather resets the value of the
+counter, and cancels a possible pending compare event.
+*/
+void bsp_timer_reset()
+{
+    // reset compare
+    TIM_SetCompare1(TIM2,0);
+
+    //enable compare interrupt
+    TIM_ClearFlag(TIM2, TIM_FLAG_CC1);
+    TIM_ITConfig(TIM2, TIM_IT_CC1, ENABLE);
+
+    // reset timer
+    TIM_SetCounter(TIM2,0);
+
+    // record last timer compare value
+    bsp_timer_vars.last_compare_value =  0;
+}
+
+/**
+\brief Schedule the callback to be called in some specified time.
+
+The delay is expressed relative to the last compare event. It doesn't matter
+how long it took to call this function after the last compare, the timer will
+expire precisely delayTicks after the last one.
+
+The only possible problem is that it took so long to call this function that
+the delay specified is shorter than the time already elapsed since the last
+compare. In that case, this function triggers the interrupt to fire right away.
+
+This means that the interrupt may fire a bit off, but this inaccuracy does not
+propagate to subsequent timers.
+
+\param delayTicks Number of ticks before the timer expired, relative to the
+                  last compare event.
+*/
+void bsp_timer_scheduleIn(PORT_TIMER_WIDTH delayTicks)
+{
+   PORT_TIMER_WIDTH newCompareValue;
+   PORT_TIMER_WIDTH temp_last_compare_value;
+   //enable it if not enabled.
+   TIM_Cmd(TIM2, ENABLE);
+
+   temp_last_compare_value = bsp_timer_vars.last_compare_value;
+
+   newCompareValue = bsp_timer_vars.last_compare_value+delayTicks;
+   bsp_timer_vars.last_compare_value = newCompareValue;
+
+   if (delayTicks < (TIM_GetCounter(TIM2)-temp_last_compare_value))
+   {
+      // setting the interrupt flag triggers an interrupt
+        TIM2->SR |= (u16)TIM_FLAG_CC1;
+   }
+   else
+   {
+      // this is the normal case, have timer expire at newCompareValue
+      TIM_SetCompare1(TIM2,newCompareValue);
+      TIM_ClearFlag(TIM2, TIM_FLAG_CC1);
+      TIM_ITConfig(TIM2, TIM_IT_CC1, ENABLE);
+   }
+}
+
+/**
+\brief Cancel a running compare.
+*/
+void bsp_timer_cancel_schedule()
+{
+    TIM_SetCompare1(TIM2,0);
+    TIM_ITConfig(TIM2, TIM_IT_CC1, DISABLE);
+}
+
+/**
+\brief Return the current value of the timer's counter.
+
+\returns The current value of the timer's counter.
+*/
+PORT_TIMER_WIDTH bsp_timer_get_currentValue()
+{
+   return TIM_GetCounter(TIM2);
+}
+
+//=========================== private =========================================
+
+//=========================== interrupt handlers ==============================
+
+kick_scheduler_t bsp_timer_isr()
+{
+   // call the callback
+   bsp_timer_vars.cb();
+   // kick the OS
+   return KICK_SCHEDULER;
+}
diff --git a/bsp/boards/vesna/configure/stm32f10x_conf.h b/bsp/boards/vesna/configure/stm32f10x_conf.h
new file mode 100644
index 0000000..d292474
--- /dev/null
+++ b/bsp/boards/vesna/configure/stm32f10x_conf.h
@@ -0,0 +1,180 @@
+/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
+* File Name          : stm32f10x_conf.h
+* Author             : MCD Application Team
+* Version            : V2.0.3
+* Date               : 09/22/2008
+* Description        : Library configuration file.
+********************************************************************************
+* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*******************************************************************************/
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F10x_CONF_H
+#define __STM32F10x_CONF_H
+
+/* Includes ------------------------------------------------------------------*/
+//#include "stm32f10x_type.h"
+
+/* Exported types ------------------------------------------------------------*/
+/* Exported constants --------------------------------------------------------*/
+/* Uncomment the line below to compile the library in DEBUG mode, this will expanse
+   the "assert_param" macro in the firmware library code (see "Exported macro"
+   section below) */
+/* #define DEBUG    1*/
+
+/* Comment the line below to disable the specific peripheral inclusion */
+/************************************* ADC ************************************/
+#define _ADC
+#define _ADC1
+#define _ADC2
+#define _ADC3
+
+/************************************* BKP ************************************/
+#define _BKP
+
+/************************************* CAN ************************************/
+#define _CAN
+
+/************************************* CRC ************************************/
+#define _CRC
+
+/************************************* DAC ************************************/
+#define _DAC
+
+/************************************* DBGMCU *********************************/
+#define _DBGMCU
+
+/************************************* DMA ************************************/
+#define _DMA
+#define _DMA1_Channel1
+#define _DMA1_Channel2
+#define _DMA1_Channel3
+#define _DMA1_Channel4
+#define _DMA1_Channel5
+#define _DMA1_Channel6
+#define _DMA1_Channel7
+#define _DMA2_Channel1
+#define _DMA2_Channel2
+#define _DMA2_Channel3
+#define _DMA2_Channel4
+#define _DMA2_Channel5
+
+/************************************* EXTI ***********************************/
+#define _EXTI
+
+/************************************* FLASH and Option Bytes *****************/
+#define _FLASH
+/* Uncomment the line below to enable FLASH program/erase/protections functions,
+   otherwise only FLASH configuration (latency, prefetch, half cycle) functions
+   are enabled */
+#define _FLASH_PROG
+
+/************************************* FSMC ***********************************/
+#define _FSMC
+
+/************************************* GPIO ***********************************/
+#define _GPIO
+#define _GPIOA
+#define _GPIOB
+#define _GPIOC
+#define _GPIOD
+#define _GPIOE
+#define _GPIOF
+#define _GPIOG
+#define _AFIO
+
+/************************************* I2C ************************************/
+#define _I2C
+#define _I2C1
+#define _I2C2
+
+/************************************* IWDG ***********************************/
+#define _IWDG
+
+/************************************* NVIC ***********************************/
+#define _NVIC
+
+/************************************* PWR ************************************/
+#define _PWR
+
+/************************************* RCC ************************************/
+#define _RCC
+
+/************************************* RTC ************************************/
+#define _RTC
+
+/************************************* SDIO ***********************************/
+#define _SDIO
+
+/************************************* SPI ************************************/
+#define _SPI
+#define _SPI1
+#define _SPI2
+#define _SPI3
+
+/************************************* SysTick ********************************/
+#define _SysTick
+
+/************************************* TIM ************************************/
+#define _TIM
+#define _TIM1
+#define _TIM2
+#define _TIM3
+#define _TIM4
+#define _TIM5
+#define _TIM6
+#define _TIM7
+#define _TIM8
+
+/************************************* USART **********************************/
+#define _USART
+#define _USART1
+#define _USART2
+#define _USART3
+#define _UART4
+#define _UART5
+
+/************************************* WWDG ***********************************/
+#define _WWDG
+
+/* In the following line adjust the value of External High Speed oscillator (HSE)
+   used in your application */
+#ifdef HSE_Value
+#undef HSE_Value
+#endif
+#define HSE_Value    ((u32)16000000) /* Value of the External oscillator in Hz*/
+
+/* In the following line adjust the External High Speed oscillator (HSE) Startup
+   Timeout value */
+#ifdef HSEStartUp_TimeOut
+#undef HSEStartUp_TimeOut
+#endif
+#define HSEStartUp_TimeOut    ((u16)0x0500) /* Time out for HSE start up */
+
+/* Exported macro ------------------------------------------------------------*/
+#ifdef  DEBUG
+/*******************************************************************************
+* Macro Name     : assert_param
+* Description    : The assert_param macro is used for function's parameters check.
+*                  It is used only if the library is compiled in DEBUG mode.
+* Input          : - expr: If expr is false, it calls assert_failed function
+*                    which reports the name of the source file and the source
+*                    line number of the call that failed.
+*                    If expr is true, it returns no value.
+* Return         : None
+*******************************************************************************/
+  #define assert_param(expr) ((expr) ? (void)0 : assert_failed((u8 *)__FILE__, __LINE__))
+/* Exported functions ------------------------------------------------------- */
+  void assert_failed(u8* file, u32 line);
+#else
+  #define assert_param(expr) ((void)0)
+#endif /* DEBUG */
+
+#endif /* __STM32F10x_CONF_H */
+
+/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/configure/stm32f10x_it.c b/bsp/boards/vesna/configure/stm32f10x_it.c
new file mode 100644
index 0000000..6ea3425
--- /dev/null
+++ b/bsp/boards/vesna/configure/stm32f10x_it.c
@@ -0,0 +1,874 @@
+/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
+* File Name          : stm32f10x_it.c
+* Author             : MCD Application Team
+* Version            : V2.0.3
+* Date               : 09/22/2008
+* Description        : Main Interrupt Service Routines.
+*                      This file provides template for all exceptions handler
+*                      and peripherals interrupt service routine.
+********************************************************************************
+* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*******************************************************************************/
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x_it.h"
+#include "leds.h"
+#include "bsp_timer.h"
+#include "radiotimer.h"
+#include "spi.h"
+#include "radio.h"
+#include "rtc_timer.h"
+#include "uart.h"
+#include "debugpins.h"
+#include "rcc.h"
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/*******************************************************************************
+* Function Name  : NMIException
+* Description    : This function handles NMI exception.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void NMIException(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : HardFaultException
+* Description    : This function handles Hard Fault exception.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void HardFaultException(void)
+{
+  /* Go to infinite loop when Hard Fault exception occurs */
+  while (1)
+  {
+  }
+}
+
+/*******************************************************************************
+* Function Name  : MemManageException
+* Description    : This function handles Memory Manage exception.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void MemManageException(void)
+{
+  /* Go to infinite loop when Memory Manage exception occurs */
+  while (1)
+  {
+  }
+}
+
+/*******************************************************************************
+* Function Name  : BusFaultException
+* Description    : This function handles Bus Fault exception.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void BusFaultException(void)
+{
+  /* Go to infinite loop when Bus Fault exception occurs */
+  while (1)
+  {
+  }
+}
+
+/*******************************************************************************
+* Function Name  : UsageFaultException
+* Description    : This function handles Usage Fault exception.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void UsageFaultException(void)
+{
+  /* Go to infinite loop when Usage Fault exception occurs */
+  while (1)
+  {
+  }
+}
+
+/*******************************************************************************
+* Function Name  : DebugMonitor
+* Description    : This function handles Debug Monitor exception.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void DebugMonitor(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : SVCHandler
+* Description    : This function handles SVCall exception.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SVCHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : PendSVC
+* Description    : This function handles PendSVC exception.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void PendSVC(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : SysTickHandler
+* Description    : This function handles SysTick Handler.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SysTickHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : WWDG_IRQHandler
+* Description    : This function handles WWDG interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void WWDG_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : PVD_IRQHandler
+* Description    : This function handles PVD interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void PVD_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : TAMPER_IRQHandler
+* Description    : This function handles Tamper interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TAMPER_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : RTC_IRQHandler
+* Description    : This function handles RTC global interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RTC_IRQHandler(void)
+{
+    if(RTC_GetFlagStatus(RTC_IT_ALR) != RESET)
+    {
+      RTC_ClearITPendingBit(RTC_IT_ALR);      //Clear RTC Alarm interrupt pending bit
+      RTC_WaitForLastTask();                  //Wait until last write operation on RTC registers has finished
+    }
+}
+
+/*******************************************************************************
+* Function Name  : FLASH_IRQHandler
+* Description    : This function handles Flash interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void FLASH_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : RCC_IRQHandler
+* Description    : This function handles RCC interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RCC_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : EXTI0_IRQHandler
+* Description    : This function handles External interrupt Line 0 request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void EXTI0_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : EXTI1_IRQHandler
+* Description    : This function handles External interrupt Line 1 request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void EXTI1_IRQHandler(void)
+{
+
+}
+
+/*******************************************************************************
+* Function Name  : EXTI2_IRQHandler
+* Description    : This function handles External interrupt Line 2 request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void EXTI2_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : EXTI3_IRQHandler
+* Description    : This function handles External interrupt Line 3 request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void EXTI3_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : EXTI4_IRQHandler
+* Description    : This function handles External interrupt Line 4 request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void EXTI4_IRQHandler(void)
+{
+  if(EXTI_GetITStatus(EXTI_Line4) != RESET){
+    debugpins_isr_set();
+
+    //leds_error_toggle();
+    EXTI_ClearITPendingBit(EXTI_Line4);
+
+    //RCC_Wakeup();
+    radio_isr();
+
+    debugpins_isr_clr();
+  }
+}
+
+/*******************************************************************************
+* Function Name  : DMA1_Channel1_IRQHandler
+* Description    : This function handles DMA1 Channel 1 interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void DMA1_Channel1_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : DMA1_Channel2_IRQHandler
+* Description    : This function handles DMA1 Channel 2 interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void DMA1_Channel2_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : DMA1_Channel3_IRQHandler
+* Description    : This function handles DMA1 Channel 3 interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void DMA1_Channel3_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : DMA1_Channel4_IRQHandler
+* Description    : This function handles DMA1 Channel 4 interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void DMA1_Channel4_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : DMA1_Channel5_IRQHandler
+* Description    : This function handles DMA1 Channel 5 interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void DMA1_Channel5_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : DMA1_Channel6_IRQHandler
+* Description    : This function handles DMA1 Channel 6 interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void DMA1_Channel6_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : DMA1_Channel7_IRQHandler
+* Description    : This function handles DMA1 Channel 7 interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void DMA1_Channel7_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : ADC1_2_IRQHandler
+* Description    : This function handles ADC1 and ADC2 global interrupts requests.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void ADC1_2_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : USB_HP_CAN_TX_IRQHandler
+* Description    : This function handles USB High Priority or CAN TX interrupts
+*                  requests.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void USB_HP_CAN_TX_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : USB_LP_CAN_RX0_IRQHandler
+* Description    : This function handles USB Low Priority or CAN RX0 interrupts
+*                  requests.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void USB_LP_CAN_RX0_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : CAN_RX1_IRQHandler
+* Description    : This function handles CAN RX1 interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void CAN_RX1_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : CAN_SCE_IRQHandler
+* Description    : This function handles CAN SCE interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void CAN_SCE_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : EXTI9_5_IRQHandler
+* Description    : This function handles External lines 9 to 5 interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void EXTI9_5_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : TIM1_BRK_IRQHandler
+* Description    : This function handles TIM1 Break interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM1_BRK_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : TIM1_UP_IRQHandler
+* Description    : This function handles TIM1 overflow and update interrupt
+*                  request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM1_UP_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : TIM1_TRG_COM_IRQHandler
+* Description    : This function handles TIM1 Trigger and commutation interrupts
+*                  requests.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM1_TRG_COM_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : TIM1_CC_IRQHandler
+* Description    : This function handles TIM1 capture compare interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM1_CC_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : TIM2_IRQHandler
+* Description    : This function handles TIM2 global interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM2_IRQHandler(void)
+{
+  debugpins_isr_set();
+  if(TIM_GetFlagStatus(TIM2,TIM_FLAG_CC1) != RESET)
+  {
+    TIM_ClearFlag(TIM2,TIM_FLAG_CC1);
+    //leds_error_toggle();
+    bsp_timer_isr();
+  }
+  debugpins_isr_clr();
+}
+
+/*******************************************************************************
+* Function Name  : TIM3_IRQHandler
+* Description    : This function handles TIM3 global interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM3_IRQHandler(void)
+{
+  if(TIM_GetFlagStatus(TIM3,TIM_FLAG_CC1) != RESET)
+  {
+    TIM_ClearFlag(TIM3,TIM_FLAG_CC1);
+  }
+}
+
+/*******************************************************************************
+* Function Name  : TIM4_IRQHandler
+* Description    : This function handles TIM4 global interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM4_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : I2C1_EV_IRQHandler
+* Description    : This function handles I2C1 Event interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void I2C1_EV_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : I2C1_ER_IRQHandler
+* Description    : This function handles I2C1 Error interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void I2C1_ER_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : I2C2_EV_IRQHandler
+* Description    : This function handles I2C2 Event interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void I2C2_EV_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : I2C2_ER_IRQHandler
+* Description    : This function handles I2C2 Error interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void I2C2_ER_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : SPI1_IRQHandler
+* Description    : This function handles SPI1 global interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SPI1_IRQHandler(void)
+{
+  debugpins_isr_set();
+  if(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_RXNE) != RESET)
+  {
+    spi_isr();
+  }
+  debugpins_isr_clr();
+}
+
+/*******************************************************************************
+* Function Name  : SPI2_IRQHandler
+* Description    : This function handles SPI2 global interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SPI2_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : USART1_IRQHandler
+* Description    : This function handles USART1 global interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void USART1_IRQHandler(void)
+{
+  debugpins_isr_set();
+  if(USART_GetFlagStatus(USART1, USART_FLAG_RXNE) != RESET)
+  {
+    USART_ClearFlag(USART1, USART_FLAG_RXNE);
+
+    uart_rx_isr();
+  }
+
+  if(USART_GetFlagStatus(USART1, USART_FLAG_TXE) != RESET)
+  {
+    uart_tx_isr();
+  }
+  debugpins_isr_clr();
+}
+
+/*******************************************************************************
+* Function Name  : USART2_IRQHandler
+* Description    : This function handles USART2 global interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void USART2_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : USART3_IRQHandler
+* Description    : This function handles USART3 global interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void USART3_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : EXTI15_10_IRQHandler
+* Description    : This function handles External lines 15 to 10 interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void EXTI15_10_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : RTCAlarm_IRQHandler
+* Description    : This function handles RTC Alarm interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RTCAlarm_IRQHandler(void)
+{
+  debugpins_isr_set();
+  if(EXTI_GetITStatus(EXTI_Line17) != RESET)
+  {
+	EXTI_ClearITPendingBit(EXTI_Line17);
+        radiotimer_isr();
+  }
+  debugpins_isr_clr();
+}
+
+/*******************************************************************************
+* Function Name  : USBWakeUp_IRQHandler
+* Description    : This function handles USB WakeUp interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void USBWakeUp_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : TIM8_BRK_IRQHandler
+* Description    : This function handles TIM8 Break interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM8_BRK_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : TIM8_UP_IRQHandler
+* Description    : This function handles TIM8 overflow and update interrupt
+*                  request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM8_UP_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : TIM8_TRG_COM_IRQHandler
+* Description    : This function handles TIM8 Trigger and commutation interrupts
+*                  requests.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM8_TRG_COM_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : TIM8_CC_IRQHandler
+* Description    : This function handles TIM8 capture compare interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM8_CC_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : ADC3_IRQHandler
+* Description    : This function handles ADC3 global interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void ADC3_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : FSMC_IRQHandler
+* Description    : This function handles FSMC global interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void FSMC_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : SDIO_IRQHandler
+* Description    : This function handles SDIO global interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SDIO_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : TIM5_IRQHandler
+* Description    : This function handles TIM5 global interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM5_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : SPI3_IRQHandler
+* Description    : This function handles SPI3 global interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SPI3_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : UART4_IRQHandler
+* Description    : This function handles UART4 global interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void UART4_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : UART5_IRQHandler
+* Description    : This function handles UART5 global interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void UART5_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : TIM6_IRQHandler
+* Description    : This function handles TIM6 global interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM6_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : TIM7_IRQHandler
+* Description    : This function handles TIM7 global interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM7_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : DMA2_Channel1_IRQHandler
+* Description    : This function handles DMA2 Channel 1 interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void DMA2_Channel1_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : DMA2_Channel2_IRQHandler
+* Description    : This function handles DMA2 Channel 2 interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void DMA2_Channel2_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : DMA2_Channel3_IRQHandler
+* Description    : This function handles DMA2 Channel 3 interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void DMA2_Channel3_IRQHandler(void)
+{
+}
+
+/*******************************************************************************
+* Function Name  : DMA2_Channel4_5_IRQHandler
+* Description    : This function handles DMA2 Channel 4 and DMA2 Channel 5
+*                  interrupt request.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void DMA2_Channel4_5_IRQHandler(void)
+{
+}
+
+/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/configure/stm32f10x_it.h b/bsp/boards/vesna/configure/stm32f10x_it.h
new file mode 100644
index 0000000..898472b
--- /dev/null
+++ b/bsp/boards/vesna/configure/stm32f10x_it.h
@@ -0,0 +1,100 @@
+/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
+* File Name          : stm32f10x_it.h
+* Author             : MCD Application Team
+* Version            : V2.0.3
+* Date               : 09/22/2008
+* Description        : This file contains the headers of the interrupt handlers.
+********************************************************************************
+* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*******************************************************************************/
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F10x_IT_H
+#define __STM32F10x_IT_H
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x_lib.h"
+
+/* Exported types ------------------------------------------------------------*/
+/* Exported constants --------------------------------------------------------*/
+/* Exported macro ------------------------------------------------------------*/
+/* Exported functions ------------------------------------------------------- */
+
+void NMIException(void);
+void HardFaultException(void);
+void MemManageException(void);
+void BusFaultException(void);
+void UsageFaultException(void);
+void DebugMonitor(void);
+void SVCHandler(void);
+void PendSVC(void);
+void SysTickHandler(void);
+void WWDG_IRQHandler(void);
+void PVD_IRQHandler(void);
+void TAMPER_IRQHandler(void);
+void RTC_IRQHandler(void);
+void FLASH_IRQHandler(void);
+void RCC_IRQHandler(void);
+void EXTI0_IRQHandler(void);
+void EXTI1_IRQHandler(void);
+void EXTI2_IRQHandler(void);
+void EXTI3_IRQHandler(void);
+void EXTI4_IRQHandler(void);
+void DMA1_Channel1_IRQHandler(void);
+void DMA1_Channel2_IRQHandler(void);
+void DMA1_Channel3_IRQHandler(void);
+void DMA1_Channel4_IRQHandler(void);
+void DMA1_Channel5_IRQHandler(void);
+void DMA1_Channel6_IRQHandler(void);
+void DMA1_Channel7_IRQHandler(void);
+void ADC1_2_IRQHandler(void);
+void USB_HP_CAN_TX_IRQHandler(void);
+void USB_LP_CAN_RX0_IRQHandler(void);
+void CAN_RX1_IRQHandler(void);
+void CAN_SCE_IRQHandler(void);
+void EXTI9_5_IRQHandler(void);
+void TIM1_BRK_IRQHandler(void);
+void TIM1_UP_IRQHandler(void);
+void TIM1_TRG_COM_IRQHandler(void);
+void TIM1_CC_IRQHandler(void);
+void TIM2_IRQHandler(void);
+void TIM3_IRQHandler(void);
+void TIM4_IRQHandler(void);
+void I2C1_EV_IRQHandler(void);
+void I2C1_ER_IRQHandler(void);
+void I2C2_EV_IRQHandler(void);
+void I2C2_ER_IRQHandler(void);
+void SPI1_IRQHandler(void);
+void SPI2_IRQHandler(void);
+void USART1_IRQHandler(void);
+void USART2_IRQHandler(void);
+void USART3_IRQHandler(void);
+void EXTI15_10_IRQHandler(void);
+void RTCAlarm_IRQHandler(void);
+void USBWakeUp_IRQHandler(void);
+void TIM8_BRK_IRQHandler(void);
+void TIM8_UP_IRQHandler(void);
+void TIM8_TRG_COM_IRQHandler(void);
+void TIM8_CC_IRQHandler(void);
+void ADC3_IRQHandler(void);
+void FSMC_IRQHandler(void);
+void SDIO_IRQHandler(void);
+void TIM5_IRQHandler(void);
+void SPI3_IRQHandler(void);
+void UART4_IRQHandler(void);
+void UART5_IRQHandler(void);
+void TIM6_IRQHandler(void);
+void TIM7_IRQHandler(void);
+void DMA2_Channel1_IRQHandler(void);
+void DMA2_Channel2_IRQHandler(void);
+void DMA2_Channel3_IRQHandler(void);
+void DMA2_Channel4_5_IRQHandler(void);
+
+#endif /* __STM32F10x_IT_H */
+
+/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/configure/stm32f10x_lib.h b/bsp/boards/vesna/configure/stm32f10x_lib.h
new file mode 100644
index 0000000..59549e3
--- /dev/null
+++ b/bsp/boards/vesna/configure/stm32f10x_lib.h
@@ -0,0 +1,77 @@
+/**
+  ******************************************************************************
+  * @file    Project/STM32F10x_StdPeriph_Template/stm32f10x_conf.h
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    08-April-2011
+  * @brief   Library configuration file.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F10x_CONF_H
+#define __STM32F10x_CONF_H
+
+/* Includes ------------------------------------------------------------------*/
+/* Uncomment/Comment the line below to enable/disable peripheral header file inclusion */
+#include "stm32f10x_adc.h"
+#include "stm32f10x_bkp.h"
+#include "stm32f10x_can.h"
+#include "stm32f10x_cec.h"
+#include "stm32f10x_crc.h"
+#include "stm32f10x_dac.h"
+#include "stm32f10x_dbgmcu.h"
+#include "stm32f10x_dma.h"
+#include "stm32f10x_exti.h"
+#include "stm32f10x_flash.h"
+#include "stm32f10x_fsmc.h"
+#include "stm32f10x_gpio.h"
+#include "stm32f10x_i2c.h"
+#include "stm32f10x_iwdg.h"
+#include "stm32f10x_pwr.h"
+#include "stm32f10x_rcc.h"
+#include "stm32f10x_rtc.h"
+#include "stm32f10x_sdio.h"
+#include "stm32f10x_spi.h"
+#include "stm32f10x_tim.h"
+#include "stm32f10x_usart.h"
+#include "stm32f10x_wwdg.h"
+#include "misc.h" /* High level functions for NVIC and SysTick (add-on to CMSIS functions) */
+
+/* Exported types ------------------------------------------------------------*/
+/* Exported constants --------------------------------------------------------*/
+/* Uncomment the line below to expanse the "assert_param" macro in the
+   Standard Peripheral Library drivers code */
+/* #define USE_FULL_ASSERT    1 */
+
+/* Exported macro ------------------------------------------------------------*/
+#ifdef  USE_FULL_ASSERT
+
+/**
+  * @brief  The assert_param macro is used for function's parameters check.
+  * @param  expr: If expr is false, it calls assert_failed function which reports
+  *         the name of the source file and the source line number of the call
+  *         that failed. If expr is true, it returns no value.
+  * @retval None
+  */
+  #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+/* Exported functions ------------------------------------------------------- */
+  void assert_failed(uint8_t* file, uint32_t line);
+#else
+  #define assert_param(expr) ((void)0)
+#endif /* USE_FULL_ASSERT */
+
+#endif /* __STM32F10x_CONF_H */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/debugpins.c b/bsp/boards/vesna/debugpins.c
new file mode 100644
index 0000000..690ea37
--- /dev/null
+++ b/bsp/boards/vesna/debugpins.c
@@ -0,0 +1,42 @@
+/**
+\brief iot-lab_M3 definition of the "debugpins" bsp module.
+
+\author Alaeddine Weslati <alaeddine.weslati@inria.fr>,  January 2014.
+*/
+#include "stm32f10x_lib.h"
+#include "debugpins.h"
+
+//=========================== defines =========================================
+
+//=========================== variables =======================================
+
+//=========================== prototypes ======================================
+
+//=========================== public ==========================================
+
+void debugpins_init() {}
+
+void debugpins_frame_toggle() {}
+void debugpins_frame_clr() {}
+void debugpins_frame_set() {}
+
+void debugpins_slot_toggle() {}
+void debugpins_slot_clr() {}
+void debugpins_slot_set() {}
+
+void debugpins_fsm_toggle() {}
+void debugpins_fsm_clr() {}
+void debugpins_fsm_set() {}
+
+void debugpins_task_toggle() {}
+void debugpins_task_clr() {}
+void debugpins_task_set() {}
+
+void debugpins_isr_toggle() {}
+void debugpins_isr_clr() {}
+void debugpins_isr_set() {}
+
+void debugpins_radio_toggle() {}
+void debugpins_radio_clr() {}
+void debugpins_radio_set() {}
+
diff --git a/bsp/boards/vesna/eui64.c b/bsp/boards/vesna/eui64.c
new file mode 100644
index 0000000..6e95236
--- /dev/null
+++ b/bsp/boards/vesna/eui64.c
@@ -0,0 +1,34 @@
+/**
+\brief iot-lab_M3 definition of the "eui64" bsp module.
+
+\author Alaeddine Weslati <alaeddine.weslati@inria.fr>, January 2014.
+*/
+
+#include "string.h"
+#include "eui64.h"
+
+//=========================== defines =========================================
+// stm32f103rey, 96-bit unique ID address
+#define UNIQUE_ID_BASE_ADDRESS          0x1FFFF7E8
+
+//=========================== variables =======================================
+
+const uint8_t const *uid = (const uint8_t *const) UNIQUE_ID_BASE_ADDRESS;
+
+//=========================== prototypes ======================================
+
+//=========================== public ==========================================
+
+void eui64_get(uint8_t* addressToWrite)
+{
+  addressToWrite[0] = uid[7];
+  addressToWrite[1] = uid[6];
+  addressToWrite[2] = uid[5];
+  addressToWrite[3] = uid[4];
+  addressToWrite[4] = uid[3];
+  addressToWrite[5] = uid[0];
+  addressToWrite[6] = uid[1];
+  addressToWrite[7] = uid[2];
+}
+
+//=========================== private =========================================
diff --git a/bsp/boards/vesna/exti.c b/bsp/boards/vesna/exti.c
new file mode 100644
index 0000000..347e250
--- /dev/null
+++ b/bsp/boards/vesna/exti.c
@@ -0,0 +1,14 @@
+/**
+\brief iot-lab_M3 definition of the "exti" bsp module.
+
+\author Alaeddine Weslati <alaeddine.weslati@inria.fr>, January 2014.
+*/
+
+// Includes ------------------------------------------------------------------*/
+#include "stm32f10x_lib.h"
+#include "stm32f10x_gpio.h"
+
+void Exti_Init(void)
+{
+}
+
diff --git a/bsp/boards/vesna/gpio.c b/bsp/boards/vesna/gpio.c
new file mode 100644
index 0000000..d27c01b
--- /dev/null
+++ b/bsp/boards/vesna/gpio.c
@@ -0,0 +1,44 @@
+#include "stm32f10x_rcc.h"
+#include "stm32f10x_exti.h"
+#include "stm32f10x_gpio.h"
+#include "gpio.h"
+
+//=========================== defines =========================================
+
+//=========================== variables =======================================
+
+//=========================== public ===========================================
+
+
+void GPIO_Config_ALL_AIN(void)
+{
+  GPIO_InitTypeDef GPIO_InitStructure;
+
+  // Enable GPIOD and GPIOE clock
+  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB
+                         | RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD
+                         | RCC_APB2Periph_AFIO, ENABLE);
+
+  // PA
+  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;
+  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
+  GPIO_Init(GPIOA, &GPIO_InitStructure);
+  // PB
+  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;
+  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
+  GPIO_Init(GPIOB, &GPIO_InitStructure);
+  // PC
+  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;
+  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
+  GPIO_Init(GPIOC, &GPIO_InitStructure);
+  // PD
+  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;
+  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
+  GPIO_Init(GPIOD, &GPIO_InitStructure);
+}
+
+
+void GPIO_Configuration(void)
+{
+}
+
diff --git a/bsp/boards/vesna/gpio.h b/bsp/boards/vesna/gpio.h
new file mode 100644
index 0000000..acfa8d1
--- /dev/null
+++ b/bsp/boards/vesna/gpio.h
@@ -0,0 +1,13 @@
+#ifndef __GPIO_H
+#define __GPIO_H
+
+//=========================== defines =========================================
+
+//=========================== variables =======================================
+
+//=========================== prototypes ======================================
+
+void GPIO_Config_ALL_AIN(void);
+void GPIO_Configuration(void);
+
+#endif
diff --git a/bsp/boards/vesna/leds.c b/bsp/boards/vesna/leds.c
new file mode 100644
index 0000000..2069d6c
--- /dev/null
+++ b/bsp/boards/vesna/leds.c
@@ -0,0 +1,174 @@
+/**
+\brief iot-lab_M3 definition of the "leds" bsp module.
+
+\author Alaeddine Weslati <alaeddine.weslati@inria.fr>, January 2014.
+*/
+
+#include "stm32f10x_lib.h"
+#include "leds.h"
+
+//=========================== defines =========================================
+#define LED_RED_PIN             (1<<2)
+#define LED_GREEN_PIN           (1<<5)
+#define LED_ORANGE_PIN          (1<<10)
+
+//=========================== variables =======================================
+
+//=========================== prototypes ======================================
+
+void Delay(void);
+
+//=========================== public ==========================================
+
+void leds_init()
+{
+  GPIO_InitTypeDef GPIO_InitStructure;
+
+  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB , ENABLE);
+
+  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
+  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
+  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
+  GPIO_Init(GPIOB, &GPIO_InitStructure);
+
+  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC , ENABLE);
+
+  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
+  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
+  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
+  GPIO_Init(GPIOC, &GPIO_InitStructure);
+
+  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD , ENABLE);
+
+  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
+  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
+  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
+  GPIO_Init(GPIOD, &GPIO_InitStructure);
+}
+
+// red
+void leds_error_on()
+{
+  GPIOD->ODR &= ~LED_RED_PIN;
+}
+void leds_error_off()
+{
+  GPIOD->ODR |= LED_RED_PIN;
+}
+void leds_error_toggle()
+{
+  GPIOD->ODR ^= LED_RED_PIN;
+}
+uint8_t leds_error_isOn()
+{
+  u8 bitstatus = 0x00;
+  if ((GPIOD->ODR & LED_RED_PIN) != (u32)0)
+  {
+    bitstatus = 0x00;
+  }
+  else
+  {
+    bitstatus = 0x01;
+  }
+  return bitstatus;
+}
+void leds_error_blink() {}
+
+// green
+void leds_sync_on()
+{
+  GPIOB->ODR &= ~LED_GREEN_PIN;
+}
+void leds_sync_off()
+{
+  GPIOB->ODR |= LED_GREEN_PIN;
+}
+void leds_sync_toggle()
+{
+  GPIOB->ODR ^= LED_GREEN_PIN;
+}
+uint8_t leds_sync_isOn()
+{
+  u8 bitstatus = 0x00;
+  if ((GPIOB->ODR & LED_GREEN_PIN) != (u32)0)
+  {
+    bitstatus = 0x00;
+  }
+  else
+  {
+    bitstatus = 0x01;
+  }
+  return bitstatus;
+}
+
+// orange
+void leds_radio_on()
+{
+  GPIOC->ODR &= ~LED_ORANGE_PIN;
+}
+void leds_radio_off()
+{
+  GPIOC->ODR |= LED_ORANGE_PIN;
+}
+void leds_radio_toggle()
+{
+  GPIOC->ODR ^= LED_ORANGE_PIN;
+}
+uint8_t leds_radio_isOn()
+{
+  u8 bitstatus = 0x00;
+  if ((GPIOC->ODR & LED_ORANGE_PIN) != (u32)0)
+  {
+    bitstatus = 0x00;
+  }
+  else
+  {
+    bitstatus = 0x01;
+  }
+  return bitstatus;
+}
+// yellow
+void leds_debug_on() {}
+void leds_debug_off() {}
+void leds_debug_toggle() {}
+uint8_t leds_debug_isOn() {}
+
+void leds_all_on()
+{
+  leds_error_on();
+  leds_sync_on();
+  leds_radio_on();
+}
+void leds_all_off()
+{
+  leds_error_off();
+  leds_sync_off();
+  leds_radio_off();
+}
+void leds_all_toggle()
+{
+  leds_error_toggle();
+  leds_sync_toggle();
+  leds_radio_toggle();
+}
+
+void leds_circular_shift()
+{
+  leds_error_toggle();
+  Delay();
+  leds_sync_toggle();
+  Delay();
+  leds_radio_toggle();
+  Delay();
+}
+
+void leds_increment() {}
+
+//=========================== private =========================================
+
+void Delay(void)
+{
+  uint32_t i;
+  for(i=0; i<0xfffff; i++);
+}
+
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/CoreSupport/core_cm3.c b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/CoreSupport/core_cm3.c
new file mode 100644
index 0000000..56fddc5
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/CoreSupport/core_cm3.c
@@ -0,0 +1,784 @@
+/**************************************************************************//**
+ * @file     core_cm3.c
+ * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Source File
+ * @version  V1.30
+ * @date     30. October 2009
+ *
+ * @note
+ * Copyright (C) 2009 ARM Limited. All rights reserved.
+ *
+ * @par
+ * ARM Limited (ARM) is supplying this software for use with Cortex-M
+ * processor based microcontrollers.  This file can be freely distributed
+ * within development tools that are supporting such ARM based processors.
+ *
+ * @par
+ * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+ * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+ * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+ * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+ *
+ ******************************************************************************/
+
+#include <stdint.h>
+
+/* define compiler specific symbols */
+#if defined ( __CC_ARM   )
+  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
+  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
+
+#elif defined ( __ICCARM__ )
+  #define __ASM           __asm                                       /*!< asm keyword for IAR Compiler          */
+  #define __INLINE        inline                                      /*!< inline keyword for IAR Compiler. Only avaiable in High optimization mode! */
+
+#elif defined   (  __GNUC__  )
+  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
+  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
+
+#elif defined   (  __TASKING__  )
+  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
+  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
+
+#endif
+
+
+/* ###################  Compiler specific Intrinsics  ########################### */
+
+#if defined ( __CC_ARM   ) /*------------------RealView Compiler -----------------*/
+/* ARM armcc specific functions */
+
+/**
+ * @brief  Return the Process Stack Pointer
+ *
+ * @return ProcessStackPointer
+ *
+ * Return the actual process stack pointer
+ */
+__ASM uint32_t __get_PSP(void)
+{
+  mrs r0, psp
+  bx lr
+}
+
+/**
+ * @brief  Set the Process Stack Pointer
+ *
+ * @param  topOfProcStack  Process Stack Pointer
+ *
+ * Assign the value ProcessStackPointer to the MSP
+ * (process stack pointer) Cortex processor register
+ */
+__ASM void __set_PSP(uint32_t topOfProcStack)
+{
+  msr psp, r0
+  bx lr
+}
+
+/**
+ * @brief  Return the Main Stack Pointer
+ *
+ * @return Main Stack Pointer
+ *
+ * Return the current value of the MSP (main stack pointer)
+ * Cortex processor register
+ */
+__ASM uint32_t __get_MSP(void)
+{
+  mrs r0, msp
+  bx lr
+}
+
+/**
+ * @brief  Set the Main Stack Pointer
+ *
+ * @param  topOfMainStack  Main Stack Pointer
+ *
+ * Assign the value mainStackPointer to the MSP
+ * (main stack pointer) Cortex processor register
+ */
+__ASM void __set_MSP(uint32_t mainStackPointer)
+{
+  msr msp, r0
+  bx lr
+}
+
+/**
+ * @brief  Reverse byte order in unsigned short value
+ *
+ * @param   value  value to reverse
+ * @return         reversed value
+ *
+ * Reverse byte order in unsigned short value
+ */
+__ASM uint32_t __REV16(uint16_t value)
+{
+  rev16 r0, r0
+  bx lr
+}
+
+/**
+ * @brief  Reverse byte order in signed short value with sign extension to integer
+ *
+ * @param   value  value to reverse
+ * @return         reversed value
+ *
+ * Reverse byte order in signed short value with sign extension to integer
+ */
+__ASM int32_t __REVSH(int16_t value)
+{
+  revsh r0, r0
+  bx lr
+}
+
+
+#if (__ARMCC_VERSION < 400000)
+
+/**
+ * @brief  Remove the exclusive lock created by ldrex
+ *
+ * Removes the exclusive lock which is created by ldrex.
+ */
+__ASM void __CLREX(void)
+{
+  clrex
+}
+
+/**
+ * @brief  Return the Base Priority value
+ *
+ * @return BasePriority
+ *
+ * Return the content of the base priority register
+ */
+__ASM uint32_t  __get_BASEPRI(void)
+{
+  mrs r0, basepri
+  bx lr
+}
+
+/**
+ * @brief  Set the Base Priority value
+ *
+ * @param  basePri  BasePriority
+ *
+ * Set the base priority register
+ */
+__ASM void __set_BASEPRI(uint32_t basePri)
+{
+  msr basepri, r0
+  bx lr
+}
+
+/**
+ * @brief  Return the Priority Mask value
+ *
+ * @return PriMask
+ *
+ * Return state of the priority mask bit from the priority mask register
+ */
+__ASM uint32_t __get_PRIMASK(void)
+{
+  mrs r0, primask
+  bx lr
+}
+
+/**
+ * @brief  Set the Priority Mask value
+ *
+ * @param  priMask  PriMask
+ *
+ * Set the priority mask bit in the priority mask register
+ */
+__ASM void __set_PRIMASK(uint32_t priMask)
+{
+  msr primask, r0
+  bx lr
+}
+
+/**
+ * @brief  Return the Fault Mask value
+ *
+ * @return FaultMask
+ *
+ * Return the content of the fault mask register
+ */
+__ASM uint32_t  __get_FAULTMASK(void)
+{
+  mrs r0, faultmask
+  bx lr
+}
+
+/**
+ * @brief  Set the Fault Mask value
+ *
+ * @param  faultMask  faultMask value
+ *
+ * Set the fault mask register
+ */
+__ASM void __set_FAULTMASK(uint32_t faultMask)
+{
+  msr faultmask, r0
+  bx lr
+}
+
+/**
+ * @brief  Return the Control Register value
+ *
+ * @return Control value
+ *
+ * Return the content of the control register
+ */
+__ASM uint32_t __get_CONTROL(void)
+{
+  mrs r0, control
+  bx lr
+}
+
+/**
+ * @brief  Set the Control Register value
+ *
+ * @param  control  Control value
+ *
+ * Set the control register
+ */
+__ASM void __set_CONTROL(uint32_t control)
+{
+  msr control, r0
+  bx lr
+}
+
+#endif /* __ARMCC_VERSION  */
+
+
+
+#elif (defined (__ICCARM__)) /*------------------ ICC Compiler -------------------*/
+/* IAR iccarm specific functions */
+#pragma diag_suppress=Pe940
+
+/**
+ * @brief  Return the Process Stack Pointer
+ *
+ * @return ProcessStackPointer
+ *
+ * Return the actual process stack pointer
+ */
+uint32_t __get_PSP(void)
+{
+  __ASM("mrs r0, psp");
+  __ASM("bx lr");
+}
+
+/**
+ * @brief  Set the Process Stack Pointer
+ *
+ * @param  topOfProcStack  Process Stack Pointer
+ *
+ * Assign the value ProcessStackPointer to the MSP
+ * (process stack pointer) Cortex processor register
+ */
+void __set_PSP(uint32_t topOfProcStack)
+{
+  __ASM("msr psp, r0");
+  __ASM("bx lr");
+}
+
+/**
+ * @brief  Return the Main Stack Pointer
+ *
+ * @return Main Stack Pointer
+ *
+ * Return the current value of the MSP (main stack pointer)
+ * Cortex processor register
+ */
+uint32_t __get_MSP(void)
+{
+  __ASM("mrs r0, msp");
+  __ASM("bx lr");
+}
+
+/**
+ * @brief  Set the Main Stack Pointer
+ *
+ * @param  topOfMainStack  Main Stack Pointer
+ *
+ * Assign the value mainStackPointer to the MSP
+ * (main stack pointer) Cortex processor register
+ */
+void __set_MSP(uint32_t topOfMainStack)
+{
+  __ASM("msr msp, r0");
+  __ASM("bx lr");
+}
+
+/**
+ * @brief  Reverse byte order in unsigned short value
+ *
+ * @param  value  value to reverse
+ * @return        reversed value
+ *
+ * Reverse byte order in unsigned short value
+ */
+uint32_t __REV16(uint16_t value)
+{
+  __ASM("rev16 r0, r0");
+  __ASM("bx lr");
+}
+
+/**
+ * @brief  Reverse bit order of value
+ *
+ * @param  value  value to reverse
+ * @return        reversed value
+ *
+ * Reverse bit order of value
+ */
+uint32_t __RBIT(uint32_t value)
+{
+  __ASM("rbit r0, r0");
+  __ASM("bx lr");
+}
+
+/**
+ * @brief  LDR Exclusive (8 bit)
+ *
+ * @param  *addr  address pointer
+ * @return        value of (*address)
+ *
+ * Exclusive LDR command for 8 bit values)
+ */
+uint8_t __LDREXB(uint8_t *addr)
+{
+  __ASM("ldrexb r0, [r0]");
+  __ASM("bx lr");
+}
+
+/**
+ * @brief  LDR Exclusive (16 bit)
+ *
+ * @param  *addr  address pointer
+ * @return        value of (*address)
+ *
+ * Exclusive LDR command for 16 bit values
+ */
+uint16_t __LDREXH(uint16_t *addr)
+{
+  __ASM("ldrexh r0, [r0]");
+  __ASM("bx lr");
+}
+
+/**
+ * @brief  LDR Exclusive (32 bit)
+ *
+ * @param  *addr  address pointer
+ * @return        value of (*address)
+ *
+ * Exclusive LDR command for 32 bit values
+ */
+uint32_t __LDREXW(uint32_t *addr)
+{
+  __ASM("ldrex r0, [r0]");
+  __ASM("bx lr");
+}
+
+/**
+ * @brief  STR Exclusive (8 bit)
+ *
+ * @param  value  value to store
+ * @param  *addr  address pointer
+ * @return        successful / failed
+ *
+ * Exclusive STR command for 8 bit values
+ */
+uint32_t __STREXB(uint8_t value, uint8_t *addr)
+{
+  __ASM("strexb r0, r0, [r1]");
+  __ASM("bx lr");
+}
+
+/**
+ * @brief  STR Exclusive (16 bit)
+ *
+ * @param  value  value to store
+ * @param  *addr  address pointer
+ * @return        successful / failed
+ *
+ * Exclusive STR command for 16 bit values
+ */
+uint32_t __STREXH(uint16_t value, uint16_t *addr)
+{
+  __ASM("strexh r0, r0, [r1]");
+  __ASM("bx lr");
+}
+
+/**
+ * @brief  STR Exclusive (32 bit)
+ *
+ * @param  value  value to store
+ * @param  *addr  address pointer
+ * @return        successful / failed
+ *
+ * Exclusive STR command for 32 bit values
+ */
+uint32_t __STREXW(uint32_t value, uint32_t *addr)
+{
+  __ASM("strex r0, r0, [r1]");
+  __ASM("bx lr");
+}
+
+#pragma diag_default=Pe940
+
+
+#elif (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/
+/* GNU gcc specific functions */
+
+/**
+ * @brief  Return the Process Stack Pointer
+ *
+ * @return ProcessStackPointer
+ *
+ * Return the actual process stack pointer
+ */
+uint32_t __get_PSP(void) __attribute__( ( naked ) );
+uint32_t __get_PSP(void)
+{
+  uint32_t result=0;
+
+  __ASM volatile ("MRS %0, psp\n\t"
+                  "MOV r0, %0 \n\t"
+                  "BX  lr     \n\t"  : "=r" (result) );
+  return(result);
+}
+
+/**
+ * @brief  Set the Process Stack Pointer
+ *
+ * @param  topOfProcStack  Process Stack Pointer
+ *
+ * Assign the value ProcessStackPointer to the MSP
+ * (process stack pointer) Cortex processor register
+ */
+void __set_PSP(uint32_t topOfProcStack) __attribute__( ( naked ) );
+void __set_PSP(uint32_t topOfProcStack)
+{
+  __ASM volatile ("MSR psp, %0\n\t"
+                  "BX  lr     \n\t" : : "r" (topOfProcStack) );
+}
+
+/**
+ * @brief  Return the Main Stack Pointer
+ *
+ * @return Main Stack Pointer
+ *
+ * Return the current value of the MSP (main stack pointer)
+ * Cortex processor register
+ */
+uint32_t __get_MSP(void) __attribute__( ( naked ) );
+uint32_t __get_MSP(void)
+{
+  uint32_t result=0;
+
+  __ASM volatile ("MRS %0, msp\n\t"
+                  "MOV r0, %0 \n\t"
+                  "BX  lr     \n\t"  : "=r" (result) );
+  return(result);
+}
+
+/**
+ * @brief  Set the Main Stack Pointer
+ *
+ * @param  topOfMainStack  Main Stack Pointer
+ *
+ * Assign the value mainStackPointer to the MSP
+ * (main stack pointer) Cortex processor register
+ */
+void __set_MSP(uint32_t topOfMainStack) __attribute__( ( naked ) );
+void __set_MSP(uint32_t topOfMainStack)
+{
+  __ASM volatile ("MSR msp, %0\n\t"
+                  "BX  lr     \n\t" : : "r" (topOfMainStack) );
+}
+
+/**
+ * @brief  Return the Base Priority value
+ *
+ * @return BasePriority
+ *
+ * Return the content of the base priority register
+ */
+uint32_t __get_BASEPRI(void)
+{
+  uint32_t result=0;
+
+  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
+  return(result);
+}
+
+/**
+ * @brief  Set the Base Priority value
+ *
+ * @param  basePri  BasePriority
+ *
+ * Set the base priority register
+ */
+void __set_BASEPRI(uint32_t value)
+{
+  __ASM volatile ("MSR basepri, %0" : : "r" (value) );
+}
+
+/**
+ * @brief  Return the Priority Mask value
+ *
+ * @return PriMask
+ *
+ * Return state of the priority mask bit from the priority mask register
+ */
+uint32_t __get_PRIMASK(void)
+{
+  uint32_t result=0;
+
+  __ASM volatile ("MRS %0, primask" : "=r" (result) );
+  return(result);
+}
+
+/**
+ * @brief  Set the Priority Mask value
+ *
+ * @param  priMask  PriMask
+ *
+ * Set the priority mask bit in the priority mask register
+ */
+void __set_PRIMASK(uint32_t priMask)
+{
+  __ASM volatile ("MSR primask, %0" : : "r" (priMask) );
+}
+
+/**
+ * @brief  Return the Fault Mask value
+ *
+ * @return FaultMask
+ *
+ * Return the content of the fault mask register
+ */
+uint32_t __get_FAULTMASK(void)
+{
+  uint32_t result=0;
+
+  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
+  return(result);
+}
+
+/**
+ * @brief  Set the Fault Mask value
+ *
+ * @param  faultMask  faultMask value
+ *
+ * Set the fault mask register
+ */
+void __set_FAULTMASK(uint32_t faultMask)
+{
+  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) );
+}
+
+/**
+ * @brief  Return the Control Register value
+*
+*  @return Control value
+ *
+ * Return the content of the control register
+ */
+uint32_t __get_CONTROL(void)
+{
+  uint32_t result=0;
+
+  __ASM volatile ("MRS %0, control" : "=r" (result) );
+  return(result);
+}
+
+/**
+ * @brief  Set the Control Register value
+ *
+ * @param  control  Control value
+ *
+ * Set the control register
+ */
+void __set_CONTROL(uint32_t control)
+{
+  __ASM volatile ("MSR control, %0" : : "r" (control) );
+}
+
+
+/**
+ * @brief  Reverse byte order in integer value
+ *
+ * @param  value  value to reverse
+ * @return        reversed value
+ *
+ * Reverse byte order in integer value
+ */
+uint32_t __REV(uint32_t value)
+{
+  uint32_t result=0;
+
+  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
+  return(result);
+}
+
+/**
+ * @brief  Reverse byte order in unsigned short value
+ *
+ * @param  value  value to reverse
+ * @return        reversed value
+ *
+ * Reverse byte order in unsigned short value
+ */
+uint32_t __REV16(uint16_t value)
+{
+  uint32_t result=0;
+
+  __ASM volatile ("rev16 %0, %1" : "=r" (result) : "r" (value) );
+  return(result);
+}
+
+/**
+ * @brief  Reverse byte order in signed short value with sign extension to integer
+ *
+ * @param  value  value to reverse
+ * @return        reversed value
+ *
+ * Reverse byte order in signed short value with sign extension to integer
+ */
+int32_t __REVSH(int16_t value)
+{
+  uint32_t result=0;
+
+  __ASM volatile ("revsh %0, %1" : "=r" (result) : "r" (value) );
+  return(result);
+}
+
+/**
+ * @brief  Reverse bit order of value
+ *
+ * @param  value  value to reverse
+ * @return        reversed value
+ *
+ * Reverse bit order of value
+ */
+uint32_t __RBIT(uint32_t value)
+{
+  uint32_t result=0;
+
+   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
+   return(result);
+}
+
+/**
+ * @brief  LDR Exclusive (8 bit)
+ *
+ * @param  *addr  address pointer
+ * @return        value of (*address)
+ *
+ * Exclusive LDR command for 8 bit value
+ */
+uint8_t __LDREXB(uint8_t *addr)
+{
+    uint8_t result=0;
+
+   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) );
+   return(result);
+}
+
+/**
+ * @brief  LDR Exclusive (16 bit)
+ *
+ * @param  *addr  address pointer
+ * @return        value of (*address)
+ *
+ * Exclusive LDR command for 16 bit values
+ */
+uint16_t __LDREXH(uint16_t *addr)
+{
+    uint16_t result=0;
+
+   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) );
+   return(result);
+}
+
+/**
+ * @brief  LDR Exclusive (32 bit)
+ *
+ * @param  *addr  address pointer
+ * @return        value of (*address)
+ *
+ * Exclusive LDR command for 32 bit values
+ */
+uint32_t __LDREXW(uint32_t *addr)
+{
+    uint32_t result=0;
+
+   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
+   return(result);
+}
+
+/**
+ * @brief  STR Exclusive (8 bit)
+ *
+ * @param  value  value to store
+ * @param  *addr  address pointer
+ * @return        successful / failed
+ *
+ * Exclusive STR command for 8 bit values
+ */
+uint32_t __STREXB(uint8_t value, uint8_t *addr)
+{
+   uint32_t result=0;
+
+   __ASM volatile ("strexb %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
+   return(result);
+}
+
+/**
+ * @brief  STR Exclusive (16 bit)
+ *
+ * @param  value  value to store
+ * @param  *addr  address pointer
+ * @return        successful / failed
+ *
+ * Exclusive STR command for 16 bit values
+ */
+uint32_t __STREXH(uint16_t value, uint16_t *addr)
+{
+   uint32_t result=0;
+
+   __ASM volatile ("strexh %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
+   return(result);
+}
+
+/**
+ * @brief  STR Exclusive (32 bit)
+ *
+ * @param  value  value to store
+ * @param  *addr  address pointer
+ * @return        successful / failed
+ *
+ * Exclusive STR command for 32 bit values
+ */
+uint32_t __STREXW(uint32_t value, uint32_t *addr)
+{
+   uint32_t result=0;
+
+   __ASM volatile ("strex %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
+   return(result);
+}
+
+
+#elif (defined (__TASKING__)) /*------------------ TASKING Compiler ---------------------*/
+/* TASKING carm specific functions */
+
+/*
+ * The CMSIS functions have been implemented as intrinsics in the compiler.
+ * Please use "carm -?i" to get an up to date list of all instrinsics,
+ * Including the CMSIS ones.
+ */
+
+#endif
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/CoreSupport/core_cm3.h b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/CoreSupport/core_cm3.h
new file mode 100644
index 0000000..e0565d7
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/CoreSupport/core_cm3.h
@@ -0,0 +1,1818 @@
+/**************************************************************************//**
+ * @file     core_cm3.h
+ * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File
+ * @version  V1.30
+ * @date     30. October 2009
+ *
+ * @note
+ * Copyright (C) 2009 ARM Limited. All rights reserved.
+ *
+ * @par
+ * ARM Limited (ARM) is supplying this software for use with Cortex-M
+ * processor based microcontrollers.  This file can be freely distributed
+ * within development tools that are supporting such ARM based processors.
+ *
+ * @par
+ * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+ * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+ * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+ * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+ *
+ ******************************************************************************/
+
+#ifndef __CM3_CORE_H__
+#define __CM3_CORE_H__
+
+/** @addtogroup CMSIS_CM3_core_LintCinfiguration CMSIS CM3 Core Lint Configuration
+ *
+ * List of Lint messages which will be suppressed and not shown:
+ *   - Error 10: \n
+ *     register uint32_t __regBasePri         __asm("basepri"); \n
+ *     Error 10: Expecting ';'
+ * .
+ *   - Error 530: \n
+ *     return(__regBasePri); \n
+ *     Warning 530: Symbol '__regBasePri' (line 264) not initialized
+ * .
+ *   - Error 550: \n
+ *     __regBasePri = (basePri & 0x1ff); \n
+ *     Warning 550: Symbol '__regBasePri' (line 271) not accessed
+ * .
+ *   - Error 754: \n
+ *     uint32_t RESERVED0[24]; \n
+ *     Info 754: local structure member '<some, not used in the HAL>' (line 109, file ./cm3_core.h) not referenced
+ * .
+ *   - Error 750: \n
+ *     #define __CM3_CORE_H__ \n
+ *     Info 750: local macro '__CM3_CORE_H__' (line 43, file./cm3_core.h) not referenced
+ * .
+ *   - Error 528: \n
+ *     static __INLINE void NVIC_DisableIRQ(uint32_t IRQn) \n
+ *     Warning 528: Symbol 'NVIC_DisableIRQ(unsigned int)' (line 419, file ./cm3_core.h) not referenced
+ * .
+ *   - Error 751: \n
+ *     } InterruptType_Type; \n
+ *     Info 751: local typedef 'InterruptType_Type' (line 170, file ./cm3_core.h) not referenced
+ * .
+ * Note:  To re-enable a Message, insert a space before 'lint' *
+ *
+ */
+
+/*lint -save */
+/*lint -e10  */
+/*lint -e530 */
+/*lint -e550 */
+/*lint -e754 */
+/*lint -e750 */
+/*lint -e528 */
+/*lint -e751 */
+
+
+/** @addtogroup CMSIS_CM3_core_definitions CM3 Core Definitions
+  This file defines all structures and symbols for CMSIS core:
+    - CMSIS version number
+    - Cortex-M core registers and bitfields
+    - Cortex-M core peripheral base address
+  @{
+ */
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+#define __CM3_CMSIS_VERSION_MAIN  (0x01)                                                       /*!< [31:16] CMSIS HAL main version */
+#define __CM3_CMSIS_VERSION_SUB   (0x30)                                                       /*!< [15:0]  CMSIS HAL sub version  */
+#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16) | __CM3_CMSIS_VERSION_SUB) /*!< CMSIS HAL version number       */
+
+#define __CORTEX_M                (0x03)                                                       /*!< Cortex core                    */
+
+#include <stdint.h>                           /* Include standard types */
+
+#if defined (__ICCARM__)
+  #include <intrinsics.h>                     /* IAR Intrinsics   */
+#endif
+
+
+#ifndef __NVIC_PRIO_BITS
+  #define __NVIC_PRIO_BITS    4               /*!< standard definition for NVIC Priority Bits */
+#endif
+
+
+
+
+/**
+ * IO definitions
+ *
+ * define access restrictions to peripheral registers
+ */
+
+#ifdef __cplusplus
+  #define     __I     volatile                /*!< defines 'read only' permissions      */
+#else
+  #define     __I     volatile const          /*!< defines 'read only' permissions      */
+#endif
+#define     __O     volatile                  /*!< defines 'write only' permissions     */
+#define     __IO    volatile                  /*!< defines 'read / write' permissions   */
+
+
+
+/*******************************************************************************
+ *                 Register Abstraction
+ ******************************************************************************/
+/** @addtogroup CMSIS_CM3_core_register CMSIS CM3 Core Register
+ @{
+*/
+
+
+/** @addtogroup CMSIS_CM3_NVIC CMSIS CM3 NVIC
+  memory mapped structure for Nested Vectored Interrupt Controller (NVIC)
+  @{
+ */
+typedef struct
+{
+  __IO uint32_t ISER[8];                      /*!< Offset: 0x000  Interrupt Set Enable Register           */
+       uint32_t RESERVED0[24];
+  __IO uint32_t ICER[8];                      /*!< Offset: 0x080  Interrupt Clear Enable Register         */
+       uint32_t RSERVED1[24];
+  __IO uint32_t ISPR[8];                      /*!< Offset: 0x100  Interrupt Set Pending Register          */
+       uint32_t RESERVED2[24];
+  __IO uint32_t ICPR[8];                      /*!< Offset: 0x180  Interrupt Clear Pending Register        */
+       uint32_t RESERVED3[24];
+  __IO uint32_t IABR[8];                      /*!< Offset: 0x200  Interrupt Active bit Register           */
+       uint32_t RESERVED4[56];
+  __IO uint8_t  IP[240];                      /*!< Offset: 0x300  Interrupt Priority Register (8Bit wide) */
+       uint32_t RESERVED5[644];
+  __O  uint32_t STIR;                         /*!< Offset: 0xE00  Software Trigger Interrupt Register     */
+}  NVIC_Type;
+/*@}*/ /* end of group CMSIS_CM3_NVIC */
+
+
+/** @addtogroup CMSIS_CM3_SCB CMSIS CM3 SCB
+  memory mapped structure for System Control Block (SCB)
+  @{
+ */
+typedef struct
+{
+  __I  uint32_t CPUID;                        /*!< Offset: 0x00  CPU ID Base Register                                  */
+  __IO uint32_t ICSR;                         /*!< Offset: 0x04  Interrupt Control State Register                      */
+  __IO uint32_t VTOR;                         /*!< Offset: 0x08  Vector Table Offset Register                          */
+  __IO uint32_t AIRCR;                        /*!< Offset: 0x0C  Application Interrupt / Reset Control Register        */
+  __IO uint32_t SCR;                          /*!< Offset: 0x10  System Control Register                               */
+  __IO uint32_t CCR;                          /*!< Offset: 0x14  Configuration Control Register                        */
+  __IO uint8_t  SHP[12];                      /*!< Offset: 0x18  System Handlers Priority Registers (4-7, 8-11, 12-15) */
+  __IO uint32_t SHCSR;                        /*!< Offset: 0x24  System Handler Control and State Register             */
+  __IO uint32_t CFSR;                         /*!< Offset: 0x28  Configurable Fault Status Register                    */
+  __IO uint32_t HFSR;                         /*!< Offset: 0x2C  Hard Fault Status Register                            */
+  __IO uint32_t DFSR;                         /*!< Offset: 0x30  Debug Fault Status Register                           */
+  __IO uint32_t MMFAR;                        /*!< Offset: 0x34  Mem Manage Address Register                           */
+  __IO uint32_t BFAR;                         /*!< Offset: 0x38  Bus Fault Address Register                            */
+  __IO uint32_t AFSR;                         /*!< Offset: 0x3C  Auxiliary Fault Status Register                       */
+  __I  uint32_t PFR[2];                       /*!< Offset: 0x40  Processor Feature Register                            */
+  __I  uint32_t DFR;                          /*!< Offset: 0x48  Debug Feature Register                                */
+  __I  uint32_t ADR;                          /*!< Offset: 0x4C  Auxiliary Feature Register                            */
+  __I  uint32_t MMFR[4];                      /*!< Offset: 0x50  Memory Model Feature Register                         */
+  __I  uint32_t ISAR[5];                      /*!< Offset: 0x60  ISA Feature Register                                  */
+} SCB_Type;
+
+/* SCB CPUID Register Definitions */
+#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
+#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFul << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
+
+#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
+#define SCB_CPUID_VARIANT_Msk              (0xFul << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
+
+#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
+#define SCB_CPUID_PARTNO_Msk               (0xFFFul << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
+
+#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
+#define SCB_CPUID_REVISION_Msk             (0xFul << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
+
+/* SCB Interrupt Control State Register Definitions */
+#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
+#define SCB_ICSR_NMIPENDSET_Msk            (1ul << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
+
+#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
+#define SCB_ICSR_PENDSVSET_Msk             (1ul << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
+
+#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
+#define SCB_ICSR_PENDSVCLR_Msk             (1ul << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
+
+#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
+#define SCB_ICSR_PENDSTSET_Msk             (1ul << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
+
+#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
+#define SCB_ICSR_PENDSTCLR_Msk             (1ul << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
+
+#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
+#define SCB_ICSR_ISRPREEMPT_Msk            (1ul << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
+
+#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
+#define SCB_ICSR_ISRPENDING_Msk            (1ul << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
+
+#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
+#define SCB_ICSR_VECTPENDING_Msk           (0x1FFul << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
+
+#define SCB_ICSR_RETTOBASE_Pos             11                                             /*!< SCB ICSR: RETTOBASE Position */
+#define SCB_ICSR_RETTOBASE_Msk             (1ul << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
+
+#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
+#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFul << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
+
+/* SCB Interrupt Control State Register Definitions */
+#define SCB_VTOR_TBLBASE_Pos               29                                             /*!< SCB VTOR: TBLBASE Position */
+#define SCB_VTOR_TBLBASE_Msk               (0x1FFul << SCB_VTOR_TBLBASE_Pos)              /*!< SCB VTOR: TBLBASE Mask */
+
+#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
+#define SCB_VTOR_TBLOFF_Msk                (0x3FFFFFul << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
+
+/* SCB Application Interrupt and Reset Control Register Definitions */
+#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
+#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFul << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
+
+#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
+#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFul << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
+
+#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
+#define SCB_AIRCR_ENDIANESS_Msk            (1ul << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
+
+#define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!< SCB AIRCR: PRIGROUP Position */
+#define SCB_AIRCR_PRIGROUP_Msk             (7ul << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
+
+#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
+#define SCB_AIRCR_SYSRESETREQ_Msk          (1ul << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
+
+#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
+#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1ul << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
+
+#define SCB_AIRCR_VECTRESET_Pos             0                                             /*!< SCB AIRCR: VECTRESET Position */
+#define SCB_AIRCR_VECTRESET_Msk            (1ul << SCB_AIRCR_VECTRESET_Pos)               /*!< SCB AIRCR: VECTRESET Mask */
+
+/* SCB System Control Register Definitions */
+#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
+#define SCB_SCR_SEVONPEND_Msk              (1ul << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
+
+#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
+#define SCB_SCR_SLEEPDEEP_Msk              (1ul << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
+
+#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
+#define SCB_SCR_SLEEPONEXIT_Msk            (1ul << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
+
+/* SCB Configuration Control Register Definitions */
+#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
+#define SCB_CCR_STKALIGN_Msk               (1ul << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
+
+#define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!< SCB CCR: BFHFNMIGN Position */
+#define SCB_CCR_BFHFNMIGN_Msk              (1ul << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
+
+#define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!< SCB CCR: DIV_0_TRP Position */
+#define SCB_CCR_DIV_0_TRP_Msk              (1ul << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
+
+#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
+#define SCB_CCR_UNALIGN_TRP_Msk            (1ul << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
+
+#define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB CCR: USERSETMPEND Position */
+#define SCB_CCR_USERSETMPEND_Msk           (1ul << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
+
+#define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!< SCB CCR: NONBASETHRDENA Position */
+#define SCB_CCR_NONBASETHRDENA_Msk         (1ul << SCB_CCR_NONBASETHRDENA_Pos)            /*!< SCB CCR: NONBASETHRDENA Mask */
+
+/* SCB System Handler Control and State Register Definitions */
+#define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB SHCSR: USGFAULTENA Position */
+#define SCB_SHCSR_USGFAULTENA_Msk          (1ul << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
+
+#define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB SHCSR: BUSFAULTENA Position */
+#define SCB_SHCSR_BUSFAULTENA_Msk          (1ul << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
+
+#define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB SHCSR: MEMFAULTENA Position */
+#define SCB_SHCSR_MEMFAULTENA_Msk          (1ul << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
+
+#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
+#define SCB_SHCSR_SVCALLPENDED_Msk         (1ul << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
+
+#define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!< SCB SHCSR: BUSFAULTPENDED Position */
+#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1ul << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
+
+#define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!< SCB SHCSR: MEMFAULTPENDED Position */
+#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1ul << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
+
+#define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!< SCB SHCSR: USGFAULTPENDED Position */
+#define SCB_SHCSR_USGFAULTPENDED_Msk       (1ul << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
+
+#define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!< SCB SHCSR: SYSTICKACT Position */
+#define SCB_SHCSR_SYSTICKACT_Msk           (1ul << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
+
+#define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!< SCB SHCSR: PENDSVACT Position */
+#define SCB_SHCSR_PENDSVACT_Msk            (1ul << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
+
+#define SCB_SHCSR_MONITORACT_Pos            8                                             /*!< SCB SHCSR: MONITORACT Position */
+#define SCB_SHCSR_MONITORACT_Msk           (1ul << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
+
+#define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!< SCB SHCSR: SVCALLACT Position */
+#define SCB_SHCSR_SVCALLACT_Msk            (1ul << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
+
+#define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!< SCB SHCSR: USGFAULTACT Position */
+#define SCB_SHCSR_USGFAULTACT_Msk          (1ul << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
+
+#define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB SHCSR: BUSFAULTACT Position */
+#define SCB_SHCSR_BUSFAULTACT_Msk          (1ul << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
+
+#define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!< SCB SHCSR: MEMFAULTACT Position */
+#define SCB_SHCSR_MEMFAULTACT_Msk          (1ul << SCB_SHCSR_MEMFAULTACT_Pos)             /*!< SCB SHCSR: MEMFAULTACT Mask */
+
+/* SCB Configurable Fault Status Registers Definitions */
+#define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!< SCB CFSR: Usage Fault Status Register Position */
+#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFul << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
+
+#define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!< SCB CFSR: Bus Fault Status Register Position */
+#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFul << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
+
+#define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!< SCB CFSR: Memory Manage Fault Status Register Position */
+#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFul << SCB_CFSR_MEMFAULTSR_Pos)            /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
+
+/* SCB Hard Fault Status Registers Definitions */
+#define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!< SCB HFSR: DEBUGEVT Position */
+#define SCB_HFSR_DEBUGEVT_Msk              (1ul << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
+
+#define SCB_HFSR_FORCED_Pos                30                                             /*!< SCB HFSR: FORCED Position */
+#define SCB_HFSR_FORCED_Msk                (1ul << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
+
+#define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB HFSR: VECTTBL Position */
+#define SCB_HFSR_VECTTBL_Msk               (1ul << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
+
+/* SCB Debug Fault Status Register Definitions */
+#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
+#define SCB_DFSR_EXTERNAL_Msk              (1ul << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
+
+#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
+#define SCB_DFSR_VCATCH_Msk                (1ul << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
+
+#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
+#define SCB_DFSR_DWTTRAP_Msk               (1ul << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
+
+#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
+#define SCB_DFSR_BKPT_Msk                  (1ul << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
+
+#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
+#define SCB_DFSR_HALTED_Msk                (1ul << SCB_DFSR_HALTED_Pos)                   /*!< SCB DFSR: HALTED Mask */
+/*@}*/ /* end of group CMSIS_CM3_SCB */
+
+
+/** @addtogroup CMSIS_CM3_SysTick CMSIS CM3 SysTick
+  memory mapped structure for SysTick
+  @{
+ */
+typedef struct
+{
+  __IO uint32_t CTRL;                         /*!< Offset: 0x00  SysTick Control and Status Register */
+  __IO uint32_t LOAD;                         /*!< Offset: 0x04  SysTick Reload Value Register       */
+  __IO uint32_t VAL;                          /*!< Offset: 0x08  SysTick Current Value Register      */
+  __I  uint32_t CALIB;                        /*!< Offset: 0x0C  SysTick Calibration Register        */
+} SysTick_Type;
+
+/* SysTick Control / Status Register Definitions */
+#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
+#define SysTick_CTRL_COUNTFLAG_Msk         (1ul << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
+
+#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
+#define SysTick_CTRL_CLKSOURCE_Msk         (1ul << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
+
+#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
+#define SysTick_CTRL_TICKINT_Msk           (1ul << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
+
+#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
+#define SysTick_CTRL_ENABLE_Msk            (1ul << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
+
+/* SysTick Reload Register Definitions */
+#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
+#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFul << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
+
+/* SysTick Current Register Definitions */
+#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
+#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFul << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
+
+/* SysTick Calibration Register Definitions */
+#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
+#define SysTick_CALIB_NOREF_Msk            (1ul << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
+
+#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
+#define SysTick_CALIB_SKEW_Msk             (1ul << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
+
+#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
+#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFul << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
+/*@}*/ /* end of group CMSIS_CM3_SysTick */
+
+
+/** @addtogroup CMSIS_CM3_ITM CMSIS CM3 ITM
+  memory mapped structure for Instrumentation Trace Macrocell (ITM)
+  @{
+ */
+typedef struct
+{
+  __O  union
+  {
+    __O  uint8_t    u8;                       /*!< Offset:       ITM Stimulus Port 8-bit                   */
+    __O  uint16_t   u16;                      /*!< Offset:       ITM Stimulus Port 16-bit                  */
+    __O  uint32_t   u32;                      /*!< Offset:       ITM Stimulus Port 32-bit                  */
+  }  PORT [32];                               /*!< Offset: 0x00  ITM Stimulus Port Registers               */
+       uint32_t RESERVED0[864];
+  __IO uint32_t TER;                          /*!< Offset:       ITM Trace Enable Register                 */
+       uint32_t RESERVED1[15];
+  __IO uint32_t TPR;                          /*!< Offset:       ITM Trace Privilege Register              */
+       uint32_t RESERVED2[15];
+  __IO uint32_t TCR;                          /*!< Offset:       ITM Trace Control Register                */
+       uint32_t RESERVED3[29];
+  __IO uint32_t IWR;                          /*!< Offset:       ITM Integration Write Register            */
+  __IO uint32_t IRR;                          /*!< Offset:       ITM Integration Read Register             */
+  __IO uint32_t IMCR;                         /*!< Offset:       ITM Integration Mode Control Register     */
+       uint32_t RESERVED4[43];
+  __IO uint32_t LAR;                          /*!< Offset:       ITM Lock Access Register                  */
+  __IO uint32_t LSR;                          /*!< Offset:       ITM Lock Status Register                  */
+       uint32_t RESERVED5[6];
+  __I  uint32_t PID4;                         /*!< Offset:       ITM Peripheral Identification Register #4 */
+  __I  uint32_t PID5;                         /*!< Offset:       ITM Peripheral Identification Register #5 */
+  __I  uint32_t PID6;                         /*!< Offset:       ITM Peripheral Identification Register #6 */
+  __I  uint32_t PID7;                         /*!< Offset:       ITM Peripheral Identification Register #7 */
+  __I  uint32_t PID0;                         /*!< Offset:       ITM Peripheral Identification Register #0 */
+  __I  uint32_t PID1;                         /*!< Offset:       ITM Peripheral Identification Register #1 */
+  __I  uint32_t PID2;                         /*!< Offset:       ITM Peripheral Identification Register #2 */
+  __I  uint32_t PID3;                         /*!< Offset:       ITM Peripheral Identification Register #3 */
+  __I  uint32_t CID0;                         /*!< Offset:       ITM Component  Identification Register #0 */
+  __I  uint32_t CID1;                         /*!< Offset:       ITM Component  Identification Register #1 */
+  __I  uint32_t CID2;                         /*!< Offset:       ITM Component  Identification Register #2 */
+  __I  uint32_t CID3;                         /*!< Offset:       ITM Component  Identification Register #3 */
+} ITM_Type;
+
+/* ITM Trace Privilege Register Definitions */
+#define ITM_TPR_PRIVMASK_Pos                0                                             /*!< ITM TPR: PRIVMASK Position */
+#define ITM_TPR_PRIVMASK_Msk               (0xFul << ITM_TPR_PRIVMASK_Pos)                /*!< ITM TPR: PRIVMASK Mask */
+
+/* ITM Trace Control Register Definitions */
+#define ITM_TCR_BUSY_Pos                   23                                             /*!< ITM TCR: BUSY Position */
+#define ITM_TCR_BUSY_Msk                   (1ul << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
+
+#define ITM_TCR_ATBID_Pos                  16                                             /*!< ITM TCR: ATBID Position */
+#define ITM_TCR_ATBID_Msk                  (0x7Ful << ITM_TCR_ATBID_Pos)                  /*!< ITM TCR: ATBID Mask */
+
+#define ITM_TCR_TSPrescale_Pos              8                                             /*!< ITM TCR: TSPrescale Position */
+#define ITM_TCR_TSPrescale_Msk             (3ul << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
+
+#define ITM_TCR_SWOENA_Pos                  4                                             /*!< ITM TCR: SWOENA Position */
+#define ITM_TCR_SWOENA_Msk                 (1ul << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
+
+#define ITM_TCR_DWTENA_Pos                  3                                             /*!< ITM TCR: DWTENA Position */
+#define ITM_TCR_DWTENA_Msk                 (1ul << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
+
+#define ITM_TCR_SYNCENA_Pos                 2                                             /*!< ITM TCR: SYNCENA Position */
+#define ITM_TCR_SYNCENA_Msk                (1ul << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
+
+#define ITM_TCR_TSENA_Pos                   1                                             /*!< ITM TCR: TSENA Position */
+#define ITM_TCR_TSENA_Msk                  (1ul << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
+
+#define ITM_TCR_ITMENA_Pos                  0                                             /*!< ITM TCR: ITM Enable bit Position */
+#define ITM_TCR_ITMENA_Msk                 (1ul << ITM_TCR_ITMENA_Pos)                    /*!< ITM TCR: ITM Enable bit Mask */
+
+/* ITM Integration Write Register Definitions */
+#define ITM_IWR_ATVALIDM_Pos                0                                             /*!< ITM IWR: ATVALIDM Position */
+#define ITM_IWR_ATVALIDM_Msk               (1ul << ITM_IWR_ATVALIDM_Pos)                  /*!< ITM IWR: ATVALIDM Mask */
+
+/* ITM Integration Read Register Definitions */
+#define ITM_IRR_ATREADYM_Pos                0                                             /*!< ITM IRR: ATREADYM Position */
+#define ITM_IRR_ATREADYM_Msk               (1ul << ITM_IRR_ATREADYM_Pos)                  /*!< ITM IRR: ATREADYM Mask */
+
+/* ITM Integration Mode Control Register Definitions */
+#define ITM_IMCR_INTEGRATION_Pos            0                                             /*!< ITM IMCR: INTEGRATION Position */
+#define ITM_IMCR_INTEGRATION_Msk           (1ul << ITM_IMCR_INTEGRATION_Pos)              /*!< ITM IMCR: INTEGRATION Mask */
+
+/* ITM Lock Status Register Definitions */
+#define ITM_LSR_ByteAcc_Pos                 2                                             /*!< ITM LSR: ByteAcc Position */
+#define ITM_LSR_ByteAcc_Msk                (1ul << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
+
+#define ITM_LSR_Access_Pos                  1                                             /*!< ITM LSR: Access Position */
+#define ITM_LSR_Access_Msk                 (1ul << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
+
+#define ITM_LSR_Present_Pos                 0                                             /*!< ITM LSR: Present Position */
+#define ITM_LSR_Present_Msk                (1ul << ITM_LSR_Present_Pos)                   /*!< ITM LSR: Present Mask */
+/*@}*/ /* end of group CMSIS_CM3_ITM */
+
+
+/** @addtogroup CMSIS_CM3_InterruptType CMSIS CM3 Interrupt Type
+  memory mapped structure for Interrupt Type
+  @{
+ */
+typedef struct
+{
+       uint32_t RESERVED0;
+  __I  uint32_t ICTR;                         /*!< Offset: 0x04  Interrupt Control Type Register */
+#if ((defined __CM3_REV) && (__CM3_REV >= 0x200))
+  __IO uint32_t ACTLR;                        /*!< Offset: 0x08  Auxiliary Control Register      */
+#else
+       uint32_t RESERVED1;
+#endif
+} InterruptType_Type;
+
+/* Interrupt Controller Type Register Definitions */
+#define InterruptType_ICTR_INTLINESNUM_Pos  0                                             /*!< InterruptType ICTR: INTLINESNUM Position */
+#define InterruptType_ICTR_INTLINESNUM_Msk (0x1Ful << InterruptType_ICTR_INTLINESNUM_Pos) /*!< InterruptType ICTR: INTLINESNUM Mask */
+
+/* Auxiliary Control Register Definitions */
+#define InterruptType_ACTLR_DISFOLD_Pos     2                                             /*!< InterruptType ACTLR: DISFOLD Position */
+#define InterruptType_ACTLR_DISFOLD_Msk    (1ul << InterruptType_ACTLR_DISFOLD_Pos)       /*!< InterruptType ACTLR: DISFOLD Mask */
+
+#define InterruptType_ACTLR_DISDEFWBUF_Pos  1                                             /*!< InterruptType ACTLR: DISDEFWBUF Position */
+#define InterruptType_ACTLR_DISDEFWBUF_Msk (1ul << InterruptType_ACTLR_DISDEFWBUF_Pos)    /*!< InterruptType ACTLR: DISDEFWBUF Mask */
+
+#define InterruptType_ACTLR_DISMCYCINT_Pos  0                                             /*!< InterruptType ACTLR: DISMCYCINT Position */
+#define InterruptType_ACTLR_DISMCYCINT_Msk (1ul << InterruptType_ACTLR_DISMCYCINT_Pos)    /*!< InterruptType ACTLR: DISMCYCINT Mask */
+/*@}*/ /* end of group CMSIS_CM3_InterruptType */
+
+
+#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1)
+/** @addtogroup CMSIS_CM3_MPU CMSIS CM3 MPU
+  memory mapped structure for Memory Protection Unit (MPU)
+  @{
+ */
+typedef struct
+{
+  __I  uint32_t TYPE;                         /*!< Offset: 0x00  MPU Type Register                              */
+  __IO uint32_t CTRL;                         /*!< Offset: 0x04  MPU Control Register                           */
+  __IO uint32_t RNR;                          /*!< Offset: 0x08  MPU Region RNRber Register                     */
+  __IO uint32_t RBAR;                         /*!< Offset: 0x0C  MPU Region Base Address Register               */
+  __IO uint32_t RASR;                         /*!< Offset: 0x10  MPU Region Attribute and Size Register         */
+  __IO uint32_t RBAR_A1;                      /*!< Offset: 0x14  MPU Alias 1 Region Base Address Register       */
+  __IO uint32_t RASR_A1;                      /*!< Offset: 0x18  MPU Alias 1 Region Attribute and Size Register */
+  __IO uint32_t RBAR_A2;                      /*!< Offset: 0x1C  MPU Alias 2 Region Base Address Register       */
+  __IO uint32_t RASR_A2;                      /*!< Offset: 0x20  MPU Alias 2 Region Attribute and Size Register */
+  __IO uint32_t RBAR_A3;                      /*!< Offset: 0x24  MPU Alias 3 Region Base Address Register       */
+  __IO uint32_t RASR_A3;                      /*!< Offset: 0x28  MPU Alias 3 Region Attribute and Size Register */
+} MPU_Type;
+
+/* MPU Type Register */
+#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
+#define MPU_TYPE_IREGION_Msk               (0xFFul << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
+
+#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
+#define MPU_TYPE_DREGION_Msk               (0xFFul << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
+
+#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
+#define MPU_TYPE_SEPARATE_Msk              (1ul << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU TYPE: SEPARATE Mask */
+
+/* MPU Control Register */
+#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
+#define MPU_CTRL_PRIVDEFENA_Msk            (1ul << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
+
+#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
+#define MPU_CTRL_HFNMIENA_Msk              (1ul << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
+
+#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
+#define MPU_CTRL_ENABLE_Msk                (1ul << MPU_CTRL_ENABLE_Pos)                   /*!< MPU CTRL: ENABLE Mask */
+
+/* MPU Region Number Register */
+#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
+#define MPU_RNR_REGION_Msk                 (0xFFul << MPU_RNR_REGION_Pos)                 /*!< MPU RNR: REGION Mask */
+
+/* MPU Region Base Address Register */
+#define MPU_RBAR_ADDR_Pos                   5                                             /*!< MPU RBAR: ADDR Position */
+#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFul << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
+
+#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
+#define MPU_RBAR_VALID_Msk                 (1ul << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
+
+#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
+#define MPU_RBAR_REGION_Msk                (0xFul << MPU_RBAR_REGION_Pos)                 /*!< MPU RBAR: REGION Mask */
+
+/* MPU Region Attribute and Size Register */
+#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: XN Position */
+#define MPU_RASR_XN_Msk                    (1ul << MPU_RASR_XN_Pos)                       /*!< MPU RASR: XN Mask */
+
+#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: AP Position */
+#define MPU_RASR_AP_Msk                    (7ul << MPU_RASR_AP_Pos)                       /*!< MPU RASR: AP Mask */
+
+#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: TEX Position */
+#define MPU_RASR_TEX_Msk                   (7ul << MPU_RASR_TEX_Pos)                      /*!< MPU RASR: TEX Mask */
+
+#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: Shareable bit Position */
+#define MPU_RASR_S_Msk                     (1ul << MPU_RASR_S_Pos)                        /*!< MPU RASR: Shareable bit Mask */
+
+#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: Cacheable bit Position */
+#define MPU_RASR_C_Msk                     (1ul << MPU_RASR_C_Pos)                        /*!< MPU RASR: Cacheable bit Mask */
+
+#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: Bufferable bit Position */
+#define MPU_RASR_B_Msk                     (1ul << MPU_RASR_B_Pos)                        /*!< MPU RASR: Bufferable bit Mask */
+
+#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
+#define MPU_RASR_SRD_Msk                   (0xFFul << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
+
+#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
+#define MPU_RASR_SIZE_Msk                  (0x1Ful << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
+
+#define MPU_RASR_ENA_Pos                     0                                            /*!< MPU RASR: Region enable bit Position */
+#define MPU_RASR_ENA_Msk                    (0x1Ful << MPU_RASR_ENA_Pos)                  /*!< MPU RASR: Region enable bit Disable Mask */
+
+/*@}*/ /* end of group CMSIS_CM3_MPU */
+#endif
+
+
+/** @addtogroup CMSIS_CM3_CoreDebug CMSIS CM3 Core Debug
+  memory mapped structure for Core Debug Register
+  @{
+ */
+typedef struct
+{
+  __IO uint32_t DHCSR;                        /*!< Offset: 0x00  Debug Halting Control and Status Register    */
+  __O  uint32_t DCRSR;                        /*!< Offset: 0x04  Debug Core Register Selector Register        */
+  __IO uint32_t DCRDR;                        /*!< Offset: 0x08  Debug Core Register Data Register            */
+  __IO uint32_t DEMCR;                        /*!< Offset: 0x0C  Debug Exception and Monitor Control Register */
+} CoreDebug_Type;
+
+/* Debug Halting Control and Status Register */
+#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
+#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFul << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
+
+#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
+#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1ul << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
+
+#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
+#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1ul << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
+
+#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
+#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1ul << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
+
+#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
+#define CoreDebug_DHCSR_S_SLEEP_Msk        (1ul << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
+
+#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
+#define CoreDebug_DHCSR_S_HALT_Msk         (1ul << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
+
+#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
+#define CoreDebug_DHCSR_S_REGRDY_Msk       (1ul << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
+
+#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
+#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1ul << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
+
+#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
+#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1ul << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
+
+#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
+#define CoreDebug_DHCSR_C_STEP_Msk         (1ul << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
+
+#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
+#define CoreDebug_DHCSR_C_HALT_Msk         (1ul << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
+
+#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
+#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1ul << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
+
+/* Debug Core Register Selector Register */
+#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
+#define CoreDebug_DCRSR_REGWnR_Msk         (1ul << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
+
+#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
+#define CoreDebug_DCRSR_REGSEL_Msk         (0x1Ful << CoreDebug_DCRSR_REGSEL_Pos)         /*!< CoreDebug DCRSR: REGSEL Mask */
+
+/* Debug Exception and Monitor Control Register */
+#define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!< CoreDebug DEMCR: TRCENA Position */
+#define CoreDebug_DEMCR_TRCENA_Msk         (1ul << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
+
+#define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!< CoreDebug DEMCR: MON_REQ Position */
+#define CoreDebug_DEMCR_MON_REQ_Msk        (1ul << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
+
+#define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!< CoreDebug DEMCR: MON_STEP Position */
+#define CoreDebug_DEMCR_MON_STEP_Msk       (1ul << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
+
+#define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!< CoreDebug DEMCR: MON_PEND Position */
+#define CoreDebug_DEMCR_MON_PEND_Msk       (1ul << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
+
+#define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!< CoreDebug DEMCR: MON_EN Position */
+#define CoreDebug_DEMCR_MON_EN_Msk         (1ul << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
+
+#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
+#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1ul << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
+
+#define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!< CoreDebug DEMCR: VC_INTERR Position */
+#define CoreDebug_DEMCR_VC_INTERR_Msk      (1ul << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
+
+#define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!< CoreDebug DEMCR: VC_BUSERR Position */
+#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1ul << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
+
+#define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!< CoreDebug DEMCR: VC_STATERR Position */
+#define CoreDebug_DEMCR_VC_STATERR_Msk     (1ul << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
+
+#define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!< CoreDebug DEMCR: VC_CHKERR Position */
+#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1ul << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
+
+#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!< CoreDebug DEMCR: VC_NOCPERR Position */
+#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1ul << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
+
+#define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!< CoreDebug DEMCR: VC_MMERR Position */
+#define CoreDebug_DEMCR_VC_MMERR_Msk       (1ul << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
+
+#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
+#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1ul << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< CoreDebug DEMCR: VC_CORERESET Mask */
+/*@}*/ /* end of group CMSIS_CM3_CoreDebug */
+
+
+/* Memory mapping of Cortex-M3 Hardware */
+#define SCS_BASE            (0xE000E000)                              /*!< System Control Space Base Address */
+#define ITM_BASE            (0xE0000000)                              /*!< ITM Base Address                  */
+#define CoreDebug_BASE      (0xE000EDF0)                              /*!< Core Debug Base Address           */
+#define SysTick_BASE        (SCS_BASE +  0x0010)                      /*!< SysTick Base Address              */
+#define NVIC_BASE           (SCS_BASE +  0x0100)                      /*!< NVIC Base Address                 */
+#define SCB_BASE            (SCS_BASE +  0x0D00)                      /*!< System Control Block Base Address */
+
+#define InterruptType       ((InterruptType_Type *) SCS_BASE)         /*!< Interrupt Type Register           */
+#define SCB                 ((SCB_Type *)           SCB_BASE)         /*!< SCB configuration struct          */
+#define SysTick             ((SysTick_Type *)       SysTick_BASE)     /*!< SysTick configuration struct      */
+#define NVIC                ((NVIC_Type *)          NVIC_BASE)        /*!< NVIC configuration struct         */
+#define ITM                 ((ITM_Type *)           ITM_BASE)         /*!< ITM configuration struct          */
+#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct   */
+
+#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1)
+  #define MPU_BASE          (SCS_BASE +  0x0D90)                      /*!< Memory Protection Unit            */
+  #define MPU               ((MPU_Type*)            MPU_BASE)         /*!< Memory Protection Unit            */
+#endif
+
+/*@}*/ /* end of group CMSIS_CM3_core_register */
+
+
+/*******************************************************************************
+ *                Hardware Abstraction Layer
+ ******************************************************************************/
+
+#if defined ( __CC_ARM   )
+  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
+  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
+
+#elif defined ( __ICCARM__ )
+  #define __ASM           __asm                                       /*!< asm keyword for IAR Compiler          */
+  #define __INLINE        inline                                      /*!< inline keyword for IAR Compiler. Only avaiable in High optimization mode! */
+
+#elif defined   (  __GNUC__  )
+  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
+  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
+
+#elif defined   (  __TASKING__  )
+  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
+  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
+
+#endif
+
+
+/* ###################  Compiler specific Intrinsics  ########################### */
+
+#if defined ( __CC_ARM   ) /*------------------RealView Compiler -----------------*/
+/* ARM armcc specific functions */
+
+#define __enable_fault_irq                __enable_fiq
+#define __disable_fault_irq               __disable_fiq
+
+#define __NOP                             __nop
+#define __WFI                             __wfi
+#define __WFE                             __wfe
+#define __SEV                             __sev
+#define __ISB()                           __isb(0)
+#define __DSB()                           __dsb(0)
+#define __DMB()                           __dmb(0)
+#define __REV                             __rev
+#define __RBIT                            __rbit
+#define __LDREXB(ptr)                     ((unsigned char ) __ldrex(ptr))
+#define __LDREXH(ptr)                     ((unsigned short) __ldrex(ptr))
+#define __LDREXW(ptr)                     ((unsigned int  ) __ldrex(ptr))
+#define __STREXB(value, ptr)              __strex(value, ptr)
+#define __STREXH(value, ptr)              __strex(value, ptr)
+#define __STREXW(value, ptr)              __strex(value, ptr)
+
+
+/* intrinsic unsigned long long __ldrexd(volatile void *ptr) */
+/* intrinsic int __strexd(unsigned long long val, volatile void *ptr) */
+/* intrinsic void __enable_irq();     */
+/* intrinsic void __disable_irq();    */
+
+
+/**
+ * @brief  Return the Process Stack Pointer
+ *
+ * @return ProcessStackPointer
+ *
+ * Return the actual process stack pointer
+ */
+extern uint32_t __get_PSP(void);
+
+/**
+ * @brief  Set the Process Stack Pointer
+ *
+ * @param  topOfProcStack  Process Stack Pointer
+ *
+ * Assign the value ProcessStackPointer to the MSP
+ * (process stack pointer) Cortex processor register
+ */
+extern void __set_PSP(uint32_t topOfProcStack);
+
+/**
+ * @brief  Return the Main Stack Pointer
+ *
+ * @return Main Stack Pointer
+ *
+ * Return the current value of the MSP (main stack pointer)
+ * Cortex processor register
+ */
+extern uint32_t __get_MSP(void);
+
+/**
+ * @brief  Set the Main Stack Pointer
+ *
+ * @param  topOfMainStack  Main Stack Pointer
+ *
+ * Assign the value mainStackPointer to the MSP
+ * (main stack pointer) Cortex processor register
+ */
+extern void __set_MSP(uint32_t topOfMainStack);
+
+/**
+ * @brief  Reverse byte order in unsigned short value
+ *
+ * @param   value  value to reverse
+ * @return         reversed value
+ *
+ * Reverse byte order in unsigned short value
+ */
+extern uint32_t __REV16(uint16_t value);
+
+/**
+ * @brief  Reverse byte order in signed short value with sign extension to integer
+ *
+ * @param   value  value to reverse
+ * @return         reversed value
+ *
+ * Reverse byte order in signed short value with sign extension to integer
+ */
+extern int32_t __REVSH(int16_t value);
+
+
+#if (__ARMCC_VERSION < 400000)
+
+/**
+ * @brief  Remove the exclusive lock created by ldrex
+ *
+ * Removes the exclusive lock which is created by ldrex.
+ */
+extern void __CLREX(void);
+
+/**
+ * @brief  Return the Base Priority value
+ *
+ * @return BasePriority
+ *
+ * Return the content of the base priority register
+ */
+extern uint32_t __get_BASEPRI(void);
+
+/**
+ * @brief  Set the Base Priority value
+ *
+ * @param  basePri  BasePriority
+ *
+ * Set the base priority register
+ */
+extern void __set_BASEPRI(uint32_t basePri);
+
+/**
+ * @brief  Return the Priority Mask value
+ *
+ * @return PriMask
+ *
+ * Return state of the priority mask bit from the priority mask register
+ */
+extern uint32_t __get_PRIMASK(void);
+
+/**
+ * @brief  Set the Priority Mask value
+ *
+ * @param   priMask  PriMask
+ *
+ * Set the priority mask bit in the priority mask register
+ */
+extern void __set_PRIMASK(uint32_t priMask);
+
+/**
+ * @brief  Return the Fault Mask value
+ *
+ * @return FaultMask
+ *
+ * Return the content of the fault mask register
+ */
+extern uint32_t __get_FAULTMASK(void);
+
+/**
+ * @brief  Set the Fault Mask value
+ *
+ * @param  faultMask faultMask value
+ *
+ * Set the fault mask register
+ */
+extern void __set_FAULTMASK(uint32_t faultMask);
+
+/**
+ * @brief  Return the Control Register value
+ *
+ * @return Control value
+ *
+ * Return the content of the control register
+ */
+extern uint32_t __get_CONTROL(void);
+
+/**
+ * @brief  Set the Control Register value
+ *
+ * @param  control  Control value
+ *
+ * Set the control register
+ */
+extern void __set_CONTROL(uint32_t control);
+
+#else  /* (__ARMCC_VERSION >= 400000)  */
+
+/**
+ * @brief  Remove the exclusive lock created by ldrex
+ *
+ * Removes the exclusive lock which is created by ldrex.
+ */
+#define __CLREX                           __clrex
+
+/**
+ * @brief  Return the Base Priority value
+ *
+ * @return BasePriority
+ *
+ * Return the content of the base priority register
+ */
+static __INLINE uint32_t  __get_BASEPRI(void)
+{
+  register uint32_t __regBasePri         __ASM("basepri");
+  return(__regBasePri);
+}
+
+/**
+ * @brief  Set the Base Priority value
+ *
+ * @param  basePri  BasePriority
+ *
+ * Set the base priority register
+ */
+static __INLINE void __set_BASEPRI(uint32_t basePri)
+{
+  register uint32_t __regBasePri         __ASM("basepri");
+  __regBasePri = (basePri & 0xff);
+}
+
+/**
+ * @brief  Return the Priority Mask value
+ *
+ * @return PriMask
+ *
+ * Return state of the priority mask bit from the priority mask register
+ */
+static __INLINE uint32_t __get_PRIMASK(void)
+{
+  register uint32_t __regPriMask         __ASM("primask");
+  return(__regPriMask);
+}
+
+/**
+ * @brief  Set the Priority Mask value
+ *
+ * @param  priMask  PriMask
+ *
+ * Set the priority mask bit in the priority mask register
+ */
+static __INLINE void __set_PRIMASK(uint32_t priMask)
+{
+  register uint32_t __regPriMask         __ASM("primask");
+  __regPriMask = (priMask);
+}
+
+/**
+ * @brief  Return the Fault Mask value
+ *
+ * @return FaultMask
+ *
+ * Return the content of the fault mask register
+ */
+static __INLINE uint32_t __get_FAULTMASK(void)
+{
+  register uint32_t __regFaultMask       __ASM("faultmask");
+  return(__regFaultMask);
+}
+
+/**
+ * @brief  Set the Fault Mask value
+ *
+ * @param  faultMask  faultMask value
+ *
+ * Set the fault mask register
+ */
+static __INLINE void __set_FAULTMASK(uint32_t faultMask)
+{
+  register uint32_t __regFaultMask       __ASM("faultmask");
+  __regFaultMask = (faultMask & 1);
+}
+
+/**
+ * @brief  Return the Control Register value
+ *
+ * @return Control value
+ *
+ * Return the content of the control register
+ */
+static __INLINE uint32_t __get_CONTROL(void)
+{
+  register uint32_t __regControl         __ASM("control");
+  return(__regControl);
+}
+
+/**
+ * @brief  Set the Control Register value
+ *
+ * @param  control  Control value
+ *
+ * Set the control register
+ */
+static __INLINE void __set_CONTROL(uint32_t control)
+{
+  register uint32_t __regControl         __ASM("control");
+  __regControl = control;
+}
+
+#endif /* __ARMCC_VERSION  */
+
+
+
+#elif (defined (__ICCARM__)) /*------------------ ICC Compiler -------------------*/
+/* IAR iccarm specific functions */
+
+#define __enable_irq                              __enable_interrupt        /*!< global Interrupt enable */
+#define __disable_irq                             __disable_interrupt       /*!< global Interrupt disable */
+
+static __INLINE void __enable_fault_irq()         { __ASM ("cpsie f"); }
+static __INLINE void __disable_fault_irq()        { __ASM ("cpsid f"); }
+
+#define __NOP                                     __no_operation            /*!< no operation intrinsic in IAR Compiler */
+static __INLINE  void __WFI()                     { __ASM ("wfi"); }
+static __INLINE  void __WFE()                     { __ASM ("wfe"); }
+static __INLINE  void __SEV()                     { __ASM ("sev"); }
+static __INLINE  void __CLREX()                   { __ASM ("clrex"); }
+
+/* intrinsic void __ISB(void)                                     */
+/* intrinsic void __DSB(void)                                     */
+/* intrinsic void __DMB(void)                                     */
+/* intrinsic void __set_PRIMASK();                                */
+/* intrinsic void __get_PRIMASK();                                */
+/* intrinsic void __set_FAULTMASK();                              */
+/* intrinsic void __get_FAULTMASK();                              */
+/* intrinsic uint32_t __REV(uint32_t value);                      */
+/* intrinsic uint32_t __REVSH(uint32_t value);                    */
+/* intrinsic unsigned long __STREX(unsigned long, unsigned long); */
+/* intrinsic unsigned long __LDREX(unsigned long *);              */
+
+
+/**
+ * @brief  Return the Process Stack Pointer
+ *
+ * @return ProcessStackPointer
+ *
+ * Return the actual process stack pointer
+ */
+extern uint32_t __get_PSP(void);
+
+/**
+ * @brief  Set the Process Stack Pointer
+ *
+ * @param  topOfProcStack  Process Stack Pointer
+ *
+ * Assign the value ProcessStackPointer to the MSP
+ * (process stack pointer) Cortex processor register
+ */
+extern void __set_PSP(uint32_t topOfProcStack);
+
+/**
+ * @brief  Return the Main Stack Pointer
+ *
+ * @return Main Stack Pointer
+ *
+ * Return the current value of the MSP (main stack pointer)
+ * Cortex processor register
+ */
+extern uint32_t __get_MSP(void);
+
+/**
+ * @brief  Set the Main Stack Pointer
+ *
+ * @param  topOfMainStack  Main Stack Pointer
+ *
+ * Assign the value mainStackPointer to the MSP
+ * (main stack pointer) Cortex processor register
+ */
+extern void __set_MSP(uint32_t topOfMainStack);
+
+/**
+ * @brief  Reverse byte order in unsigned short value
+ *
+ * @param  value  value to reverse
+ * @return        reversed value
+ *
+ * Reverse byte order in unsigned short value
+ */
+extern uint32_t __REV16(uint16_t value);
+
+/**
+ * @brief  Reverse bit order of value
+ *
+ * @param  value  value to reverse
+ * @return        reversed value
+ *
+ * Reverse bit order of value
+ */
+extern uint32_t __RBIT(uint32_t value);
+
+/**
+ * @brief  LDR Exclusive (8 bit)
+ *
+ * @param  *addr  address pointer
+ * @return        value of (*address)
+ *
+ * Exclusive LDR command for 8 bit values)
+ */
+extern uint8_t __LDREXB(uint8_t *addr);
+
+/**
+ * @brief  LDR Exclusive (16 bit)
+ *
+ * @param  *addr  address pointer
+ * @return        value of (*address)
+ *
+ * Exclusive LDR command for 16 bit values
+ */
+extern uint16_t __LDREXH(uint16_t *addr);
+
+/**
+ * @brief  LDR Exclusive (32 bit)
+ *
+ * @param  *addr  address pointer
+ * @return        value of (*address)
+ *
+ * Exclusive LDR command for 32 bit values
+ */
+extern uint32_t __LDREXW(uint32_t *addr);
+
+/**
+ * @brief  STR Exclusive (8 bit)
+ *
+ * @param  value  value to store
+ * @param  *addr  address pointer
+ * @return        successful / failed
+ *
+ * Exclusive STR command for 8 bit values
+ */
+extern uint32_t __STREXB(uint8_t value, uint8_t *addr);
+
+/**
+ * @brief  STR Exclusive (16 bit)
+ *
+ * @param  value  value to store
+ * @param  *addr  address pointer
+ * @return        successful / failed
+ *
+ * Exclusive STR command for 16 bit values
+ */
+extern uint32_t __STREXH(uint16_t value, uint16_t *addr);
+
+/**
+ * @brief  STR Exclusive (32 bit)
+ *
+ * @param  value  value to store
+ * @param  *addr  address pointer
+ * @return        successful / failed
+ *
+ * Exclusive STR command for 32 bit values
+ */
+extern uint32_t __STREXW(uint32_t value, uint32_t *addr);
+
+
+
+#elif (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/
+/* GNU gcc specific functions */
+
+static __INLINE void __enable_irq(void)               { __ASM volatile ("cpsie i"); }
+static __INLINE void __disable_irq(void)              { __ASM volatile ("cpsid i"); }
+
+static __INLINE void __enable_fault_irq(void)         { __ASM volatile ("cpsie f"); }
+static __INLINE void __disable_fault_irq(void)        { __ASM volatile ("cpsid f"); }
+
+static __INLINE void __NOP(void)                      { __ASM volatile ("nop"); }
+static __INLINE void __WFI(void)                      { __ASM volatile ("wfi"); }
+static __INLINE void __WFE(void)                      { __ASM volatile ("wfe"); }
+static __INLINE void __SEV(void)                      { __ASM volatile ("sev"); }
+static __INLINE void __ISB(void)                      { __ASM volatile ("isb"); }
+static __INLINE void __DSB(void)                      { __ASM volatile ("dsb"); }
+static __INLINE void __DMB(void)                      { __ASM volatile ("dmb"); }
+static __INLINE void __CLREX(void)                    { __ASM volatile ("clrex"); }
+
+
+/**
+ * @brief  Return the Process Stack Pointer
+ *
+ * @return ProcessStackPointer
+ *
+ * Return the actual process stack pointer
+ */
+extern uint32_t __get_PSP(void);
+
+/**
+ * @brief  Set the Process Stack Pointer
+ *
+ * @param  topOfProcStack  Process Stack Pointer
+ *
+ * Assign the value ProcessStackPointer to the MSP
+ * (process stack pointer) Cortex processor register
+ */
+extern void __set_PSP(uint32_t topOfProcStack);
+
+/**
+ * @brief  Return the Main Stack Pointer
+ *
+ * @return Main Stack Pointer
+ *
+ * Return the current value of the MSP (main stack pointer)
+ * Cortex processor register
+ */
+extern uint32_t __get_MSP(void);
+
+/**
+ * @brief  Set the Main Stack Pointer
+ *
+ * @param  topOfMainStack  Main Stack Pointer
+ *
+ * Assign the value mainStackPointer to the MSP
+ * (main stack pointer) Cortex processor register
+ */
+extern void __set_MSP(uint32_t topOfMainStack);
+
+/**
+ * @brief  Return the Base Priority value
+ *
+ * @return BasePriority
+ *
+ * Return the content of the base priority register
+ */
+extern uint32_t __get_BASEPRI(void);
+
+/**
+ * @brief  Set the Base Priority value
+ *
+ * @param  basePri  BasePriority
+ *
+ * Set the base priority register
+ */
+extern void __set_BASEPRI(uint32_t basePri);
+
+/**
+ * @brief  Return the Priority Mask value
+ *
+ * @return PriMask
+ *
+ * Return state of the priority mask bit from the priority mask register
+ */
+extern uint32_t  __get_PRIMASK(void);
+
+/**
+ * @brief  Set the Priority Mask value
+ *
+ * @param  priMask  PriMask
+ *
+ * Set the priority mask bit in the priority mask register
+ */
+extern void __set_PRIMASK(uint32_t priMask);
+
+/**
+ * @brief  Return the Fault Mask value
+ *
+ * @return FaultMask
+ *
+ * Return the content of the fault mask register
+ */
+extern uint32_t __get_FAULTMASK(void);
+
+/**
+ * @brief  Set the Fault Mask value
+ *
+ * @param  faultMask  faultMask value
+ *
+ * Set the fault mask register
+ */
+extern void __set_FAULTMASK(uint32_t faultMask);
+
+/**
+ * @brief  Return the Control Register value
+*
+*  @return Control value
+ *
+ * Return the content of the control register
+ */
+extern uint32_t __get_CONTROL(void);
+
+/**
+ * @brief  Set the Control Register value
+ *
+ * @param  control  Control value
+ *
+ * Set the control register
+ */
+extern void __set_CONTROL(uint32_t control);
+
+/**
+ * @brief  Reverse byte order in integer value
+ *
+ * @param  value  value to reverse
+ * @return        reversed value
+ *
+ * Reverse byte order in integer value
+ */
+extern uint32_t __REV(uint32_t value);
+
+/**
+ * @brief  Reverse byte order in unsigned short value
+ *
+ * @param  value  value to reverse
+ * @return        reversed value
+ *
+ * Reverse byte order in unsigned short value
+ */
+extern uint32_t __REV16(uint16_t value);
+
+/**
+ * @brief  Reverse byte order in signed short value with sign extension to integer
+ *
+ * @param  value  value to reverse
+ * @return        reversed value
+ *
+ * Reverse byte order in signed short value with sign extension to integer
+ */
+extern int32_t __REVSH(int16_t value);
+
+/**
+ * @brief  Reverse bit order of value
+ *
+ * @param  value  value to reverse
+ * @return        reversed value
+ *
+ * Reverse bit order of value
+ */
+extern uint32_t __RBIT(uint32_t value);
+
+/**
+ * @brief  LDR Exclusive (8 bit)
+ *
+ * @param  *addr  address pointer
+ * @return        value of (*address)
+ *
+ * Exclusive LDR command for 8 bit value
+ */
+extern uint8_t __LDREXB(uint8_t *addr);
+
+/**
+ * @brief  LDR Exclusive (16 bit)
+ *
+ * @param  *addr  address pointer
+ * @return        value of (*address)
+ *
+ * Exclusive LDR command for 16 bit values
+ */
+extern uint16_t __LDREXH(uint16_t *addr);
+
+/**
+ * @brief  LDR Exclusive (32 bit)
+ *
+ * @param  *addr  address pointer
+ * @return        value of (*address)
+ *
+ * Exclusive LDR command for 32 bit values
+ */
+extern uint32_t __LDREXW(uint32_t *addr);
+
+/**
+ * @brief  STR Exclusive (8 bit)
+ *
+ * @param  value  value to store
+ * @param  *addr  address pointer
+ * @return        successful / failed
+ *
+ * Exclusive STR command for 8 bit values
+ */
+extern uint32_t __STREXB(uint8_t value, uint8_t *addr);
+
+/**
+ * @brief  STR Exclusive (16 bit)
+ *
+ * @param  value  value to store
+ * @param  *addr  address pointer
+ * @return        successful / failed
+ *
+ * Exclusive STR command for 16 bit values
+ */
+extern uint32_t __STREXH(uint16_t value, uint16_t *addr);
+
+/**
+ * @brief  STR Exclusive (32 bit)
+ *
+ * @param  value  value to store
+ * @param  *addr  address pointer
+ * @return        successful / failed
+ *
+ * Exclusive STR command for 32 bit values
+ */
+extern uint32_t __STREXW(uint32_t value, uint32_t *addr);
+
+
+#elif (defined (__TASKING__)) /*------------------ TASKING Compiler ---------------------*/
+/* TASKING carm specific functions */
+
+/*
+ * The CMSIS functions have been implemented as intrinsics in the compiler.
+ * Please use "carm -?i" to get an up to date list of all instrinsics,
+ * Including the CMSIS ones.
+ */
+
+#endif
+
+
+/** @addtogroup CMSIS_CM3_Core_FunctionInterface CMSIS CM3 Core Function Interface
+  Core  Function Interface containing:
+  - Core NVIC Functions
+  - Core SysTick Functions
+  - Core Reset Functions
+*/
+/*@{*/
+
+/* ##########################   NVIC functions  #################################### */
+
+/**
+ * @brief  Set the Priority Grouping in NVIC Interrupt Controller
+ *
+ * @param  PriorityGroup is priority grouping field
+ *
+ * Set the priority grouping field using the required unlock sequence.
+ * The parameter priority_grouping is assigned to the field
+ * SCB->AIRCR [10:8] PRIGROUP field. Only values from 0..7 are used.
+ * In case of a conflict between priority grouping and available
+ * priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
+ */
+static __INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
+{
+  uint32_t reg_value;
+  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);                         /* only values 0..7 are used          */
+
+  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
+  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
+  reg_value  =  (reg_value                       |
+                (0x5FA << SCB_AIRCR_VECTKEY_Pos) |
+                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
+  SCB->AIRCR =  reg_value;
+}
+
+/**
+ * @brief  Get the Priority Grouping from NVIC Interrupt Controller
+ *
+ * @return priority grouping field
+ *
+ * Get the priority grouping from NVIC Interrupt Controller.
+ * priority grouping is SCB->AIRCR [10:8] PRIGROUP field.
+ */
+static __INLINE uint32_t NVIC_GetPriorityGrouping(void)
+{
+  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
+}
+
+/**
+ * @brief  Enable Interrupt in NVIC Interrupt Controller
+ *
+ * @param  IRQn   The positive number of the external interrupt to enable
+ *
+ * Enable a device specific interupt in the NVIC interrupt controller.
+ * The interrupt number cannot be a negative value.
+ */
+static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
+{
+  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
+}
+
+/**
+ * @brief  Disable the interrupt line for external interrupt specified
+ *
+ * @param  IRQn   The positive number of the external interrupt to disable
+ *
+ * Disable a device specific interupt in the NVIC interrupt controller.
+ * The interrupt number cannot be a negative value.
+ */
+static __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
+{
+  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
+}
+
+/**
+ * @brief  Read the interrupt pending bit for a device specific interrupt source
+ *
+ * @param  IRQn    The number of the device specifc interrupt
+ * @return         1 = interrupt pending, 0 = interrupt not pending
+ *
+ * Read the pending register in NVIC and return 1 if its status is pending,
+ * otherwise it returns 0
+ */
+static __INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
+{
+  return((uint32_t) ((NVIC->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */
+}
+
+/**
+ * @brief  Set the pending bit for an external interrupt
+ *
+ * @param  IRQn    The number of the interrupt for set pending
+ *
+ * Set the pending bit for the specified interrupt.
+ * The interrupt number cannot be a negative value.
+ */
+static __INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
+{
+  NVIC->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
+}
+
+/**
+ * @brief  Clear the pending bit for an external interrupt
+ *
+ * @param  IRQn    The number of the interrupt for clear pending
+ *
+ * Clear the pending bit for the specified interrupt.
+ * The interrupt number cannot be a negative value.
+ */
+static __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
+{
+  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
+}
+
+/**
+ * @brief  Read the active bit for an external interrupt
+ *
+ * @param  IRQn    The number of the interrupt for read active bit
+ * @return         1 = interrupt active, 0 = interrupt not active
+ *
+ * Read the active register in NVIC and returns 1 if its status is active,
+ * otherwise it returns 0.
+ */
+static __INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
+{
+  return((uint32_t)((NVIC->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if active else 0 */
+}
+
+/**
+ * @brief  Set the priority for an interrupt
+ *
+ * @param  IRQn      The number of the interrupt for set priority
+ * @param  priority  The priority to set
+ *
+ * Set the priority for the specified interrupt. The interrupt
+ * number can be positive to specify an external (device specific)
+ * interrupt, or negative to specify an internal (core) interrupt.
+ *
+ * Note: The priority cannot be set for every core interrupt.
+ */
+static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
+{
+  if(IRQn < 0) {
+    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M3 System Interrupts */
+  else {
+    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
+}
+
+/**
+ * @brief  Read the priority for an interrupt
+ *
+ * @param  IRQn      The number of the interrupt for get priority
+ * @return           The priority for the interrupt
+ *
+ * Read the priority for the specified interrupt. The interrupt
+ * number can be positive to specify an external (device specific)
+ * interrupt, or negative to specify an internal (core) interrupt.
+ *
+ * The returned priority value is automatically aligned to the implemented
+ * priority bits of the microcontroller.
+ *
+ * Note: The priority cannot be set for every core interrupt.
+ */
+static __INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
+{
+
+  if(IRQn < 0) {
+    return((uint32_t)(SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M3 system interrupts */
+  else {
+    return((uint32_t)(NVIC->IP[(uint32_t)(IRQn)]           >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
+}
+
+
+/**
+ * @brief  Encode the priority for an interrupt
+ *
+ * @param  PriorityGroup    The used priority group
+ * @param  PreemptPriority  The preemptive priority value (starting from 0)
+ * @param  SubPriority      The sub priority value (starting from 0)
+ * @return                  The encoded priority for the interrupt
+ *
+ * Encode the priority for an interrupt with the given priority group,
+ * preemptive priority value and sub priority value.
+ * In case of a conflict between priority grouping and available
+ * priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
+ *
+ * The returned priority value can be used for NVIC_SetPriority(...) function
+ */
+static __INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
+{
+  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
+  uint32_t PreemptPriorityBits;
+  uint32_t SubPriorityBits;
+
+  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
+  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
+
+  return (
+           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
+           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
+         );
+}
+
+
+/**
+ * @brief  Decode the priority of an interrupt
+ *
+ * @param  Priority           The priority for the interrupt
+ * @param  PriorityGroup      The used priority group
+ * @param  pPreemptPriority   The preemptive priority value (starting from 0)
+ * @param  pSubPriority       The sub priority value (starting from 0)
+ *
+ * Decode an interrupt priority value with the given priority group to
+ * preemptive priority value and sub priority value.
+ * In case of a conflict between priority grouping and available
+ * priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
+ *
+ * The priority value can be retrieved with NVIC_GetPriority(...) function
+ */
+static __INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
+{
+  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
+  uint32_t PreemptPriorityBits;
+  uint32_t SubPriorityBits;
+
+  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
+  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
+
+  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);
+  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);
+}
+
+
+
+/* ##################################    SysTick function  ############################################ */
+
+#if (!defined (__Vendor_SysTickConfig)) || (__Vendor_SysTickConfig == 0)
+
+/**
+ * @brief  Initialize and start the SysTick counter and its interrupt.
+ *
+ * @param   ticks   number of ticks between two interrupts
+ * @return  1 = failed, 0 = successful
+ *
+ * Initialise the system tick timer and its interrupt and start the
+ * system tick timer / counter in free running mode to generate
+ * periodical interrupts.
+ */
+static __INLINE uint32_t SysTick_Config(uint32_t ticks)
+{
+  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
+
+  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
+  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
+  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
+  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
+                   SysTick_CTRL_TICKINT_Msk   |
+                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
+  return (0);                                                  /* Function successful */
+}
+
+#endif
+
+
+
+
+/* ##################################    Reset function  ############################################ */
+
+/**
+ * @brief  Initiate a system reset request.
+ *
+ * Initiate a system reset request to reset the MCU
+ */
+static __INLINE void NVIC_SystemReset(void)
+{
+  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
+                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
+                 SCB_AIRCR_SYSRESETREQ_Msk);                   /* Keep priority group unchanged */
+  __DSB();                                                     /* Ensure completion of memory access */
+  while(1);                                                    /* wait until reset */
+}
+
+/*@}*/ /* end of group CMSIS_CM3_Core_FunctionInterface */
+
+
+
+/* ##################################### Debug In/Output function ########################################### */
+
+/** @addtogroup CMSIS_CM3_CoreDebugInterface CMSIS CM3 Core Debug Interface
+  Core Debug Interface containing:
+  - Core Debug Receive / Transmit Functions
+  - Core Debug Defines
+  - Core Debug Variables
+*/
+/*@{*/
+
+extern volatile int ITM_RxBuffer;                    /*!< variable to receive characters                             */
+#define             ITM_RXBUFFER_EMPTY    0x5AA55AA5 /*!< value identifying ITM_RxBuffer is ready for next character */
+
+
+/**
+ * @brief  Outputs a character via the ITM channel 0
+ *
+ * @param  ch   character to output
+ * @return      character to output
+ *
+ * The function outputs a character via the ITM channel 0.
+ * The function returns when no debugger is connected that has booked the output.
+ * It is blocking when a debugger is connected, but the previous character send is not transmitted.
+ */
+static __INLINE uint32_t ITM_SendChar (uint32_t ch)
+{
+  if ((CoreDebug->DEMCR & CoreDebug_DEMCR_TRCENA_Msk)  &&      /* Trace enabled */
+      (ITM->TCR & ITM_TCR_ITMENA_Msk)                  &&      /* ITM enabled */
+      (ITM->TER & (1ul << 0)        )                    )     /* ITM Port #0 enabled */
+  {
+    while (ITM->PORT[0].u32 == 0);
+    ITM->PORT[0].u8 = (uint8_t) ch;
+  }
+  return (ch);
+}
+
+
+/**
+ * @brief  Inputs a character via variable ITM_RxBuffer
+ *
+ * @return      received character, -1 = no character received
+ *
+ * The function inputs a character via variable ITM_RxBuffer.
+ * The function returns when no debugger is connected that has booked the output.
+ * It is blocking when a debugger is connected, but the previous character send is not transmitted.
+ */
+static __INLINE int ITM_ReceiveChar (void) {
+  int ch = -1;                               /* no character available */
+
+  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY) {
+    ch = ITM_RxBuffer;
+    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
+  }
+
+  return (ch);
+}
+
+
+/**
+ * @brief  Check if a character via variable ITM_RxBuffer is available
+ *
+ * @return      1 = character available, 0 = no character available
+ *
+ * The function checks  variable ITM_RxBuffer whether a character is available or not.
+ * The function returns '1' if a character is available and '0' if no character is available.
+ */
+static __INLINE int ITM_CheckChar (void) {
+
+  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY) {
+    return (0);                                 /* no character available */
+  } else {
+    return (1);                                 /*    character available */
+  }
+}
+
+/*@}*/ /* end of group CMSIS_CM3_core_DebugInterface */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/*@}*/ /* end of group CMSIS_CM3_core_definitions */
+
+#endif /* __CM3_CORE_H__ */
+
+/*lint -restore */
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/Release_Notes.html b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/Release_Notes.html
new file mode 100644
index 0000000..b80f38d
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/Release_Notes.html
@@ -0,0 +1,284 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:w="urn:schemas-microsoft-com:office:word" xmlns="http://www.w3.org/TR/REC-html40"><head>
+
+
+
+
+
+
+
+
+<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+<link rel="File-List" href="Library_files/filelist.xml">
+<link rel="Edit-Time-Data" href="Library_files/editdata.mso"><!--[if !mso]> <style> v\:* {behavior:url(#default#VML);} o\:* {behavior:url(#default#VML);} w\:* {behavior:url(#default#VML);} .shape {behavior:url(#default#VML);} </style> <![endif]--><title>Release Notes for STM32F10x CMSIS</title><!--[if gte mso 9]><xml> <o:DocumentProperties> <o:Author>STMicroelectronics</o:Author> <o:LastAuthor>STMicroelectronics</o:LastAuthor> <o:Revision>37</o:Revision> <o:TotalTime>136</o:TotalTime> <o:Created>2009-02-27T19:26:00Z</o:Created> <o:LastSaved>2009-03-01T17:56:00Z</o:LastSaved> <o:Pages>1</o:Pages> <o:Words>522</o:Words> <o:Characters>2977</o:Characters> <o:Company>STMicroelectronics</o:Company> <o:Lines>24</o:Lines> <o:Paragraphs>6</o:Paragraphs> <o:CharactersWithSpaces>3493</o:CharactersWithSpaces> <o:Version>11.6568</o:Version> </o:DocumentProperties> </xml><![endif]--><!--[if gte mso 9]><xml> <w:WordDocument> <w:Zoom>110</w:Zoom> <w:ValidateAgainstSchemas/> <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid> <w:IgnoreMixedContent>false</w:IgnoreMixedContent> <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText> <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel> </w:WordDocument> </xml><![endif]--><!--[if gte mso 9]><xml> <w:LatentStyles DefLockedState="false" LatentStyleCount="156"> </w:LatentStyles> </xml><![endif]-->
+
+
+
+<style>
+<!--
+/* Style Definitions */
+p.MsoNormal, li.MsoNormal, div.MsoNormal
+{mso-style-parent:"";
+margin:0in;
+margin-bottom:.0001pt;
+mso-pagination:widow-orphan;
+font-size:12.0pt;
+font-family:"Times New Roman";
+mso-fareast-font-family:"Times New Roman";}
+h2
+{mso-style-next:Normal;
+margin-top:12.0pt;
+margin-right:0in;
+margin-bottom:3.0pt;
+margin-left:0in;
+mso-pagination:widow-orphan;
+page-break-after:avoid;
+mso-outline-level:2;
+font-size:14.0pt;
+font-family:Arial;
+font-weight:bold;
+font-style:italic;}
+a:link, span.MsoHyperlink
+{color:blue;
+text-decoration:underline;
+text-underline:single;}
+a:visited, span.MsoHyperlinkFollowed
+{color:blue;
+text-decoration:underline;
+text-underline:single;}
+p
+{mso-margin-top-alt:auto;
+margin-right:0in;
+mso-margin-bottom-alt:auto;
+margin-left:0in;
+mso-pagination:widow-orphan;
+font-size:12.0pt;
+font-family:"Times New Roman";
+mso-fareast-font-family:"Times New Roman";}
+@page Section1
+{size:8.5in 11.0in;
+margin:1.0in 1.25in 1.0in 1.25in;
+mso-header-margin:.5in;
+mso-footer-margin:.5in;
+mso-paper-source:0;}
+div.Section1
+{page:Section1;}
+-->
+</style><!--[if gte mso 10]> <style> /* Style Definitions */ table.MsoNormalTable {mso-style-name:"Table Normal"; mso-tstyle-rowband-size:0; mso-tstyle-colband-size:0; mso-style-noshow:yes; mso-style-parent:""; mso-padding-alt:0in 5.4pt 0in 5.4pt; mso-para-margin:0in; mso-para-margin-bottom:.0001pt; mso-pagination:widow-orphan; font-size:10.0pt; font-family:"Times New Roman"; mso-ansi-language:#0400; mso-fareast-language:#0400; mso-bidi-language:#0400;} </style> <![endif]--><!--[if gte mso 9]><xml> <o:shapedefaults v:ext="edit" spidmax="5122"/> </xml><![endif]--><!--[if gte mso 9]><xml> <o:shapelayout v:ext="edit"> <o:idmap v:ext="edit" data="1"/> </o:shapelayout></xml><![endif]--></head>
+<body lang="EN-US" link="blue" vlink="blue">
+<div class="Section1">
+<p class="MsoNormal"><span style="font-family: Arial;"><o:p><br>
+</o:p></span></p>
+<div align="center">
+<table class="MsoNormalTable" style="width: 675pt;" border="0" cellpadding="0" cellspacing="0" width="900">
+<tbody>
+<tr style="">
+<td style="padding: 0cm;" valign="top">
+<table class="MsoNormalTable" style="width: 675pt;" border="0" cellpadding="0" cellspacing="0" width="900">
+<tbody>
+          <tr>
+            <td style="vertical-align: top;"><span style="font-size: 8pt; font-family: Arial; color: blue;"><a href="../../../../../../Release_Notes.html">Back to Release page</a></span></td>
+          </tr>
+<tr style="">
+<td style="padding: 1.5pt;">
+<h1 style="margin-bottom: 18pt; text-align: center;" align="center"><span style="font-size: 20pt; font-family: Verdana; color: rgb(51, 102, 255);">Release
+Notes for STM32F10x CMSIS</span><span style="font-size: 20pt; font-family: Verdana;"><o:p></o:p></span></h1>
+<p class="MsoNormal" style="text-align: center;" align="center"><span style="font-size: 10pt; font-family: Arial; color: black;">Copyright 2011 STMicroelectronics</span><span style="color: black;"><u1:p></u1:p><o:p></o:p></span></p>
+<p class="MsoNormal" style="text-align: center;" align="center"><span style="font-size: 10pt; font-family: Arial; color: black;"><img alt="" id="_x0000_i1025" src="../../../../../../_htmresc/logo.bmp" style="border: 0px solid ; width: 86px; height: 65px;"></span><span style="font-size: 10pt;"><o:p></o:p></span></p>
+</td>
+</tr>
+</tbody>
+</table>
+<p class="MsoNormal"><span style="font-family: Arial; display: none;"><o:p>&nbsp;</o:p></span></p>
+<table class="MsoNormalTable" style="width: 675pt;" border="0" cellpadding="0" width="900">
+<tbody>
+<tr>
+<td style="padding: 0cm;" valign="top">
+<h2 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial;"><span style="font-size: 12pt; color: white;">Contents<o:p></o:p></span></h2>
+<ol style="margin-top: 0cm;" start="1" type="1">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"><a href="#History">STM32F10x CMSIS
+update History</a><o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"><a href="#License">License</a><o:p></o:p></span></li>
+</ol>
+<span style="font-family: &quot;Times New Roman&quot;;"></span>
+<h2 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial;"><a name="History"></a><span style="font-size: 12pt; color: white;">STM32F10x CMSIS
+update History</span></h2><br>
+            <h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; margin-right: 500pt; width: 167px;"><span style="font-size: 10pt; font-family: Arial; color: white;">V3.5.0 / 11-March-2011<o:p></o:p></span></h3>
+            <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 18pt;"><b style=""><u><span style="font-size: 10pt; font-family: Verdana; color: black;">Main
+Changes<o:p></o:p></span></u></b></p>
+
+            <ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">stm32f10x.h
+</span>and <span style="font-style: italic;">startup_stm32f10x_hd_vl.s</span> files: remove the FSMC interrupt
+definition for STM32F10x High-density Value line devices.<br>
+</span></li>
+              <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">system_stm32f10x.c</span> file&nbsp;provided within the CMSIS folder. <br>
+</span></li>
+
+            </ul>
+
+            <h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; margin-right: 558.05pt;"><span style="font-size: 10pt; font-family: Arial; color: white;">3.4.0
+- 10/15/2010</span></h3>
+
+            <ol>
+<li><b><i><span style="font-size: 10pt; font-family: Verdana;">General</span></i></b></li>
+            </ol>
+
+            <ul style="margin-top: 0in;" type="disc">
+              <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Add support
+for&nbsp;<b>STM32F10x High-density Value line devices</b>.</span></li>
+            </ul>
+            <ol start="2">
+              <li><b><i><span style="font-size: 10pt; font-family: Verdana;">STM32F10x CMSIS Device Peripheral Access Layer </span></i></b></li>
+            </ol>
+
+
+
+            <ul style="margin-top: 0in;" type="disc">
+<li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;">STM32F10x CMSIS Cortex-M3 Device Peripheral Access Layer Header File:</span> <span style="font-weight: bold; font-style: italic;">stm32f10x.h</span></span><br>
+              </li><ul><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Update to support High-density Value line devices</span><span style="font-size: 10pt; font-family: Verdana;"></span></li><ul><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Add new define <span style="font-style: italic;">STM32F10X_HD_VL</span></span></li>
+                  <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">RCC, AFIO, FSMC bits definition updated</span></li>
+</ul>
+                <li class="MsoNormal" style="">
+
+                  <span style="font-size: 10pt; font-family: &quot;Verdana&quot;,&quot;sans-serif&quot;;">All
+STM32 devices definitions are commented by default. User has to select the
+appropriate device before starting else an error will be signaled on compile
+time.</span></li>
+                <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: &quot;Verdana&quot;,&quot;sans-serif&quot;;">Add new IRQs definitons inside the IRQn_Type enumeration for STM23 High-density Value line devices.</span></li>
+                <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: &quot;Verdana&quot;,&quot;sans-serif&quot;;">"<span style="font-weight: bold;">bool</span>" type removed.</span><br>
+                  <span style="font-size: 10pt; font-family: &quot;Verdana&quot;,&quot;sans-serif&quot;;"></span></li>
+</ul><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;">STM32F10x CMSIS Cortex-M3 Device Peripheral Access Layer System Files:</span> <span style="font-weight: bold; font-style: italic;">system_stm32f10x.h and system_stm32f10x.c</span></span><br>
+                <span style="font-size: 10pt; font-family: Verdana;"></span></li>
+              <ul>
+<li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="font-weight: bold; font-style: italic;">"system_stm32f10x.c" </span><span style="font-weight: bold;"></span>moved to to "<span style="font-weight: bold; font-style: italic;">STM32F10x_StdPeriph_Template</span>" directory. This file is also moved to each example directory under "<span style="font-weight: bold; font-style: italic;">STM32F10x_StdPeriph_Examples</span>".</span><br>
+<span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;"></span></span></li>
+                <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">SystemInit_ExtMemCtl() </span>function: update to support High-density Value line devices.</span></li>
+                <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Add "<span style="font-style: italic;">VECT_TAB_SRAM</span>" inside "</span><span style="font-size: 10pt; font-family: Verdana;"><span style="font-weight: bold; font-style: italic;">system_stm32f10x.c</span></span><span style="font-size: 10pt; font-family: Verdana;">"
+to select if the user want to place the Vector Table in internal SRAM.
+An additional define is also to specify the Vector Table offset "<span style="font-style: italic;">VECT_TAB_OFFSET</span>".<br>
+                  </span></li>
+
+              </ul>
+<li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;">STM32F10x CMSIS startup files:</span></span><span style="font-size: 10pt; font-family: Verdana;"><span style="font-weight: bold; font-style: italic;">startup_stm32f10x_xx.s</span></span></li><ul><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Add three
+startup files for STM32 High-density Value line devices:
+                  <span style="font-weight: bold; font-style: italic;">startup_stm32f10x_hd_vl.s</span></span></li></ul>
+            </ul>
+            <h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; margin-right: 558.05pt;"><span style="font-size: 10pt; font-family: Arial; color: white;">3.3.0
+- 04/16/2010</span></h3>
+
+<ol><li><b><i><span style="font-size: 10pt; font-family: Verdana;">General</span></i></b></li></ol>
+<ul style="margin-top: 0in;" type="disc"><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Add support
+for&nbsp;<b>STM32F10x XL-density devices</b>.</span></li><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Add startup files for TrueSTUDIO toolchain<br></span></li></ul><ol start="2"><li><b><i><span style="font-size: 10pt; font-family: Verdana;">STM32F10x CMSIS Device Peripheral Access Layer </span></i></b></li></ol>
+
+            <ul style="margin-top: 0in;" type="disc"><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;">STM32F10x CMSIS Cortex-M3 Device Peripheral Access Layer Header File:</span> <span style="font-weight: bold; font-style: italic;">stm32f10x.h</span></span><br>
+              </li><ul><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Update to support XL-density devices</span><span style="font-size: 10pt; font-family: Verdana;"></span></li><ul><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Add new define <span style="font-style: italic;">STM32F10X_XL</span></span></li></ul><ul><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Add new IRQs for&nbsp;</span><span style="font-size: 10pt; font-family: Verdana;">TIM9..14</span></li><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Update FLASH_TypeDef structure</span></li><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Add new IP instances TIM9..14</span></li><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">RCC, AFIO, DBGMCU bits definition updated</span></li></ul><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Correct IRQs definition for MD-, LD-, MD_VL- and LD_VL-density devices&nbsp;(remove&nbsp;comma "," at the end of enum list)<br></span></li></ul><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;">STM32F10x CMSIS Cortex-M3 Device Peripheral Access Layer System Files:</span> <span style="font-weight: bold; font-style: italic;">system_stm32f10x.h and system_stm32f10x.c</span></span><br>
+                <span style="font-size: 10pt; font-family: Verdana;"></span></li><ul><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">SystemInit_ExtMemCtl() </span>function: update to support XL-density devices</span></li><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">SystemInit()</span> function: swap the order of SetSysClock() and SystemInit_ExtMemCtl() functions.&nbsp;</span><span style="font-size: 10pt; font-family: Verdana;"><br>
+                  </span></li></ul><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;">STM32F10x CMSIS startup files:</span><span style="font-weight: bold; font-style: italic;"></span><span style="font-style: italic;"><span style="font-weight: bold;"></span></span></span></li><ul><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">add three
+startup files for STM32 XL-density&nbsp;devices:
+                  <span style="font-weight: bold; font-style: italic;">startup_stm32f10x_xl.s</span></span></li><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="font-weight: bold;">startup_stm32f10x_md_vl.s</span> for RIDE7: add USART3 IRQ&nbsp;Handler (was missing in&nbsp;previous version)</span></li><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Add startup files for TrueSTUDIO toolchain</span></li></ul></ul><span style="font-size: 10pt; font-family: Verdana;"><span style="font-weight: bold; font-style: italic;"></span></span>
+<h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; margin-right: 558.05pt;"><span style="font-size: 10pt; font-family: Arial; color: white;">3.2.0
+- 03/01/2010</span></h3>
+<ol style="margin-top: 0in;" start="1" type="1">
+<li class="MsoNormal" style=""><b><i><span style="font-size: 10pt; font-family: Verdana;">General</span></i></b><i><span style="font-size: 10pt; font-family: Verdana;"></span></i><i><span style="font-size: 10pt;"><o:p></o:p></span></i></li>
+</ol>
+<ul style="margin-top: 0in;" type="disc">
+
+              <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">STM32F10x CMSIS files updated to <span style="font-weight: bold;">CMSIS V1.30</span> release</span></li>
+              <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Directory structure updated to be aligned with CMSIS V1.30<br>
+                </span></li>
+              <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Add support
+for&nbsp;<b>STM32 Low-density Value line (STM32F100x4/6) and
+Medium-density Value line (STM32F100x8/B) devices</b>.&nbsp;</span><span style="font-size: 10pt;"><o:p></o:p></span></li>
+
+</ul>
+<ol style="margin-top: 0in;" start="2" type="1">
+<li class="MsoNormal" style=""><b><i><span style="font-size: 10pt; font-family: Verdana;">CMSIS Core Peripheral Access Layer</span></i></b></li></ol>
+            <ul>
+              <li><b><i><span style="font-size: 10pt; font-family: Verdana;"></span></i></b><span style="font-size: 10pt; font-family: Verdana;"> Refer to <a href="../../../CMSIS_changes.htm" target="_blank">CMSIS changes</a></span></li>
+            </ul>
+            <ol style="margin-top: 0in; list-style-type: decimal;" start="3">
+              <li class="MsoNormal" style=""><b><i><span style="font-size: 10pt; font-family: Verdana;">STM32F10x CMSIS Device Peripheral Access Layer </span></i></b><b><i><span style="font-size: 10pt;"><o:p></o:p></span></i></b></li>
+
+            </ol>
+
+            <ul style="margin-top: 0in;" type="disc">
+
+              <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;">STM32F10x CMSIS Cortex-M3 Device Peripheral Access Layer Header File:</span> <span style="font-weight: bold; font-style: italic;">stm32f10x.h</span></span><br>
+              </li>
+              <ul>
+                <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Update
+the stm32f10x.h file to support new Value line devices features: CEC
+peripheral, new General purpose timers TIM15, TIM16 and TIM17.</span></li>
+                <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Peripherals Bits definitions updated to be in line with Value line devices available features.<br>
+                  </span></li>
+                <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">HSE_Value,
+HSI_Value and HSEStartup_TimeOut changed to upper case: HSE_VALUE,
+HSI_VALUE and HSE_STARTUP_TIMEOUT. Old names are kept for legacy
+purposes.<br>
+                  </span></li>
+              </ul>
+              <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;">STM32F10x CMSIS Cortex-M3 Device Peripheral Access Layer System Files:</span> <span style="font-weight: bold; font-style: italic;">system_stm32f10x.h and system_stm32f10x.c</span></span><br>
+                <span style="font-size: 10pt; font-family: Verdana;"></span></li>
+              <ul>
+                <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">SystemFrequency variable name changed to SystemCoreClock</span><br>
+                  <span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;"></span></span></li>
+                <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">Default
+                  </span></span><span style="font-size: 10pt; font-family: Verdana;">SystemCoreClock</span><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;"> is changed to 24MHz when Value line devices are selected and to 72MHz on other devices.</span></span><span style="font-size: 10pt;"><o:p></o:p></span><span style="font-size: 10pt; font-family: Verdana;"> <br>
+                  </span></li>
+                <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">All while(1) loop were removed from all clock setting functions. User has to handle the HSE startup failure.<br>
+                  </span></li>
+                <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Additional function <span style="font-weight: bold; font-style: italic;">void SystemCoreClockUpdate (void)</span> is provided.<br>
+                  </span></li>
+              </ul>
+              <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;">STM32F10x CMSIS Startup files:</span> <span style="font-weight: bold; font-style: italic;">startup_stm32f10x_xx.s</span></span></li>
+              <ul>
+                <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Add new
+startup files for STM32 Low-density Value line devices:
+                  <span style="font-weight: bold; font-style: italic;">startup_stm32f10x_ld_vl.s</span></span></li>
+                <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Add new startup
+files for STM32 Medium-density Value line devices:
+                  <span style="font-weight: bold; font-style: italic;">startup_stm32f10x_md_vl.s</span></span></li>
+                <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">SystemInit() function is called from startup file (startup_stm32f10x_xx.s) before to branch to application main.<br>
+To reconfigure the default setting of SystemInit() function, refer to system_stm32f10x.c file <br>
+</span></li>
+                <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">GNU startup file for Low density devices (startup_stm32f10x_ld.s) is updated to fix compilation errors.<br>
+</span></li>
+              </ul>
+
+            </ul>
+
+<ul style="margin-top: 0in;" type="disc">
+</ul>
+<h2 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial;"><a name="License"></a><span style="font-size: 12pt; color: white;">License<o:p></o:p></span></h2>
+<p class="MsoNormal" style="margin: 4.5pt 0cm;"><span style="font-size: 10pt; font-family: Verdana; color: black;">The
+enclosed firmware and all the related documentation are not covered by
+a License Agreement, if you need such License you can contact your
+local STMicroelectronics office.<u1:p></u1:p><o:p></o:p></span></p>
+<p class="MsoNormal"><b style=""><span style="font-size: 10pt; font-family: Verdana; color: black;">THE
+PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO
+SAVE TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR
+ANY DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY
+CLAIMS ARISING FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY
+CUSTOMERS OF THE CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH
+THEIR PRODUCTS. <o:p></o:p></span></b></p>
+<p class="MsoNormal"><span style="color: black;"><o:p>&nbsp;</o:p></span></p>
+<div class="MsoNormal" style="text-align: center;" align="center"><span style="color: black;">
+<hr align="center" size="2" width="100%"></span></div>
+<p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 18pt; text-align: center;" align="center"><span style="font-size: 10pt; font-family: Verdana; color: black;">For
+complete documentation on </span><span style="font-size: 10pt; font-family: Verdana;">STM32(<span style="color: black;">CORTEX M3) 32-Bit Microcontrollers
+visit </span><u><span style="color: blue;"><a href="http://www.st.com/stm32" target="_blank">www.st.com/STM32</a></span></u></span><span style="color: black;"><o:p></o:p></span></p>
+</td>
+</tr>
+</tbody>
+</table>
+<p class="MsoNormal"><span style="font-size: 10pt;"><o:p></o:p></span></p>
+</td>
+</tr>
+</tbody>
+</table>
+</div>
+<p class="MsoNormal"><o:p>&nbsp;</o:p></p>
+</div>
+</body></html>
\ No newline at end of file
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_cl.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_cl.s
new file mode 100644
index 0000000..e34a520
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_cl.s
@@ -0,0 +1,473 @@
+/**
+  ******************************************************************************
+  * @file      startup_stm32f10x_cl.s
+  * @author    MCD Application Team
+  * @version   V3.5.0
+  * @date      11-March-2011
+  * @brief     STM32F10x Connectivity line Devices vector table for Atollic
+  *            toolchain.
+  *            This module performs:
+  *                - Set the initial SP
+  *                - Set the initial PC == Reset_Handler,
+  *                - Set the vector table entries with the exceptions ISR
+  *                  address.
+  *                - Configure the clock system
+  *                - Branches to main in the C library (which eventually
+  *                  calls main()).
+  *            After Reset the Cortex-M3 processor is in Thread mode,
+  *            priority is Privileged, and the Stack is set to Main.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+  .syntax unified
+	.cpu cortex-m3
+	.fpu softvfp
+	.thumb
+
+.global	g_pfnVectors
+.global	Default_Handler
+
+/* start address for the initialization values of the .data section.
+defined in linker script */
+.word	_sidata
+/* start address for the .data section. defined in linker script */
+.word	_sdata
+/* end address for the .data section. defined in linker script */
+.word	_edata
+/* start address for the .bss section. defined in linker script */
+.word	_sbss
+/* end address for the .bss section. defined in linker script */
+.word	_ebss
+
+.equ  BootRAM, 0xF1E0F85F
+/**
+ * @brief  This is the code that gets called when the processor first
+ *          starts execution following a reset event. Only the absolutely
+ *          necessary set is performed, after which the application
+ *          supplied main() routine is called.
+ * @param  None
+ * @retval : None
+*/
+
+    .section	.text.Reset_Handler
+	.weak	Reset_Handler
+	.type	Reset_Handler, %function
+Reset_Handler:
+
+/* Copy the data segment initializers from flash to SRAM */
+  movs	r1, #0
+  b	LoopCopyDataInit
+
+CopyDataInit:
+	ldr	r3, =_sidata
+	ldr	r3, [r3, r1]
+	str	r3, [r0, r1]
+	adds	r1, r1, #4
+
+LoopCopyDataInit:
+	ldr	r0, =_sdata
+	ldr	r3, =_edata
+	adds	r2, r0, r1
+	cmp	r2, r3
+	bcc	CopyDataInit
+	ldr	r2, =_sbss
+	b	LoopFillZerobss
+
+/* Zero fill the bss segment. */
+FillZerobss:
+	movs	r3, #0
+	str	r3, [r2], #4
+
+LoopFillZerobss:
+	ldr	r3, = _ebss
+	cmp	r2, r3
+	bcc	FillZerobss
+
+/* Call the clock system intitialization function.*/
+   bl  SystemInit
+/* Call static constructors */
+   bl __libc_init_array
+/* Call the application's entry point.*/
+	bl	main
+	bx	lr
+.size	Reset_Handler, .-Reset_Handler
+
+/**
+ * @brief  This is the code that gets called when the processor receives an
+ *         unexpected interrupt.  This simply enters an infinite loop, preserving
+ *         the system state for examination by a debugger.
+ *
+ * @param  None
+ * @retval : None
+*/
+    .section	.text.Default_Handler,"ax",%progbits
+Default_Handler:
+Infinite_Loop:
+	b	Infinite_Loop
+	.size	Default_Handler, .-Default_Handler
+
+/******************************************************************************
+*
+* The minimal vector table for a Cortex M3.  Note that the proper constructs
+* must be placed on this to ensure that it ends up at physical address
+* 0x0000.0000.
+*
+******************************************************************************/
+	.section	.isr_vector,"a",%progbits
+	.type	g_pfnVectors, %object
+	.size	g_pfnVectors, .-g_pfnVectors
+
+
+g_pfnVectors:
+	.word	_estack
+	.word	Reset_Handler
+	.word	NMI_Handler
+	.word	HardFault_Handler
+	.word	MemManage_Handler
+	.word	BusFault_Handler
+	.word	UsageFault_Handler
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	SVC_Handler
+	.word	DebugMon_Handler
+	.word	0
+	.word	PendSV_Handler
+	.word	SysTick_Handler
+	.word	WWDG_IRQHandler
+	.word	PVD_IRQHandler
+	.word	TAMPER_IRQHandler
+	.word	RTC_IRQHandler
+	.word	FLASH_IRQHandler
+	.word	RCC_IRQHandler
+	.word	EXTI0_IRQHandler
+	.word	EXTI1_IRQHandler
+	.word	EXTI2_IRQHandler
+	.word	EXTI3_IRQHandler
+	.word	EXTI4_IRQHandler
+	.word	DMA1_Channel1_IRQHandler
+	.word	DMA1_Channel2_IRQHandler
+	.word	DMA1_Channel3_IRQHandler
+	.word	DMA1_Channel4_IRQHandler
+	.word	DMA1_Channel5_IRQHandler
+	.word	DMA1_Channel6_IRQHandler
+	.word	DMA1_Channel7_IRQHandler
+	.word	ADC1_2_IRQHandler
+  .word CAN1_TX_IRQHandler
+  .word CAN1_RX0_IRQHandler
+	.word	CAN1_RX1_IRQHandler
+	.word	CAN1_SCE_IRQHandler
+	.word	EXTI9_5_IRQHandler
+	.word	TIM1_BRK_IRQHandler
+	.word	TIM1_UP_IRQHandler
+	.word	TIM1_TRG_COM_IRQHandler
+	.word	TIM1_CC_IRQHandler
+	.word	TIM2_IRQHandler
+	.word	TIM3_IRQHandler
+	.word	TIM4_IRQHandler
+	.word	I2C1_EV_IRQHandler
+	.word	I2C1_ER_IRQHandler
+	.word	I2C2_EV_IRQHandler
+	.word	I2C2_ER_IRQHandler
+	.word	SPI1_IRQHandler
+	.word	SPI2_IRQHandler
+	.word	USART1_IRQHandler
+	.word	USART2_IRQHandler
+	.word	USART3_IRQHandler
+	.word	EXTI15_10_IRQHandler
+	.word	RTCAlarm_IRQHandler
+	.word	OTG_FS_WKUP_IRQHandler
+  .word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word TIM5_IRQHandler
+  .word SPI3_IRQHandler
+  .word UART4_IRQHandler
+  .word UART5_IRQHandler
+  .word TIM6_IRQHandler
+  .word TIM7_IRQHandler
+  .word DMA2_Channel1_IRQHandler
+  .word DMA2_Channel2_IRQHandler
+  .word DMA2_Channel3_IRQHandler
+  .word DMA2_Channel4_IRQHandler
+  .word DMA2_Channel5_IRQHandler
+  .word ETH_IRQHandler
+  .word ETH_WKUP_IRQHandler
+  .word CAN2_TX_IRQHandler
+  .word CAN2_RX0_IRQHandler
+  .word CAN2_RX1_IRQHandler
+  .word CAN2_SCE_IRQHandler
+  .word OTG_FS_IRQHandler
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word BootRAM     /* @0x1E0. This is for boot in RAM mode for
+                         STM32F10x Connectivity line Devices. */
+
+/*******************************************************************************
+*
+* Provide weak aliases for each Exception handler to the Default_Handler.
+* As they are weak aliases, any function with the same name will override
+* this definition.
+*
+*******************************************************************************/
+  .weak	NMI_Handler
+	.thumb_set NMI_Handler,Default_Handler
+
+  .weak	HardFault_Handler
+	.thumb_set HardFault_Handler,Default_Handler
+
+  .weak	MemManage_Handler
+	.thumb_set MemManage_Handler,Default_Handler
+
+  .weak	BusFault_Handler
+	.thumb_set BusFault_Handler,Default_Handler
+
+	.weak	UsageFault_Handler
+	.thumb_set UsageFault_Handler,Default_Handler
+
+	.weak	SVC_Handler
+	.thumb_set SVC_Handler,Default_Handler
+
+	.weak	DebugMon_Handler
+	.thumb_set DebugMon_Handler,Default_Handler
+
+	.weak	PendSV_Handler
+	.thumb_set PendSV_Handler,Default_Handler
+
+	.weak	SysTick_Handler
+	.thumb_set SysTick_Handler,Default_Handler
+
+	.weak	WWDG_IRQHandler
+	.thumb_set WWDG_IRQHandler,Default_Handler
+
+	.weak	PVD_IRQHandler
+	.thumb_set PVD_IRQHandler,Default_Handler
+
+	.weak	TAMPER_IRQHandler
+	.thumb_set TAMPER_IRQHandler,Default_Handler
+
+	.weak	RTC_IRQHandler
+	.thumb_set RTC_IRQHandler,Default_Handler
+
+	.weak	FLASH_IRQHandler
+	.thumb_set FLASH_IRQHandler,Default_Handler
+
+	.weak	RCC_IRQHandler
+	.thumb_set RCC_IRQHandler,Default_Handler
+
+	.weak	EXTI0_IRQHandler
+	.thumb_set EXTI0_IRQHandler,Default_Handler
+
+	.weak	EXTI1_IRQHandler
+	.thumb_set EXTI1_IRQHandler,Default_Handler
+
+	.weak	EXTI2_IRQHandler
+	.thumb_set EXTI2_IRQHandler,Default_Handler
+
+	.weak	EXTI3_IRQHandler
+	.thumb_set EXTI3_IRQHandler,Default_Handler
+
+	.weak	EXTI4_IRQHandler
+	.thumb_set EXTI4_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel1_IRQHandler
+	.thumb_set DMA1_Channel1_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel2_IRQHandler
+	.thumb_set DMA1_Channel2_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel3_IRQHandler
+	.thumb_set DMA1_Channel3_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel4_IRQHandler
+	.thumb_set DMA1_Channel4_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel5_IRQHandler
+	.thumb_set DMA1_Channel5_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel6_IRQHandler
+	.thumb_set DMA1_Channel6_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel7_IRQHandler
+	.thumb_set DMA1_Channel7_IRQHandler,Default_Handler
+
+	.weak	ADC1_2_IRQHandler
+	.thumb_set ADC1_2_IRQHandler,Default_Handler
+
+	.weak	CAN1_TX_IRQHandler
+	.thumb_set CAN1_TX_IRQHandler,Default_Handler
+
+	.weak	CAN1_RX0_IRQHandler
+	.thumb_set CAN1_RX0_IRQHandler,Default_Handler
+
+	.weak	CAN1_RX1_IRQHandler
+	.thumb_set CAN1_RX1_IRQHandler,Default_Handler
+
+	.weak	CAN1_SCE_IRQHandler
+	.thumb_set CAN1_SCE_IRQHandler,Default_Handler
+
+	.weak	EXTI9_5_IRQHandler
+	.thumb_set EXTI9_5_IRQHandler,Default_Handler
+
+	.weak	TIM1_BRK_IRQHandler
+	.thumb_set TIM1_BRK_IRQHandler,Default_Handler
+
+	.weak	TIM1_UP_IRQHandler
+	.thumb_set TIM1_UP_IRQHandler,Default_Handler
+
+	.weak	TIM1_TRG_COM_IRQHandler
+	.thumb_set TIM1_TRG_COM_IRQHandler,Default_Handler
+
+	.weak	TIM1_CC_IRQHandler
+	.thumb_set TIM1_CC_IRQHandler,Default_Handler
+
+	.weak	TIM2_IRQHandler
+	.thumb_set TIM2_IRQHandler,Default_Handler
+
+	.weak	TIM3_IRQHandler
+	.thumb_set TIM3_IRQHandler,Default_Handler
+
+	.weak	TIM4_IRQHandler
+	.thumb_set TIM4_IRQHandler,Default_Handler
+
+	.weak	I2C1_EV_IRQHandler
+	.thumb_set I2C1_EV_IRQHandler,Default_Handler
+
+	.weak	I2C1_ER_IRQHandler
+	.thumb_set I2C1_ER_IRQHandler,Default_Handler
+
+	.weak	I2C2_EV_IRQHandler
+	.thumb_set I2C2_EV_IRQHandler,Default_Handler
+
+	.weak	I2C2_ER_IRQHandler
+	.thumb_set I2C2_ER_IRQHandler,Default_Handler
+
+	.weak	SPI1_IRQHandler
+	.thumb_set SPI1_IRQHandler,Default_Handler
+
+	.weak	SPI2_IRQHandler
+	.thumb_set SPI2_IRQHandler,Default_Handler
+
+	.weak	USART1_IRQHandler
+	.thumb_set USART1_IRQHandler,Default_Handler
+
+	.weak	USART2_IRQHandler
+	.thumb_set USART2_IRQHandler,Default_Handler
+
+	.weak	USART3_IRQHandler
+	.thumb_set USART3_IRQHandler,Default_Handler
+
+	.weak	EXTI15_10_IRQHandler
+	.thumb_set EXTI15_10_IRQHandler,Default_Handler
+
+	.weak	RTCAlarm_IRQHandler
+	.thumb_set RTCAlarm_IRQHandler,Default_Handler
+
+	.weak	OTG_FS_WKUP_IRQHandler
+	.thumb_set OTG_FS_WKUP_IRQHandler,Default_Handler
+
+	.weak	TIM5_IRQHandler
+	.thumb_set TIM5_IRQHandler,Default_Handler
+
+	.weak	SPI3_IRQHandler
+	.thumb_set SPI3_IRQHandler,Default_Handler
+
+	.weak	UART4_IRQHandler
+	.thumb_set UART4_IRQHandler,Default_Handler
+
+	.weak	UART5_IRQHandler
+	.thumb_set UART5_IRQHandler,Default_Handler
+
+	.weak	TIM6_IRQHandler
+	.thumb_set TIM6_IRQHandler,Default_Handler
+
+	.weak	TIM7_IRQHandler
+	.thumb_set TIM7_IRQHandler,Default_Handler
+
+	.weak	DMA2_Channel1_IRQHandler
+	.thumb_set DMA2_Channel1_IRQHandler,Default_Handler
+
+	.weak	DMA2_Channel2_IRQHandler
+	.thumb_set DMA2_Channel2_IRQHandler,Default_Handler
+
+	.weak	DMA2_Channel3_IRQHandler
+	.thumb_set DMA2_Channel3_IRQHandler,Default_Handler
+
+	.weak	DMA2_Channel4_IRQHandler
+	.thumb_set DMA2_Channel4_IRQHandler,Default_Handler
+
+	.weak	DMA2_Channel5_IRQHandler
+	.thumb_set DMA2_Channel5_IRQHandler,Default_Handler
+
+	.weak	ETH_IRQHandler
+	.thumb_set ETH_IRQHandler,Default_Handler
+
+	.weak	ETH_WKUP_IRQHandler
+	.thumb_set ETH_WKUP_IRQHandler,Default_Handler
+
+	.weak	CAN2_TX_IRQHandler
+	.thumb_set CAN2_TX_IRQHandler,Default_Handler
+
+	.weak	CAN2_RX0_IRQHandler
+	.thumb_set CAN2_RX0_IRQHandler,Default_Handler
+
+	.weak	CAN2_RX1_IRQHandler
+	.thumb_set CAN2_RX1_IRQHandler,Default_Handler
+
+	.weak	CAN2_SCE_IRQHandler
+	.thumb_set CAN2_SCE_IRQHandler,Default_Handler
+
+	.weak	OTG_FS_IRQHandler
+	.thumb_set OTG_FS_IRQHandler ,Default_Handler
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_hd.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_hd.s
new file mode 100644
index 0000000..0aa9188
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_hd.s
@@ -0,0 +1,469 @@
+/**
+  ******************************************************************************
+  * @file      startup_stm32f10x_hd.s
+  * @author    MCD Application Team
+  * @version   V3.5.0
+  * @date      11-March-2011
+  * @brief     STM32F10x High Density Devices vector table for Atollic toolchain.
+  *            This module performs:
+  *                - Set the initial SP
+  *                - Set the initial PC == Reset_Handler,
+  *                - Set the vector table entries with the exceptions ISR address,
+  *                - Configure the clock system
+  *                - Configure external SRAM mounted on STM3210E-EVAL board
+  *                  to be used as data memory (optional, to be enabled by user)
+  *                - Branches to main in the C library (which eventually
+  *                  calls main()).
+  *            After Reset the Cortex-M3 processor is in Thread mode,
+  *            priority is Privileged, and the Stack is set to Main.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+    .syntax unified
+	.cpu cortex-m3
+	.fpu softvfp
+	.thumb
+
+.global	g_pfnVectors
+.global	Default_Handler
+
+/* start address for the initialization values of the .data section.
+defined in linker script */
+.word	_sidata
+/* start address for the .data section. defined in linker script */
+.word	_sdata
+/* end address for the .data section. defined in linker script */
+.word	_edata
+/* start address for the .bss section. defined in linker script */
+.word	_sbss
+/* end address for the .bss section. defined in linker script */
+.word	_ebss
+
+.equ  BootRAM,        0xF1E0F85F
+/**
+ * @brief  This is the code that gets called when the processor first
+ *          starts execution following a reset event. Only the absolutely
+ *          necessary set is performed, after which the application
+ *          supplied main() routine is called.
+ * @param  None
+ * @retval : None
+*/
+
+    .section	.text.Reset_Handler
+	.weak	Reset_Handler
+	.type	Reset_Handler, %function
+Reset_Handler:
+
+/* Copy the data segment initializers from flash to SRAM */
+  movs	r1, #0
+  b	LoopCopyDataInit
+
+CopyDataInit:
+	ldr	r3, =_sidata
+	ldr	r3, [r3, r1]
+	str	r3, [r0, r1]
+	adds	r1, r1, #4
+
+LoopCopyDataInit:
+	ldr	r0, =_sdata
+	ldr	r3, =_edata
+	adds	r2, r0, r1
+	cmp	r2, r3
+	bcc	CopyDataInit
+	ldr	r2, =_sbss
+	b	LoopFillZerobss
+/* Zero fill the bss segment. */
+FillZerobss:
+	movs	r3, #0
+	str	r3, [r2], #4
+
+LoopFillZerobss:
+	ldr	r3, = _ebss
+	cmp	r2, r3
+	bcc	FillZerobss
+
+/* Call the clock system intitialization function.*/
+    bl  SystemInit
+/* Call static constructors */
+    bl __libc_init_array
+/* Call the application's entry point.*/
+	bl	main
+	bx	lr
+.size	Reset_Handler, .-Reset_Handler
+
+/**
+ * @brief  This is the code that gets called when the processor receives an
+ *         unexpected interrupt.  This simply enters an infinite loop, preserving
+ *         the system state for examination by a debugger.
+ *
+ * @param  None
+ * @retval : None
+*/
+    .section	.text.Default_Handler,"ax",%progbits
+Default_Handler:
+Infinite_Loop:
+	b	Infinite_Loop
+	.size	Default_Handler, .-Default_Handler
+/******************************************************************************
+*
+* The minimal vector table for a Cortex M3.  Note that the proper constructs
+* must be placed on this to ensure that it ends up at physical address
+* 0x0000.0000.
+*
+******************************************************************************/
+	.section	.isr_vector,"a",%progbits
+	.type	g_pfnVectors, %object
+	.size	g_pfnVectors, .-g_pfnVectors
+
+
+g_pfnVectors:
+	.word	_estack
+	.word	Reset_Handler
+	.word	NMI_Handler
+	.word	HardFault_Handler
+	.word	MemManage_Handler
+	.word	BusFault_Handler
+	.word	UsageFault_Handler
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	SVC_Handler
+	.word	DebugMon_Handler
+	.word	0
+	.word	PendSV_Handler
+	.word	SysTick_Handler
+	.word	WWDG_IRQHandler
+	.word	PVD_IRQHandler
+	.word	TAMPER_IRQHandler
+	.word	RTC_IRQHandler
+	.word	FLASH_IRQHandler
+	.word	RCC_IRQHandler
+	.word	EXTI0_IRQHandler
+	.word	EXTI1_IRQHandler
+	.word	EXTI2_IRQHandler
+	.word	EXTI3_IRQHandler
+	.word	EXTI4_IRQHandler
+	.word	DMA1_Channel1_IRQHandler
+	.word	DMA1_Channel2_IRQHandler
+	.word	DMA1_Channel3_IRQHandler
+	.word	DMA1_Channel4_IRQHandler
+	.word	DMA1_Channel5_IRQHandler
+	.word	DMA1_Channel6_IRQHandler
+	.word	DMA1_Channel7_IRQHandler
+	.word	ADC1_2_IRQHandler
+	.word	USB_HP_CAN1_TX_IRQHandler
+	.word	USB_LP_CAN1_RX0_IRQHandler
+	.word	CAN1_RX1_IRQHandler
+	.word	CAN1_SCE_IRQHandler
+	.word	EXTI9_5_IRQHandler
+	.word	TIM1_BRK_IRQHandler
+	.word	TIM1_UP_IRQHandler
+	.word	TIM1_TRG_COM_IRQHandler
+	.word	TIM1_CC_IRQHandler
+	.word	TIM2_IRQHandler
+	.word	TIM3_IRQHandler
+	.word	TIM4_IRQHandler
+	.word	I2C1_EV_IRQHandler
+	.word	I2C1_ER_IRQHandler
+	.word	I2C2_EV_IRQHandler
+	.word	I2C2_ER_IRQHandler
+	.word	SPI1_IRQHandler
+	.word	SPI2_IRQHandler
+	.word	USART1_IRQHandler
+	.word	USART2_IRQHandler
+	.word	USART3_IRQHandler
+	.word	EXTI15_10_IRQHandler
+	.word	RTCAlarm_IRQHandler
+	.word	USBWakeUp_IRQHandler
+	.word	TIM8_BRK_IRQHandler
+	.word	TIM8_UP_IRQHandler
+	.word	TIM8_TRG_COM_IRQHandler
+	.word	TIM8_CC_IRQHandler
+	.word	ADC3_IRQHandler
+	.word	FSMC_IRQHandler
+	.word	SDIO_IRQHandler
+	.word	TIM5_IRQHandler
+	.word	SPI3_IRQHandler
+	.word	UART4_IRQHandler
+	.word	UART5_IRQHandler
+	.word	TIM6_IRQHandler
+	.word	TIM7_IRQHandler
+	.word	DMA2_Channel1_IRQHandler
+	.word	DMA2_Channel2_IRQHandler
+	.word	DMA2_Channel3_IRQHandler
+	.word	DMA2_Channel4_5_IRQHandler
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	BootRAM       /* @0x1E0. This is for boot in RAM mode for
+                         STM32F10x High Density devices. */
+
+/*******************************************************************************
+*
+* Provide weak aliases for each Exception handler to the Default_Handler.
+* As they are weak aliases, any function with the same name will override
+* this definition.
+*
+*******************************************************************************/
+
+  .weak	NMI_Handler
+	.thumb_set NMI_Handler,Default_Handler
+
+  .weak	HardFault_Handler
+	.thumb_set HardFault_Handler,Default_Handler
+
+  .weak	MemManage_Handler
+	.thumb_set MemManage_Handler,Default_Handler
+
+  .weak	BusFault_Handler
+	.thumb_set BusFault_Handler,Default_Handler
+
+	.weak	UsageFault_Handler
+	.thumb_set UsageFault_Handler,Default_Handler
+
+	.weak	SVC_Handler
+	.thumb_set SVC_Handler,Default_Handler
+
+	.weak	DebugMon_Handler
+	.thumb_set DebugMon_Handler,Default_Handler
+
+	.weak	PendSV_Handler
+	.thumb_set PendSV_Handler,Default_Handler
+
+	.weak	SysTick_Handler
+	.thumb_set SysTick_Handler,Default_Handler
+
+	.weak	WWDG_IRQHandler
+	.thumb_set WWDG_IRQHandler,Default_Handler
+
+	.weak	PVD_IRQHandler
+	.thumb_set PVD_IRQHandler,Default_Handler
+
+	.weak	TAMPER_IRQHandler
+	.thumb_set TAMPER_IRQHandler,Default_Handler
+
+	.weak	RTC_IRQHandler
+	.thumb_set RTC_IRQHandler,Default_Handler
+
+	.weak	FLASH_IRQHandler
+	.thumb_set FLASH_IRQHandler,Default_Handler
+
+	.weak	RCC_IRQHandler
+	.thumb_set RCC_IRQHandler,Default_Handler
+
+	.weak	EXTI0_IRQHandler
+	.thumb_set EXTI0_IRQHandler,Default_Handler
+
+	.weak	EXTI1_IRQHandler
+	.thumb_set EXTI1_IRQHandler,Default_Handler
+
+	.weak	EXTI2_IRQHandler
+	.thumb_set EXTI2_IRQHandler,Default_Handler
+
+	.weak	EXTI3_IRQHandler
+	.thumb_set EXTI3_IRQHandler,Default_Handler
+
+	.weak	EXTI4_IRQHandler
+	.thumb_set EXTI4_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel1_IRQHandler
+	.thumb_set DMA1_Channel1_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel2_IRQHandler
+	.thumb_set DMA1_Channel2_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel3_IRQHandler
+	.thumb_set DMA1_Channel3_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel4_IRQHandler
+	.thumb_set DMA1_Channel4_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel5_IRQHandler
+	.thumb_set DMA1_Channel5_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel6_IRQHandler
+	.thumb_set DMA1_Channel6_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel7_IRQHandler
+	.thumb_set DMA1_Channel7_IRQHandler,Default_Handler
+
+	.weak	ADC1_2_IRQHandler
+	.thumb_set ADC1_2_IRQHandler,Default_Handler
+
+	.weak	USB_HP_CAN1_TX_IRQHandler
+	.thumb_set USB_HP_CAN1_TX_IRQHandler,Default_Handler
+
+	.weak	USB_LP_CAN1_RX0_IRQHandler
+	.thumb_set USB_LP_CAN1_RX0_IRQHandler,Default_Handler
+
+	.weak	CAN1_RX1_IRQHandler
+	.thumb_set CAN1_RX1_IRQHandler,Default_Handler
+
+	.weak	CAN1_SCE_IRQHandler
+	.thumb_set CAN1_SCE_IRQHandler,Default_Handler
+
+	.weak	EXTI9_5_IRQHandler
+	.thumb_set EXTI9_5_IRQHandler,Default_Handler
+
+	.weak	TIM1_BRK_IRQHandler
+	.thumb_set TIM1_BRK_IRQHandler,Default_Handler
+
+	.weak	TIM1_UP_IRQHandler
+	.thumb_set TIM1_UP_IRQHandler,Default_Handler
+
+	.weak	TIM1_TRG_COM_IRQHandler
+	.thumb_set TIM1_TRG_COM_IRQHandler,Default_Handler
+
+	.weak	TIM1_CC_IRQHandler
+	.thumb_set TIM1_CC_IRQHandler,Default_Handler
+
+	.weak	TIM2_IRQHandler
+	.thumb_set TIM2_IRQHandler,Default_Handler
+
+	.weak	TIM3_IRQHandler
+	.thumb_set TIM3_IRQHandler,Default_Handler
+
+	.weak	TIM4_IRQHandler
+	.thumb_set TIM4_IRQHandler,Default_Handler
+
+	.weak	I2C1_EV_IRQHandler
+	.thumb_set I2C1_EV_IRQHandler,Default_Handler
+
+	.weak	I2C1_ER_IRQHandler
+	.thumb_set I2C1_ER_IRQHandler,Default_Handler
+
+	.weak	I2C2_EV_IRQHandler
+	.thumb_set I2C2_EV_IRQHandler,Default_Handler
+
+	.weak	I2C2_ER_IRQHandler
+	.thumb_set I2C2_ER_IRQHandler,Default_Handler
+
+	.weak	SPI1_IRQHandler
+	.thumb_set SPI1_IRQHandler,Default_Handler
+
+	.weak	SPI2_IRQHandler
+	.thumb_set SPI2_IRQHandler,Default_Handler
+
+	.weak	USART1_IRQHandler
+	.thumb_set USART1_IRQHandler,Default_Handler
+
+	.weak	USART2_IRQHandler
+	.thumb_set USART2_IRQHandler,Default_Handler
+
+	.weak	USART3_IRQHandler
+	.thumb_set USART3_IRQHandler,Default_Handler
+
+	.weak	EXTI15_10_IRQHandler
+	.thumb_set EXTI15_10_IRQHandler,Default_Handler
+
+	.weak	RTCAlarm_IRQHandler
+	.thumb_set RTCAlarm_IRQHandler,Default_Handler
+
+	.weak	USBWakeUp_IRQHandler
+	.thumb_set USBWakeUp_IRQHandler,Default_Handler
+
+	.weak	TIM8_BRK_IRQHandler
+	.thumb_set TIM8_BRK_IRQHandler,Default_Handler
+
+	.weak	TIM8_UP_IRQHandler
+	.thumb_set TIM8_UP_IRQHandler,Default_Handler
+
+	.weak	TIM8_TRG_COM_IRQHandler
+	.thumb_set TIM8_TRG_COM_IRQHandler,Default_Handler
+
+	.weak	TIM8_CC_IRQHandler
+	.thumb_set TIM8_CC_IRQHandler,Default_Handler
+
+	.weak	ADC3_IRQHandler
+	.thumb_set ADC3_IRQHandler,Default_Handler
+
+	.weak	FSMC_IRQHandler
+	.thumb_set FSMC_IRQHandler,Default_Handler
+
+	.weak	SDIO_IRQHandler
+	.thumb_set SDIO_IRQHandler,Default_Handler
+
+	.weak	TIM5_IRQHandler
+	.thumb_set TIM5_IRQHandler,Default_Handler
+
+	.weak	SPI3_IRQHandler
+	.thumb_set SPI3_IRQHandler,Default_Handler
+
+	.weak	UART4_IRQHandler
+	.thumb_set UART4_IRQHandler,Default_Handler
+
+	.weak	UART5_IRQHandler
+	.thumb_set UART5_IRQHandler,Default_Handler
+
+	.weak	TIM6_IRQHandler
+	.thumb_set TIM6_IRQHandler,Default_Handler
+
+	.weak	TIM7_IRQHandler
+	.thumb_set TIM7_IRQHandler,Default_Handler
+
+	.weak	DMA2_Channel1_IRQHandler
+	.thumb_set DMA2_Channel1_IRQHandler,Default_Handler
+
+	.weak	DMA2_Channel2_IRQHandler
+	.thumb_set DMA2_Channel2_IRQHandler,Default_Handler
+
+	.weak	DMA2_Channel3_IRQHandler
+	.thumb_set DMA2_Channel3_IRQHandler,Default_Handler
+
+	.weak	DMA2_Channel4_5_IRQHandler
+	.thumb_set DMA2_Channel4_5_IRQHandler,Default_Handler
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_hd_vl.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_hd_vl.s
new file mode 100644
index 0000000..55aa398
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_hd_vl.s
@@ -0,0 +1,451 @@
+/**
+  ******************************************************************************
+  * @file      startup_stm32f10x_hd_vl.s
+  * @author    MCD Application Team
+  * @version   V3.5.0
+  * @date      11-March-2011
+  * @brief     STM32F10x High Density Value Line Devices vector table for Atollic
+  *            toolchain.
+  *            This module performs:
+  *                - Set the initial SP
+  *                - Set the initial PC == Reset_Handler,
+  *                - Set the vector table entries with the exceptions ISR address
+  *                - Configure the clock system
+  *                - Configure external SRAM mounted on STM32100E-EVAL board
+  *                  to be used as data memory (optional, to be enabled by user)
+  *                - Branches to main in the C library (which eventually
+  *                  calls main()).
+  *            After Reset the Cortex-M3 processor is in Thread mode,
+  *            priority is Privileged, and the Stack is set to Main.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+  .syntax unified
+	.cpu cortex-m3
+	.fpu softvfp
+	.thumb
+
+.global	g_pfnVectors
+.global	Default_Handler
+
+/* start address for the initialization values of the .data section.
+defined in linker script */
+.word	_sidata
+/* start address for the .data section. defined in linker script */
+.word	_sdata
+/* end address for the .data section. defined in linker script */
+.word	_edata
+/* start address for the .bss section. defined in linker script */
+.word	_sbss
+/* end address for the .bss section. defined in linker script */
+.word	_ebss
+
+.equ  BootRAM, 0xF108F85F
+/**
+ * @brief  This is the code that gets called when the processor first
+ *          starts execution following a reset event. Only the absolutely
+ *          necessary set is performed, after which the application
+ *          supplied main() routine is called.
+ * @param  None
+ * @retval : None
+*/
+
+    .section	.text.Reset_Handler
+	.weak	Reset_Handler
+	.type	Reset_Handler, %function
+Reset_Handler:
+
+/* Copy the data segment initializers from flash to SRAM */
+  movs	r1, #0
+  b	LoopCopyDataInit
+
+CopyDataInit:
+	ldr	r3, =_sidata
+	ldr	r3, [r3, r1]
+	str	r3, [r0, r1]
+	adds	r1, r1, #4
+
+LoopCopyDataInit:
+	ldr	r0, =_sdata
+	ldr	r3, =_edata
+	adds	r2, r0, r1
+	cmp	r2, r3
+	bcc	CopyDataInit
+	ldr	r2, =_sbss
+	b	LoopFillZerobss
+/* Zero fill the bss segment. */
+FillZerobss:
+	movs	r3, #0
+	str	r3, [r2], #4
+
+LoopFillZerobss:
+	ldr	r3, = _ebss
+	cmp	r2, r3
+	bcc	FillZerobss
+
+/* Call the clock system intitialization function.*/
+  bl  SystemInit
+/* Call static constructors */
+  bl __libc_init_array
+/* Call the application's entry point.*/
+	bl	main
+	bx	lr
+.size	Reset_Handler, .-Reset_Handler
+
+/**
+ * @brief  This is the code that gets called when the processor receives an
+ *         unexpected interrupt.  This simply enters an infinite loop, preserving
+ *         the system state for examination by a debugger.
+ *
+ * @param  None
+ * @retval : None
+*/
+    .section	.text.Default_Handler,"ax",%progbits
+Default_Handler:
+Infinite_Loop:
+	b	Infinite_Loop
+	.size	Default_Handler, .-Default_Handler
+/******************************************************************************
+*
+* The minimal vector table for a Cortex M3.  Note that the proper constructs
+* must be placed on this to ensure that it ends up at physical address
+* 0x0000.0000.
+*
+******************************************************************************/
+	.section	.isr_vector,"a",%progbits
+	.type	g_pfnVectors, %object
+	.size	g_pfnVectors, .-g_pfnVectors
+
+
+g_pfnVectors:
+	.word	_estack
+	.word	Reset_Handler
+	.word	NMI_Handler
+	.word	HardFault_Handler
+	.word	MemManage_Handler
+	.word	BusFault_Handler
+	.word	UsageFault_Handler
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	SVC_Handler
+	.word	DebugMon_Handler
+	.word	0
+	.word	PendSV_Handler
+	.word	SysTick_Handler
+	.word	WWDG_IRQHandler
+	.word	PVD_IRQHandler
+	.word	TAMPER_IRQHandler
+	.word	RTC_IRQHandler
+	.word	FLASH_IRQHandler
+	.word	RCC_IRQHandler
+	.word	EXTI0_IRQHandler
+	.word	EXTI1_IRQHandler
+	.word	EXTI2_IRQHandler
+	.word	EXTI3_IRQHandler
+	.word	EXTI4_IRQHandler
+	.word	DMA1_Channel1_IRQHandler
+	.word	DMA1_Channel2_IRQHandler
+	.word	DMA1_Channel3_IRQHandler
+	.word	DMA1_Channel4_IRQHandler
+	.word	DMA1_Channel5_IRQHandler
+	.word	DMA1_Channel6_IRQHandler
+	.word	DMA1_Channel7_IRQHandler
+	.word	ADC1_IRQHandler
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	EXTI9_5_IRQHandler
+	.word	TIM1_BRK_TIM15_IRQHandler
+	.word	TIM1_UP_TIM16_IRQHandler
+	.word	TIM1_TRG_COM_TIM17_IRQHandler
+	.word	TIM1_CC_IRQHandler
+	.word	TIM2_IRQHandler
+	.word	TIM3_IRQHandler
+	.word	TIM4_IRQHandler
+	.word	I2C1_EV_IRQHandler
+	.word	I2C1_ER_IRQHandler
+	.word	I2C2_EV_IRQHandler
+	.word	I2C2_ER_IRQHandler
+	.word	SPI1_IRQHandler
+	.word	SPI2_IRQHandler
+	.word	USART1_IRQHandler
+	.word	USART2_IRQHandler
+	.word	USART3_IRQHandler
+	.word	EXTI15_10_IRQHandler
+	.word	RTCAlarm_IRQHandler
+	.word	CEC_IRQHandler
+  .word TIM12_IRQHandler
+  .word TIM13_IRQHandler
+  .word TIM14_IRQHandler
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word TIM5_IRQHandler
+  .word SPI3_IRQHandler
+  .word UART4_IRQHandler
+  .word UART5_IRQHandler
+  .word TIM6_DAC_IRQHandler
+  .word TIM7_IRQHandler
+  .word DMA2_Channel1_IRQHandler
+  .word DMA2_Channel2_IRQHandler
+  .word DMA2_Channel3_IRQHandler
+  .word DMA2_Channel4_5_IRQHandler
+  .word DMA2_Channel5_IRQHandler
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word 0
+  .word  BootRAM       /* @0x1E0. This is for boot in RAM mode for
+                         STM32F10x High Density Value line devices. */
+
+/*******************************************************************************
+*
+* Provide weak aliases for each Exception handler to the Default_Handler.
+* As they are weak aliases, any function with the same name will override
+* this definition.
+*
+*******************************************************************************/
+
+
+  .weak  NMI_Handler
+  .thumb_set NMI_Handler,Default_Handler
+
+  .weak  HardFault_Handler
+  .thumb_set HardFault_Handler,Default_Handler
+
+  .weak  MemManage_Handler
+  .thumb_set MemManage_Handler,Default_Handler
+
+  .weak  BusFault_Handler
+  .thumb_set BusFault_Handler,Default_Handler
+
+  .weak  UsageFault_Handler
+  .thumb_set UsageFault_Handler,Default_Handler
+
+  .weak  SVC_Handler
+  .thumb_set SVC_Handler,Default_Handler
+
+  .weak  DebugMon_Handler
+  .thumb_set DebugMon_Handler,Default_Handler
+
+  .weak  PendSV_Handler
+  .thumb_set PendSV_Handler,Default_Handler
+
+  .weak  SysTick_Handler
+  .thumb_set SysTick_Handler,Default_Handler
+
+  .weak  WWDG_IRQHandler
+  .thumb_set WWDG_IRQHandler,Default_Handler
+
+  .weak  PVD_IRQHandler
+  .thumb_set PVD_IRQHandler,Default_Handler
+
+  .weak  TAMPER_IRQHandler
+  .thumb_set TAMPER_IRQHandler,Default_Handler
+
+  .weak  RTC_IRQHandler
+  .thumb_set RTC_IRQHandler,Default_Handler
+
+  .weak  FLASH_IRQHandler
+  .thumb_set FLASH_IRQHandler,Default_Handler
+
+  .weak  RCC_IRQHandler
+  .thumb_set RCC_IRQHandler,Default_Handler
+
+  .weak  EXTI0_IRQHandler
+  .thumb_set EXTI0_IRQHandler,Default_Handler
+
+  .weak  EXTI1_IRQHandler
+  .thumb_set EXTI1_IRQHandler,Default_Handler
+
+  .weak  EXTI2_IRQHandler
+  .thumb_set EXTI2_IRQHandler,Default_Handler
+
+  .weak  EXTI3_IRQHandler
+  .thumb_set EXTI3_IRQHandler,Default_Handler
+
+  .weak  EXTI4_IRQHandler
+  .thumb_set EXTI4_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel1_IRQHandler
+  .thumb_set DMA1_Channel1_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel2_IRQHandler
+  .thumb_set DMA1_Channel2_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel3_IRQHandler
+  .thumb_set DMA1_Channel3_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel4_IRQHandler
+  .thumb_set DMA1_Channel4_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel5_IRQHandler
+  .thumb_set DMA1_Channel5_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel6_IRQHandler
+  .thumb_set DMA1_Channel6_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel7_IRQHandler
+  .thumb_set DMA1_Channel7_IRQHandler,Default_Handler
+
+  .weak  ADC1_IRQHandler
+  .thumb_set ADC1_IRQHandler,Default_Handler
+
+  .weak  EXTI9_5_IRQHandler
+  .thumb_set EXTI9_5_IRQHandler,Default_Handler
+
+  .weak  TIM1_BRK_TIM15_IRQHandler
+  .thumb_set TIM1_BRK_TIM15_IRQHandler,Default_Handler
+
+  .weak  TIM1_UP_TIM16_IRQHandler
+  .thumb_set TIM1_UP_TIM16_IRQHandler,Default_Handler
+
+  .weak  TIM1_TRG_COM_TIM17_IRQHandler
+  .thumb_set TIM1_TRG_COM_TIM17_IRQHandler,Default_Handler
+
+  .weak  TIM1_CC_IRQHandler
+  .thumb_set TIM1_CC_IRQHandler,Default_Handler
+
+  .weak  TIM2_IRQHandler
+  .thumb_set TIM2_IRQHandler,Default_Handler
+
+  .weak  TIM3_IRQHandler
+  .thumb_set TIM3_IRQHandler,Default_Handler
+
+  .weak  TIM4_IRQHandler
+  .thumb_set TIM4_IRQHandler,Default_Handler
+
+  .weak  I2C1_EV_IRQHandler
+  .thumb_set I2C1_EV_IRQHandler,Default_Handler
+
+  .weak  I2C1_ER_IRQHandler
+  .thumb_set I2C1_ER_IRQHandler,Default_Handler
+
+  .weak  I2C2_EV_IRQHandler
+  .thumb_set I2C2_EV_IRQHandler,Default_Handler
+
+  .weak  I2C2_ER_IRQHandler
+  .thumb_set I2C2_ER_IRQHandler,Default_Handler
+
+  .weak  SPI1_IRQHandler
+  .thumb_set SPI1_IRQHandler,Default_Handler
+
+  .weak  SPI2_IRQHandler
+  .thumb_set SPI2_IRQHandler,Default_Handler
+
+  .weak  USART1_IRQHandler
+  .thumb_set USART1_IRQHandler,Default_Handler
+
+  .weak  USART2_IRQHandler
+  .thumb_set USART2_IRQHandler,Default_Handler
+
+  .weak  USART3_IRQHandler
+  .thumb_set USART3_IRQHandler,Default_Handler
+
+  .weak  EXTI15_10_IRQHandler
+  .thumb_set EXTI15_10_IRQHandler,Default_Handler
+
+  .weak  RTCAlarm_IRQHandler
+  .thumb_set RTCAlarm_IRQHandler,Default_Handler
+
+  .weak  CEC_IRQHandler
+  .thumb_set CEC_IRQHandler,Default_Handler
+
+  .weak  TIM12_IRQHandler
+  .thumb_set TIM12_IRQHandler,Default_Handler
+
+  .weak  TIM13_IRQHandler
+  .thumb_set TIM13_IRQHandler,Default_Handler
+
+  .weak  TIM14_IRQHandler
+  .thumb_set TIM14_IRQHandler,Default_Handler
+
+  .weak  TIM5_IRQHandler
+  .thumb_set TIM5_IRQHandler,Default_Handler
+
+  .weak  SPI3_IRQHandler
+  .thumb_set SPI3_IRQHandler,Default_Handler
+
+  .weak  UART4_IRQHandler
+  .thumb_set UART4_IRQHandler,Default_Handler
+
+  .weak  UART5_IRQHandler
+  .thumb_set UART5_IRQHandler,Default_Handler
+
+  .weak  TIM6_DAC_IRQHandler
+  .thumb_set TIM6_DAC_IRQHandler,Default_Handler
+
+  .weak  TIM7_IRQHandler
+  .thumb_set TIM7_IRQHandler,Default_Handler
+
+  .weak  DMA2_Channel1_IRQHandler
+  .thumb_set DMA2_Channel1_IRQHandler,Default_Handler
+
+  .weak  DMA2_Channel2_IRQHandler
+  .thumb_set DMA2_Channel2_IRQHandler,Default_Handler
+
+  .weak  DMA2_Channel3_IRQHandler
+  .thumb_set DMA2_Channel3_IRQHandler,Default_Handler
+
+  .weak  DMA2_Channel4_5_IRQHandler
+  .thumb_set DMA2_Channel4_5_IRQHandler,Default_Handler
+
+  .weak  DMA2_Channel5_IRQHandler
+  .thumb_set DMA2_Channel5_IRQHandler,Default_Handler
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
+
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_ld.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_ld.s
new file mode 100644
index 0000000..2c5aaa0
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_ld.s
@@ -0,0 +1,347 @@
+/**
+  ******************************************************************************
+  * @file      startup_stm32f10x_ld.s
+  * @author    MCD Application Team
+  * @version   V3.5.0
+  * @date      11-March-2011
+  * @brief     STM32F10x Low Density Devices vector table for Atollic toolchain.
+  *            This module performs:
+  *                - Set the initial SP
+  *                - Set the initial PC == Reset_Handler,
+  *                - Set the vector table entries with the exceptions ISR address.
+  *                - Configure the clock system
+  *                - Branches to main in the C library (which eventually
+  *                  calls main()).
+  *            After Reset the Cortex-M3 processor is in Thread mode,
+  *            priority is Privileged, and the Stack is set to Main.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+  .syntax unified
+	.cpu cortex-m3
+	.fpu softvfp
+	.thumb
+
+.global	g_pfnVectors
+.global	Default_Handler
+
+/* start address for the initialization values of the .data section.
+defined in linker script */
+.word	_sidata
+/* start address for the .data section. defined in linker script */
+.word	_sdata
+/* end address for the .data section. defined in linker script */
+.word	_edata
+/* start address for the .bss section. defined in linker script */
+.word	_sbss
+/* end address for the .bss section. defined in linker script */
+.word	_ebss
+
+.equ  BootRAM, 0xF108F85F
+/**
+ * @brief  This is the code that gets called when the processor first
+ *          starts execution following a reset event. Only the absolutely
+ *          necessary set is performed, after which the application
+ *          supplied main() routine is called.
+ * @param  None
+ * @retval : None
+*/
+
+    .section	.text.Reset_Handler
+	.weak	Reset_Handler
+	.type	Reset_Handler, %function
+Reset_Handler:
+
+/* Copy the data segment initializers from flash to SRAM */
+  movs	r1, #0
+  b	LoopCopyDataInit
+
+CopyDataInit:
+	ldr	r3, =_sidata
+	ldr	r3, [r3, r1]
+	str	r3, [r0, r1]
+	adds	r1, r1, #4
+
+LoopCopyDataInit:
+	ldr	r0, =_sdata
+	ldr	r3, =_edata
+	adds	r2, r0, r1
+	cmp	r2, r3
+	bcc	CopyDataInit
+	ldr	r2, =_sbss
+	b	LoopFillZerobss
+/* Zero fill the bss segment. */
+FillZerobss:
+	movs	r3, #0
+	str	r3, [r2], #4
+
+LoopFillZerobss:
+	ldr	r3, = _ebss
+	cmp	r2, r3
+	bcc	FillZerobss
+
+/* Call the clock system intitialization function.*/
+  bl  SystemInit
+/* Call static constructors */
+  bl __libc_init_array
+/* Call the application's entry point.*/
+	bl	main
+	bx	lr
+.size	Reset_Handler, .-Reset_Handler
+
+/**
+ * @brief  This is the code that gets called when the processor receives an
+ *         unexpected interrupt.  This simply enters an infinite loop, preserving
+ *         the system state for examination by a debugger.
+ *
+ * @param  None
+ * @retval : None
+*/
+    .section	.text.Default_Handler,"ax",%progbits
+Default_Handler:
+Infinite_Loop:
+	b	Infinite_Loop
+	.size	Default_Handler, .-Default_Handler
+/******************************************************************************
+*
+* The minimal vector table for a Cortex M3.  Note that the proper constructs
+* must be placed on this to ensure that it ends up at physical address
+* 0x0000.0000.
+*
+******************************************************************************/
+	.section	.isr_vector,"a",%progbits
+	.type	g_pfnVectors, %object
+	.size	g_pfnVectors, .-g_pfnVectors
+
+
+g_pfnVectors:
+	.word	_estack
+	.word	Reset_Handler
+	.word	NMI_Handler
+	.word	HardFault_Handler
+	.word	MemManage_Handler
+	.word	BusFault_Handler
+	.word	UsageFault_Handler
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	SVC_Handler
+	.word	DebugMon_Handler
+	.word	0
+	.word	PendSV_Handler
+	.word	SysTick_Handler
+	.word	WWDG_IRQHandler
+	.word	PVD_IRQHandler
+	.word	TAMPER_IRQHandler
+	.word	RTC_IRQHandler
+	.word	FLASH_IRQHandler
+	.word	RCC_IRQHandler
+	.word	EXTI0_IRQHandler
+	.word	EXTI1_IRQHandler
+	.word	EXTI2_IRQHandler
+	.word	EXTI3_IRQHandler
+	.word	EXTI4_IRQHandler
+	.word	DMA1_Channel1_IRQHandler
+	.word	DMA1_Channel2_IRQHandler
+	.word	DMA1_Channel3_IRQHandler
+	.word	DMA1_Channel4_IRQHandler
+	.word	DMA1_Channel5_IRQHandler
+	.word	DMA1_Channel6_IRQHandler
+	.word	DMA1_Channel7_IRQHandler
+	.word	ADC1_2_IRQHandler
+	.word	USB_HP_CAN1_TX_IRQHandler
+	.word	USB_LP_CAN1_RX0_IRQHandler
+	.word	CAN1_RX1_IRQHandler
+	.word	CAN1_SCE_IRQHandler
+	.word	EXTI9_5_IRQHandler
+	.word	TIM1_BRK_IRQHandler
+	.word	TIM1_UP_IRQHandler
+  .word TIM1_TRG_COM_IRQHandler
+  .word TIM1_CC_IRQHandler
+  .word TIM2_IRQHandler
+  .word TIM3_IRQHandler
+  .word 0
+  .word I2C1_EV_IRQHandler
+  .word I2C1_ER_IRQHandler
+  .word 0
+  .word 0
+  .word SPI1_IRQHandler
+  .word 0
+  .word USART1_IRQHandler
+  .word USART2_IRQHandler
+  .word 0
+  .word EXTI15_10_IRQHandler
+	.word	RTCAlarm_IRQHandler
+	.word	USBWakeUp_IRQHandler
+  .word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	BootRAM        /* @0x108. This is for boot in RAM mode for
+                          STM32F10x Low Density devices.*/
+
+/*******************************************************************************
+*
+* Provide weak aliases for each Exception handler to the Default_Handler.
+* As they are weak aliases, any function with the same name will override
+* this definition.
+*
+*******************************************************************************/
+
+  .weak	NMI_Handler
+	.thumb_set NMI_Handler,Default_Handler
+
+  .weak	HardFault_Handler
+	.thumb_set HardFault_Handler,Default_Handler
+
+  .weak	MemManage_Handler
+	.thumb_set MemManage_Handler,Default_Handler
+
+  .weak	BusFault_Handler
+	.thumb_set BusFault_Handler,Default_Handler
+
+	.weak	UsageFault_Handler
+	.thumb_set UsageFault_Handler,Default_Handler
+
+	.weak	SVC_Handler
+	.thumb_set SVC_Handler,Default_Handler
+
+	.weak	DebugMon_Handler
+	.thumb_set DebugMon_Handler,Default_Handler
+
+	.weak	PendSV_Handler
+	.thumb_set PendSV_Handler,Default_Handler
+
+	.weak	SysTick_Handler
+	.thumb_set SysTick_Handler,Default_Handler
+
+	.weak	WWDG_IRQHandler
+	.thumb_set WWDG_IRQHandler,Default_Handler
+
+	.weak	PVD_IRQHandler
+	.thumb_set PVD_IRQHandler,Default_Handler
+
+	.weak	TAMPER_IRQHandler
+	.thumb_set TAMPER_IRQHandler,Default_Handler
+
+	.weak	RTC_IRQHandler
+	.thumb_set RTC_IRQHandler,Default_Handler
+
+	.weak	FLASH_IRQHandler
+	.thumb_set FLASH_IRQHandler,Default_Handler
+
+	.weak	RCC_IRQHandler
+	.thumb_set RCC_IRQHandler,Default_Handler
+
+	.weak	EXTI0_IRQHandler
+	.thumb_set EXTI0_IRQHandler,Default_Handler
+
+	.weak	EXTI1_IRQHandler
+	.thumb_set EXTI1_IRQHandler,Default_Handler
+
+	.weak	EXTI2_IRQHandler
+	.thumb_set EXTI2_IRQHandler,Default_Handler
+
+	.weak	EXTI3_IRQHandler
+	.thumb_set EXTI3_IRQHandler,Default_Handler
+
+	.weak	EXTI4_IRQHandler
+	.thumb_set EXTI4_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel1_IRQHandler
+	.thumb_set DMA1_Channel1_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel2_IRQHandler
+	.thumb_set DMA1_Channel2_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel3_IRQHandler
+	.thumb_set DMA1_Channel3_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel4_IRQHandler
+	.thumb_set DMA1_Channel4_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel5_IRQHandler
+	.thumb_set DMA1_Channel5_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel6_IRQHandler
+	.thumb_set DMA1_Channel6_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel7_IRQHandler
+	.thumb_set DMA1_Channel7_IRQHandler,Default_Handler
+
+	.weak	ADC1_2_IRQHandler
+	.thumb_set ADC1_2_IRQHandler,Default_Handler
+
+	.weak	USB_HP_CAN1_TX_IRQHandler
+	.thumb_set USB_HP_CAN1_TX_IRQHandler,Default_Handler
+
+	.weak	USB_LP_CAN1_RX0_IRQHandler
+	.thumb_set USB_LP_CAN1_RX0_IRQHandler,Default_Handler
+
+	.weak	CAN1_RX1_IRQHandler
+	.thumb_set CAN1_RX1_IRQHandler,Default_Handler
+
+	.weak	CAN1_SCE_IRQHandler
+	.thumb_set CAN1_SCE_IRQHandler,Default_Handler
+
+	.weak	EXTI9_5_IRQHandler
+	.thumb_set EXTI9_5_IRQHandler,Default_Handler
+
+	.weak	TIM1_BRK_IRQHandler
+	.thumb_set TIM1_BRK_IRQHandler,Default_Handler
+
+	.weak	TIM1_UP_IRQHandler
+	.thumb_set TIM1_UP_IRQHandler,Default_Handler
+
+	.weak	TIM1_TRG_COM_IRQHandler
+	.thumb_set TIM1_TRG_COM_IRQHandler,Default_Handler
+
+	.weak	TIM1_CC_IRQHandler
+	.thumb_set TIM1_CC_IRQHandler,Default_Handler
+
+	.weak	TIM2_IRQHandler
+	.thumb_set TIM2_IRQHandler,Default_Handler
+
+	.weak	TIM3_IRQHandler
+	.thumb_set TIM3_IRQHandler,Default_Handler
+
+	.weak	I2C1_EV_IRQHandler
+	.thumb_set I2C1_EV_IRQHandler,Default_Handler
+
+	.weak	I2C1_ER_IRQHandler
+	.thumb_set I2C1_ER_IRQHandler,Default_Handler
+
+	.weak	SPI1_IRQHandler
+	.thumb_set SPI1_IRQHandler,Default_Handler
+
+	.weak	USART1_IRQHandler
+	.thumb_set USART1_IRQHandler,Default_Handler
+
+	.weak	USART2_IRQHandler
+	.thumb_set USART2_IRQHandler,Default_Handler
+
+	.weak	EXTI15_10_IRQHandler
+	.thumb_set EXTI15_10_IRQHandler,Default_Handler
+
+	.weak	RTCAlarm_IRQHandler
+	.thumb_set RTCAlarm_IRQHandler,Default_Handler
+
+	.weak	USBWakeUp_IRQHandler
+	.thumb_set USBWakeUp_IRQHandler,Default_Handler
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_ld_vl.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_ld_vl.s
new file mode 100644
index 0000000..9af6e8b
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_ld_vl.s
@@ -0,0 +1,392 @@
+/**
+  ******************************************************************************
+  * @file      startup_stm32f10x_ld_vl.s
+  * @author    MCD Application Team
+  * @version   V3.5.0
+  * @date      11-March-2011
+  * @brief     STM32F10x Low Density Value Line Devices vector table for Atollic toolchain.
+  *            This module performs:
+  *                - Set the initial SP
+  *                - Set the initial PC == Reset_Handler,
+  *                - Set the vector table entries with the exceptions ISR address
+  *                - Configure the clock system
+  *                - Branches to main in the C library (which eventually
+  *                  calls main()).
+  *            After Reset the Cortex-M3 processor is in Thread mode,
+  *            priority is Privileged, and the Stack is set to Main.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+  .syntax unified
+	.cpu cortex-m3
+	.fpu softvfp
+	.thumb
+
+.global	g_pfnVectors
+.global	Default_Handler
+
+/* start address for the initialization values of the .data section.
+defined in linker script */
+.word	_sidata
+/* start address for the .data section. defined in linker script */
+.word	_sdata
+/* end address for the .data section. defined in linker script */
+.word	_edata
+/* start address for the .bss section. defined in linker script */
+.word	_sbss
+/* end address for the .bss section. defined in linker script */
+.word	_ebss
+
+.equ  BootRAM, 0xF108F85F
+/**
+ * @brief  This is the code that gets called when the processor first
+ *          starts execution following a reset event. Only the absolutely
+ *          necessary set is performed, after which the application
+ *          supplied main() routine is called.
+ * @param  None
+ * @retval : None
+*/
+
+    .section	.text.Reset_Handler
+	.weak	Reset_Handler
+	.type	Reset_Handler, %function
+Reset_Handler:
+
+/* Copy the data segment initializers from flash to SRAM */
+  movs	r1, #0
+  b	LoopCopyDataInit
+
+CopyDataInit:
+	ldr	r3, =_sidata
+	ldr	r3, [r3, r1]
+	str	r3, [r0, r1]
+	adds	r1, r1, #4
+
+LoopCopyDataInit:
+	ldr	r0, =_sdata
+	ldr	r3, =_edata
+	adds	r2, r0, r1
+	cmp	r2, r3
+	bcc	CopyDataInit
+	ldr	r2, =_sbss
+	b	LoopFillZerobss
+/* Zero fill the bss segment. */
+FillZerobss:
+	movs	r3, #0
+	str	r3, [r2], #4
+
+LoopFillZerobss:
+	ldr	r3, = _ebss
+	cmp	r2, r3
+	bcc	FillZerobss
+
+/* Call the clock system intitialization function.*/
+  bl  SystemInit
+/* Call static constructors */
+  bl __libc_init_array
+/* Call the application's entry point.*/
+	bl	main
+	bx	lr
+.size	Reset_Handler, .-Reset_Handler
+
+/**
+ * @brief  This is the code that gets called when the processor receives an
+ *         unexpected interrupt.  This simply enters an infinite loop, preserving
+ *         the system state for examination by a debugger.
+ *
+ * @param  None
+ * @retval : None
+*/
+    .section	.text.Default_Handler,"ax",%progbits
+Default_Handler:
+Infinite_Loop:
+	b	Infinite_Loop
+	.size	Default_Handler, .-Default_Handler
+/******************************************************************************
+*
+* The minimal vector table for a Cortex M3.  Note that the proper constructs
+* must be placed on this to ensure that it ends up at physical address
+* 0x0000.0000.
+*
+******************************************************************************/
+	.section	.isr_vector,"a",%progbits
+	.type	g_pfnVectors, %object
+	.size	g_pfnVectors, .-g_pfnVectors
+
+
+g_pfnVectors:
+	.word	_estack
+	.word	Reset_Handler
+	.word	NMI_Handler
+	.word	HardFault_Handler
+	.word	MemManage_Handler
+	.word	BusFault_Handler
+	.word	UsageFault_Handler
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	SVC_Handler
+	.word	DebugMon_Handler
+	.word	0
+	.word	PendSV_Handler
+	.word	SysTick_Handler
+	.word	WWDG_IRQHandler
+	.word	PVD_IRQHandler
+	.word	TAMPER_IRQHandler
+	.word	RTC_IRQHandler
+	.word	FLASH_IRQHandler
+	.word	RCC_IRQHandler
+	.word	EXTI0_IRQHandler
+	.word	EXTI1_IRQHandler
+	.word	EXTI2_IRQHandler
+	.word	EXTI3_IRQHandler
+	.word	EXTI4_IRQHandler
+	.word	DMA1_Channel1_IRQHandler
+	.word	DMA1_Channel2_IRQHandler
+	.word	DMA1_Channel3_IRQHandler
+	.word	DMA1_Channel4_IRQHandler
+	.word	DMA1_Channel5_IRQHandler
+	.word	DMA1_Channel6_IRQHandler
+	.word	DMA1_Channel7_IRQHandler
+	.word	ADC1_IRQHandler
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	EXTI9_5_IRQHandler
+	.word	TIM1_BRK_TIM15_IRQHandler
+	.word	TIM1_UP_TIM16_IRQHandler
+	.word	TIM1_TRG_COM_TIM17_IRQHandler
+	.word	TIM1_CC_IRQHandler
+	.word	TIM2_IRQHandler
+	.word	TIM3_IRQHandler
+	.word	0
+	.word	I2C1_EV_IRQHandler
+	.word	I2C1_ER_IRQHandler
+	.word	0
+	.word	0
+	.word	SPI1_IRQHandler
+	.word	0
+	.word	USART1_IRQHandler
+	.word	USART2_IRQHandler
+	.word	0
+	.word	EXTI15_10_IRQHandler
+	.word	RTCAlarm_IRQHandler
+	.word	CEC_IRQHandler
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word TIM6_DAC_IRQHandler
+	.word TIM7_IRQHandler
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word BootRAM          /* @0x01CC. This is for boot in RAM mode for
+                            STM32F10x Medium Value Line Density devices. */
+
+/*******************************************************************************
+*
+* Provide weak aliases for each Exception handler to the Default_Handler.
+* As they are weak aliases, any function with the same name will override
+* this definition.
+*
+*******************************************************************************/
+
+
+  .weak  NMI_Handler
+  .thumb_set NMI_Handler,Default_Handler
+
+  .weak  HardFault_Handler
+  .thumb_set HardFault_Handler,Default_Handler
+
+  .weak  MemManage_Handler
+  .thumb_set MemManage_Handler,Default_Handler
+
+  .weak  BusFault_Handler
+  .thumb_set BusFault_Handler,Default_Handler
+
+  .weak  UsageFault_Handler
+  .thumb_set UsageFault_Handler,Default_Handler
+
+  .weak  SVC_Handler
+  .thumb_set SVC_Handler,Default_Handler
+
+  .weak  DebugMon_Handler
+  .thumb_set DebugMon_Handler,Default_Handler
+
+  .weak  PendSV_Handler
+  .thumb_set PendSV_Handler,Default_Handler
+
+  .weak  SysTick_Handler
+  .thumb_set SysTick_Handler,Default_Handler
+
+  .weak  WWDG_IRQHandler
+  .thumb_set WWDG_IRQHandler,Default_Handler
+
+  .weak  PVD_IRQHandler
+  .thumb_set PVD_IRQHandler,Default_Handler
+
+  .weak  TAMPER_IRQHandler
+  .thumb_set TAMPER_IRQHandler,Default_Handler
+
+  .weak  RTC_IRQHandler
+  .thumb_set RTC_IRQHandler,Default_Handler
+
+  .weak  FLASH_IRQHandler
+  .thumb_set FLASH_IRQHandler,Default_Handler
+
+  .weak  RCC_IRQHandler
+  .thumb_set RCC_IRQHandler,Default_Handler
+
+  .weak  EXTI0_IRQHandler
+  .thumb_set EXTI0_IRQHandler,Default_Handler
+
+  .weak  EXTI1_IRQHandler
+  .thumb_set EXTI1_IRQHandler,Default_Handler
+
+  .weak  EXTI2_IRQHandler
+  .thumb_set EXTI2_IRQHandler,Default_Handler
+
+  .weak  EXTI3_IRQHandler
+  .thumb_set EXTI3_IRQHandler,Default_Handler
+
+  .weak  EXTI4_IRQHandler
+  .thumb_set EXTI4_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel1_IRQHandler
+  .thumb_set DMA1_Channel1_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel2_IRQHandler
+  .thumb_set DMA1_Channel2_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel3_IRQHandler
+  .thumb_set DMA1_Channel3_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel4_IRQHandler
+  .thumb_set DMA1_Channel4_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel5_IRQHandler
+  .thumb_set DMA1_Channel5_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel6_IRQHandler
+  .thumb_set DMA1_Channel6_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel7_IRQHandler
+  .thumb_set DMA1_Channel7_IRQHandler,Default_Handler
+
+  .weak  ADC1_IRQHandler
+  .thumb_set ADC1_IRQHandler,Default_Handler
+
+  .weak  EXTI9_5_IRQHandler
+  .thumb_set EXTI9_5_IRQHandler,Default_Handler
+
+  .weak  TIM1_BRK_TIM15_IRQHandler
+  .thumb_set TIM1_BRK_TIM15_IRQHandler,Default_Handler
+
+  .weak  TIM1_UP_TIM16_IRQHandler
+  .thumb_set TIM1_UP_TIM16_IRQHandler,Default_Handler
+
+  .weak  TIM1_TRG_COM_TIM17_IRQHandler
+  .thumb_set TIM1_TRG_COM_TIM17_IRQHandler,Default_Handler
+
+  .weak  TIM1_CC_IRQHandler
+  .thumb_set TIM1_CC_IRQHandler,Default_Handler
+
+  .weak  TIM2_IRQHandler
+  .thumb_set TIM2_IRQHandler,Default_Handler
+
+  .weak  TIM3_IRQHandler
+  .thumb_set TIM3_IRQHandler,Default_Handler
+
+  .weak  I2C1_EV_IRQHandler
+  .thumb_set I2C1_EV_IRQHandler,Default_Handler
+
+  .weak  I2C1_ER_IRQHandler
+  .thumb_set I2C1_ER_IRQHandler,Default_Handler
+
+  .weak  SPI1_IRQHandler
+  .thumb_set SPI1_IRQHandler,Default_Handler
+
+  .weak  USART1_IRQHandler
+  .thumb_set USART1_IRQHandler,Default_Handler
+
+  .weak  USART2_IRQHandler
+  .thumb_set USART2_IRQHandler,Default_Handler
+
+  .weak  EXTI15_10_IRQHandler
+  .thumb_set EXTI15_10_IRQHandler,Default_Handler
+
+  .weak  RTCAlarm_IRQHandler
+  .thumb_set RTCAlarm_IRQHandler,Default_Handler
+
+  .weak  CEC_IRQHandler
+  .thumb_set CEC_IRQHandler,Default_Handler
+
+  .weak  TIM6_DAC_IRQHandler
+  .thumb_set TIM6_DAC_IRQHandler,Default_Handler
+
+  .weak  TIM7_IRQHandler
+  .thumb_set TIM7_IRQHandler,Default_Handler
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
+
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_md.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_md.s
new file mode 100644
index 0000000..c14ba21
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_md.s
@@ -0,0 +1,363 @@
+/**
+  ******************************************************************************
+  * @file      startup_stm32f10x_md.s
+  * @author    MCD Application Team
+  * @version   V3.5.0
+  * @date      11-March-2011
+  * @brief     STM32F10x Medium Density Devices vector table for Atollic toolchain.
+  *            This module performs:
+  *                - Set the initial SP
+  *                - Set the initial PC == Reset_Handler,
+  *                - Set the vector table entries with the exceptions ISR address
+  *                - Configure the clock system
+  *                - Branches to main in the C library (which eventually
+  *                  calls main()).
+  *            After Reset the Cortex-M3 processor is in Thread mode,
+  *            priority is Privileged, and the Stack is set to Main.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+  .syntax unified
+	.cpu cortex-m3
+	.fpu softvfp
+	.thumb
+
+.global	g_pfnVectors
+.global	Default_Handler
+
+/* start address for the initialization values of the .data section.
+defined in linker script */
+.word	_sidata
+/* start address for the .data section. defined in linker script */
+.word	_sdata
+/* end address for the .data section. defined in linker script */
+.word	_edata
+/* start address for the .bss section. defined in linker script */
+.word	_sbss
+/* end address for the .bss section. defined in linker script */
+.word	_ebss
+
+.equ  BootRAM, 0xF108F85F
+/**
+ * @brief  This is the code that gets called when the processor first
+ *          starts execution following a reset event. Only the absolutely
+ *          necessary set is performed, after which the application
+ *          supplied main() routine is called.
+ * @param  None
+ * @retval : None
+*/
+
+    .section	.text.Reset_Handler
+	.weak	Reset_Handler
+	.type	Reset_Handler, %function
+Reset_Handler:
+
+/* Copy the data segment initializers from flash to SRAM */
+  movs	r1, #0
+  b	LoopCopyDataInit
+
+CopyDataInit:
+	ldr	r3, =_sidata
+	ldr	r3, [r3, r1]
+	str	r3, [r0, r1]
+	adds	r1, r1, #4
+
+LoopCopyDataInit:
+	ldr	r0, =_sdata
+	ldr	r3, =_edata
+	adds	r2, r0, r1
+	cmp	r2, r3
+	bcc	CopyDataInit
+	ldr	r2, =_sbss
+	b	LoopFillZerobss
+/* Zero fill the bss segment. */
+FillZerobss:
+	movs	r3, #0
+	str	r3, [r2], #4
+
+LoopFillZerobss:
+	ldr	r3, = _ebss
+	cmp	r2, r3
+	bcc	FillZerobss
+
+/* Call the clock system intitialization function.*/
+    bl  SystemInit
+/* Call static constructors */
+    bl __libc_init_array
+/* Call the application's entry point.*/
+	bl	main
+	bx	lr
+.size	Reset_Handler, .-Reset_Handler
+
+/**
+ * @brief  This is the code that gets called when the processor receives an
+ *         unexpected interrupt.  This simply enters an infinite loop, preserving
+ *         the system state for examination by a debugger.
+ *
+ * @param  None
+ * @retval : None
+*/
+    .section	.text.Default_Handler,"ax",%progbits
+Default_Handler:
+Infinite_Loop:
+	b	Infinite_Loop
+	.size	Default_Handler, .-Default_Handler
+/******************************************************************************
+*
+* The minimal vector table for a Cortex M3.  Note that the proper constructs
+* must be placed on this to ensure that it ends up at physical address
+* 0x0000.0000.
+*
+******************************************************************************/
+	.section	.isr_vector,"a",%progbits
+	.type	g_pfnVectors, %object
+	.size	g_pfnVectors, .-g_pfnVectors
+
+
+g_pfnVectors:
+	.word	_estack
+	.word	Reset_Handler
+	.word	NMI_Handler
+	.word	HardFault_Handler
+	.word	MemManage_Handler
+	.word	BusFault_Handler
+	.word	UsageFault_Handler
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	SVC_Handler
+	.word	DebugMon_Handler
+	.word	0
+	.word	PendSV_Handler
+	.word	SysTick_Handler
+	.word	WWDG_IRQHandler
+	.word	PVD_IRQHandler
+	.word	TAMPER_IRQHandler
+	.word	RTC_IRQHandler
+	.word	FLASH_IRQHandler
+	.word	RCC_IRQHandler
+	.word	EXTI0_IRQHandler
+	.word	EXTI1_IRQHandler
+	.word	EXTI2_IRQHandler
+	.word	EXTI3_IRQHandler
+	.word	EXTI4_IRQHandler
+	.word	DMA1_Channel1_IRQHandler
+	.word	DMA1_Channel2_IRQHandler
+	.word	DMA1_Channel3_IRQHandler
+	.word	DMA1_Channel4_IRQHandler
+	.word	DMA1_Channel5_IRQHandler
+	.word	DMA1_Channel6_IRQHandler
+	.word	DMA1_Channel7_IRQHandler
+	.word	ADC1_2_IRQHandler
+	.word	USB_HP_CAN1_TX_IRQHandler
+	.word	USB_LP_CAN1_RX0_IRQHandler
+	.word	CAN1_RX1_IRQHandler
+	.word	CAN1_SCE_IRQHandler
+	.word	EXTI9_5_IRQHandler
+	.word	TIM1_BRK_IRQHandler
+	.word	TIM1_UP_IRQHandler
+	.word	TIM1_TRG_COM_IRQHandler
+	.word	TIM1_CC_IRQHandler
+	.word	TIM2_IRQHandler
+	.word	TIM3_IRQHandler
+	.word	TIM4_IRQHandler
+	.word	I2C1_EV_IRQHandler
+	.word	I2C1_ER_IRQHandler
+	.word	I2C2_EV_IRQHandler
+	.word	I2C2_ER_IRQHandler
+	.word	SPI1_IRQHandler
+	.word	SPI2_IRQHandler
+	.word	USART1_IRQHandler
+	.word	USART2_IRQHandler
+	.word	USART3_IRQHandler
+	.word	EXTI15_10_IRQHandler
+	.word	RTCAlarm_IRQHandler
+	.word	USBWakeUp_IRQHandler
+  .word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	BootRAM          /* @0x108. This is for boot in RAM mode for
+                            STM32F10x Medium Density devices. */
+
+/*******************************************************************************
+*
+* Provide weak aliases for each Exception handler to the Default_Handler.
+* As they are weak aliases, any function with the same name will override
+* this definition.
+*
+*******************************************************************************/
+
+  .weak	NMI_Handler
+	.thumb_set NMI_Handler,Default_Handler
+
+  .weak	HardFault_Handler
+	.thumb_set HardFault_Handler,Default_Handler
+
+  .weak	MemManage_Handler
+	.thumb_set MemManage_Handler,Default_Handler
+
+  .weak	BusFault_Handler
+	.thumb_set BusFault_Handler,Default_Handler
+
+	.weak	UsageFault_Handler
+	.thumb_set UsageFault_Handler,Default_Handler
+
+	.weak	SVC_Handler
+	.thumb_set SVC_Handler,Default_Handler
+
+	.weak	DebugMon_Handler
+	.thumb_set DebugMon_Handler,Default_Handler
+
+	.weak	PendSV_Handler
+	.thumb_set PendSV_Handler,Default_Handler
+
+	.weak	SysTick_Handler
+	.thumb_set SysTick_Handler,Default_Handler
+
+	.weak	WWDG_IRQHandler
+	.thumb_set WWDG_IRQHandler,Default_Handler
+
+	.weak	PVD_IRQHandler
+	.thumb_set PVD_IRQHandler,Default_Handler
+
+	.weak	TAMPER_IRQHandler
+	.thumb_set TAMPER_IRQHandler,Default_Handler
+
+	.weak	RTC_IRQHandler
+	.thumb_set RTC_IRQHandler,Default_Handler
+
+	.weak	FLASH_IRQHandler
+	.thumb_set FLASH_IRQHandler,Default_Handler
+
+	.weak	RCC_IRQHandler
+	.thumb_set RCC_IRQHandler,Default_Handler
+
+	.weak	EXTI0_IRQHandler
+	.thumb_set EXTI0_IRQHandler,Default_Handler
+
+	.weak	EXTI1_IRQHandler
+	.thumb_set EXTI1_IRQHandler,Default_Handler
+
+	.weak	EXTI2_IRQHandler
+	.thumb_set EXTI2_IRQHandler,Default_Handler
+
+	.weak	EXTI3_IRQHandler
+	.thumb_set EXTI3_IRQHandler,Default_Handler
+
+	.weak	EXTI4_IRQHandler
+	.thumb_set EXTI4_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel1_IRQHandler
+	.thumb_set DMA1_Channel1_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel2_IRQHandler
+	.thumb_set DMA1_Channel2_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel3_IRQHandler
+	.thumb_set DMA1_Channel3_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel4_IRQHandler
+	.thumb_set DMA1_Channel4_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel5_IRQHandler
+	.thumb_set DMA1_Channel5_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel6_IRQHandler
+	.thumb_set DMA1_Channel6_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel7_IRQHandler
+	.thumb_set DMA1_Channel7_IRQHandler,Default_Handler
+
+	.weak	ADC1_2_IRQHandler
+	.thumb_set ADC1_2_IRQHandler,Default_Handler
+
+	.weak	USB_HP_CAN1_TX_IRQHandler
+	.thumb_set USB_HP_CAN1_TX_IRQHandler,Default_Handler
+
+	.weak	USB_LP_CAN1_RX0_IRQHandler
+	.thumb_set USB_LP_CAN1_RX0_IRQHandler,Default_Handler
+
+	.weak	CAN1_RX1_IRQHandler
+	.thumb_set CAN1_RX1_IRQHandler,Default_Handler
+
+	.weak	CAN1_SCE_IRQHandler
+	.thumb_set CAN1_SCE_IRQHandler,Default_Handler
+
+	.weak	EXTI9_5_IRQHandler
+	.thumb_set EXTI9_5_IRQHandler,Default_Handler
+
+	.weak	TIM1_BRK_IRQHandler
+	.thumb_set TIM1_BRK_IRQHandler,Default_Handler
+
+	.weak	TIM1_UP_IRQHandler
+	.thumb_set TIM1_UP_IRQHandler,Default_Handler
+
+	.weak	TIM1_TRG_COM_IRQHandler
+	.thumb_set TIM1_TRG_COM_IRQHandler,Default_Handler
+
+	.weak	TIM1_CC_IRQHandler
+	.thumb_set TIM1_CC_IRQHandler,Default_Handler
+
+	.weak	TIM2_IRQHandler
+	.thumb_set TIM2_IRQHandler,Default_Handler
+
+	.weak	TIM3_IRQHandler
+	.thumb_set TIM3_IRQHandler,Default_Handler
+
+	.weak	TIM4_IRQHandler
+	.thumb_set TIM4_IRQHandler,Default_Handler
+
+	.weak	I2C1_EV_IRQHandler
+	.thumb_set I2C1_EV_IRQHandler,Default_Handler
+
+	.weak	I2C1_ER_IRQHandler
+	.thumb_set I2C1_ER_IRQHandler,Default_Handler
+
+	.weak	I2C2_EV_IRQHandler
+	.thumb_set I2C2_EV_IRQHandler,Default_Handler
+
+	.weak	I2C2_ER_IRQHandler
+	.thumb_set I2C2_ER_IRQHandler,Default_Handler
+
+	.weak	SPI1_IRQHandler
+	.thumb_set SPI1_IRQHandler,Default_Handler
+
+	.weak	SPI2_IRQHandler
+	.thumb_set SPI2_IRQHandler,Default_Handler
+
+	.weak	USART1_IRQHandler
+	.thumb_set USART1_IRQHandler,Default_Handler
+
+	.weak	USART2_IRQHandler
+	.thumb_set USART2_IRQHandler,Default_Handler
+
+	.weak	USART3_IRQHandler
+	.thumb_set USART3_IRQHandler,Default_Handler
+
+	.weak	EXTI15_10_IRQHandler
+	.thumb_set EXTI15_10_IRQHandler,Default_Handler
+
+	.weak	RTCAlarm_IRQHandler
+	.thumb_set RTCAlarm_IRQHandler,Default_Handler
+
+	.weak	USBWakeUp_IRQHandler
+	.thumb_set USBWakeUp_IRQHandler,Default_Handler
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
+
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_md_vl.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_md_vl.s
new file mode 100644
index 0000000..4ac1230
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_md_vl.s
@@ -0,0 +1,408 @@
+/**
+  ******************************************************************************
+  * @file      startup_stm32f10x_md_vl.s
+  * @author    MCD Application Team
+  * @version   V3.5.0
+  * @date      11-March-2011
+  * @brief     STM32F10x Medium Density Value Line Devices vector table for Atollic
+  *            toolchain.
+  *            This module performs:
+  *                - Set the initial SP
+  *                - Set the initial PC == Reset_Handler,
+  *                - Set the vector table entries with the exceptions ISR address
+  *                - Configure the clock system
+  *                - Branches to main in the C library (which eventually
+  *                  calls main()).
+  *            After Reset the Cortex-M3 processor is in Thread mode,
+  *            priority is Privileged, and the Stack is set to Main.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+  .syntax unified
+	.cpu cortex-m3
+	.fpu softvfp
+	.thumb
+
+.global	g_pfnVectors
+.global	Default_Handler
+
+/* start address for the initialization values of the .data section.
+defined in linker script */
+.word	_sidata
+/* start address for the .data section. defined in linker script */
+.word	_sdata
+/* end address for the .data section. defined in linker script */
+.word	_edata
+/* start address for the .bss section. defined in linker script */
+.word	_sbss
+/* end address for the .bss section. defined in linker script */
+.word	_ebss
+
+.equ  BootRAM, 0xF108F85F
+/**
+ * @brief  This is the code that gets called when the processor first
+ *          starts execution following a reset event. Only the absolutely
+ *          necessary set is performed, after which the application
+ *          supplied main() routine is called.
+ * @param  None
+ * @retval : None
+*/
+
+    .section	.text.Reset_Handler
+	.weak	Reset_Handler
+	.type	Reset_Handler, %function
+Reset_Handler:
+
+/* Copy the data segment initializers from flash to SRAM */
+  movs	r1, #0
+  b	LoopCopyDataInit
+
+CopyDataInit:
+	ldr	r3, =_sidata
+	ldr	r3, [r3, r1]
+	str	r3, [r0, r1]
+	adds	r1, r1, #4
+
+LoopCopyDataInit:
+	ldr	r0, =_sdata
+	ldr	r3, =_edata
+	adds	r2, r0, r1
+	cmp	r2, r3
+	bcc	CopyDataInit
+	ldr	r2, =_sbss
+	b	LoopFillZerobss
+/* Zero fill the bss segment. */
+FillZerobss:
+	movs	r3, #0
+	str	r3, [r2], #4
+
+LoopFillZerobss:
+	ldr	r3, = _ebss
+	cmp	r2, r3
+	bcc	FillZerobss
+
+/* Call the clock system intitialization function.*/
+  bl  SystemInit
+/* Call static constructors */
+  bl __libc_init_array
+/* Call the application's entry point.*/
+	bl	main
+	bx	lr
+.size	Reset_Handler, .-Reset_Handler
+
+/**
+ * @brief  This is the code that gets called when the processor receives an
+ *         unexpected interrupt.  This simply enters an infinite loop, preserving
+ *         the system state for examination by a debugger.
+ *
+ * @param  None
+ * @retval : None
+*/
+    .section	.text.Default_Handler,"ax",%progbits
+Default_Handler:
+Infinite_Loop:
+	b	Infinite_Loop
+	.size	Default_Handler, .-Default_Handler
+/******************************************************************************
+*
+* The minimal vector table for a Cortex M3.  Note that the proper constructs
+* must be placed on this to ensure that it ends up at physical address
+* 0x0000.0000.
+*
+******************************************************************************/
+	.section	.isr_vector,"a",%progbits
+	.type	g_pfnVectors, %object
+	.size	g_pfnVectors, .-g_pfnVectors
+
+
+g_pfnVectors:
+	.word	_estack
+	.word	Reset_Handler
+	.word	NMI_Handler
+	.word	HardFault_Handler
+	.word	MemManage_Handler
+	.word	BusFault_Handler
+	.word	UsageFault_Handler
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	SVC_Handler
+	.word	DebugMon_Handler
+	.word	0
+	.word	PendSV_Handler
+	.word	SysTick_Handler
+	.word	WWDG_IRQHandler
+	.word	PVD_IRQHandler
+	.word	TAMPER_IRQHandler
+	.word	RTC_IRQHandler
+	.word	FLASH_IRQHandler
+	.word	RCC_IRQHandler
+	.word	EXTI0_IRQHandler
+	.word	EXTI1_IRQHandler
+	.word	EXTI2_IRQHandler
+	.word	EXTI3_IRQHandler
+	.word	EXTI4_IRQHandler
+	.word	DMA1_Channel1_IRQHandler
+	.word	DMA1_Channel2_IRQHandler
+	.word	DMA1_Channel3_IRQHandler
+	.word	DMA1_Channel4_IRQHandler
+	.word	DMA1_Channel5_IRQHandler
+	.word	DMA1_Channel6_IRQHandler
+	.word	DMA1_Channel7_IRQHandler
+	.word	ADC1_IRQHandler
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	EXTI9_5_IRQHandler
+	.word	TIM1_BRK_TIM15_IRQHandler
+	.word	TIM1_UP_TIM16_IRQHandler
+	.word	TIM1_TRG_COM_TIM17_IRQHandler
+	.word	TIM1_CC_IRQHandler
+	.word	TIM2_IRQHandler
+	.word	TIM3_IRQHandler
+	.word	TIM4_IRQHandler
+	.word	I2C1_EV_IRQHandler
+	.word	I2C1_ER_IRQHandler
+	.word	I2C2_EV_IRQHandler
+	.word	I2C2_ER_IRQHandler
+	.word	SPI1_IRQHandler
+	.word	SPI2_IRQHandler
+	.word	USART1_IRQHandler
+	.word	USART2_IRQHandler
+	.word	USART3_IRQHandler
+	.word	EXTI15_10_IRQHandler
+	.word	RTCAlarm_IRQHandler
+	.word	CEC_IRQHandler
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word TIM6_DAC_IRQHandler
+	.word TIM7_IRQHandler
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word 0
+	.word BootRAM          /* @0x01CC. This is for boot in RAM mode for
+                         STM32F10x Medium Value Line Density devices. */
+
+/*******************************************************************************
+*
+* Provide weak aliases for each Exception handler to the Default_Handler.
+* As they are weak aliases, any function with the same name will override
+* this definition.
+*
+*******************************************************************************/
+
+
+  .weak  NMI_Handler
+  .thumb_set NMI_Handler,Default_Handler
+
+  .weak  HardFault_Handler
+  .thumb_set HardFault_Handler,Default_Handler
+
+  .weak  MemManage_Handler
+  .thumb_set MemManage_Handler,Default_Handler
+
+  .weak  BusFault_Handler
+  .thumb_set BusFault_Handler,Default_Handler
+
+  .weak  UsageFault_Handler
+  .thumb_set UsageFault_Handler,Default_Handler
+
+  .weak  SVC_Handler
+  .thumb_set SVC_Handler,Default_Handler
+
+  .weak  DebugMon_Handler
+  .thumb_set DebugMon_Handler,Default_Handler
+
+  .weak  PendSV_Handler
+  .thumb_set PendSV_Handler,Default_Handler
+
+  .weak  SysTick_Handler
+  .thumb_set SysTick_Handler,Default_Handler
+
+  .weak  WWDG_IRQHandler
+  .thumb_set WWDG_IRQHandler,Default_Handler
+
+  .weak  PVD_IRQHandler
+  .thumb_set PVD_IRQHandler,Default_Handler
+
+  .weak  TAMPER_IRQHandler
+  .thumb_set TAMPER_IRQHandler,Default_Handler
+
+  .weak  RTC_IRQHandler
+  .thumb_set RTC_IRQHandler,Default_Handler
+
+  .weak  FLASH_IRQHandler
+  .thumb_set FLASH_IRQHandler,Default_Handler
+
+  .weak  RCC_IRQHandler
+  .thumb_set RCC_IRQHandler,Default_Handler
+
+  .weak  EXTI0_IRQHandler
+  .thumb_set EXTI0_IRQHandler,Default_Handler
+
+  .weak  EXTI1_IRQHandler
+  .thumb_set EXTI1_IRQHandler,Default_Handler
+
+  .weak  EXTI2_IRQHandler
+  .thumb_set EXTI2_IRQHandler,Default_Handler
+
+  .weak  EXTI3_IRQHandler
+  .thumb_set EXTI3_IRQHandler,Default_Handler
+
+  .weak  EXTI4_IRQHandler
+  .thumb_set EXTI4_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel1_IRQHandler
+  .thumb_set DMA1_Channel1_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel2_IRQHandler
+  .thumb_set DMA1_Channel2_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel3_IRQHandler
+  .thumb_set DMA1_Channel3_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel4_IRQHandler
+  .thumb_set DMA1_Channel4_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel5_IRQHandler
+  .thumb_set DMA1_Channel5_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel6_IRQHandler
+  .thumb_set DMA1_Channel6_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel7_IRQHandler
+  .thumb_set DMA1_Channel7_IRQHandler,Default_Handler
+
+  .weak  ADC1_IRQHandler
+  .thumb_set ADC1_IRQHandler,Default_Handler
+
+  .weak  EXTI9_5_IRQHandler
+  .thumb_set EXTI9_5_IRQHandler,Default_Handler
+
+  .weak  TIM1_BRK_TIM15_IRQHandler
+  .thumb_set TIM1_BRK_TIM15_IRQHandler,Default_Handler
+
+  .weak  TIM1_UP_TIM16_IRQHandler
+  .thumb_set TIM1_UP_TIM16_IRQHandler,Default_Handler
+
+  .weak  TIM1_TRG_COM_TIM17_IRQHandler
+  .thumb_set TIM1_TRG_COM_TIM17_IRQHandler,Default_Handler
+
+  .weak  TIM1_CC_IRQHandler
+  .thumb_set TIM1_CC_IRQHandler,Default_Handler
+
+  .weak  TIM2_IRQHandler
+  .thumb_set TIM2_IRQHandler,Default_Handler
+
+  .weak  TIM3_IRQHandler
+  .thumb_set TIM3_IRQHandler,Default_Handler
+
+  .weak  TIM4_IRQHandler
+  .thumb_set TIM4_IRQHandler,Default_Handler
+
+  .weak  I2C1_EV_IRQHandler
+  .thumb_set I2C1_EV_IRQHandler,Default_Handler
+
+  .weak  I2C1_ER_IRQHandler
+  .thumb_set I2C1_ER_IRQHandler,Default_Handler
+
+  .weak  I2C2_EV_IRQHandler
+  .thumb_set I2C2_EV_IRQHandler,Default_Handler
+
+  .weak  I2C2_ER_IRQHandler
+  .thumb_set I2C2_ER_IRQHandler,Default_Handler
+
+  .weak  SPI1_IRQHandler
+  .thumb_set SPI1_IRQHandler,Default_Handler
+
+  .weak  SPI2_IRQHandler
+  .thumb_set SPI2_IRQHandler,Default_Handler
+
+  .weak  USART1_IRQHandler
+  .thumb_set USART1_IRQHandler,Default_Handler
+
+  .weak  USART2_IRQHandler
+  .thumb_set USART2_IRQHandler,Default_Handler
+
+  .weak  USART3_IRQHandler
+  .thumb_set USART3_IRQHandler,Default_Handler
+
+  .weak  EXTI15_10_IRQHandler
+  .thumb_set EXTI15_10_IRQHandler,Default_Handler
+
+  .weak  RTCAlarm_IRQHandler
+  .thumb_set RTCAlarm_IRQHandler,Default_Handler
+
+  .weak  CEC_IRQHandler
+  .thumb_set CEC_IRQHandler,Default_Handler
+
+  .weak  TIM6_DAC_IRQHandler
+  .thumb_set TIM6_DAC_IRQHandler,Default_Handler
+
+  .weak  TIM7_IRQHandler
+  .thumb_set TIM7_IRQHandler,Default_Handler
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
+
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_xl.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_xl.s
new file mode 100644
index 0000000..19bdf5a
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/startup_stm32f10x_xl.s
@@ -0,0 +1,467 @@
+/**
+  ******************************************************************************
+  * @file      startup_stm32f10x_xl.s
+  * @author    MCD Application Team
+  * @version   V3.5.0
+  * @date      11-March-2011
+  * @brief     STM32F10x XL-Density Devices vector table for TrueSTUDIO toolchain.
+  *            This module performs:
+  *                - Set the initial SP
+  *                - Set the initial PC == Reset_Handler,
+  *                - Set the vector table entries with the exceptions ISR address
+  *                - Configure the clock system and the external SRAM mounted on
+  *                  STM3210E-EVAL board to be used as data memory (optional,
+  *                  to be enabled by user)
+  *                - Branches to main in the C library (which eventually
+  *                  calls main()).
+  *            After Reset the Cortex-M3 processor is in Thread mode,
+  *            priority is Privileged, and the Stack is set to Main.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+  .syntax unified
+  .cpu cortex-m3
+  .fpu softvfp
+  .thumb
+
+.global  g_pfnVectors
+.global  Default_Handler
+
+/* start address for the initialization values of the .data section.
+defined in linker script */
+.word  _sidata
+/* start address for the .data section. defined in linker script */
+.word  _sdata
+/* end address for the .data section. defined in linker script */
+.word  _edata
+/* start address for the .bss section. defined in linker script */
+.word  _sbss
+/* end address for the .bss section. defined in linker script */
+.word  _ebss
+
+.equ  BootRAM,        0xF1E0F85F
+/**
+ * @brief  This is the code that gets called when the processor first
+ *          starts execution following a reset event. Only the absolutely
+ *          necessary set is performed, after which the application
+ *          supplied main() routine is called.
+ * @param  None
+ * @retval : None
+*/
+
+    .section  .text.Reset_Handler
+  .weak  Reset_Handler
+  .type  Reset_Handler, %function
+Reset_Handler:
+
+/* Copy the data segment initializers from flash to SRAM */
+  movs  r1, #0
+  b  LoopCopyDataInit
+
+CopyDataInit:
+  ldr  r3, =_sidata
+  ldr  r3, [r3, r1]
+  str  r3, [r0, r1]
+  adds  r1, r1, #4
+
+LoopCopyDataInit:
+  ldr  r0, =_sdata
+  ldr  r3, =_edata
+  adds  r2, r0, r1
+  cmp  r2, r3
+  bcc  CopyDataInit
+  ldr  r2, =_sbss
+  b  LoopFillZerobss
+/* Zero fill the bss segment. */
+FillZerobss:
+  movs  r3, #0
+  str  r3, [r2], #4
+
+LoopFillZerobss:
+  ldr  r3, = _ebss
+  cmp  r2, r3
+  bcc  FillZerobss
+
+/* Call the clock system intitialization function.*/
+  bl  SystemInit
+/* Call static constructors */
+  bl __libc_init_array
+/* Call the application's entry point.*/
+  bl  main
+  bx  lr
+.size  Reset_Handler, .-Reset_Handler
+
+/**
+ * @brief  This is the code that gets called when the processor receives an
+ *         unexpected interrupt.  This simply enters an infinite loop, preserving
+ *         the system state for examination by a debugger.
+ * @param  None
+ * @retval None
+*/
+    .section  .text.Default_Handler,"ax",%progbits
+Default_Handler:
+Infinite_Loop:
+  b  Infinite_Loop
+  .size  Default_Handler, .-Default_Handler
+/******************************************************************************
+*
+* The minimal vector table for a Cortex M3. Note that the proper constructs
+* must be placed on this to ensure that it ends up at physical address
+* 0x0000.0000.
+*
+*******************************************************************************/
+   .section  .isr_vector,"a",%progbits
+  .type  g_pfnVectors, %object
+  .size  g_pfnVectors, .-g_pfnVectors
+
+
+g_pfnVectors:
+  .word  _estack
+  .word  Reset_Handler
+  .word  NMI_Handler
+  .word  HardFault_Handler
+  .word  MemManage_Handler
+  .word  BusFault_Handler
+  .word  UsageFault_Handler
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  SVC_Handler
+  .word  DebugMon_Handler
+  .word  0
+  .word  PendSV_Handler
+  .word  SysTick_Handler
+  .word  WWDG_IRQHandler
+  .word  PVD_IRQHandler
+  .word  TAMPER_IRQHandler
+  .word  RTC_IRQHandler
+  .word  FLASH_IRQHandler
+  .word  RCC_IRQHandler
+  .word  EXTI0_IRQHandler
+  .word  EXTI1_IRQHandler
+  .word  EXTI2_IRQHandler
+  .word  EXTI3_IRQHandler
+  .word  EXTI4_IRQHandler
+  .word  DMA1_Channel1_IRQHandler
+  .word  DMA1_Channel2_IRQHandler
+  .word  DMA1_Channel3_IRQHandler
+  .word  DMA1_Channel4_IRQHandler
+  .word  DMA1_Channel5_IRQHandler
+  .word  DMA1_Channel6_IRQHandler
+  .word  DMA1_Channel7_IRQHandler
+  .word  ADC1_2_IRQHandler
+  .word  USB_HP_CAN1_TX_IRQHandler
+  .word  USB_LP_CAN1_RX0_IRQHandler
+  .word  CAN1_RX1_IRQHandler
+  .word  CAN1_SCE_IRQHandler
+  .word  EXTI9_5_IRQHandler
+  .word  TIM1_BRK_TIM9_IRQHandler
+  .word  TIM1_UP_TIM10_IRQHandler
+  .word  TIM1_TRG_COM_TIM11_IRQHandler
+  .word  TIM1_CC_IRQHandler
+  .word  TIM2_IRQHandler
+  .word  TIM3_IRQHandler
+  .word  TIM4_IRQHandler
+  .word  I2C1_EV_IRQHandler
+  .word  I2C1_ER_IRQHandler
+  .word  I2C2_EV_IRQHandler
+  .word  I2C2_ER_IRQHandler
+  .word  SPI1_IRQHandler
+  .word  SPI2_IRQHandler
+  .word  USART1_IRQHandler
+  .word  USART2_IRQHandler
+  .word  USART3_IRQHandler
+  .word  EXTI15_10_IRQHandler
+  .word  RTCAlarm_IRQHandler
+  .word  USBWakeUp_IRQHandler
+  .word  TIM8_BRK_TIM12_IRQHandler
+  .word  TIM8_UP_TIM13_IRQHandler
+  .word  TIM8_TRG_COM_TIM14_IRQHandler
+  .word  TIM8_CC_IRQHandler
+  .word  ADC3_IRQHandler
+  .word  FSMC_IRQHandler
+  .word  SDIO_IRQHandler
+  .word  TIM5_IRQHandler
+  .word  SPI3_IRQHandler
+  .word  UART4_IRQHandler
+  .word  UART5_IRQHandler
+  .word  TIM6_IRQHandler
+  .word  TIM7_IRQHandler
+  .word  DMA2_Channel1_IRQHandler
+  .word  DMA2_Channel2_IRQHandler
+  .word  DMA2_Channel3_IRQHandler
+  .word  DMA2_Channel4_5_IRQHandler
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  BootRAM       /* @0x1E0. This is for boot in RAM mode for
+                         STM32F10x XL-Density devices. */
+/*******************************************************************************
+*
+* Provide weak aliases for each Exception handler to the Default_Handler.
+* As they are weak aliases, any function with the same name will override
+* this definition.
+*
+*******************************************************************************/
+
+  .weak  NMI_Handler
+  .thumb_set NMI_Handler,Default_Handler
+
+  .weak  HardFault_Handler
+  .thumb_set HardFault_Handler,Default_Handler
+
+  .weak  MemManage_Handler
+  .thumb_set MemManage_Handler,Default_Handler
+
+  .weak  BusFault_Handler
+  .thumb_set BusFault_Handler,Default_Handler
+
+  .weak  UsageFault_Handler
+  .thumb_set UsageFault_Handler,Default_Handler
+
+  .weak  SVC_Handler
+  .thumb_set SVC_Handler,Default_Handler
+
+  .weak  DebugMon_Handler
+  .thumb_set DebugMon_Handler,Default_Handler
+
+  .weak  PendSV_Handler
+  .thumb_set PendSV_Handler,Default_Handler
+
+  .weak  SysTick_Handler
+  .thumb_set SysTick_Handler,Default_Handler
+
+  .weak  WWDG_IRQHandler
+  .thumb_set WWDG_IRQHandler,Default_Handler
+
+  .weak  PVD_IRQHandler
+  .thumb_set PVD_IRQHandler,Default_Handler
+
+  .weak  TAMPER_IRQHandler
+  .thumb_set TAMPER_IRQHandler,Default_Handler
+
+  .weak  RTC_IRQHandler
+  .thumb_set RTC_IRQHandler,Default_Handler
+
+  .weak  FLASH_IRQHandler
+  .thumb_set FLASH_IRQHandler,Default_Handler
+
+  .weak  RCC_IRQHandler
+  .thumb_set RCC_IRQHandler,Default_Handler
+
+  .weak  EXTI0_IRQHandler
+  .thumb_set EXTI0_IRQHandler,Default_Handler
+
+  .weak  EXTI1_IRQHandler
+  .thumb_set EXTI1_IRQHandler,Default_Handler
+
+  .weak  EXTI2_IRQHandler
+  .thumb_set EXTI2_IRQHandler,Default_Handler
+
+  .weak  EXTI3_IRQHandler
+  .thumb_set EXTI3_IRQHandler,Default_Handler
+
+  .weak  EXTI4_IRQHandler
+  .thumb_set EXTI4_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel1_IRQHandler
+  .thumb_set DMA1_Channel1_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel2_IRQHandler
+  .thumb_set DMA1_Channel2_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel3_IRQHandler
+  .thumb_set DMA1_Channel3_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel4_IRQHandler
+  .thumb_set DMA1_Channel4_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel5_IRQHandler
+  .thumb_set DMA1_Channel5_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel6_IRQHandler
+  .thumb_set DMA1_Channel6_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel7_IRQHandler
+  .thumb_set DMA1_Channel7_IRQHandler,Default_Handler
+
+  .weak  ADC1_2_IRQHandler
+  .thumb_set ADC1_2_IRQHandler,Default_Handler
+
+  .weak  USB_HP_CAN1_TX_IRQHandler
+  .thumb_set USB_HP_CAN1_TX_IRQHandler,Default_Handler
+
+  .weak  USB_LP_CAN1_RX0_IRQHandler
+  .thumb_set USB_LP_CAN1_RX0_IRQHandler,Default_Handler
+
+  .weak  CAN1_RX1_IRQHandler
+  .thumb_set CAN1_RX1_IRQHandler,Default_Handler
+
+  .weak  CAN1_SCE_IRQHandler
+  .thumb_set CAN1_SCE_IRQHandler,Default_Handler
+
+  .weak  EXTI9_5_IRQHandler
+  .thumb_set EXTI9_5_IRQHandler,Default_Handler
+
+  .weak  TIM1_BRK_TIM9_IRQHandler
+  .thumb_set TIM1_BRK_TIM9_IRQHandler,Default_Handler
+
+  .weak  TIM1_UP_TIM10_IRQHandler
+  .thumb_set TIM1_UP_TIM10_IRQHandler,Default_Handler
+
+  .weak  TIM1_TRG_COM_TIM11_IRQHandler
+  .thumb_set TIM1_TRG_COM_TIM11_IRQHandler,Default_Handler
+
+  .weak  TIM1_CC_IRQHandler
+  .thumb_set TIM1_CC_IRQHandler,Default_Handler
+
+  .weak  TIM2_IRQHandler
+  .thumb_set TIM2_IRQHandler,Default_Handler
+
+  .weak  TIM3_IRQHandler
+  .thumb_set TIM3_IRQHandler,Default_Handler
+
+  .weak  TIM4_IRQHandler
+  .thumb_set TIM4_IRQHandler,Default_Handler
+
+  .weak  I2C1_EV_IRQHandler
+  .thumb_set I2C1_EV_IRQHandler,Default_Handler
+
+  .weak  I2C1_ER_IRQHandler
+  .thumb_set I2C1_ER_IRQHandler,Default_Handler
+
+  .weak  I2C2_EV_IRQHandler
+  .thumb_set I2C2_EV_IRQHandler,Default_Handler
+
+  .weak  I2C2_ER_IRQHandler
+  .thumb_set I2C2_ER_IRQHandler,Default_Handler
+
+  .weak  SPI1_IRQHandler
+  .thumb_set SPI1_IRQHandler,Default_Handler
+
+  .weak  SPI2_IRQHandler
+  .thumb_set SPI2_IRQHandler,Default_Handler
+
+  .weak  USART1_IRQHandler
+  .thumb_set USART1_IRQHandler,Default_Handler
+
+  .weak  USART2_IRQHandler
+  .thumb_set USART2_IRQHandler,Default_Handler
+
+  .weak  USART3_IRQHandler
+  .thumb_set USART3_IRQHandler,Default_Handler
+
+  .weak  EXTI15_10_IRQHandler
+  .thumb_set EXTI15_10_IRQHandler,Default_Handler
+
+  .weak  RTCAlarm_IRQHandler
+  .thumb_set RTCAlarm_IRQHandler,Default_Handler
+
+  .weak  USBWakeUp_IRQHandler
+  .thumb_set USBWakeUp_IRQHandler,Default_Handler
+
+  .weak  TIM8_BRK_TIM12_IRQHandler
+  .thumb_set TIM8_BRK_TIM12_IRQHandler,Default_Handler
+
+  .weak  TIM8_UP_TIM13_IRQHandler
+  .thumb_set TIM8_UP_TIM13_IRQHandler,Default_Handler
+
+  .weak  TIM8_TRG_COM_TIM14_IRQHandler
+  .thumb_set TIM8_TRG_COM_TIM14_IRQHandler,Default_Handler
+
+  .weak  TIM8_CC_IRQHandler
+  .thumb_set TIM8_CC_IRQHandler,Default_Handler
+
+  .weak  ADC3_IRQHandler
+  .thumb_set ADC3_IRQHandler,Default_Handler
+
+  .weak  FSMC_IRQHandler
+  .thumb_set FSMC_IRQHandler,Default_Handler
+
+  .weak  SDIO_IRQHandler
+  .thumb_set SDIO_IRQHandler,Default_Handler
+
+  .weak  TIM5_IRQHandler
+  .thumb_set TIM5_IRQHandler,Default_Handler
+
+  .weak  SPI3_IRQHandler
+  .thumb_set SPI3_IRQHandler,Default_Handler
+
+  .weak  UART4_IRQHandler
+  .thumb_set UART4_IRQHandler,Default_Handler
+
+  .weak  UART5_IRQHandler
+  .thumb_set UART5_IRQHandler,Default_Handler
+
+  .weak  TIM6_IRQHandler
+  .thumb_set TIM6_IRQHandler,Default_Handler
+
+  .weak  TIM7_IRQHandler
+  .thumb_set TIM7_IRQHandler,Default_Handler
+
+  .weak  DMA2_Channel1_IRQHandler
+  .thumb_set DMA2_Channel1_IRQHandler,Default_Handler
+
+  .weak  DMA2_Channel2_IRQHandler
+  .thumb_set DMA2_Channel2_IRQHandler,Default_Handler
+
+  .weak  DMA2_Channel3_IRQHandler
+  .thumb_set DMA2_Channel3_IRQHandler,Default_Handler
+
+  .weak  DMA2_Channel4_5_IRQHandler
+  .thumb_set DMA2_Channel4_5_IRQHandler,Default_Handler
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_cl.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_cl.s
new file mode 100644
index 0000000..8196e69
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_cl.s
@@ -0,0 +1,368 @@
+;******************** (C) COPYRIGHT 2011 STMicroelectronics ********************
+;* File Name          : startup_stm32f10x_cl.s
+;* Author             : MCD Application Team
+;* Version            : V3.5.0
+;* Date               : 11-March-2011
+;* Description        : STM32F10x Connectivity line devices vector table for MDK-ARM
+;*                      toolchain.
+;*                      This module performs:
+;*                      - Set the initial SP
+;*                      - Set the initial PC == Reset_Handler
+;*                      - Set the vector table entries with the exceptions ISR address
+;*                      - Configure the clock system
+;*                      - Branches to __main in the C library (which eventually
+;*                        calls main()).
+;*                      After Reset the CortexM3 processor is in Thread mode,
+;*                      priority is Privileged, and the Stack is set to Main.
+;* <<< Use Configuration Wizard in Context Menu >>>
+;*******************************************************************************
+; THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+; WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+; AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+; INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+; CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+; INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+;*******************************************************************************
+
+; Amount of memory (in bytes) allocated for Stack
+; Tailor this value to your application needs
+; <h> Stack Configuration
+;   <o> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8>
+; </h>
+
+Stack_Size      EQU     0x00000400
+
+                AREA    STACK, NOINIT, READWRITE, ALIGN=3
+Stack_Mem       SPACE   Stack_Size
+__initial_sp
+
+
+; <h> Heap Configuration
+;   <o>  Heap Size (in Bytes) <0x0-0xFFFFFFFF:8>
+; </h>
+
+Heap_Size       EQU     0x00000200
+
+                AREA    HEAP, NOINIT, READWRITE, ALIGN=3
+__heap_base
+Heap_Mem        SPACE   Heap_Size
+__heap_limit
+
+                PRESERVE8
+                THUMB
+
+
+; Vector Table Mapped to Address 0 at Reset
+                AREA    RESET, DATA, READONLY
+                EXPORT  __Vectors
+                EXPORT  __Vectors_End
+                EXPORT  __Vectors_Size
+
+__Vectors       DCD     __initial_sp               ; Top of Stack
+                DCD     Reset_Handler              ; Reset Handler
+                DCD     NMI_Handler                ; NMI Handler
+                DCD     HardFault_Handler          ; Hard Fault Handler
+                DCD     MemManage_Handler          ; MPU Fault Handler
+                DCD     BusFault_Handler           ; Bus Fault Handler
+                DCD     UsageFault_Handler         ; Usage Fault Handler
+                DCD     0                          ; Reserved
+                DCD     0                          ; Reserved
+                DCD     0                          ; Reserved
+                DCD     0                          ; Reserved
+                DCD     SVC_Handler                ; SVCall Handler
+                DCD     DebugMon_Handler           ; Debug Monitor Handler
+                DCD     0                          ; Reserved
+                DCD     PendSV_Handler             ; PendSV Handler
+                DCD     SysTick_Handler            ; SysTick Handler
+
+                ; External Interrupts
+                DCD     WWDG_IRQHandler            ; Window Watchdog
+                DCD     PVD_IRQHandler             ; PVD through EXTI Line detect
+                DCD     TAMPER_IRQHandler          ; Tamper
+                DCD     RTC_IRQHandler             ; RTC
+                DCD     FLASH_IRQHandler           ; Flash
+                DCD     RCC_IRQHandler             ; RCC
+                DCD     EXTI0_IRQHandler           ; EXTI Line 0
+                DCD     EXTI1_IRQHandler           ; EXTI Line 1
+                DCD     EXTI2_IRQHandler           ; EXTI Line 2
+                DCD     EXTI3_IRQHandler           ; EXTI Line 3
+                DCD     EXTI4_IRQHandler           ; EXTI Line 4
+                DCD     DMA1_Channel1_IRQHandler   ; DMA1 Channel 1
+                DCD     DMA1_Channel2_IRQHandler   ; DMA1 Channel 2
+                DCD     DMA1_Channel3_IRQHandler   ; DMA1 Channel 3
+                DCD     DMA1_Channel4_IRQHandler   ; DMA1 Channel 4
+                DCD     DMA1_Channel5_IRQHandler   ; DMA1 Channel 5
+                DCD     DMA1_Channel6_IRQHandler   ; DMA1 Channel 6
+                DCD     DMA1_Channel7_IRQHandler   ; DMA1 Channel 7
+                DCD     ADC1_2_IRQHandler          ; ADC1 and ADC2
+                DCD     CAN1_TX_IRQHandler         ; CAN1 TX
+                DCD     CAN1_RX0_IRQHandler        ; CAN1 RX0
+                DCD     CAN1_RX1_IRQHandler        ; CAN1 RX1
+                DCD     CAN1_SCE_IRQHandler        ; CAN1 SCE
+                DCD     EXTI9_5_IRQHandler         ; EXTI Line 9..5
+                DCD     TIM1_BRK_IRQHandler        ; TIM1 Break
+                DCD     TIM1_UP_IRQHandler         ; TIM1 Update
+                DCD     TIM1_TRG_COM_IRQHandler    ; TIM1 Trigger and Commutation
+                DCD     TIM1_CC_IRQHandler         ; TIM1 Capture Compare
+                DCD     TIM2_IRQHandler            ; TIM2
+                DCD     TIM3_IRQHandler            ; TIM3
+                DCD     TIM4_IRQHandler            ; TIM4
+                DCD     I2C1_EV_IRQHandler         ; I2C1 Event
+                DCD     I2C1_ER_IRQHandler         ; I2C1 Error
+                DCD     I2C2_EV_IRQHandler         ; I2C2 Event
+                DCD     I2C2_ER_IRQHandler         ; I2C1 Error
+                DCD     SPI1_IRQHandler            ; SPI1
+                DCD     SPI2_IRQHandler            ; SPI2
+                DCD     USART1_IRQHandler          ; USART1
+                DCD     USART2_IRQHandler          ; USART2
+                DCD     USART3_IRQHandler          ; USART3
+                DCD     EXTI15_10_IRQHandler       ; EXTI Line 15..10
+                DCD     RTCAlarm_IRQHandler        ; RTC alarm through EXTI line
+                DCD     OTG_FS_WKUP_IRQHandler     ; USB OTG FS Wakeup through EXTI line
+                DCD     0                          ; Reserved
+                DCD     0                          ; Reserved
+                DCD     0                          ; Reserved
+                DCD     0                          ; Reserved
+                DCD     0                          ; Reserved
+                DCD     0                          ; Reserved
+                DCD     0                          ; Reserved
+                DCD     TIM5_IRQHandler            ; TIM5
+                DCD     SPI3_IRQHandler            ; SPI3
+                DCD     UART4_IRQHandler           ; UART4
+                DCD     UART5_IRQHandler           ; UART5
+                DCD     TIM6_IRQHandler            ; TIM6
+                DCD     TIM7_IRQHandler            ; TIM7
+                DCD     DMA2_Channel1_IRQHandler   ; DMA2 Channel1
+                DCD     DMA2_Channel2_IRQHandler   ; DMA2 Channel2
+                DCD     DMA2_Channel3_IRQHandler   ; DMA2 Channel3
+                DCD     DMA2_Channel4_IRQHandler   ; DMA2 Channel4
+                DCD     DMA2_Channel5_IRQHandler   ; DMA2 Channel5
+                DCD     ETH_IRQHandler             ; Ethernet
+                DCD     ETH_WKUP_IRQHandler        ; Ethernet Wakeup through EXTI line
+                DCD     CAN2_TX_IRQHandler         ; CAN2 TX
+                DCD     CAN2_RX0_IRQHandler        ; CAN2 RX0
+                DCD     CAN2_RX1_IRQHandler        ; CAN2 RX1
+                DCD     CAN2_SCE_IRQHandler        ; CAN2 SCE
+                DCD     OTG_FS_IRQHandler          ; USB OTG FS
+__Vectors_End
+
+__Vectors_Size  EQU  __Vectors_End - __Vectors
+
+                AREA    |.text|, CODE, READONLY
+
+; Reset handler
+Reset_Handler    PROC
+                 EXPORT  Reset_Handler             [WEAK]
+        IMPORT  SystemInit
+        IMPORT  __main
+                 LDR     R0, =SystemInit
+                 BLX     R0
+                 LDR     R0, =__main
+                 BX      R0
+                 ENDP
+
+; Dummy Exception Handlers (infinite loops which can be modified)
+
+NMI_Handler     PROC
+                EXPORT  NMI_Handler                [WEAK]
+                B       .
+                ENDP
+HardFault_Handler\
+                PROC
+                EXPORT  HardFault_Handler          [WEAK]
+                B       .
+                ENDP
+MemManage_Handler\
+                PROC
+                EXPORT  MemManage_Handler          [WEAK]
+                B       .
+                ENDP
+BusFault_Handler\
+                PROC
+                EXPORT  BusFault_Handler           [WEAK]
+                B       .
+                ENDP
+UsageFault_Handler\
+                PROC
+                EXPORT  UsageFault_Handler         [WEAK]
+                B       .
+                ENDP
+SVC_Handler     PROC
+                EXPORT  SVC_Handler                [WEAK]
+                B       .
+                ENDP
+DebugMon_Handler\
+                PROC
+                EXPORT  DebugMon_Handler           [WEAK]
+                B       .
+                ENDP
+PendSV_Handler  PROC
+                EXPORT  PendSV_Handler             [WEAK]
+                B       .
+                ENDP
+SysTick_Handler PROC
+                EXPORT  SysTick_Handler            [WEAK]
+                B       .
+                ENDP
+
+Default_Handler PROC
+
+                EXPORT  WWDG_IRQHandler            [WEAK]
+                EXPORT  PVD_IRQHandler             [WEAK]
+                EXPORT  TAMPER_IRQHandler          [WEAK]
+                EXPORT  RTC_IRQHandler             [WEAK]
+                EXPORT  FLASH_IRQHandler           [WEAK]
+                EXPORT  RCC_IRQHandler             [WEAK]
+                EXPORT  EXTI0_IRQHandler           [WEAK]
+                EXPORT  EXTI1_IRQHandler           [WEAK]
+                EXPORT  EXTI2_IRQHandler           [WEAK]
+                EXPORT  EXTI3_IRQHandler           [WEAK]
+                EXPORT  EXTI4_IRQHandler           [WEAK]
+                EXPORT  DMA1_Channel1_IRQHandler   [WEAK]
+                EXPORT  DMA1_Channel2_IRQHandler   [WEAK]
+                EXPORT  DMA1_Channel3_IRQHandler   [WEAK]
+                EXPORT  DMA1_Channel4_IRQHandler   [WEAK]
+                EXPORT  DMA1_Channel5_IRQHandler   [WEAK]
+                EXPORT  DMA1_Channel6_IRQHandler   [WEAK]
+                EXPORT  DMA1_Channel7_IRQHandler   [WEAK]
+                EXPORT  ADC1_2_IRQHandler          [WEAK]
+                EXPORT  CAN1_TX_IRQHandler         [WEAK]
+                EXPORT  CAN1_RX0_IRQHandler        [WEAK]
+                EXPORT  CAN1_RX1_IRQHandler        [WEAK]
+                EXPORT  CAN1_SCE_IRQHandler        [WEAK]
+                EXPORT  EXTI9_5_IRQHandler         [WEAK]
+                EXPORT  TIM1_BRK_IRQHandler        [WEAK]
+                EXPORT  TIM1_UP_IRQHandler         [WEAK]
+                EXPORT  TIM1_TRG_COM_IRQHandler    [WEAK]
+                EXPORT  TIM1_CC_IRQHandler         [WEAK]
+                EXPORT  TIM2_IRQHandler            [WEAK]
+                EXPORT  TIM3_IRQHandler            [WEAK]
+                EXPORT  TIM4_IRQHandler            [WEAK]
+                EXPORT  I2C1_EV_IRQHandler         [WEAK]
+                EXPORT  I2C1_ER_IRQHandler         [WEAK]
+                EXPORT  I2C2_EV_IRQHandler         [WEAK]
+                EXPORT  I2C2_ER_IRQHandler         [WEAK]
+                EXPORT  SPI1_IRQHandler            [WEAK]
+                EXPORT  SPI2_IRQHandler            [WEAK]
+                EXPORT  USART1_IRQHandler          [WEAK]
+                EXPORT  USART2_IRQHandler          [WEAK]
+                EXPORT  USART3_IRQHandler          [WEAK]
+                EXPORT  EXTI15_10_IRQHandler       [WEAK]
+                EXPORT  RTCAlarm_IRQHandler        [WEAK]
+                EXPORT  OTG_FS_WKUP_IRQHandler     [WEAK]
+                EXPORT  TIM5_IRQHandler            [WEAK]
+                EXPORT  SPI3_IRQHandler            [WEAK]
+                EXPORT  UART4_IRQHandler           [WEAK]
+                EXPORT  UART5_IRQHandler           [WEAK]
+                EXPORT  TIM6_IRQHandler            [WEAK]
+                EXPORT  TIM7_IRQHandler            [WEAK]
+                EXPORT  DMA2_Channel1_IRQHandler   [WEAK]
+                EXPORT  DMA2_Channel2_IRQHandler   [WEAK]
+                EXPORT  DMA2_Channel3_IRQHandler   [WEAK]
+                EXPORT  DMA2_Channel4_IRQHandler   [WEAK]
+                EXPORT  DMA2_Channel5_IRQHandler   [WEAK]
+                EXPORT  ETH_IRQHandler             [WEAK]
+                EXPORT  ETH_WKUP_IRQHandler        [WEAK]
+                EXPORT  CAN2_TX_IRQHandler         [WEAK]
+                EXPORT  CAN2_RX0_IRQHandler        [WEAK]
+                EXPORT  CAN2_RX1_IRQHandler        [WEAK]
+                EXPORT  CAN2_SCE_IRQHandler        [WEAK]
+                EXPORT  OTG_FS_IRQHandler          [WEAK]
+
+WWDG_IRQHandler
+PVD_IRQHandler
+TAMPER_IRQHandler
+RTC_IRQHandler
+FLASH_IRQHandler
+RCC_IRQHandler
+EXTI0_IRQHandler
+EXTI1_IRQHandler
+EXTI2_IRQHandler
+EXTI3_IRQHandler
+EXTI4_IRQHandler
+DMA1_Channel1_IRQHandler
+DMA1_Channel2_IRQHandler
+DMA1_Channel3_IRQHandler
+DMA1_Channel4_IRQHandler
+DMA1_Channel5_IRQHandler
+DMA1_Channel6_IRQHandler
+DMA1_Channel7_IRQHandler
+ADC1_2_IRQHandler
+CAN1_TX_IRQHandler
+CAN1_RX0_IRQHandler
+CAN1_RX1_IRQHandler
+CAN1_SCE_IRQHandler
+EXTI9_5_IRQHandler
+TIM1_BRK_IRQHandler
+TIM1_UP_IRQHandler
+TIM1_TRG_COM_IRQHandler
+TIM1_CC_IRQHandler
+TIM2_IRQHandler
+TIM3_IRQHandler
+TIM4_IRQHandler
+I2C1_EV_IRQHandler
+I2C1_ER_IRQHandler
+I2C2_EV_IRQHandler
+I2C2_ER_IRQHandler
+SPI1_IRQHandler
+SPI2_IRQHandler
+USART1_IRQHandler
+USART2_IRQHandler
+USART3_IRQHandler
+EXTI15_10_IRQHandler
+RTCAlarm_IRQHandler
+OTG_FS_WKUP_IRQHandler
+TIM5_IRQHandler
+SPI3_IRQHandler
+UART4_IRQHandler
+UART5_IRQHandler
+TIM6_IRQHandler
+TIM7_IRQHandler
+DMA2_Channel1_IRQHandler
+DMA2_Channel2_IRQHandler
+DMA2_Channel3_IRQHandler
+DMA2_Channel4_IRQHandler
+DMA2_Channel5_IRQHandler
+ETH_IRQHandler
+ETH_WKUP_IRQHandler
+CAN2_TX_IRQHandler
+CAN2_RX0_IRQHandler
+CAN2_RX1_IRQHandler
+CAN2_SCE_IRQHandler
+OTG_FS_IRQHandler
+
+                B       .
+
+                ENDP
+
+                ALIGN
+
+;*******************************************************************************
+; User Stack and Heap initialization
+;*******************************************************************************
+                 IF      :DEF:__MICROLIB
+
+                 EXPORT  __initial_sp
+                 EXPORT  __heap_base
+                 EXPORT  __heap_limit
+
+                 ELSE
+
+                 IMPORT  __use_two_region_memory
+                 EXPORT  __user_initial_stackheap
+
+__user_initial_stackheap
+
+                 LDR     R0, =  Heap_Mem
+                 LDR     R1, =(Stack_Mem + Stack_Size)
+                 LDR     R2, = (Heap_Mem +  Heap_Size)
+                 LDR     R3, = Stack_Mem
+                 BX      LR
+
+                 ALIGN
+
+                 ENDIF
+
+                 END
+
+;******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE*****
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_hd.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_hd.s
new file mode 100644
index 0000000..adc9b94
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_hd.s
@@ -0,0 +1,358 @@
+;******************** (C) COPYRIGHT 2011 STMicroelectronics ********************
+;* File Name          : startup_stm32f10x_hd.s
+;* Author             : MCD Application Team
+;* Version            : V3.5.0
+;* Date               : 11-March-2011
+;* Description        : STM32F10x High Density Devices vector table for MDK-ARM
+;*                      toolchain.
+;*                      This module performs:
+;*                      - Set the initial SP
+;*                      - Set the initial PC == Reset_Handler
+;*                      - Set the vector table entries with the exceptions ISR address
+;*                      - Configure the clock system and also configure the external
+;*                        SRAM mounted on STM3210E-EVAL board to be used as data
+;*                        memory (optional, to be enabled by user)
+;*                      - Branches to __main in the C library (which eventually
+;*                        calls main()).
+;*                      After Reset the CortexM3 processor is in Thread mode,
+;*                      priority is Privileged, and the Stack is set to Main.
+;* <<< Use Configuration Wizard in Context Menu >>>
+;*******************************************************************************
+; THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+; WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+; AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+; INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+; CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+; INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+;*******************************************************************************
+
+; Amount of memory (in bytes) allocated for Stack
+; Tailor this value to your application needs
+; <h> Stack Configuration
+;   <o> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8>
+; </h>
+
+Stack_Size      EQU     0x00000400
+
+                AREA    STACK, NOINIT, READWRITE, ALIGN=3
+Stack_Mem       SPACE   Stack_Size
+__initial_sp
+
+; <h> Heap Configuration
+;   <o>  Heap Size (in Bytes) <0x0-0xFFFFFFFF:8>
+; </h>
+
+Heap_Size       EQU     0x00000200
+
+                AREA    HEAP, NOINIT, READWRITE, ALIGN=3
+__heap_base
+Heap_Mem        SPACE   Heap_Size
+__heap_limit
+
+                PRESERVE8
+                THUMB
+
+
+; Vector Table Mapped to Address 0 at Reset
+                AREA    RESET, DATA, READONLY
+                EXPORT  __Vectors
+                EXPORT  __Vectors_End
+                EXPORT  __Vectors_Size
+
+__Vectors       DCD     __initial_sp               ; Top of Stack
+                DCD     Reset_Handler              ; Reset Handler
+                DCD     NMI_Handler                ; NMI Handler
+                DCD     HardFault_Handler          ; Hard Fault Handler
+                DCD     MemManage_Handler          ; MPU Fault Handler
+                DCD     BusFault_Handler           ; Bus Fault Handler
+                DCD     UsageFault_Handler         ; Usage Fault Handler
+                DCD     0                          ; Reserved
+                DCD     0                          ; Reserved
+                DCD     0                          ; Reserved
+                DCD     0                          ; Reserved
+                DCD     SVC_Handler                ; SVCall Handler
+                DCD     DebugMon_Handler           ; Debug Monitor Handler
+                DCD     0                          ; Reserved
+                DCD     PendSV_Handler             ; PendSV Handler
+                DCD     SysTick_Handler            ; SysTick Handler
+
+                ; External Interrupts
+                DCD     WWDG_IRQHandler            ; Window Watchdog
+                DCD     PVD_IRQHandler             ; PVD through EXTI Line detect
+                DCD     TAMPER_IRQHandler          ; Tamper
+                DCD     RTC_IRQHandler             ; RTC
+                DCD     FLASH_IRQHandler           ; Flash
+                DCD     RCC_IRQHandler             ; RCC
+                DCD     EXTI0_IRQHandler           ; EXTI Line 0
+                DCD     EXTI1_IRQHandler           ; EXTI Line 1
+                DCD     EXTI2_IRQHandler           ; EXTI Line 2
+                DCD     EXTI3_IRQHandler           ; EXTI Line 3
+                DCD     EXTI4_IRQHandler           ; EXTI Line 4
+                DCD     DMA1_Channel1_IRQHandler   ; DMA1 Channel 1
+                DCD     DMA1_Channel2_IRQHandler   ; DMA1 Channel 2
+                DCD     DMA1_Channel3_IRQHandler   ; DMA1 Channel 3
+                DCD     DMA1_Channel4_IRQHandler   ; DMA1 Channel 4
+                DCD     DMA1_Channel5_IRQHandler   ; DMA1 Channel 5
+                DCD     DMA1_Channel6_IRQHandler   ; DMA1 Channel 6
+                DCD     DMA1_Channel7_IRQHandler   ; DMA1 Channel 7
+                DCD     ADC1_2_IRQHandler          ; ADC1 & ADC2
+                DCD     USB_HP_CAN1_TX_IRQHandler  ; USB High Priority or CAN1 TX
+                DCD     USB_LP_CAN1_RX0_IRQHandler ; USB Low  Priority or CAN1 RX0
+                DCD     CAN1_RX1_IRQHandler        ; CAN1 RX1
+                DCD     CAN1_SCE_IRQHandler        ; CAN1 SCE
+                DCD     EXTI9_5_IRQHandler         ; EXTI Line 9..5
+                DCD     TIM1_BRK_IRQHandler        ; TIM1 Break
+                DCD     TIM1_UP_IRQHandler         ; TIM1 Update
+                DCD     TIM1_TRG_COM_IRQHandler    ; TIM1 Trigger and Commutation
+                DCD     TIM1_CC_IRQHandler         ; TIM1 Capture Compare
+                DCD     TIM2_IRQHandler            ; TIM2
+                DCD     TIM3_IRQHandler            ; TIM3
+                DCD     TIM4_IRQHandler            ; TIM4
+                DCD     I2C1_EV_IRQHandler         ; I2C1 Event
+                DCD     I2C1_ER_IRQHandler         ; I2C1 Error
+                DCD     I2C2_EV_IRQHandler         ; I2C2 Event
+                DCD     I2C2_ER_IRQHandler         ; I2C2 Error
+                DCD     SPI1_IRQHandler            ; SPI1
+                DCD     SPI2_IRQHandler            ; SPI2
+                DCD     USART1_IRQHandler          ; USART1
+                DCD     USART2_IRQHandler          ; USART2
+                DCD     USART3_IRQHandler          ; USART3
+                DCD     EXTI15_10_IRQHandler       ; EXTI Line 15..10
+                DCD     RTCAlarm_IRQHandler        ; RTC Alarm through EXTI Line
+                DCD     USBWakeUp_IRQHandler       ; USB Wakeup from suspend
+                DCD     TIM8_BRK_IRQHandler        ; TIM8 Break
+                DCD     TIM8_UP_IRQHandler         ; TIM8 Update
+                DCD     TIM8_TRG_COM_IRQHandler    ; TIM8 Trigger and Commutation
+                DCD     TIM8_CC_IRQHandler         ; TIM8 Capture Compare
+                DCD     ADC3_IRQHandler            ; ADC3
+                DCD     FSMC_IRQHandler            ; FSMC
+                DCD     SDIO_IRQHandler            ; SDIO
+                DCD     TIM5_IRQHandler            ; TIM5
+                DCD     SPI3_IRQHandler            ; SPI3
+                DCD     UART4_IRQHandler           ; UART4
+                DCD     UART5_IRQHandler           ; UART5
+                DCD     TIM6_IRQHandler            ; TIM6
+                DCD     TIM7_IRQHandler            ; TIM7
+                DCD     DMA2_Channel1_IRQHandler   ; DMA2 Channel1
+                DCD     DMA2_Channel2_IRQHandler   ; DMA2 Channel2
+                DCD     DMA2_Channel3_IRQHandler   ; DMA2 Channel3
+                DCD     DMA2_Channel4_5_IRQHandler ; DMA2 Channel4 & Channel5
+__Vectors_End
+
+__Vectors_Size  EQU  __Vectors_End - __Vectors
+
+                AREA    |.text|, CODE, READONLY
+
+; Reset handler
+Reset_Handler   PROC
+                EXPORT  Reset_Handler             [WEAK]
+                IMPORT  __main
+                IMPORT  SystemInit
+                LDR     R0, =SystemInit
+                BLX     R0
+                LDR     R0, =__main
+                BX      R0
+                ENDP
+
+; Dummy Exception Handlers (infinite loops which can be modified)
+
+NMI_Handler     PROC
+                EXPORT  NMI_Handler                [WEAK]
+                B       .
+                ENDP
+HardFault_Handler\
+                PROC
+                EXPORT  HardFault_Handler          [WEAK]
+                B       .
+                ENDP
+MemManage_Handler\
+                PROC
+                EXPORT  MemManage_Handler          [WEAK]
+                B       .
+                ENDP
+BusFault_Handler\
+                PROC
+                EXPORT  BusFault_Handler           [WEAK]
+                B       .
+                ENDP
+UsageFault_Handler\
+                PROC
+                EXPORT  UsageFault_Handler         [WEAK]
+                B       .
+                ENDP
+SVC_Handler     PROC
+                EXPORT  SVC_Handler                [WEAK]
+                B       .
+                ENDP
+DebugMon_Handler\
+                PROC
+                EXPORT  DebugMon_Handler           [WEAK]
+                B       .
+                ENDP
+PendSV_Handler  PROC
+                EXPORT  PendSV_Handler             [WEAK]
+                B       .
+                ENDP
+SysTick_Handler PROC
+                EXPORT  SysTick_Handler            [WEAK]
+                B       .
+                ENDP
+
+Default_Handler PROC
+
+                EXPORT  WWDG_IRQHandler            [WEAK]
+                EXPORT  PVD_IRQHandler             [WEAK]
+                EXPORT  TAMPER_IRQHandler          [WEAK]
+                EXPORT  RTC_IRQHandler             [WEAK]
+                EXPORT  FLASH_IRQHandler           [WEAK]
+                EXPORT  RCC_IRQHandler             [WEAK]
+                EXPORT  EXTI0_IRQHandler           [WEAK]
+                EXPORT  EXTI1_IRQHandler           [WEAK]
+                EXPORT  EXTI2_IRQHandler           [WEAK]
+                EXPORT  EXTI3_IRQHandler           [WEAK]
+                EXPORT  EXTI4_IRQHandler           [WEAK]
+                EXPORT  DMA1_Channel1_IRQHandler   [WEAK]
+                EXPORT  DMA1_Channel2_IRQHandler   [WEAK]
+                EXPORT  DMA1_Channel3_IRQHandler   [WEAK]
+                EXPORT  DMA1_Channel4_IRQHandler   [WEAK]
+                EXPORT  DMA1_Channel5_IRQHandler   [WEAK]
+                EXPORT  DMA1_Channel6_IRQHandler   [WEAK]
+                EXPORT  DMA1_Channel7_IRQHandler   [WEAK]
+                EXPORT  ADC1_2_IRQHandler          [WEAK]
+                EXPORT  USB_HP_CAN1_TX_IRQHandler  [WEAK]
+                EXPORT  USB_LP_CAN1_RX0_IRQHandler [WEAK]
+                EXPORT  CAN1_RX1_IRQHandler        [WEAK]
+                EXPORT  CAN1_SCE_IRQHandler        [WEAK]
+                EXPORT  EXTI9_5_IRQHandler         [WEAK]
+                EXPORT  TIM1_BRK_IRQHandler        [WEAK]
+                EXPORT  TIM1_UP_IRQHandler         [WEAK]
+                EXPORT  TIM1_TRG_COM_IRQHandler    [WEAK]
+                EXPORT  TIM1_CC_IRQHandler         [WEAK]
+                EXPORT  TIM2_IRQHandler            [WEAK]
+                EXPORT  TIM3_IRQHandler            [WEAK]
+                EXPORT  TIM4_IRQHandler            [WEAK]
+                EXPORT  I2C1_EV_IRQHandler         [WEAK]
+                EXPORT  I2C1_ER_IRQHandler         [WEAK]
+                EXPORT  I2C2_EV_IRQHandler         [WEAK]
+                EXPORT  I2C2_ER_IRQHandler         [WEAK]
+                EXPORT  SPI1_IRQHandler            [WEAK]
+                EXPORT  SPI2_IRQHandler            [WEAK]
+                EXPORT  USART1_IRQHandler          [WEAK]
+                EXPORT  USART2_IRQHandler          [WEAK]
+                EXPORT  USART3_IRQHandler          [WEAK]
+                EXPORT  EXTI15_10_IRQHandler       [WEAK]
+                EXPORT  RTCAlarm_IRQHandler        [WEAK]
+                EXPORT  USBWakeUp_IRQHandler       [WEAK]
+                EXPORT  TIM8_BRK_IRQHandler        [WEAK]
+                EXPORT  TIM8_UP_IRQHandler         [WEAK]
+                EXPORT  TIM8_TRG_COM_IRQHandler    [WEAK]
+                EXPORT  TIM8_CC_IRQHandler         [WEAK]
+                EXPORT  ADC3_IRQHandler            [WEAK]
+                EXPORT  FSMC_IRQHandler            [WEAK]
+                EXPORT  SDIO_IRQHandler            [WEAK]
+                EXPORT  TIM5_IRQHandler            [WEAK]
+                EXPORT  SPI3_IRQHandler            [WEAK]
+                EXPORT  UART4_IRQHandler           [WEAK]
+                EXPORT  UART5_IRQHandler           [WEAK]
+                EXPORT  TIM6_IRQHandler            [WEAK]
+                EXPORT  TIM7_IRQHandler            [WEAK]
+                EXPORT  DMA2_Channel1_IRQHandler   [WEAK]
+                EXPORT  DMA2_Channel2_IRQHandler   [WEAK]
+                EXPORT  DMA2_Channel3_IRQHandler   [WEAK]
+                EXPORT  DMA2_Channel4_5_IRQHandler [WEAK]
+
+WWDG_IRQHandler
+PVD_IRQHandler
+TAMPER_IRQHandler
+RTC_IRQHandler
+FLASH_IRQHandler
+RCC_IRQHandler
+EXTI0_IRQHandler
+EXTI1_IRQHandler
+EXTI2_IRQHandler
+EXTI3_IRQHandler
+EXTI4_IRQHandler
+DMA1_Channel1_IRQHandler
+DMA1_Channel2_IRQHandler
+DMA1_Channel3_IRQHandler
+DMA1_Channel4_IRQHandler
+DMA1_Channel5_IRQHandler
+DMA1_Channel6_IRQHandler
+DMA1_Channel7_IRQHandler
+ADC1_2_IRQHandler
+USB_HP_CAN1_TX_IRQHandler
+USB_LP_CAN1_RX0_IRQHandler
+CAN1_RX1_IRQHandler
+CAN1_SCE_IRQHandler
+EXTI9_5_IRQHandler
+TIM1_BRK_IRQHandler
+TIM1_UP_IRQHandler
+TIM1_TRG_COM_IRQHandler
+TIM1_CC_IRQHandler
+TIM2_IRQHandler
+TIM3_IRQHandler
+TIM4_IRQHandler
+I2C1_EV_IRQHandler
+I2C1_ER_IRQHandler
+I2C2_EV_IRQHandler
+I2C2_ER_IRQHandler
+SPI1_IRQHandler
+SPI2_IRQHandler
+USART1_IRQHandler
+USART2_IRQHandler
+USART3_IRQHandler
+EXTI15_10_IRQHandler
+RTCAlarm_IRQHandler
+USBWakeUp_IRQHandler
+TIM8_BRK_IRQHandler
+TIM8_UP_IRQHandler
+TIM8_TRG_COM_IRQHandler
+TIM8_CC_IRQHandler
+ADC3_IRQHandler
+FSMC_IRQHandler
+SDIO_IRQHandler
+TIM5_IRQHandler
+SPI3_IRQHandler
+UART4_IRQHandler
+UART5_IRQHandler
+TIM6_IRQHandler
+TIM7_IRQHandler
+DMA2_Channel1_IRQHandler
+DMA2_Channel2_IRQHandler
+DMA2_Channel3_IRQHandler
+DMA2_Channel4_5_IRQHandler
+                B       .
+
+                ENDP
+
+                ALIGN
+
+;*******************************************************************************
+; User Stack and Heap initialization
+;*******************************************************************************
+                 IF      :DEF:__MICROLIB
+
+                 EXPORT  __initial_sp
+                 EXPORT  __heap_base
+                 EXPORT  __heap_limit
+
+                 ELSE
+
+                 IMPORT  __use_two_region_memory
+                 EXPORT  __user_initial_stackheap
+
+__user_initial_stackheap
+
+                 LDR     R0, =  Heap_Mem
+                 LDR     R1, =(Stack_Mem + Stack_Size)
+                 LDR     R2, = (Heap_Mem +  Heap_Size)
+                 LDR     R3, = Stack_Mem
+                 BX      LR
+
+                 ALIGN
+
+                 ENDIF
+
+                 END
+
+;******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE*****
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_hd_vl.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_hd_vl.s
new file mode 100644
index 0000000..d6082b0
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_hd_vl.s
@@ -0,0 +1,346 @@
+;******************** (C) COPYRIGHT 2011 STMicroelectronics ********************
+;* File Name          : startup_stm32f10x_hd_vl.s
+;* Author             : MCD Application Team
+;* Version            : V3.5.0
+;* Date               : 11-March-2011
+;* Description        : STM32F10x High Density Value Line Devices vector table
+;*                      for MDK-ARM toolchain.
+;*                      This module performs:
+;*                      - Set the initial SP
+;*                      - Set the initial PC == Reset_Handler
+;*                      - Set the vector table entries with the exceptions ISR address
+;*                      - Configure the clock system and also configure the external
+;*                        SRAM mounted on STM32100E-EVAL board to be used as data
+;*                        memory (optional, to be enabled by user)
+;*                      - Branches to __main in the C library (which eventually
+;*                        calls main()).
+;*                      After Reset the CortexM3 processor is in Thread mode,
+;*                      priority is Privileged, and the Stack is set to Main.
+;* <<< Use Configuration Wizard in Context Menu >>>
+;*******************************************************************************
+; THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+; WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+; AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+; INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+; CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+; INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+;*******************************************************************************
+
+; Amount of memory (in bytes) allocated for Stack
+; Tailor this value to your application needs
+; <h> Stack Configuration
+;   <o> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8>
+; </h>
+
+Stack_Size      EQU     0x00000400
+
+                AREA    STACK, NOINIT, READWRITE, ALIGN=3
+Stack_Mem       SPACE   Stack_Size
+__initial_sp
+
+
+; <h> Heap Configuration
+;   <o>  Heap Size (in Bytes) <0x0-0xFFFFFFFF:8>
+; </h>
+
+Heap_Size       EQU     0x00000200
+
+                AREA    HEAP, NOINIT, READWRITE, ALIGN=3
+__heap_base
+Heap_Mem        SPACE   Heap_Size
+__heap_limit
+
+                PRESERVE8
+                THUMB
+
+
+; Vector Table Mapped to Address 0 at Reset
+                AREA    RESET, DATA, READONLY
+                EXPORT  __Vectors
+                EXPORT  __Vectors_End
+                EXPORT  __Vectors_Size
+
+__Vectors       DCD     __initial_sp                    ; Top of Stack
+                DCD     Reset_Handler                   ; Reset Handler
+                DCD     NMI_Handler                     ; NMI Handler
+                DCD     HardFault_Handler               ; Hard Fault Handler
+                DCD     MemManage_Handler               ; MPU Fault Handler
+                DCD     BusFault_Handler                ; Bus Fault Handler
+                DCD     UsageFault_Handler              ; Usage Fault Handler
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     SVC_Handler                     ; SVCall Handler
+                DCD     DebugMon_Handler                ; Debug Monitor Handler
+                DCD     0                               ; Reserved
+                DCD     PendSV_Handler                  ; PendSV Handler
+                DCD     SysTick_Handler                 ; SysTick Handler
+
+                ; External Interrupts
+                DCD     WWDG_IRQHandler                 ; Window Watchdog
+                DCD     PVD_IRQHandler                  ; PVD through EXTI Line detect
+                DCD     TAMPER_IRQHandler               ; Tamper
+                DCD     RTC_IRQHandler                  ; RTC
+                DCD     FLASH_IRQHandler                ; Flash
+                DCD     RCC_IRQHandler                  ; RCC
+                DCD     EXTI0_IRQHandler                ; EXTI Line 0
+                DCD     EXTI1_IRQHandler                ; EXTI Line 1
+                DCD     EXTI2_IRQHandler                ; EXTI Line 2
+                DCD     EXTI3_IRQHandler                ; EXTI Line 3
+                DCD     EXTI4_IRQHandler                ; EXTI Line 4
+                DCD     DMA1_Channel1_IRQHandler        ; DMA1 Channel 1
+                DCD     DMA1_Channel2_IRQHandler        ; DMA1 Channel 2
+                DCD     DMA1_Channel3_IRQHandler        ; DMA1 Channel 3
+                DCD     DMA1_Channel4_IRQHandler        ; DMA1 Channel 4
+                DCD     DMA1_Channel5_IRQHandler        ; DMA1 Channel 5
+                DCD     DMA1_Channel6_IRQHandler        ; DMA1 Channel 6
+                DCD     DMA1_Channel7_IRQHandler        ; DMA1 Channel 7
+                DCD     ADC1_IRQHandler                 ; ADC1
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     EXTI9_5_IRQHandler              ; EXTI Line 9..5
+                DCD     TIM1_BRK_TIM15_IRQHandler       ; TIM1 Break and TIM15
+                DCD     TIM1_UP_TIM16_IRQHandler        ; TIM1 Update and TIM16
+                DCD     TIM1_TRG_COM_TIM17_IRQHandler   ; TIM1 Trigger and Commutation and TIM17
+                DCD     TIM1_CC_IRQHandler              ; TIM1 Capture Compare
+                DCD     TIM2_IRQHandler                 ; TIM2
+                DCD     TIM3_IRQHandler                 ; TIM3
+                DCD     TIM4_IRQHandler                 ; TIM4
+                DCD     I2C1_EV_IRQHandler              ; I2C1 Event
+                DCD     I2C1_ER_IRQHandler              ; I2C1 Error
+                DCD     I2C2_EV_IRQHandler              ; I2C2 Event
+                DCD     I2C2_ER_IRQHandler              ; I2C2 Error
+                DCD     SPI1_IRQHandler                 ; SPI1
+                DCD     SPI2_IRQHandler                 ; SPI2
+                DCD     USART1_IRQHandler               ; USART1
+                DCD     USART2_IRQHandler               ; USART2
+                DCD     USART3_IRQHandler               ; USART3
+                DCD     EXTI15_10_IRQHandler            ; EXTI Line 15..10
+                DCD     RTCAlarm_IRQHandler             ; RTC Alarm through EXTI Line
+                DCD     CEC_IRQHandler                  ; HDMI-CEC
+                DCD     TIM12_IRQHandler                ; TIM12
+                DCD     TIM13_IRQHandler                ; TIM13
+                DCD     TIM14_IRQHandler                ; TIM14
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     TIM5_IRQHandler                 ; TIM5
+                DCD     SPI3_IRQHandler                 ; SPI3
+                DCD     UART4_IRQHandler                ; UART4
+                DCD     UART5_IRQHandler                ; UART5
+                DCD     TIM6_DAC_IRQHandler             ; TIM6 and DAC underrun
+                DCD     TIM7_IRQHandler                 ; TIM7
+                DCD     DMA2_Channel1_IRQHandler        ; DMA2 Channel1
+                DCD     DMA2_Channel2_IRQHandler        ; DMA2 Channel2
+                DCD     DMA2_Channel3_IRQHandler        ; DMA2 Channel3
+                DCD     DMA2_Channel4_5_IRQHandler      ; DMA2 Channel4 & Channel5
+                DCD     DMA2_Channel5_IRQHandler        ; DMA2 Channel5
+__Vectors_End
+
+__Vectors_Size  EQU  __Vectors_End - __Vectors
+
+                AREA    |.text|, CODE, READONLY
+
+; Reset handler
+Reset_Handler    PROC
+                 EXPORT  Reset_Handler             [WEAK]
+     IMPORT  __main
+     IMPORT  SystemInit
+                 LDR     R0, =SystemInit
+                 BLX     R0
+                 LDR     R0, =__main
+                 BX      R0
+                 ENDP
+
+; Dummy Exception Handlers (infinite loops which can be modified)
+
+NMI_Handler     PROC
+                EXPORT  NMI_Handler                      [WEAK]
+                B       .
+                ENDP
+HardFault_Handler\
+                PROC
+                EXPORT  HardFault_Handler                [WEAK]
+                B       .
+                ENDP
+MemManage_Handler\
+                PROC
+                EXPORT  MemManage_Handler                [WEAK]
+                B       .
+                ENDP
+BusFault_Handler\
+                PROC
+                EXPORT  BusFault_Handler                 [WEAK]
+                B       .
+                ENDP
+UsageFault_Handler\
+                PROC
+                EXPORT  UsageFault_Handler               [WEAK]
+                B       .
+                ENDP
+SVC_Handler     PROC
+                EXPORT  SVC_Handler                      [WEAK]
+                B       .
+                ENDP
+DebugMon_Handler\
+                PROC
+                EXPORT  DebugMon_Handler                 [WEAK]
+                B       .
+                ENDP
+PendSV_Handler  PROC
+                EXPORT  PendSV_Handler                   [WEAK]
+                B       .
+                ENDP
+SysTick_Handler PROC
+                EXPORT  SysTick_Handler                  [WEAK]
+                B       .
+                ENDP
+
+Default_Handler PROC
+
+                EXPORT  WWDG_IRQHandler                  [WEAK]
+                EXPORT  PVD_IRQHandler                   [WEAK]
+                EXPORT  TAMPER_IRQHandler                [WEAK]
+                EXPORT  RTC_IRQHandler                   [WEAK]
+                EXPORT  FLASH_IRQHandler                 [WEAK]
+                EXPORT  RCC_IRQHandler                   [WEAK]
+                EXPORT  EXTI0_IRQHandler                 [WEAK]
+                EXPORT  EXTI1_IRQHandler                 [WEAK]
+                EXPORT  EXTI2_IRQHandler                 [WEAK]
+                EXPORT  EXTI3_IRQHandler                 [WEAK]
+                EXPORT  EXTI4_IRQHandler                 [WEAK]
+                EXPORT  DMA1_Channel1_IRQHandler         [WEAK]
+                EXPORT  DMA1_Channel2_IRQHandler         [WEAK]
+                EXPORT  DMA1_Channel3_IRQHandler         [WEAK]
+                EXPORT  DMA1_Channel4_IRQHandler         [WEAK]
+                EXPORT  DMA1_Channel5_IRQHandler         [WEAK]
+                EXPORT  DMA1_Channel6_IRQHandler         [WEAK]
+                EXPORT  DMA1_Channel7_IRQHandler         [WEAK]
+                EXPORT  ADC1_IRQHandler                  [WEAK]
+                EXPORT  EXTI9_5_IRQHandler               [WEAK]
+                EXPORT  TIM1_BRK_TIM15_IRQHandler        [WEAK]
+                EXPORT  TIM1_UP_TIM16_IRQHandler         [WEAK]
+                EXPORT  TIM1_TRG_COM_TIM17_IRQHandler    [WEAK]
+                EXPORT  TIM1_CC_IRQHandler               [WEAK]
+                EXPORT  TIM2_IRQHandler                  [WEAK]
+                EXPORT  TIM3_IRQHandler                  [WEAK]
+                EXPORT  TIM4_IRQHandler                  [WEAK]
+                EXPORT  I2C1_EV_IRQHandler               [WEAK]
+                EXPORT  I2C1_ER_IRQHandler               [WEAK]
+                EXPORT  I2C2_EV_IRQHandler               [WEAK]
+                EXPORT  I2C2_ER_IRQHandler               [WEAK]
+                EXPORT  SPI1_IRQHandler                  [WEAK]
+                EXPORT  SPI2_IRQHandler                  [WEAK]
+                EXPORT  USART1_IRQHandler                [WEAK]
+                EXPORT  USART2_IRQHandler                [WEAK]
+                EXPORT  USART3_IRQHandler                [WEAK]
+                EXPORT  EXTI15_10_IRQHandler             [WEAK]
+                EXPORT  RTCAlarm_IRQHandler              [WEAK]
+                EXPORT  CEC_IRQHandler                   [WEAK]
+                EXPORT  TIM12_IRQHandler                 [WEAK]
+                EXPORT  TIM13_IRQHandler                 [WEAK]
+                EXPORT  TIM14_IRQHandler                 [WEAK]
+                EXPORT  TIM5_IRQHandler                  [WEAK]
+                EXPORT  SPI3_IRQHandler                  [WEAK]
+                EXPORT  UART4_IRQHandler                 [WEAK]
+                EXPORT  UART5_IRQHandler                 [WEAK]
+                EXPORT  TIM6_DAC_IRQHandler              [WEAK]
+                EXPORT  TIM7_IRQHandler                  [WEAK]
+                EXPORT  DMA2_Channel1_IRQHandler         [WEAK]
+                EXPORT  DMA2_Channel2_IRQHandler         [WEAK]
+                EXPORT  DMA2_Channel3_IRQHandler         [WEAK]
+                EXPORT  DMA2_Channel4_5_IRQHandler       [WEAK]
+                EXPORT  DMA2_Channel5_IRQHandler         [WEAK]
+
+WWDG_IRQHandler
+PVD_IRQHandler
+TAMPER_IRQHandler
+RTC_IRQHandler
+FLASH_IRQHandler
+RCC_IRQHandler
+EXTI0_IRQHandler
+EXTI1_IRQHandler
+EXTI2_IRQHandler
+EXTI3_IRQHandler
+EXTI4_IRQHandler
+DMA1_Channel1_IRQHandler
+DMA1_Channel2_IRQHandler
+DMA1_Channel3_IRQHandler
+DMA1_Channel4_IRQHandler
+DMA1_Channel5_IRQHandler
+DMA1_Channel6_IRQHandler
+DMA1_Channel7_IRQHandler
+ADC1_IRQHandler
+EXTI9_5_IRQHandler
+TIM1_BRK_TIM15_IRQHandler
+TIM1_UP_TIM16_IRQHandler
+TIM1_TRG_COM_TIM17_IRQHandler
+TIM1_CC_IRQHandler
+TIM2_IRQHandler
+TIM3_IRQHandler
+TIM4_IRQHandler
+I2C1_EV_IRQHandler
+I2C1_ER_IRQHandler
+I2C2_EV_IRQHandler
+I2C2_ER_IRQHandler
+SPI1_IRQHandler
+SPI2_IRQHandler
+USART1_IRQHandler
+USART2_IRQHandler
+USART3_IRQHandler
+EXTI15_10_IRQHandler
+RTCAlarm_IRQHandler
+CEC_IRQHandler
+TIM12_IRQHandler
+TIM13_IRQHandler
+TIM14_IRQHandler
+TIM5_IRQHandler
+SPI3_IRQHandler
+UART4_IRQHandler
+UART5_IRQHandler
+TIM6_DAC_IRQHandler
+TIM7_IRQHandler
+DMA2_Channel1_IRQHandler
+DMA2_Channel2_IRQHandler
+DMA2_Channel3_IRQHandler
+DMA2_Channel4_5_IRQHandler
+DMA2_Channel5_IRQHandler
+                B       .
+
+                ENDP
+
+                ALIGN
+
+;*******************************************************************************
+; User Stack and Heap initialization
+;*******************************************************************************
+                 IF      :DEF:__MICROLIB
+
+                 EXPORT  __initial_sp
+                 EXPORT  __heap_base
+                 EXPORT  __heap_limit
+
+                 ELSE
+
+                 IMPORT  __use_two_region_memory
+                 EXPORT  __user_initial_stackheap
+
+__user_initial_stackheap
+
+                 LDR     R0, =  Heap_Mem
+                 LDR     R1, =(Stack_Mem + Stack_Size)
+                 LDR     R2, = (Heap_Mem +  Heap_Size)
+                 LDR     R3, = Stack_Mem
+                 BX      LR
+
+                 ALIGN
+
+                 ENDIF
+
+                 END
+
+;******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE*****
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_ld.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_ld.s
new file mode 100644
index 0000000..3f3ac2f
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_ld.s
@@ -0,0 +1,297 @@
+;******************** (C) COPYRIGHT 2011 STMicroelectronics ********************
+;* File Name          : startup_stm32f10x_ld.s
+;* Author             : MCD Application Team
+;* Version            : V3.5.0
+;* Date               : 11-March-2011
+;* Description        : STM32F10x Low Density Devices vector table for MDK-ARM
+;*                      toolchain.
+;*                      This module performs:
+;*                      - Set the initial SP
+;*                      - Set the initial PC == Reset_Handler
+;*                      - Set the vector table entries with the exceptions ISR address
+;*                      - Configure the clock system
+;*                      - Branches to __main in the C library (which eventually
+;*                        calls main()).
+;*                      After Reset the CortexM3 processor is in Thread mode,
+;*                      priority is Privileged, and the Stack is set to Main.
+;* <<< Use Configuration Wizard in Context Menu >>>
+;*******************************************************************************
+; THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+; WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+; AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+; INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+; CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+; INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+;*******************************************************************************
+
+; Amount of memory (in bytes) allocated for Stack
+; Tailor this value to your application needs
+; <h> Stack Configuration
+;   <o> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8>
+; </h>
+
+Stack_Size      EQU     0x00000400
+
+                AREA    STACK, NOINIT, READWRITE, ALIGN=3
+Stack_Mem       SPACE   Stack_Size
+__initial_sp
+
+
+; <h> Heap Configuration
+;   <o>  Heap Size (in Bytes) <0x0-0xFFFFFFFF:8>
+; </h>
+
+Heap_Size       EQU     0x00000200
+
+                AREA    HEAP, NOINIT, READWRITE, ALIGN=3
+__heap_base
+Heap_Mem        SPACE   Heap_Size
+__heap_limit
+
+                PRESERVE8
+                THUMB
+
+
+; Vector Table Mapped to Address 0 at Reset
+                AREA    RESET, DATA, READONLY
+                EXPORT  __Vectors
+                EXPORT  __Vectors_End
+                EXPORT  __Vectors_Size
+
+__Vectors       DCD     __initial_sp               ; Top of Stack
+                DCD     Reset_Handler              ; Reset Handler
+                DCD     NMI_Handler                ; NMI Handler
+                DCD     HardFault_Handler          ; Hard Fault Handler
+                DCD     MemManage_Handler          ; MPU Fault Handler
+                DCD     BusFault_Handler           ; Bus Fault Handler
+                DCD     UsageFault_Handler         ; Usage Fault Handler
+                DCD     0                          ; Reserved
+                DCD     0                          ; Reserved
+                DCD     0                          ; Reserved
+                DCD     0                          ; Reserved
+                DCD     SVC_Handler                ; SVCall Handler
+                DCD     DebugMon_Handler           ; Debug Monitor Handler
+                DCD     0                          ; Reserved
+                DCD     PendSV_Handler             ; PendSV Handler
+                DCD     SysTick_Handler            ; SysTick Handler
+
+                ; External Interrupts
+                DCD     WWDG_IRQHandler            ; Window Watchdog
+                DCD     PVD_IRQHandler             ; PVD through EXTI Line detect
+                DCD     TAMPER_IRQHandler          ; Tamper
+                DCD     RTC_IRQHandler             ; RTC
+                DCD     FLASH_IRQHandler           ; Flash
+                DCD     RCC_IRQHandler             ; RCC
+                DCD     EXTI0_IRQHandler           ; EXTI Line 0
+                DCD     EXTI1_IRQHandler           ; EXTI Line 1
+                DCD     EXTI2_IRQHandler           ; EXTI Line 2
+                DCD     EXTI3_IRQHandler           ; EXTI Line 3
+                DCD     EXTI4_IRQHandler           ; EXTI Line 4
+                DCD     DMA1_Channel1_IRQHandler   ; DMA1 Channel 1
+                DCD     DMA1_Channel2_IRQHandler   ; DMA1 Channel 2
+                DCD     DMA1_Channel3_IRQHandler   ; DMA1 Channel 3
+                DCD     DMA1_Channel4_IRQHandler   ; DMA1 Channel 4
+                DCD     DMA1_Channel5_IRQHandler   ; DMA1 Channel 5
+                DCD     DMA1_Channel6_IRQHandler   ; DMA1 Channel 6
+                DCD     DMA1_Channel7_IRQHandler   ; DMA1 Channel 7
+                DCD     ADC1_2_IRQHandler          ; ADC1_2
+                DCD     USB_HP_CAN1_TX_IRQHandler  ; USB High Priority or CAN1 TX
+                DCD     USB_LP_CAN1_RX0_IRQHandler ; USB Low  Priority or CAN1 RX0
+                DCD     CAN1_RX1_IRQHandler        ; CAN1 RX1
+                DCD     CAN1_SCE_IRQHandler        ; CAN1 SCE
+                DCD     EXTI9_5_IRQHandler         ; EXTI Line 9..5
+                DCD     TIM1_BRK_IRQHandler        ; TIM1 Break
+                DCD     TIM1_UP_IRQHandler         ; TIM1 Update
+                DCD     TIM1_TRG_COM_IRQHandler    ; TIM1 Trigger and Commutation
+                DCD     TIM1_CC_IRQHandler         ; TIM1 Capture Compare
+                DCD     TIM2_IRQHandler            ; TIM2
+                DCD     TIM3_IRQHandler            ; TIM3
+                DCD     0                          ; Reserved
+                DCD     I2C1_EV_IRQHandler         ; I2C1 Event
+                DCD     I2C1_ER_IRQHandler         ; I2C1 Error
+                DCD     0                          ; Reserved
+                DCD     0                          ; Reserved
+                DCD     SPI1_IRQHandler            ; SPI1
+                DCD     0                          ; Reserved
+                DCD     USART1_IRQHandler          ; USART1
+                DCD     USART2_IRQHandler          ; USART2
+                DCD     0                          ; Reserved
+                DCD     EXTI15_10_IRQHandler       ; EXTI Line 15..10
+                DCD     RTCAlarm_IRQHandler        ; RTC Alarm through EXTI Line
+                DCD     USBWakeUp_IRQHandler       ; USB Wakeup from suspend
+__Vectors_End
+
+__Vectors_Size  EQU  __Vectors_End - __Vectors
+
+                AREA    |.text|, CODE, READONLY
+
+; Reset handler routine
+Reset_Handler    PROC
+                 EXPORT  Reset_Handler             [WEAK]
+     IMPORT  __main
+     IMPORT  SystemInit
+                 LDR     R0, =SystemInit
+                 BLX     R0
+                 LDR     R0, =__main
+                 BX      R0
+                 ENDP
+
+; Dummy Exception Handlers (infinite loops which can be modified)
+
+NMI_Handler     PROC
+                EXPORT  NMI_Handler                [WEAK]
+                B       .
+                ENDP
+HardFault_Handler\
+                PROC
+                EXPORT  HardFault_Handler          [WEAK]
+                B       .
+                ENDP
+MemManage_Handler\
+                PROC
+                EXPORT  MemManage_Handler          [WEAK]
+                B       .
+                ENDP
+BusFault_Handler\
+                PROC
+                EXPORT  BusFault_Handler           [WEAK]
+                B       .
+                ENDP
+UsageFault_Handler\
+                PROC
+                EXPORT  UsageFault_Handler         [WEAK]
+                B       .
+                ENDP
+SVC_Handler     PROC
+                EXPORT  SVC_Handler                [WEAK]
+                B       .
+                ENDP
+DebugMon_Handler\
+                PROC
+                EXPORT  DebugMon_Handler           [WEAK]
+                B       .
+                ENDP
+PendSV_Handler  PROC
+                EXPORT  PendSV_Handler             [WEAK]
+                B       .
+                ENDP
+SysTick_Handler PROC
+                EXPORT  SysTick_Handler            [WEAK]
+                B       .
+                ENDP
+
+Default_Handler PROC
+
+                EXPORT  WWDG_IRQHandler            [WEAK]
+                EXPORT  PVD_IRQHandler             [WEAK]
+                EXPORT  TAMPER_IRQHandler          [WEAK]
+                EXPORT  RTC_IRQHandler             [WEAK]
+                EXPORT  FLASH_IRQHandler           [WEAK]
+                EXPORT  RCC_IRQHandler             [WEAK]
+                EXPORT  EXTI0_IRQHandler           [WEAK]
+                EXPORT  EXTI1_IRQHandler           [WEAK]
+                EXPORT  EXTI2_IRQHandler           [WEAK]
+                EXPORT  EXTI3_IRQHandler           [WEAK]
+                EXPORT  EXTI4_IRQHandler           [WEAK]
+                EXPORT  DMA1_Channel1_IRQHandler   [WEAK]
+                EXPORT  DMA1_Channel2_IRQHandler   [WEAK]
+                EXPORT  DMA1_Channel3_IRQHandler   [WEAK]
+                EXPORT  DMA1_Channel4_IRQHandler   [WEAK]
+                EXPORT  DMA1_Channel5_IRQHandler   [WEAK]
+                EXPORT  DMA1_Channel6_IRQHandler   [WEAK]
+                EXPORT  DMA1_Channel7_IRQHandler   [WEAK]
+                EXPORT  ADC1_2_IRQHandler          [WEAK]
+                EXPORT  USB_HP_CAN1_TX_IRQHandler  [WEAK]
+                EXPORT  USB_LP_CAN1_RX0_IRQHandler [WEAK]
+                EXPORT  CAN1_RX1_IRQHandler        [WEAK]
+                EXPORT  CAN1_SCE_IRQHandler        [WEAK]
+                EXPORT  EXTI9_5_IRQHandler         [WEAK]
+                EXPORT  TIM1_BRK_IRQHandler        [WEAK]
+                EXPORT  TIM1_UP_IRQHandler         [WEAK]
+                EXPORT  TIM1_TRG_COM_IRQHandler    [WEAK]
+                EXPORT  TIM1_CC_IRQHandler         [WEAK]
+                EXPORT  TIM2_IRQHandler            [WEAK]
+                EXPORT  TIM3_IRQHandler            [WEAK]
+                EXPORT  I2C1_EV_IRQHandler         [WEAK]
+                EXPORT  I2C1_ER_IRQHandler         [WEAK]
+                EXPORT  SPI1_IRQHandler            [WEAK]
+                EXPORT  USART1_IRQHandler          [WEAK]
+                EXPORT  USART2_IRQHandler          [WEAK]
+                EXPORT  EXTI15_10_IRQHandler       [WEAK]
+                EXPORT  RTCAlarm_IRQHandler        [WEAK]
+                EXPORT  USBWakeUp_IRQHandler       [WEAK]
+
+WWDG_IRQHandler
+PVD_IRQHandler
+TAMPER_IRQHandler
+RTC_IRQHandler
+FLASH_IRQHandler
+RCC_IRQHandler
+EXTI0_IRQHandler
+EXTI1_IRQHandler
+EXTI2_IRQHandler
+EXTI3_IRQHandler
+EXTI4_IRQHandler
+DMA1_Channel1_IRQHandler
+DMA1_Channel2_IRQHandler
+DMA1_Channel3_IRQHandler
+DMA1_Channel4_IRQHandler
+DMA1_Channel5_IRQHandler
+DMA1_Channel6_IRQHandler
+DMA1_Channel7_IRQHandler
+ADC1_2_IRQHandler
+USB_HP_CAN1_TX_IRQHandler
+USB_LP_CAN1_RX0_IRQHandler
+CAN1_RX1_IRQHandler
+CAN1_SCE_IRQHandler
+EXTI9_5_IRQHandler
+TIM1_BRK_IRQHandler
+TIM1_UP_IRQHandler
+TIM1_TRG_COM_IRQHandler
+TIM1_CC_IRQHandler
+TIM2_IRQHandler
+TIM3_IRQHandler
+I2C1_EV_IRQHandler
+I2C1_ER_IRQHandler
+SPI1_IRQHandler
+USART1_IRQHandler
+USART2_IRQHandler
+EXTI15_10_IRQHandler
+RTCAlarm_IRQHandler
+USBWakeUp_IRQHandler
+
+                B       .
+
+                ENDP
+
+                ALIGN
+
+;*******************************************************************************
+; User Stack and Heap initialization
+;*******************************************************************************
+                 IF      :DEF:__MICROLIB
+
+                 EXPORT  __initial_sp
+                 EXPORT  __heap_base
+                 EXPORT  __heap_limit
+
+                 ELSE
+
+                 IMPORT  __use_two_region_memory
+                 EXPORT  __user_initial_stackheap
+
+__user_initial_stackheap
+
+                 LDR     R0, =  Heap_Mem
+                 LDR     R1, =(Stack_Mem + Stack_Size)
+                 LDR     R2, = (Heap_Mem +  Heap_Size)
+                 LDR     R3, = Stack_Mem
+                 BX      LR
+
+                 ALIGN
+
+                 ENDIF
+
+                 END
+
+;******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE*****
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_ld_vl.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_ld_vl.s
new file mode 100644
index 0000000..fe22fc0
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_ld_vl.s
@@ -0,0 +1,304 @@
+;******************** (C) COPYRIGHT 2011 STMicroelectronics ********************
+;* File Name          : startup_stm32f10x_ld_vl.s
+;* Author             : MCD Application Team
+;* Version            : V3.5.0
+;* Date               : 11-March-2011
+;* Description        : STM32F10x Low Density Value Line Devices vector table
+;*                      for MDK-ARM toolchain.
+;*                      This module performs:
+;*                      - Set the initial SP
+;*                      - Set the initial PC == Reset_Handler
+;*                      - Set the vector table entries with the exceptions ISR address
+;*                      - Configure the clock system
+;*                      - Branches to __main in the C library (which eventually
+;*                        calls main()).
+;*                      After Reset the CortexM3 processor is in Thread mode,
+;*                      priority is Privileged, and the Stack is set to Main.
+;* <<< Use Configuration Wizard in Context Menu >>>
+;*******************************************************************************
+; THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+; WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+; AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+; INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+; CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+; INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+;*******************************************************************************
+
+; Amount of memory (in bytes) allocated for Stack
+; Tailor this value to your application needs
+; <h> Stack Configuration
+;   <o> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8>
+; </h>
+
+Stack_Size      EQU     0x00000400
+
+                AREA    STACK, NOINIT, READWRITE, ALIGN=3
+Stack_Mem       SPACE   Stack_Size
+__initial_sp
+
+
+; <h> Heap Configuration
+;   <o>  Heap Size (in Bytes) <0x0-0xFFFFFFFF:8>
+; </h>
+
+Heap_Size       EQU     0x00000200
+
+                AREA    HEAP, NOINIT, READWRITE, ALIGN=3
+__heap_base
+Heap_Mem        SPACE   Heap_Size
+__heap_limit
+
+                PRESERVE8
+                THUMB
+
+
+; Vector Table Mapped to Address 0 at Reset
+                AREA    RESET, DATA, READONLY
+                EXPORT  __Vectors
+                EXPORT  __Vectors_End
+                EXPORT  __Vectors_Size
+
+__Vectors       DCD     __initial_sp                    ; Top of Stack
+                DCD     Reset_Handler                   ; Reset Handler
+                DCD     NMI_Handler                     ; NMI Handler
+                DCD     HardFault_Handler               ; Hard Fault Handler
+                DCD     MemManage_Handler               ; MPU Fault Handler
+                DCD     BusFault_Handler                ; Bus Fault Handler
+                DCD     UsageFault_Handler              ; Usage Fault Handler
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     SVC_Handler                     ; SVCall Handler
+                DCD     DebugMon_Handler                ; Debug Monitor Handler
+                DCD     0                               ; Reserved
+                DCD     PendSV_Handler                  ; PendSV Handler
+                DCD     SysTick_Handler                 ; SysTick Handler
+
+                ; External Interrupts
+                DCD     WWDG_IRQHandler                 ; Window Watchdog
+                DCD     PVD_IRQHandler                  ; PVD through EXTI Line detect
+                DCD     TAMPER_IRQHandler               ; Tamper
+                DCD     RTC_IRQHandler                  ; RTC
+                DCD     FLASH_IRQHandler                ; Flash
+                DCD     RCC_IRQHandler                  ; RCC
+                DCD     EXTI0_IRQHandler                ; EXTI Line 0
+                DCD     EXTI1_IRQHandler                ; EXTI Line 1
+                DCD     EXTI2_IRQHandler                ; EXTI Line 2
+                DCD     EXTI3_IRQHandler                ; EXTI Line 3
+                DCD     EXTI4_IRQHandler                ; EXTI Line 4
+                DCD     DMA1_Channel1_IRQHandler        ; DMA1 Channel 1
+                DCD     DMA1_Channel2_IRQHandler        ; DMA1 Channel 2
+                DCD     DMA1_Channel3_IRQHandler        ; DMA1 Channel 3
+                DCD     DMA1_Channel4_IRQHandler        ; DMA1 Channel 4
+                DCD     DMA1_Channel5_IRQHandler        ; DMA1 Channel 5
+                DCD     DMA1_Channel6_IRQHandler        ; DMA1 Channel 6
+                DCD     DMA1_Channel7_IRQHandler        ; DMA1 Channel 7
+                DCD     ADC1_IRQHandler                 ; ADC1
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     EXTI9_5_IRQHandler              ; EXTI Line 9..5
+                DCD     TIM1_BRK_TIM15_IRQHandler       ; TIM1 Break and TIM15
+                DCD     TIM1_UP_TIM16_IRQHandler        ; TIM1 Update and TIM16
+                DCD     TIM1_TRG_COM_TIM17_IRQHandler   ; TIM1 Trigger and Commutation and TIM17
+                DCD     TIM1_CC_IRQHandler              ; TIM1 Capture Compare
+                DCD     TIM2_IRQHandler                 ; TIM2
+                DCD     TIM3_IRQHandler                 ; TIM3
+                DCD     0                               ; Reserved
+                DCD     I2C1_EV_IRQHandler              ; I2C1 Event
+                DCD     I2C1_ER_IRQHandler              ; I2C1 Error
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     SPI1_IRQHandler                 ; SPI1
+                DCD     0                               ; Reserved
+                DCD     USART1_IRQHandler               ; USART1
+                DCD     USART2_IRQHandler               ; USART2
+                DCD     0                               ; Reserved
+                DCD     EXTI15_10_IRQHandler            ; EXTI Line 15..10
+                DCD     RTCAlarm_IRQHandler             ; RTC Alarm through EXTI Line
+                DCD     CEC_IRQHandler                  ; HDMI-CEC
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     TIM6_DAC_IRQHandler             ; TIM6 and DAC underrun
+                DCD     TIM7_IRQHandler                 ; TIM7
+__Vectors_End
+
+__Vectors_Size  EQU  __Vectors_End - __Vectors
+
+                AREA    |.text|, CODE, READONLY
+
+; Reset handler
+Reset_Handler    PROC
+                 EXPORT  Reset_Handler             [WEAK]
+     IMPORT  __main
+     IMPORT  SystemInit
+                 LDR     R0, =SystemInit
+                 BLX     R0
+                 LDR     R0, =__main
+                 BX      R0
+                 ENDP
+
+; Dummy Exception Handlers (infinite loops which can be modified)
+
+NMI_Handler     PROC
+                EXPORT  NMI_Handler                      [WEAK]
+                B       .
+                ENDP
+HardFault_Handler\
+                PROC
+                EXPORT  HardFault_Handler                [WEAK]
+                B       .
+                ENDP
+MemManage_Handler\
+                PROC
+                EXPORT  MemManage_Handler                [WEAK]
+                B       .
+                ENDP
+BusFault_Handler\
+                PROC
+                EXPORT  BusFault_Handler                 [WEAK]
+                B       .
+                ENDP
+UsageFault_Handler\
+                PROC
+                EXPORT  UsageFault_Handler               [WEAK]
+                B       .
+                ENDP
+SVC_Handler     PROC
+                EXPORT  SVC_Handler                      [WEAK]
+                B       .
+                ENDP
+DebugMon_Handler\
+                PROC
+                EXPORT  DebugMon_Handler                 [WEAK]
+                B       .
+                ENDP
+PendSV_Handler  PROC
+                EXPORT  PendSV_Handler                   [WEAK]
+                B       .
+                ENDP
+SysTick_Handler PROC
+                EXPORT  SysTick_Handler                  [WEAK]
+                B       .
+                ENDP
+
+Default_Handler PROC
+
+                EXPORT  WWDG_IRQHandler                  [WEAK]
+                EXPORT  PVD_IRQHandler                   [WEAK]
+                EXPORT  TAMPER_IRQHandler                [WEAK]
+                EXPORT  RTC_IRQHandler                   [WEAK]
+                EXPORT  FLASH_IRQHandler                 [WEAK]
+                EXPORT  RCC_IRQHandler                   [WEAK]
+                EXPORT  EXTI0_IRQHandler                 [WEAK]
+                EXPORT  EXTI1_IRQHandler                 [WEAK]
+                EXPORT  EXTI2_IRQHandler                 [WEAK]
+                EXPORT  EXTI3_IRQHandler                 [WEAK]
+                EXPORT  EXTI4_IRQHandler                 [WEAK]
+                EXPORT  DMA1_Channel1_IRQHandler         [WEAK]
+                EXPORT  DMA1_Channel2_IRQHandler         [WEAK]
+                EXPORT  DMA1_Channel3_IRQHandler         [WEAK]
+                EXPORT  DMA1_Channel4_IRQHandler         [WEAK]
+                EXPORT  DMA1_Channel5_IRQHandler         [WEAK]
+                EXPORT  DMA1_Channel6_IRQHandler         [WEAK]
+                EXPORT  DMA1_Channel7_IRQHandler         [WEAK]
+                EXPORT  ADC1_IRQHandler                  [WEAK]
+                EXPORT  EXTI9_5_IRQHandler               [WEAK]
+                EXPORT  TIM1_BRK_TIM15_IRQHandler        [WEAK]
+                EXPORT  TIM1_UP_TIM16_IRQHandler         [WEAK]
+                EXPORT  TIM1_TRG_COM_TIM17_IRQHandler    [WEAK]
+                EXPORT  TIM1_CC_IRQHandler               [WEAK]
+                EXPORT  TIM2_IRQHandler                  [WEAK]
+                EXPORT  TIM3_IRQHandler                  [WEAK]
+                EXPORT  I2C1_EV_IRQHandler               [WEAK]
+                EXPORT  I2C1_ER_IRQHandler               [WEAK]
+                EXPORT  SPI1_IRQHandler                  [WEAK]
+                EXPORT  USART1_IRQHandler                [WEAK]
+                EXPORT  USART2_IRQHandler                [WEAK]
+                EXPORT  EXTI15_10_IRQHandler             [WEAK]
+                EXPORT  RTCAlarm_IRQHandler              [WEAK]
+                EXPORT  CEC_IRQHandler                   [WEAK]
+                EXPORT  TIM6_DAC_IRQHandler              [WEAK]
+                EXPORT  TIM7_IRQHandler                  [WEAK]
+WWDG_IRQHandler
+PVD_IRQHandler
+TAMPER_IRQHandler
+RTC_IRQHandler
+FLASH_IRQHandler
+RCC_IRQHandler
+EXTI0_IRQHandler
+EXTI1_IRQHandler
+EXTI2_IRQHandler
+EXTI3_IRQHandler
+EXTI4_IRQHandler
+DMA1_Channel1_IRQHandler
+DMA1_Channel2_IRQHandler
+DMA1_Channel3_IRQHandler
+DMA1_Channel4_IRQHandler
+DMA1_Channel5_IRQHandler
+DMA1_Channel6_IRQHandler
+DMA1_Channel7_IRQHandler
+ADC1_IRQHandler
+EXTI9_5_IRQHandler
+TIM1_BRK_TIM15_IRQHandler
+TIM1_UP_TIM16_IRQHandler
+TIM1_TRG_COM_TIM17_IRQHandler
+TIM1_CC_IRQHandler
+TIM2_IRQHandler
+TIM3_IRQHandler
+I2C1_EV_IRQHandler
+I2C1_ER_IRQHandler
+SPI1_IRQHandler
+USART1_IRQHandler
+USART2_IRQHandler
+EXTI15_10_IRQHandler
+RTCAlarm_IRQHandler
+CEC_IRQHandler
+TIM6_DAC_IRQHandler
+TIM7_IRQHandler
+                B       .
+
+                ENDP
+
+                ALIGN
+
+;*******************************************************************************
+; User Stack and Heap initialization
+;*******************************************************************************
+                 IF      :DEF:__MICROLIB
+
+                 EXPORT  __initial_sp
+                 EXPORT  __heap_base
+                 EXPORT  __heap_limit
+
+                 ELSE
+
+                 IMPORT  __use_two_region_memory
+                 EXPORT  __user_initial_stackheap
+
+__user_initial_stackheap
+
+                 LDR     R0, =  Heap_Mem
+                 LDR     R1, =(Stack_Mem + Stack_Size)
+                 LDR     R2, = (Heap_Mem +  Heap_Size)
+                 LDR     R3, = Stack_Mem
+                 BX      LR
+
+                 ALIGN
+
+                 ENDIF
+
+                 END
+
+;******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE*****
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_md.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_md.s
new file mode 100644
index 0000000..3223fc9
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_md.s
@@ -0,0 +1,307 @@
+;******************** (C) COPYRIGHT 2011 STMicroelectronics ********************
+;* File Name          : startup_stm32f10x_md.s
+;* Author             : MCD Application Team
+;* Version            : V3.5.0
+;* Date               : 11-March-2011
+;* Description        : STM32F10x Medium Density Devices vector table for MDK-ARM
+;*                      toolchain.
+;*                      This module performs:
+;*                      - Set the initial SP
+;*                      - Set the initial PC == Reset_Handler
+;*                      - Set the vector table entries with the exceptions ISR address
+;*                      - Configure the clock system
+;*                      - Branches to __main in the C library (which eventually
+;*                        calls main()).
+;*                      After Reset the CortexM3 processor is in Thread mode,
+;*                      priority is Privileged, and the Stack is set to Main.
+;* <<< Use Configuration Wizard in Context Menu >>>
+;*******************************************************************************
+; THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+; WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+; AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+; INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+; CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+; INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+;*******************************************************************************
+
+; Amount of memory (in bytes) allocated for Stack
+; Tailor this value to your application needs
+; <h> Stack Configuration
+;   <o> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8>
+; </h>
+
+Stack_Size      EQU     0x00000400
+
+                AREA    STACK, NOINIT, READWRITE, ALIGN=3
+Stack_Mem       SPACE   Stack_Size
+__initial_sp
+
+
+; <h> Heap Configuration
+;   <o>  Heap Size (in Bytes) <0x0-0xFFFFFFFF:8>
+; </h>
+
+Heap_Size       EQU     0x00000200
+
+                AREA    HEAP, NOINIT, READWRITE, ALIGN=3
+__heap_base
+Heap_Mem        SPACE   Heap_Size
+__heap_limit
+
+                PRESERVE8
+                THUMB
+
+
+; Vector Table Mapped to Address 0 at Reset
+                AREA    RESET, DATA, READONLY
+                EXPORT  __Vectors
+                EXPORT  __Vectors_End
+                EXPORT  __Vectors_Size
+
+__Vectors       DCD     __initial_sp               ; Top of Stack
+                DCD     Reset_Handler              ; Reset Handler
+                DCD     NMI_Handler                ; NMI Handler
+                DCD     HardFault_Handler          ; Hard Fault Handler
+                DCD     MemManage_Handler          ; MPU Fault Handler
+                DCD     BusFault_Handler           ; Bus Fault Handler
+                DCD     UsageFault_Handler         ; Usage Fault Handler
+                DCD     0                          ; Reserved
+                DCD     0                          ; Reserved
+                DCD     0                          ; Reserved
+                DCD     0                          ; Reserved
+                DCD     SVC_Handler                ; SVCall Handler
+                DCD     DebugMon_Handler           ; Debug Monitor Handler
+                DCD     0                          ; Reserved
+                DCD     PendSV_Handler             ; PendSV Handler
+                DCD     SysTick_Handler            ; SysTick Handler
+
+                ; External Interrupts
+                DCD     WWDG_IRQHandler            ; Window Watchdog
+                DCD     PVD_IRQHandler             ; PVD through EXTI Line detect
+                DCD     TAMPER_IRQHandler          ; Tamper
+                DCD     RTC_IRQHandler             ; RTC
+                DCD     FLASH_IRQHandler           ; Flash
+                DCD     RCC_IRQHandler             ; RCC
+                DCD     EXTI0_IRQHandler           ; EXTI Line 0
+                DCD     EXTI1_IRQHandler           ; EXTI Line 1
+                DCD     EXTI2_IRQHandler           ; EXTI Line 2
+                DCD     EXTI3_IRQHandler           ; EXTI Line 3
+                DCD     EXTI4_IRQHandler           ; EXTI Line 4
+                DCD     DMA1_Channel1_IRQHandler   ; DMA1 Channel 1
+                DCD     DMA1_Channel2_IRQHandler   ; DMA1 Channel 2
+                DCD     DMA1_Channel3_IRQHandler   ; DMA1 Channel 3
+                DCD     DMA1_Channel4_IRQHandler   ; DMA1 Channel 4
+                DCD     DMA1_Channel5_IRQHandler   ; DMA1 Channel 5
+                DCD     DMA1_Channel6_IRQHandler   ; DMA1 Channel 6
+                DCD     DMA1_Channel7_IRQHandler   ; DMA1 Channel 7
+                DCD     ADC1_2_IRQHandler          ; ADC1_2
+                DCD     USB_HP_CAN1_TX_IRQHandler  ; USB High Priority or CAN1 TX
+                DCD     USB_LP_CAN1_RX0_IRQHandler ; USB Low  Priority or CAN1 RX0
+                DCD     CAN1_RX1_IRQHandler        ; CAN1 RX1
+                DCD     CAN1_SCE_IRQHandler        ; CAN1 SCE
+                DCD     EXTI9_5_IRQHandler         ; EXTI Line 9..5
+                DCD     TIM1_BRK_IRQHandler        ; TIM1 Break
+                DCD     TIM1_UP_IRQHandler         ; TIM1 Update
+                DCD     TIM1_TRG_COM_IRQHandler    ; TIM1 Trigger and Commutation
+                DCD     TIM1_CC_IRQHandler         ; TIM1 Capture Compare
+                DCD     TIM2_IRQHandler            ; TIM2
+                DCD     TIM3_IRQHandler            ; TIM3
+                DCD     TIM4_IRQHandler            ; TIM4
+                DCD     I2C1_EV_IRQHandler         ; I2C1 Event
+                DCD     I2C1_ER_IRQHandler         ; I2C1 Error
+                DCD     I2C2_EV_IRQHandler         ; I2C2 Event
+                DCD     I2C2_ER_IRQHandler         ; I2C2 Error
+                DCD     SPI1_IRQHandler            ; SPI1
+                DCD     SPI2_IRQHandler            ; SPI2
+                DCD     USART1_IRQHandler          ; USART1
+                DCD     USART2_IRQHandler          ; USART2
+                DCD     USART3_IRQHandler          ; USART3
+                DCD     EXTI15_10_IRQHandler       ; EXTI Line 15..10
+                DCD     RTCAlarm_IRQHandler        ; RTC Alarm through EXTI Line
+                DCD     USBWakeUp_IRQHandler       ; USB Wakeup from suspend
+__Vectors_End
+
+__Vectors_Size  EQU  __Vectors_End - __Vectors
+
+                AREA    |.text|, CODE, READONLY
+
+; Reset handler
+Reset_Handler    PROC
+                 EXPORT  Reset_Handler             [WEAK]
+     IMPORT  __main
+     IMPORT  SystemInit
+                 LDR     R0, =SystemInit
+                 BLX     R0
+                 LDR     R0, =__main
+                 BX      R0
+                 ENDP
+
+; Dummy Exception Handlers (infinite loops which can be modified)
+
+NMI_Handler     PROC
+                EXPORT  NMI_Handler                [WEAK]
+                B       .
+                ENDP
+HardFault_Handler\
+                PROC
+                EXPORT  HardFault_Handler          [WEAK]
+                B       .
+                ENDP
+MemManage_Handler\
+                PROC
+                EXPORT  MemManage_Handler          [WEAK]
+                B       .
+                ENDP
+BusFault_Handler\
+                PROC
+                EXPORT  BusFault_Handler           [WEAK]
+                B       .
+                ENDP
+UsageFault_Handler\
+                PROC
+                EXPORT  UsageFault_Handler         [WEAK]
+                B       .
+                ENDP
+SVC_Handler     PROC
+                EXPORT  SVC_Handler                [WEAK]
+                B       .
+                ENDP
+DebugMon_Handler\
+                PROC
+                EXPORT  DebugMon_Handler           [WEAK]
+                B       .
+                ENDP
+PendSV_Handler  PROC
+                EXPORT  PendSV_Handler             [WEAK]
+                B       .
+                ENDP
+SysTick_Handler PROC
+                EXPORT  SysTick_Handler            [WEAK]
+                B       .
+                ENDP
+
+Default_Handler PROC
+
+                EXPORT  WWDG_IRQHandler            [WEAK]
+                EXPORT  PVD_IRQHandler             [WEAK]
+                EXPORT  TAMPER_IRQHandler          [WEAK]
+                EXPORT  RTC_IRQHandler             [WEAK]
+                EXPORT  FLASH_IRQHandler           [WEAK]
+                EXPORT  RCC_IRQHandler             [WEAK]
+                EXPORT  EXTI0_IRQHandler           [WEAK]
+                EXPORT  EXTI1_IRQHandler           [WEAK]
+                EXPORT  EXTI2_IRQHandler           [WEAK]
+                EXPORT  EXTI3_IRQHandler           [WEAK]
+                EXPORT  EXTI4_IRQHandler           [WEAK]
+                EXPORT  DMA1_Channel1_IRQHandler   [WEAK]
+                EXPORT  DMA1_Channel2_IRQHandler   [WEAK]
+                EXPORT  DMA1_Channel3_IRQHandler   [WEAK]
+                EXPORT  DMA1_Channel4_IRQHandler   [WEAK]
+                EXPORT  DMA1_Channel5_IRQHandler   [WEAK]
+                EXPORT  DMA1_Channel6_IRQHandler   [WEAK]
+                EXPORT  DMA1_Channel7_IRQHandler   [WEAK]
+                EXPORT  ADC1_2_IRQHandler          [WEAK]
+                EXPORT  USB_HP_CAN1_TX_IRQHandler  [WEAK]
+                EXPORT  USB_LP_CAN1_RX0_IRQHandler [WEAK]
+                EXPORT  CAN1_RX1_IRQHandler        [WEAK]
+                EXPORT  CAN1_SCE_IRQHandler        [WEAK]
+                EXPORT  EXTI9_5_IRQHandler         [WEAK]
+                EXPORT  TIM1_BRK_IRQHandler        [WEAK]
+                EXPORT  TIM1_UP_IRQHandler         [WEAK]
+                EXPORT  TIM1_TRG_COM_IRQHandler    [WEAK]
+                EXPORT  TIM1_CC_IRQHandler         [WEAK]
+                EXPORT  TIM2_IRQHandler            [WEAK]
+                EXPORT  TIM3_IRQHandler            [WEAK]
+                EXPORT  TIM4_IRQHandler            [WEAK]
+                EXPORT  I2C1_EV_IRQHandler         [WEAK]
+                EXPORT  I2C1_ER_IRQHandler         [WEAK]
+                EXPORT  I2C2_EV_IRQHandler         [WEAK]
+                EXPORT  I2C2_ER_IRQHandler         [WEAK]
+                EXPORT  SPI1_IRQHandler            [WEAK]
+                EXPORT  SPI2_IRQHandler            [WEAK]
+                EXPORT  USART1_IRQHandler          [WEAK]
+                EXPORT  USART2_IRQHandler          [WEAK]
+                EXPORT  USART3_IRQHandler          [WEAK]
+                EXPORT  EXTI15_10_IRQHandler       [WEAK]
+                EXPORT  RTCAlarm_IRQHandler        [WEAK]
+                EXPORT  USBWakeUp_IRQHandler       [WEAK]
+
+WWDG_IRQHandler
+PVD_IRQHandler
+TAMPER_IRQHandler
+RTC_IRQHandler
+FLASH_IRQHandler
+RCC_IRQHandler
+EXTI0_IRQHandler
+EXTI1_IRQHandler
+EXTI2_IRQHandler
+EXTI3_IRQHandler
+EXTI4_IRQHandler
+DMA1_Channel1_IRQHandler
+DMA1_Channel2_IRQHandler
+DMA1_Channel3_IRQHandler
+DMA1_Channel4_IRQHandler
+DMA1_Channel5_IRQHandler
+DMA1_Channel6_IRQHandler
+DMA1_Channel7_IRQHandler
+ADC1_2_IRQHandler
+USB_HP_CAN1_TX_IRQHandler
+USB_LP_CAN1_RX0_IRQHandler
+CAN1_RX1_IRQHandler
+CAN1_SCE_IRQHandler
+EXTI9_5_IRQHandler
+TIM1_BRK_IRQHandler
+TIM1_UP_IRQHandler
+TIM1_TRG_COM_IRQHandler
+TIM1_CC_IRQHandler
+TIM2_IRQHandler
+TIM3_IRQHandler
+TIM4_IRQHandler
+I2C1_EV_IRQHandler
+I2C1_ER_IRQHandler
+I2C2_EV_IRQHandler
+I2C2_ER_IRQHandler
+SPI1_IRQHandler
+SPI2_IRQHandler
+USART1_IRQHandler
+USART2_IRQHandler
+USART3_IRQHandler
+EXTI15_10_IRQHandler
+RTCAlarm_IRQHandler
+USBWakeUp_IRQHandler
+
+                B       .
+
+                ENDP
+
+                ALIGN
+
+;*******************************************************************************
+; User Stack and Heap initialization
+;*******************************************************************************
+                 IF      :DEF:__MICROLIB
+
+                 EXPORT  __initial_sp
+                 EXPORT  __heap_base
+                 EXPORT  __heap_limit
+
+                 ELSE
+
+                 IMPORT  __use_two_region_memory
+                 EXPORT  __user_initial_stackheap
+
+__user_initial_stackheap
+
+                 LDR     R0, =  Heap_Mem
+                 LDR     R1, =(Stack_Mem + Stack_Size)
+                 LDR     R2, = (Heap_Mem +  Heap_Size)
+                 LDR     R3, = Stack_Mem
+                 BX      LR
+
+                 ALIGN
+
+                 ENDIF
+
+                 END
+
+;******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE*****
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_md_vl.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_md_vl.s
new file mode 100644
index 0000000..d3b8aa6
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_md_vl.s
@@ -0,0 +1,315 @@
+;******************** (C) COPYRIGHT 2011 STMicroelectronics ********************
+;* File Name          : startup_stm32f10x_md_vl.s
+;* Author             : MCD Application Team
+;* Version            : V3.5.0
+;* Date               : 11-March-2011
+;* Description        : STM32F10x Medium Density Value Line Devices vector table
+;*                      for MDK-ARM toolchain.
+;*                      This module performs:
+;*                      - Set the initial SP
+;*                      - Set the initial PC == Reset_Handler
+;*                      - Set the vector table entries with the exceptions ISR address
+;*                      - Configure the clock system
+;*                      - Branches to __main in the C library (which eventually
+;*                        calls main()).
+;*                      After Reset the CortexM3 processor is in Thread mode,
+;*                      priority is Privileged, and the Stack is set to Main.
+;* <<< Use Configuration Wizard in Context Menu >>>
+;*******************************************************************************
+; THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+; WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+; AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+; INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+; CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+; INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+;*******************************************************************************
+
+; Amount of memory (in bytes) allocated for Stack
+; Tailor this value to your application needs
+; <h> Stack Configuration
+;   <o> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8>
+; </h>
+
+Stack_Size      EQU     0x00000400
+
+                AREA    STACK, NOINIT, READWRITE, ALIGN=3
+Stack_Mem       SPACE   Stack_Size
+__initial_sp
+
+
+; <h> Heap Configuration
+;   <o>  Heap Size (in Bytes) <0x0-0xFFFFFFFF:8>
+; </h>
+
+Heap_Size       EQU     0x00000200
+
+                AREA    HEAP, NOINIT, READWRITE, ALIGN=3
+__heap_base
+Heap_Mem        SPACE   Heap_Size
+__heap_limit
+
+                PRESERVE8
+                THUMB
+
+
+; Vector Table Mapped to Address 0 at Reset
+                AREA    RESET, DATA, READONLY
+                EXPORT  __Vectors
+                EXPORT  __Vectors_End
+                EXPORT  __Vectors_Size
+
+__Vectors       DCD     __initial_sp                    ; Top of Stack
+                DCD     Reset_Handler                   ; Reset Handler
+                DCD     NMI_Handler                     ; NMI Handler
+                DCD     HardFault_Handler               ; Hard Fault Handler
+                DCD     MemManage_Handler               ; MPU Fault Handler
+                DCD     BusFault_Handler                ; Bus Fault Handler
+                DCD     UsageFault_Handler              ; Usage Fault Handler
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     SVC_Handler                     ; SVCall Handler
+                DCD     DebugMon_Handler                ; Debug Monitor Handler
+                DCD     0                               ; Reserved
+                DCD     PendSV_Handler                  ; PendSV Handler
+                DCD     SysTick_Handler                 ; SysTick Handler
+
+                ; External Interrupts
+                DCD     WWDG_IRQHandler                 ; Window Watchdog
+                DCD     PVD_IRQHandler                  ; PVD through EXTI Line detect
+                DCD     TAMPER_IRQHandler               ; Tamper
+                DCD     RTC_IRQHandler                  ; RTC
+                DCD     FLASH_IRQHandler                ; Flash
+                DCD     RCC_IRQHandler                  ; RCC
+                DCD     EXTI0_IRQHandler                ; EXTI Line 0
+                DCD     EXTI1_IRQHandler                ; EXTI Line 1
+                DCD     EXTI2_IRQHandler                ; EXTI Line 2
+                DCD     EXTI3_IRQHandler                ; EXTI Line 3
+                DCD     EXTI4_IRQHandler                ; EXTI Line 4
+                DCD     DMA1_Channel1_IRQHandler        ; DMA1 Channel 1
+                DCD     DMA1_Channel2_IRQHandler        ; DMA1 Channel 2
+                DCD     DMA1_Channel3_IRQHandler        ; DMA1 Channel 3
+                DCD     DMA1_Channel4_IRQHandler        ; DMA1 Channel 4
+                DCD     DMA1_Channel5_IRQHandler        ; DMA1 Channel 5
+                DCD     DMA1_Channel6_IRQHandler        ; DMA1 Channel 6
+                DCD     DMA1_Channel7_IRQHandler        ; DMA1 Channel 7
+                DCD     ADC1_IRQHandler                 ; ADC1
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     EXTI9_5_IRQHandler              ; EXTI Line 9..5
+                DCD     TIM1_BRK_TIM15_IRQHandler       ; TIM1 Break and TIM15
+                DCD     TIM1_UP_TIM16_IRQHandler        ; TIM1 Update and TIM16
+                DCD     TIM1_TRG_COM_TIM17_IRQHandler   ; TIM1 Trigger and Commutation and TIM17
+                DCD     TIM1_CC_IRQHandler              ; TIM1 Capture Compare
+                DCD     TIM2_IRQHandler                 ; TIM2
+                DCD     TIM3_IRQHandler                 ; TIM3
+                DCD     TIM4_IRQHandler                 ; TIM4
+                DCD     I2C1_EV_IRQHandler              ; I2C1 Event
+                DCD     I2C1_ER_IRQHandler              ; I2C1 Error
+                DCD     I2C2_EV_IRQHandler              ; I2C2 Event
+                DCD     I2C2_ER_IRQHandler              ; I2C2 Error
+                DCD     SPI1_IRQHandler                 ; SPI1
+                DCD     SPI2_IRQHandler                 ; SPI2
+                DCD     USART1_IRQHandler               ; USART1
+                DCD     USART2_IRQHandler               ; USART2
+                DCD     USART3_IRQHandler               ; USART3
+                DCD     EXTI15_10_IRQHandler            ; EXTI Line 15..10
+                DCD     RTCAlarm_IRQHandler             ; RTC Alarm through EXTI Line
+                DCD     CEC_IRQHandler                  ; HDMI-CEC
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     0                               ; Reserved
+                DCD     TIM6_DAC_IRQHandler             ; TIM6 and DAC underrun
+                DCD     TIM7_IRQHandler                 ; TIM7
+__Vectors_End
+
+__Vectors_Size  EQU  __Vectors_End - __Vectors
+
+                AREA    |.text|, CODE, READONLY
+
+; Reset handler
+Reset_Handler    PROC
+                 EXPORT  Reset_Handler             [WEAK]
+     IMPORT  __main
+     IMPORT  SystemInit
+                 LDR     R0, =SystemInit
+                 BLX     R0
+                 LDR     R0, =__main
+                 BX      R0
+                 ENDP
+
+; Dummy Exception Handlers (infinite loops which can be modified)
+
+NMI_Handler     PROC
+                EXPORT  NMI_Handler                      [WEAK]
+                B       .
+                ENDP
+HardFault_Handler\
+                PROC
+                EXPORT  HardFault_Handler                [WEAK]
+                B       .
+                ENDP
+MemManage_Handler\
+                PROC
+                EXPORT  MemManage_Handler                [WEAK]
+                B       .
+                ENDP
+BusFault_Handler\
+                PROC
+                EXPORT  BusFault_Handler                 [WEAK]
+                B       .
+                ENDP
+UsageFault_Handler\
+                PROC
+                EXPORT  UsageFault_Handler               [WEAK]
+                B       .
+                ENDP
+SVC_Handler     PROC
+                EXPORT  SVC_Handler                      [WEAK]
+                B       .
+                ENDP
+DebugMon_Handler\
+                PROC
+                EXPORT  DebugMon_Handler                 [WEAK]
+                B       .
+                ENDP
+PendSV_Handler  PROC
+                EXPORT  PendSV_Handler                   [WEAK]
+                B       .
+                ENDP
+SysTick_Handler PROC
+                EXPORT  SysTick_Handler                  [WEAK]
+                B       .
+                ENDP
+
+Default_Handler PROC
+
+                EXPORT  WWDG_IRQHandler                  [WEAK]
+                EXPORT  PVD_IRQHandler                   [WEAK]
+                EXPORT  TAMPER_IRQHandler                [WEAK]
+                EXPORT  RTC_IRQHandler                   [WEAK]
+                EXPORT  FLASH_IRQHandler                 [WEAK]
+                EXPORT  RCC_IRQHandler                   [WEAK]
+                EXPORT  EXTI0_IRQHandler                 [WEAK]
+                EXPORT  EXTI1_IRQHandler                 [WEAK]
+                EXPORT  EXTI2_IRQHandler                 [WEAK]
+                EXPORT  EXTI3_IRQHandler                 [WEAK]
+                EXPORT  EXTI4_IRQHandler                 [WEAK]
+                EXPORT  DMA1_Channel1_IRQHandler         [WEAK]
+                EXPORT  DMA1_Channel2_IRQHandler         [WEAK]
+                EXPORT  DMA1_Channel3_IRQHandler         [WEAK]
+                EXPORT  DMA1_Channel4_IRQHandler         [WEAK]
+                EXPORT  DMA1_Channel5_IRQHandler         [WEAK]
+                EXPORT  DMA1_Channel6_IRQHandler         [WEAK]
+                EXPORT  DMA1_Channel7_IRQHandler         [WEAK]
+                EXPORT  ADC1_IRQHandler                  [WEAK]
+                EXPORT  EXTI9_5_IRQHandler               [WEAK]
+                EXPORT  TIM1_BRK_TIM15_IRQHandler        [WEAK]
+                EXPORT  TIM1_UP_TIM16_IRQHandler         [WEAK]
+                EXPORT  TIM1_TRG_COM_TIM17_IRQHandler    [WEAK]
+                EXPORT  TIM1_CC_IRQHandler               [WEAK]
+                EXPORT  TIM2_IRQHandler                  [WEAK]
+                EXPORT  TIM3_IRQHandler                  [WEAK]
+                EXPORT  TIM4_IRQHandler                  [WEAK]
+                EXPORT  I2C1_EV_IRQHandler               [WEAK]
+                EXPORT  I2C1_ER_IRQHandler               [WEAK]
+                EXPORT  I2C2_EV_IRQHandler               [WEAK]
+                EXPORT  I2C2_ER_IRQHandler               [WEAK]
+                EXPORT  SPI1_IRQHandler                  [WEAK]
+                EXPORT  SPI2_IRQHandler                  [WEAK]
+                EXPORT  USART1_IRQHandler                [WEAK]
+                EXPORT  USART2_IRQHandler                [WEAK]
+                EXPORT  USART3_IRQHandler                [WEAK]
+                EXPORT  EXTI15_10_IRQHandler             [WEAK]
+                EXPORT  RTCAlarm_IRQHandler              [WEAK]
+                EXPORT  CEC_IRQHandler                   [WEAK]
+                EXPORT  TIM6_DAC_IRQHandler              [WEAK]
+                EXPORT  TIM7_IRQHandler                  [WEAK]
+
+WWDG_IRQHandler
+PVD_IRQHandler
+TAMPER_IRQHandler
+RTC_IRQHandler
+FLASH_IRQHandler
+RCC_IRQHandler
+EXTI0_IRQHandler
+EXTI1_IRQHandler
+EXTI2_IRQHandler
+EXTI3_IRQHandler
+EXTI4_IRQHandler
+DMA1_Channel1_IRQHandler
+DMA1_Channel2_IRQHandler
+DMA1_Channel3_IRQHandler
+DMA1_Channel4_IRQHandler
+DMA1_Channel5_IRQHandler
+DMA1_Channel6_IRQHandler
+DMA1_Channel7_IRQHandler
+ADC1_IRQHandler
+EXTI9_5_IRQHandler
+TIM1_BRK_TIM15_IRQHandler
+TIM1_UP_TIM16_IRQHandler
+TIM1_TRG_COM_TIM17_IRQHandler
+TIM1_CC_IRQHandler
+TIM2_IRQHandler
+TIM3_IRQHandler
+TIM4_IRQHandler
+I2C1_EV_IRQHandler
+I2C1_ER_IRQHandler
+I2C2_EV_IRQHandler
+I2C2_ER_IRQHandler
+SPI1_IRQHandler
+SPI2_IRQHandler
+USART1_IRQHandler
+USART2_IRQHandler
+USART3_IRQHandler
+EXTI15_10_IRQHandler
+RTCAlarm_IRQHandler
+CEC_IRQHandler
+TIM6_DAC_IRQHandler
+TIM7_IRQHandler
+                B       .
+
+                ENDP
+
+                ALIGN
+
+;*******************************************************************************
+; User Stack and Heap initialization
+;*******************************************************************************
+                 IF      :DEF:__MICROLIB
+
+                 EXPORT  __initial_sp
+                 EXPORT  __heap_base
+                 EXPORT  __heap_limit
+
+                 ELSE
+
+                 IMPORT  __use_two_region_memory
+                 EXPORT  __user_initial_stackheap
+
+__user_initial_stackheap
+
+                 LDR     R0, =  Heap_Mem
+                 LDR     R1, =(Stack_Mem + Stack_Size)
+                 LDR     R2, = (Heap_Mem +  Heap_Size)
+                 LDR     R3, = Stack_Mem
+                 BX      LR
+
+                 ALIGN
+
+                 ENDIF
+
+                 END
+
+;******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE*****
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_xl.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_xl.s
new file mode 100644
index 0000000..7970052
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup_stm32f10x_xl.s
@@ -0,0 +1,358 @@
+;******************** (C) COPYRIGHT 2011 STMicroelectronics ********************
+;* File Name          : startup_stm32f10x_xl.s
+;* Author             : MCD Application Team
+;* Version            : V3.5.0
+;* Date               : 11-March-2011
+;* Description        : STM32F10x XL-Density Devices vector table for MDK-ARM
+;*                      toolchain.
+;*                      This module performs:
+;*                      - Set the initial SP
+;*                      - Set the initial PC == Reset_Handler
+;*                      - Set the vector table entries with the exceptions ISR address
+;*                      - Configure the clock system and also configure the external
+;*                        SRAM mounted on STM3210E-EVAL board to be used as data
+;*                        memory (optional, to be enabled by user)
+;*                      - Branches to __main in the C library (which eventually
+;*                        calls main()).
+;*                      After Reset the CortexM3 processor is in Thread mode,
+;*                      priority is Privileged, and the Stack is set to Main.
+;* <<< Use Configuration Wizard in Context Menu >>>
+;*******************************************************************************
+; THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+; WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+; AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+; INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+; CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+; INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+;*******************************************************************************
+
+; Amount of memory (in bytes) allocated for Stack
+; Tailor this value to your application needs
+; <h> Stack Configuration
+;   <o> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8>
+; </h>
+
+Stack_Size      EQU     0x00000400
+
+                AREA    STACK, NOINIT, READWRITE, ALIGN=3
+Stack_Mem       SPACE   Stack_Size
+__initial_sp
+
+; <h> Heap Configuration
+;   <o>  Heap Size (in Bytes) <0x0-0xFFFFFFFF:8>
+; </h>
+
+Heap_Size       EQU     0x00000200
+
+                AREA    HEAP, NOINIT, READWRITE, ALIGN=3
+__heap_base
+Heap_Mem        SPACE   Heap_Size
+__heap_limit
+
+                PRESERVE8
+                THUMB
+
+
+; Vector Table Mapped to Address 0 at Reset
+                AREA    RESET, DATA, READONLY
+                EXPORT  __Vectors
+                EXPORT  __Vectors_End
+                EXPORT  __Vectors_Size
+
+__Vectors       DCD     __initial_sp               ; Top of Stack
+                DCD     Reset_Handler              ; Reset Handler
+                DCD     NMI_Handler                ; NMI Handler
+                DCD     HardFault_Handler          ; Hard Fault Handler
+                DCD     MemManage_Handler          ; MPU Fault Handler
+                DCD     BusFault_Handler           ; Bus Fault Handler
+                DCD     UsageFault_Handler         ; Usage Fault Handler
+                DCD     0                          ; Reserved
+                DCD     0                          ; Reserved
+                DCD     0                          ; Reserved
+                DCD     0                          ; Reserved
+                DCD     SVC_Handler                ; SVCall Handler
+                DCD     DebugMon_Handler           ; Debug Monitor Handler
+                DCD     0                          ; Reserved
+                DCD     PendSV_Handler             ; PendSV Handler
+                DCD     SysTick_Handler            ; SysTick Handler
+
+                ; External Interrupts
+                DCD     WWDG_IRQHandler               ; Window Watchdog
+                DCD     PVD_IRQHandler                ; PVD through EXTI Line detect
+                DCD     TAMPER_IRQHandler             ; Tamper
+                DCD     RTC_IRQHandler                ; RTC
+                DCD     FLASH_IRQHandler              ; Flash
+                DCD     RCC_IRQHandler                ; RCC
+                DCD     EXTI0_IRQHandler              ; EXTI Line 0
+                DCD     EXTI1_IRQHandler              ; EXTI Line 1
+                DCD     EXTI2_IRQHandler              ; EXTI Line 2
+                DCD     EXTI3_IRQHandler              ; EXTI Line 3
+                DCD     EXTI4_IRQHandler              ; EXTI Line 4
+                DCD     DMA1_Channel1_IRQHandler      ; DMA1 Channel 1
+                DCD     DMA1_Channel2_IRQHandler      ; DMA1 Channel 2
+                DCD     DMA1_Channel3_IRQHandler      ; DMA1 Channel 3
+                DCD     DMA1_Channel4_IRQHandler      ; DMA1 Channel 4
+                DCD     DMA1_Channel5_IRQHandler      ; DMA1 Channel 5
+                DCD     DMA1_Channel6_IRQHandler      ; DMA1 Channel 6
+                DCD     DMA1_Channel7_IRQHandler      ; DMA1 Channel 7
+                DCD     ADC1_2_IRQHandler             ; ADC1 & ADC2
+                DCD     USB_HP_CAN1_TX_IRQHandler     ; USB High Priority or CAN1 TX
+                DCD     USB_LP_CAN1_RX0_IRQHandler    ; USB Low  Priority or CAN1 RX0
+                DCD     CAN1_RX1_IRQHandler           ; CAN1 RX1
+                DCD     CAN1_SCE_IRQHandler           ; CAN1 SCE
+                DCD     EXTI9_5_IRQHandler            ; EXTI Line 9..5
+                DCD     TIM1_BRK_TIM9_IRQHandler      ; TIM1 Break and TIM9
+                DCD     TIM1_UP_TIM10_IRQHandler      ; TIM1 Update and TIM10
+                DCD     TIM1_TRG_COM_TIM11_IRQHandler ; TIM1 Trigger and Commutation and TIM11
+                DCD     TIM1_CC_IRQHandler            ; TIM1 Capture Compare
+                DCD     TIM2_IRQHandler               ; TIM2
+                DCD     TIM3_IRQHandler               ; TIM3
+                DCD     TIM4_IRQHandler               ; TIM4
+                DCD     I2C1_EV_IRQHandler            ; I2C1 Event
+                DCD     I2C1_ER_IRQHandler            ; I2C1 Error
+                DCD     I2C2_EV_IRQHandler            ; I2C2 Event
+                DCD     I2C2_ER_IRQHandler            ; I2C2 Error
+                DCD     SPI1_IRQHandler               ; SPI1
+                DCD     SPI2_IRQHandler               ; SPI2
+                DCD     USART1_IRQHandler             ; USART1
+                DCD     USART2_IRQHandler             ; USART2
+                DCD     USART3_IRQHandler             ; USART3
+                DCD     EXTI15_10_IRQHandler          ; EXTI Line 15..10
+                DCD     RTCAlarm_IRQHandler           ; RTC Alarm through EXTI Line
+                DCD     USBWakeUp_IRQHandler          ; USB Wakeup from suspend
+                DCD     TIM8_BRK_TIM12_IRQHandler     ; TIM8 Break and TIM12
+                DCD     TIM8_UP_TIM13_IRQHandler      ; TIM8 Update and TIM13
+                DCD     TIM8_TRG_COM_TIM14_IRQHandler ; TIM8 Trigger and Commutation and TIM14
+                DCD     TIM8_CC_IRQHandler            ; TIM8 Capture Compare
+                DCD     ADC3_IRQHandler               ; ADC3
+                DCD     FSMC_IRQHandler               ; FSMC
+                DCD     SDIO_IRQHandler               ; SDIO
+                DCD     TIM5_IRQHandler               ; TIM5
+                DCD     SPI3_IRQHandler               ; SPI3
+                DCD     UART4_IRQHandler              ; UART4
+                DCD     UART5_IRQHandler              ; UART5
+                DCD     TIM6_IRQHandler               ; TIM6
+                DCD     TIM7_IRQHandler               ; TIM7
+                DCD     DMA2_Channel1_IRQHandler      ; DMA2 Channel1
+                DCD     DMA2_Channel2_IRQHandler      ; DMA2 Channel2
+                DCD     DMA2_Channel3_IRQHandler      ; DMA2 Channel3
+                DCD     DMA2_Channel4_5_IRQHandler    ; DMA2 Channel4 & Channel5
+__Vectors_End
+
+__Vectors_Size  EQU  __Vectors_End - __Vectors
+
+                AREA    |.text|, CODE, READONLY
+
+; Reset handler
+Reset_Handler   PROC
+                EXPORT  Reset_Handler             [WEAK]
+                IMPORT  __main
+                IMPORT  SystemInit
+                LDR     R0, =SystemInit
+                BLX     R0
+                LDR     R0, =__main
+                BX      R0
+                ENDP
+
+; Dummy Exception Handlers (infinite loops which can be modified)
+
+NMI_Handler     PROC
+                EXPORT  NMI_Handler                [WEAK]
+                B       .
+                ENDP
+HardFault_Handler\
+                PROC
+                EXPORT  HardFault_Handler          [WEAK]
+                B       .
+                ENDP
+MemManage_Handler\
+                PROC
+                EXPORT  MemManage_Handler          [WEAK]
+                B       .
+                ENDP
+BusFault_Handler\
+                PROC
+                EXPORT  BusFault_Handler           [WEAK]
+                B       .
+                ENDP
+UsageFault_Handler\
+                PROC
+                EXPORT  UsageFault_Handler         [WEAK]
+                B       .
+                ENDP
+SVC_Handler     PROC
+                EXPORT  SVC_Handler                [WEAK]
+                B       .
+                ENDP
+DebugMon_Handler\
+                PROC
+                EXPORT  DebugMon_Handler           [WEAK]
+                B       .
+                ENDP
+PendSV_Handler  PROC
+                EXPORT  PendSV_Handler             [WEAK]
+                B       .
+                ENDP
+SysTick_Handler PROC
+                EXPORT  SysTick_Handler            [WEAK]
+                B       .
+                ENDP
+
+Default_Handler PROC
+
+                EXPORT  WWDG_IRQHandler               [WEAK]
+                EXPORT  PVD_IRQHandler                [WEAK]
+                EXPORT  TAMPER_IRQHandler             [WEAK]
+                EXPORT  RTC_IRQHandler                [WEAK]
+                EXPORT  FLASH_IRQHandler              [WEAK]
+                EXPORT  RCC_IRQHandler                [WEAK]
+                EXPORT  EXTI0_IRQHandler              [WEAK]
+                EXPORT  EXTI1_IRQHandler              [WEAK]
+                EXPORT  EXTI2_IRQHandler              [WEAK]
+                EXPORT  EXTI3_IRQHandler              [WEAK]
+                EXPORT  EXTI4_IRQHandler              [WEAK]
+                EXPORT  DMA1_Channel1_IRQHandler      [WEAK]
+                EXPORT  DMA1_Channel2_IRQHandler      [WEAK]
+                EXPORT  DMA1_Channel3_IRQHandler      [WEAK]
+                EXPORT  DMA1_Channel4_IRQHandler      [WEAK]
+                EXPORT  DMA1_Channel5_IRQHandler      [WEAK]
+                EXPORT  DMA1_Channel6_IRQHandler      [WEAK]
+                EXPORT  DMA1_Channel7_IRQHandler      [WEAK]
+                EXPORT  ADC1_2_IRQHandler             [WEAK]
+                EXPORT  USB_HP_CAN1_TX_IRQHandler     [WEAK]
+                EXPORT  USB_LP_CAN1_RX0_IRQHandler    [WEAK]
+                EXPORT  CAN1_RX1_IRQHandler           [WEAK]
+                EXPORT  CAN1_SCE_IRQHandler           [WEAK]
+                EXPORT  EXTI9_5_IRQHandler            [WEAK]
+                EXPORT  TIM1_BRK_TIM9_IRQHandler      [WEAK]
+                EXPORT  TIM1_UP_TIM10_IRQHandler      [WEAK]
+                EXPORT  TIM1_TRG_COM_TIM11_IRQHandler [WEAK]
+                EXPORT  TIM1_CC_IRQHandler            [WEAK]
+                EXPORT  TIM2_IRQHandler               [WEAK]
+                EXPORT  TIM3_IRQHandler               [WEAK]
+                EXPORT  TIM4_IRQHandler               [WEAK]
+                EXPORT  I2C1_EV_IRQHandler            [WEAK]
+                EXPORT  I2C1_ER_IRQHandler            [WEAK]
+                EXPORT  I2C2_EV_IRQHandler            [WEAK]
+                EXPORT  I2C2_ER_IRQHandler            [WEAK]
+                EXPORT  SPI1_IRQHandler               [WEAK]
+                EXPORT  SPI2_IRQHandler               [WEAK]
+                EXPORT  USART1_IRQHandler             [WEAK]
+                EXPORT  USART2_IRQHandler             [WEAK]
+                EXPORT  USART3_IRQHandler             [WEAK]
+                EXPORT  EXTI15_10_IRQHandler          [WEAK]
+                EXPORT  RTCAlarm_IRQHandler           [WEAK]
+                EXPORT  USBWakeUp_IRQHandler          [WEAK]
+                EXPORT  TIM8_BRK_TIM12_IRQHandler     [WEAK]
+                EXPORT  TIM8_UP_TIM13_IRQHandler      [WEAK]
+                EXPORT  TIM8_TRG_COM_TIM14_IRQHandler [WEAK]
+                EXPORT  TIM8_CC_IRQHandler            [WEAK]
+                EXPORT  ADC3_IRQHandler               [WEAK]
+                EXPORT  FSMC_IRQHandler               [WEAK]
+                EXPORT  SDIO_IRQHandler               [WEAK]
+                EXPORT  TIM5_IRQHandler               [WEAK]
+                EXPORT  SPI3_IRQHandler               [WEAK]
+                EXPORT  UART4_IRQHandler              [WEAK]
+                EXPORT  UART5_IRQHandler              [WEAK]
+                EXPORT  TIM6_IRQHandler               [WEAK]
+                EXPORT  TIM7_IRQHandler               [WEAK]
+                EXPORT  DMA2_Channel1_IRQHandler      [WEAK]
+                EXPORT  DMA2_Channel2_IRQHandler      [WEAK]
+                EXPORT  DMA2_Channel3_IRQHandler      [WEAK]
+                EXPORT  DMA2_Channel4_5_IRQHandler    [WEAK]
+
+WWDG_IRQHandler
+PVD_IRQHandler
+TAMPER_IRQHandler
+RTC_IRQHandler
+FLASH_IRQHandler
+RCC_IRQHandler
+EXTI0_IRQHandler
+EXTI1_IRQHandler
+EXTI2_IRQHandler
+EXTI3_IRQHandler
+EXTI4_IRQHandler
+DMA1_Channel1_IRQHandler
+DMA1_Channel2_IRQHandler
+DMA1_Channel3_IRQHandler
+DMA1_Channel4_IRQHandler
+DMA1_Channel5_IRQHandler
+DMA1_Channel6_IRQHandler
+DMA1_Channel7_IRQHandler
+ADC1_2_IRQHandler
+USB_HP_CAN1_TX_IRQHandler
+USB_LP_CAN1_RX0_IRQHandler
+CAN1_RX1_IRQHandler
+CAN1_SCE_IRQHandler
+EXTI9_5_IRQHandler
+TIM1_BRK_TIM9_IRQHandler
+TIM1_UP_TIM10_IRQHandler
+TIM1_TRG_COM_TIM11_IRQHandler
+TIM1_CC_IRQHandler
+TIM2_IRQHandler
+TIM3_IRQHandler
+TIM4_IRQHandler
+I2C1_EV_IRQHandler
+I2C1_ER_IRQHandler
+I2C2_EV_IRQHandler
+I2C2_ER_IRQHandler
+SPI1_IRQHandler
+SPI2_IRQHandler
+USART1_IRQHandler
+USART2_IRQHandler
+USART3_IRQHandler
+EXTI15_10_IRQHandler
+RTCAlarm_IRQHandler
+USBWakeUp_IRQHandler
+TIM8_BRK_TIM12_IRQHandler
+TIM8_UP_TIM13_IRQHandler
+TIM8_TRG_COM_TIM14_IRQHandler
+TIM8_CC_IRQHandler
+ADC3_IRQHandler
+FSMC_IRQHandler
+SDIO_IRQHandler
+TIM5_IRQHandler
+SPI3_IRQHandler
+UART4_IRQHandler
+UART5_IRQHandler
+TIM6_IRQHandler
+TIM7_IRQHandler
+DMA2_Channel1_IRQHandler
+DMA2_Channel2_IRQHandler
+DMA2_Channel3_IRQHandler
+DMA2_Channel4_5_IRQHandler
+                B       .
+
+                ENDP
+
+                ALIGN
+
+;*******************************************************************************
+; User Stack and Heap initialization
+;*******************************************************************************
+                 IF      :DEF:__MICROLIB
+
+                 EXPORT  __initial_sp
+                 EXPORT  __heap_base
+                 EXPORT  __heap_limit
+
+                 ELSE
+
+                 IMPORT  __use_two_region_memory
+                 EXPORT  __user_initial_stackheap
+
+__user_initial_stackheap
+
+                 LDR     R0, =  Heap_Mem
+                 LDR     R1, =(Stack_Mem + Stack_Size)
+                 LDR     R2, = (Heap_Mem +  Heap_Size)
+                 LDR     R3, = Stack_Mem
+                 BX      LR
+
+                 ALIGN
+
+                 ENDIF
+
+                 END
+
+;******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE*****
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_cl.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_cl.s
new file mode 100644
index 0000000..039ec06
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_cl.s
@@ -0,0 +1,468 @@
+/**
+  ******************************************************************************
+  * @file      startup_stm32f10x_cl.s
+  * @author    MCD Application Team
+  * @version   V3.5.0
+  * @date      11-March-2011
+  * @brief     STM32F10x Connectivity line Devices vector table for RIDE7 toolchain.
+  *            This module performs:
+  *                - Set the initial SP
+  *                - Set the initial PC == Reset_Handler,
+  *                - Set the vector table entries with the exceptions ISR
+  *                  address.
+  *                - Configure the clock system
+  *                - Branches to main in the C library (which eventually
+  *                  calls main()).
+  *            After Reset the Cortex-M3 processor is in Thread mode,
+  *            priority is Privileged, and the Stack is set to Main.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+  .syntax unified
+  .cpu cortex-m3
+  .fpu softvfp
+  .thumb
+
+.global  g_pfnVectors
+.global  Default_Handler
+
+/* start address for the initialization values of the .data section.
+defined in linker script */
+.word  _sidata
+/* start address for the .data section. defined in linker script */
+.word  _sdata
+/* end address for the .data section. defined in linker script */
+.word  _edata
+/* start address for the .bss section. defined in linker script */
+.word  _sbss
+/* end address for the .bss section. defined in linker script */
+.word  _ebss
+
+.equ  BootRAM, 0xF1E0F85F
+/**
+ * @brief  This is the code that gets called when the processor first
+ *          starts execution following a reset event. Only the absolutely
+ *          necessary set is performed, after which the application
+ *          supplied main() routine is called.
+ * @param  None
+ * @retval : None
+*/
+
+    .section  .text.Reset_Handler
+  .weak  Reset_Handler
+  .type  Reset_Handler, %function
+Reset_Handler:
+
+/* Copy the data segment initializers from flash to SRAM */
+  movs  r1, #0
+  b     LoopCopyDataInit
+
+CopyDataInit:
+  ldr   r3, =_sidata
+  ldr   r3, [r3, r1]
+  str   r3, [r0, r1]
+  adds  r1, r1, #4
+
+LoopCopyDataInit:
+  ldr   r0, =_sdata
+  ldr   r3, =_edata
+  adds  r2, r0, r1
+  cmp   r2, r3
+  bcc   CopyDataInit
+  ldr   r2, =_sbss
+  b     LoopFillZerobss
+
+/* Zero fill the bss segment. */
+FillZerobss:
+  movs  r3, #0
+  str   r3, [r2], #4
+
+LoopFillZerobss:
+  ldr   r3, = _ebss
+  cmp   r2, r3
+  bcc   FillZerobss
+/* Call the clock system intitialization function.*/
+  bl  SystemInit
+/* Call the application's entry point.*/
+  bl    main
+  bx    lr
+.size   Reset_Handler, .-Reset_Handler
+
+/**
+ * @brief  This is the code that gets called when the processor receives an
+ *         unexpected interrupt. This simply enters an infinite loop, preserving
+ *         the system state for examination by a debugger.
+ * @param  None
+ * @retval None
+*/
+    .section  .text.Default_Handler,"ax",%progbits
+Default_Handler:
+Infinite_Loop:
+  b  Infinite_Loop
+  .size  Default_Handler, .-Default_Handler
+
+/******************************************************************************
+*
+* The minimal vector table for a Cortex M3. Note that the proper constructs
+* must be placed on this to ensure that it ends up at physical address
+* 0x0000.0000.
+*
+*******************************************************************************/
+  .section  .isr_vector,"a",%progbits
+  .type  g_pfnVectors, %object
+  .size  g_pfnVectors, .-g_pfnVectors
+
+
+g_pfnVectors:
+  .word  _estack
+  .word  Reset_Handler
+  .word  NMI_Handler
+  .word  HardFault_Handler
+  .word  MemManage_Handler
+  .word  BusFault_Handler
+  .word  UsageFault_Handler
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  SVC_Handler
+  .word  DebugMon_Handler
+  .word  0
+  .word  PendSV_Handler
+  .word  SysTick_Handler
+  .word  WWDG_IRQHandler
+  .word  PVD_IRQHandler
+  .word  TAMPER_IRQHandler
+  .word  RTC_IRQHandler
+  .word  FLASH_IRQHandler
+  .word  RCC_IRQHandler
+  .word  EXTI0_IRQHandler
+  .word  EXTI1_IRQHandler
+  .word  EXTI2_IRQHandler
+  .word  EXTI3_IRQHandler
+  .word  EXTI4_IRQHandler
+  .word  DMA1_Channel1_IRQHandler
+  .word  DMA1_Channel2_IRQHandler
+  .word  DMA1_Channel3_IRQHandler
+  .word  DMA1_Channel4_IRQHandler
+  .word  DMA1_Channel5_IRQHandler
+  .word  DMA1_Channel6_IRQHandler
+  .word  DMA1_Channel7_IRQHandler
+  .word  ADC1_2_IRQHandler
+  .word  CAN1_TX_IRQHandler
+  .word  CAN1_RX0_IRQHandler
+  .word  CAN1_RX1_IRQHandler
+  .word  CAN1_SCE_IRQHandler
+  .word  EXTI9_5_IRQHandler
+  .word  TIM1_BRK_IRQHandler
+  .word  TIM1_UP_IRQHandler
+  .word  TIM1_TRG_COM_IRQHandler
+  .word  TIM1_CC_IRQHandler
+  .word  TIM2_IRQHandler
+  .word  TIM3_IRQHandler
+  .word  TIM4_IRQHandler
+  .word  I2C1_EV_IRQHandler
+  .word  I2C1_ER_IRQHandler
+  .word  I2C2_EV_IRQHandler
+  .word  I2C2_ER_IRQHandler
+  .word  SPI1_IRQHandler
+  .word  SPI2_IRQHandler
+  .word  USART1_IRQHandler
+  .word  USART2_IRQHandler
+  .word  USART3_IRQHandler
+  .word  EXTI15_10_IRQHandler
+  .word  RTCAlarm_IRQHandler
+  .word  OTG_FS_WKUP_IRQHandler
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  TIM5_IRQHandler
+  .word  SPI3_IRQHandler
+  .word  UART4_IRQHandler
+  .word  UART5_IRQHandler
+  .word  TIM6_IRQHandler
+  .word  TIM7_IRQHandler
+  .word  DMA2_Channel1_IRQHandler
+  .word  DMA2_Channel2_IRQHandler
+  .word  DMA2_Channel3_IRQHandler
+  .word  DMA2_Channel4_IRQHandler
+  .word  DMA2_Channel5_IRQHandler
+  .word  ETH_IRQHandler
+  .word  ETH_WKUP_IRQHandler
+  .word  CAN2_TX_IRQHandler
+  .word  CAN2_RX0_IRQHandler
+  .word  CAN2_RX1_IRQHandler
+  .word  CAN2_SCE_IRQHandler
+  .word  OTG_FS_IRQHandler
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  BootRAM     /* @0x1E0. This is for boot in RAM mode for
+                         STM32F10x Connectivity line Devices. */
+
+/*******************************************************************************
+*
+* Provide weak aliases for each Exception handler to the Default_Handler.
+* As they are weak aliases, any function with the same name will override
+* this definition.
+*
+*******************************************************************************/
+  .weak  NMI_Handler
+  .thumb_set NMI_Handler,Default_Handler
+
+  .weak  HardFault_Handler
+  .thumb_set HardFault_Handler,Default_Handler
+
+  .weak  MemManage_Handler
+  .thumb_set MemManage_Handler,Default_Handler
+
+  .weak  BusFault_Handler
+  .thumb_set BusFault_Handler,Default_Handler
+
+  .weak  UsageFault_Handler
+  .thumb_set UsageFault_Handler,Default_Handler
+
+  .weak  SVC_Handler
+  .thumb_set SVC_Handler,Default_Handler
+
+  .weak  DebugMon_Handler
+  .thumb_set DebugMon_Handler,Default_Handler
+
+  .weak  PendSV_Handler
+  .thumb_set PendSV_Handler,Default_Handler
+
+  .weak  SysTick_Handler
+  .thumb_set SysTick_Handler,Default_Handler
+
+  .weak  WWDG_IRQHandler
+  .thumb_set WWDG_IRQHandler,Default_Handler
+
+  .weak  PVD_IRQHandler
+  .thumb_set PVD_IRQHandler,Default_Handler
+
+  .weak  TAMPER_IRQHandler
+  .thumb_set TAMPER_IRQHandler,Default_Handler
+
+  .weak  RTC_IRQHandler
+  .thumb_set RTC_IRQHandler,Default_Handler
+
+  .weak  FLASH_IRQHandler
+  .thumb_set FLASH_IRQHandler,Default_Handler
+
+  .weak  RCC_IRQHandler
+  .thumb_set RCC_IRQHandler,Default_Handler
+
+  .weak  EXTI0_IRQHandler
+  .thumb_set EXTI0_IRQHandler,Default_Handler
+
+  .weak  EXTI1_IRQHandler
+  .thumb_set EXTI1_IRQHandler,Default_Handler
+
+  .weak  EXTI2_IRQHandler
+  .thumb_set EXTI2_IRQHandler,Default_Handler
+
+  .weak  EXTI3_IRQHandler
+  .thumb_set EXTI3_IRQHandler,Default_Handler
+
+  .weak  EXTI4_IRQHandler
+  .thumb_set EXTI4_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel1_IRQHandler
+  .thumb_set DMA1_Channel1_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel2_IRQHandler
+  .thumb_set DMA1_Channel2_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel3_IRQHandler
+  .thumb_set DMA1_Channel3_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel4_IRQHandler
+  .thumb_set DMA1_Channel4_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel5_IRQHandler
+  .thumb_set DMA1_Channel5_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel6_IRQHandler
+  .thumb_set DMA1_Channel6_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel7_IRQHandler
+  .thumb_set DMA1_Channel7_IRQHandler,Default_Handler
+
+  .weak  ADC1_2_IRQHandler
+  .thumb_set ADC1_2_IRQHandler,Default_Handler
+
+  .weak  CAN1_TX_IRQHandler
+  .thumb_set CAN1_TX_IRQHandler,Default_Handler
+
+  .weak  CAN1_RX0_IRQHandler
+  .thumb_set CAN1_RX0_IRQHandler,Default_Handler
+
+  .weak  CAN1_RX1_IRQHandler
+  .thumb_set CAN1_RX1_IRQHandler,Default_Handler
+
+  .weak  CAN1_SCE_IRQHandler
+  .thumb_set CAN1_SCE_IRQHandler,Default_Handler
+
+  .weak  EXTI9_5_IRQHandler
+  .thumb_set EXTI9_5_IRQHandler,Default_Handler
+
+  .weak  TIM1_BRK_IRQHandler
+  .thumb_set TIM1_BRK_IRQHandler,Default_Handler
+
+  .weak  TIM1_UP_IRQHandler
+  .thumb_set TIM1_UP_IRQHandler,Default_Handler
+
+  .weak  TIM1_TRG_COM_IRQHandler
+  .thumb_set TIM1_TRG_COM_IRQHandler,Default_Handler
+
+  .weak  TIM1_CC_IRQHandler
+  .thumb_set TIM1_CC_IRQHandler,Default_Handler
+
+  .weak  TIM2_IRQHandler
+  .thumb_set TIM2_IRQHandler,Default_Handler
+
+  .weak  TIM3_IRQHandler
+  .thumb_set TIM3_IRQHandler,Default_Handler
+
+  .weak  TIM4_IRQHandler
+  .thumb_set TIM4_IRQHandler,Default_Handler
+
+  .weak  I2C1_EV_IRQHandler
+  .thumb_set I2C1_EV_IRQHandler,Default_Handler
+
+  .weak  I2C1_ER_IRQHandler
+  .thumb_set I2C1_ER_IRQHandler,Default_Handler
+
+  .weak  I2C2_EV_IRQHandler
+  .thumb_set I2C2_EV_IRQHandler,Default_Handler
+
+  .weak  I2C2_ER_IRQHandler
+  .thumb_set I2C2_ER_IRQHandler,Default_Handler
+
+  .weak  SPI1_IRQHandler
+  .thumb_set SPI1_IRQHandler,Default_Handler
+
+  .weak  SPI2_IRQHandler
+  .thumb_set SPI2_IRQHandler,Default_Handler
+
+  .weak  USART1_IRQHandler
+  .thumb_set USART1_IRQHandler,Default_Handler
+
+  .weak  USART2_IRQHandler
+  .thumb_set USART2_IRQHandler,Default_Handler
+
+  .weak  USART3_IRQHandler
+  .thumb_set USART3_IRQHandler,Default_Handler
+
+  .weak  EXTI15_10_IRQHandler
+  .thumb_set EXTI15_10_IRQHandler,Default_Handler
+
+  .weak  RTCAlarm_IRQHandler
+  .thumb_set RTCAlarm_IRQHandler,Default_Handler
+
+  .weak  OTG_FS_WKUP_IRQHandler
+  .thumb_set OTG_FS_WKUP_IRQHandler,Default_Handler
+
+  .weak  TIM5_IRQHandler
+  .thumb_set TIM5_IRQHandler,Default_Handler
+
+  .weak  SPI3_IRQHandler
+  .thumb_set SPI3_IRQHandler,Default_Handler
+
+  .weak  UART4_IRQHandler
+  .thumb_set UART4_IRQHandler,Default_Handler
+
+  .weak  UART5_IRQHandler
+  .thumb_set UART5_IRQHandler,Default_Handler
+
+  .weak  TIM6_IRQHandler
+  .thumb_set TIM6_IRQHandler,Default_Handler
+
+  .weak  TIM7_IRQHandler
+  .thumb_set TIM7_IRQHandler,Default_Handler
+
+  .weak  DMA2_Channel1_IRQHandler
+  .thumb_set DMA2_Channel1_IRQHandler,Default_Handler
+
+  .weak  DMA2_Channel2_IRQHandler
+  .thumb_set DMA2_Channel2_IRQHandler,Default_Handler
+
+  .weak  DMA2_Channel3_IRQHandler
+  .thumb_set DMA2_Channel3_IRQHandler,Default_Handler
+
+  .weak  DMA2_Channel4_IRQHandler
+  .thumb_set DMA2_Channel4_IRQHandler,Default_Handler
+
+  .weak  DMA2_Channel5_IRQHandler
+  .thumb_set DMA2_Channel5_IRQHandler,Default_Handler
+
+  .weak  ETH_IRQHandler
+  .thumb_set ETH_IRQHandler,Default_Handler
+
+  .weak  ETH_WKUP_IRQHandler
+  .thumb_set ETH_WKUP_IRQHandler,Default_Handler
+
+  .weak  CAN2_TX_IRQHandler
+  .thumb_set CAN2_TX_IRQHandler,Default_Handler
+
+  .weak  CAN2_RX0_IRQHandler
+  .thumb_set CAN2_RX0_IRQHandler,Default_Handler
+
+  .weak  CAN2_RX1_IRQHandler
+  .thumb_set CAN2_RX1_IRQHandler,Default_Handler
+
+  .weak  CAN2_SCE_IRQHandler
+  .thumb_set CAN2_SCE_IRQHandler,Default_Handler
+
+  .weak  OTG_FS_IRQHandler
+  .thumb_set OTG_FS_IRQHandler ,Default_Handler
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_hd.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_hd.s
new file mode 100644
index 0000000..e4ba08c
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_hd.s
@@ -0,0 +1,465 @@
+/**
+  ******************************************************************************
+  * @file      startup_stm32f10x_hd.s
+  * @author    MCD Application Team
+  * @version   V3.5.0
+  * @date      11-March-2011
+  * @brief     STM32F10x High Density Devices vector table for RIDE7 toolchain.
+  *            This module performs:
+  *                - Set the initial SP
+  *                - Set the initial PC == Reset_Handler,
+  *                - Set the vector table entries with the exceptions ISR address
+  *                - Configure the clock system and the external SRAM mounted on
+  *                  STM3210E-EVAL board to be used as data memory (optional,
+  *                  to be enabled by user)
+  *                - Branches to main in the C library (which eventually
+  *                  calls main()).
+  *            After Reset the Cortex-M3 processor is in Thread mode,
+  *            priority is Privileged, and the Stack is set to Main.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+  .syntax unified
+  .cpu cortex-m3
+  .fpu softvfp
+  .thumb
+
+.global  g_pfnVectors
+.global  Default_Handler
+
+/* start address for the initialization values of the .data section.
+defined in linker script */
+.word  _sidata
+/* start address for the .data section. defined in linker script */
+.word  _sdata
+/* end address for the .data section. defined in linker script */
+.word  _edata
+/* start address for the .bss section. defined in linker script */
+.word  _sbss
+/* end address for the .bss section. defined in linker script */
+.word  _ebss
+/* stack used for SystemInit_ExtMemCtl; always internal RAM used */
+
+.equ  BootRAM,        0xF1E0F85F
+/**
+ * @brief  This is the code that gets called when the processor first
+ *          starts execution following a reset event. Only the absolutely
+ *          necessary set is performed, after which the application
+ *          supplied main() routine is called.
+ * @param  None
+ * @retval : None
+*/
+
+    .section  .text.Reset_Handler
+  .weak  Reset_Handler
+  .type  Reset_Handler, %function
+Reset_Handler:
+
+/* Copy the data segment initializers from flash to SRAM */
+  movs  r1, #0
+  b  LoopCopyDataInit
+
+CopyDataInit:
+  ldr  r3, =_sidata
+  ldr  r3, [r3, r1]
+  str  r3, [r0, r1]
+  adds  r1, r1, #4
+
+LoopCopyDataInit:
+  ldr  r0, =_sdata
+  ldr  r3, =_edata
+  adds  r2, r0, r1
+  cmp  r2, r3
+  bcc  CopyDataInit
+  ldr  r2, =_sbss
+  b  LoopFillZerobss
+/* Zero fill the bss segment. */
+FillZerobss:
+  movs  r3, #0
+  str  r3, [r2], #4
+
+LoopFillZerobss:
+  ldr  r3, = _ebss
+  cmp  r2, r3
+  bcc  FillZerobss
+/* Call the clock system intitialization function.*/
+  bl  SystemInit
+/* Call the application's entry point.*/
+  bl  main
+  bx  lr
+.size  Reset_Handler, .-Reset_Handler
+
+/**
+ * @brief  This is the code that gets called when the processor receives an
+ *         unexpected interrupt.  This simply enters an infinite loop, preserving
+ *         the system state for examination by a debugger.
+ * @param  None
+ * @retval None
+*/
+    .section  .text.Default_Handler,"ax",%progbits
+Default_Handler:
+Infinite_Loop:
+  b  Infinite_Loop
+  .size  Default_Handler, .-Default_Handler
+/******************************************************************************
+*
+* The minimal vector table for a Cortex M3. Note that the proper constructs
+* must be placed on this to ensure that it ends up at physical address
+* 0x0000.0000.
+*
+*******************************************************************************/
+   .section  .isr_vector,"a",%progbits
+  .type  g_pfnVectors, %object
+  .size  g_pfnVectors, .-g_pfnVectors
+
+
+g_pfnVectors:
+  .word  _estack
+  .word  Reset_Handler
+  .word  NMI_Handler
+  .word  HardFault_Handler
+  .word  MemManage_Handler
+  .word  BusFault_Handler
+  .word  UsageFault_Handler
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  SVC_Handler
+  .word  DebugMon_Handler
+  .word  0
+  .word  PendSV_Handler
+  .word  SysTick_Handler
+  .word  WWDG_IRQHandler
+  .word  PVD_IRQHandler
+  .word  TAMPER_IRQHandler
+  .word  RTC_IRQHandler
+  .word  FLASH_IRQHandler
+  .word  RCC_IRQHandler
+  .word  EXTI0_IRQHandler
+  .word  EXTI1_IRQHandler
+  .word  EXTI2_IRQHandler
+  .word  EXTI3_IRQHandler
+  .word  EXTI4_IRQHandler
+  .word  DMA1_Channel1_IRQHandler
+  .word  DMA1_Channel2_IRQHandler
+  .word  DMA1_Channel3_IRQHandler
+  .word  DMA1_Channel4_IRQHandler
+  .word  DMA1_Channel5_IRQHandler
+  .word  DMA1_Channel6_IRQHandler
+  .word  DMA1_Channel7_IRQHandler
+  .word  ADC1_2_IRQHandler
+  .word  USB_HP_CAN1_TX_IRQHandler
+  .word  USB_LP_CAN1_RX0_IRQHandler
+  .word  CAN1_RX1_IRQHandler
+  .word  CAN1_SCE_IRQHandler
+  .word  EXTI9_5_IRQHandler
+  .word  TIM1_BRK_IRQHandler
+  .word  TIM1_UP_IRQHandler
+  .word  TIM1_TRG_COM_IRQHandler
+  .word  TIM1_CC_IRQHandler
+  .word  TIM2_IRQHandler
+  .word  TIM3_IRQHandler
+  .word  TIM4_IRQHandler
+  .word  I2C1_EV_IRQHandler
+  .word  I2C1_ER_IRQHandler
+  .word  I2C2_EV_IRQHandler
+  .word  I2C2_ER_IRQHandler
+  .word  SPI1_IRQHandler
+  .word  SPI2_IRQHandler
+  .word  USART1_IRQHandler
+  .word  USART2_IRQHandler
+  .word  USART3_IRQHandler
+  .word  EXTI15_10_IRQHandler
+  .word  RTCAlarm_IRQHandler
+  .word  USBWakeUp_IRQHandler
+  .word  TIM8_BRK_IRQHandler
+  .word  TIM8_UP_IRQHandler
+  .word  TIM8_TRG_COM_IRQHandler
+  .word  TIM8_CC_IRQHandler
+  .word  ADC3_IRQHandler
+  .word  FSMC_IRQHandler
+  .word  SDIO_IRQHandler
+  .word  TIM5_IRQHandler
+  .word  SPI3_IRQHandler
+  .word  UART4_IRQHandler
+  .word  UART5_IRQHandler
+  .word  TIM6_IRQHandler
+  .word  TIM7_IRQHandler
+  .word  DMA2_Channel1_IRQHandler
+  .word  DMA2_Channel2_IRQHandler
+  .word  DMA2_Channel3_IRQHandler
+  .word  DMA2_Channel4_5_IRQHandler
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  BootRAM       /* @0x1E0. This is for boot in RAM mode for
+                         STM32F10x High Density devices. */
+/*******************************************************************************
+*
+* Provide weak aliases for each Exception handler to the Default_Handler.
+* As they are weak aliases, any function with the same name will override
+* this definition.
+*
+*******************************************************************************/
+
+  .weak  NMI_Handler
+  .thumb_set NMI_Handler,Default_Handler
+
+  .weak  HardFault_Handler
+  .thumb_set HardFault_Handler,Default_Handler
+
+  .weak  MemManage_Handler
+  .thumb_set MemManage_Handler,Default_Handler
+
+  .weak  BusFault_Handler
+  .thumb_set BusFault_Handler,Default_Handler
+
+  .weak  UsageFault_Handler
+  .thumb_set UsageFault_Handler,Default_Handler
+
+  .weak  SVC_Handler
+  .thumb_set SVC_Handler,Default_Handler
+
+  .weak  DebugMon_Handler
+  .thumb_set DebugMon_Handler,Default_Handler
+
+  .weak  PendSV_Handler
+  .thumb_set PendSV_Handler,Default_Handler
+
+  .weak  SysTick_Handler
+  .thumb_set SysTick_Handler,Default_Handler
+
+  .weak  WWDG_IRQHandler
+  .thumb_set WWDG_IRQHandler,Default_Handler
+
+  .weak  PVD_IRQHandler
+  .thumb_set PVD_IRQHandler,Default_Handler
+
+  .weak  TAMPER_IRQHandler
+  .thumb_set TAMPER_IRQHandler,Default_Handler
+
+  .weak  RTC_IRQHandler
+  .thumb_set RTC_IRQHandler,Default_Handler
+
+  .weak  FLASH_IRQHandler
+  .thumb_set FLASH_IRQHandler,Default_Handler
+
+  .weak  RCC_IRQHandler
+  .thumb_set RCC_IRQHandler,Default_Handler
+
+  .weak  EXTI0_IRQHandler
+  .thumb_set EXTI0_IRQHandler,Default_Handler
+
+  .weak  EXTI1_IRQHandler
+  .thumb_set EXTI1_IRQHandler,Default_Handler
+
+  .weak  EXTI2_IRQHandler
+  .thumb_set EXTI2_IRQHandler,Default_Handler
+
+  .weak  EXTI3_IRQHandler
+  .thumb_set EXTI3_IRQHandler,Default_Handler
+
+  .weak  EXTI4_IRQHandler
+  .thumb_set EXTI4_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel1_IRQHandler
+  .thumb_set DMA1_Channel1_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel2_IRQHandler
+  .thumb_set DMA1_Channel2_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel3_IRQHandler
+  .thumb_set DMA1_Channel3_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel4_IRQHandler
+  .thumb_set DMA1_Channel4_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel5_IRQHandler
+  .thumb_set DMA1_Channel5_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel6_IRQHandler
+  .thumb_set DMA1_Channel6_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel7_IRQHandler
+  .thumb_set DMA1_Channel7_IRQHandler,Default_Handler
+
+  .weak  ADC1_2_IRQHandler
+  .thumb_set ADC1_2_IRQHandler,Default_Handler
+
+  .weak  USB_HP_CAN1_TX_IRQHandler
+  .thumb_set USB_HP_CAN1_TX_IRQHandler,Default_Handler
+
+  .weak  USB_LP_CAN1_RX0_IRQHandler
+  .thumb_set USB_LP_CAN1_RX0_IRQHandler,Default_Handler
+
+  .weak  CAN1_RX1_IRQHandler
+  .thumb_set CAN1_RX1_IRQHandler,Default_Handler
+
+  .weak  CAN1_SCE_IRQHandler
+  .thumb_set CAN1_SCE_IRQHandler,Default_Handler
+
+  .weak  EXTI9_5_IRQHandler
+  .thumb_set EXTI9_5_IRQHandler,Default_Handler
+
+  .weak  TIM1_BRK_IRQHandler
+  .thumb_set TIM1_BRK_IRQHandler,Default_Handler
+
+  .weak  TIM1_UP_IRQHandler
+  .thumb_set TIM1_UP_IRQHandler,Default_Handler
+
+  .weak  TIM1_TRG_COM_IRQHandler
+  .thumb_set TIM1_TRG_COM_IRQHandler,Default_Handler
+
+  .weak  TIM1_CC_IRQHandler
+  .thumb_set TIM1_CC_IRQHandler,Default_Handler
+
+  .weak  TIM2_IRQHandler
+  .thumb_set TIM2_IRQHandler,Default_Handler
+
+  .weak  TIM3_IRQHandler
+  .thumb_set TIM3_IRQHandler,Default_Handler
+
+  .weak  TIM4_IRQHandler
+  .thumb_set TIM4_IRQHandler,Default_Handler
+
+  .weak  I2C1_EV_IRQHandler
+  .thumb_set I2C1_EV_IRQHandler,Default_Handler
+
+  .weak  I2C1_ER_IRQHandler
+  .thumb_set I2C1_ER_IRQHandler,Default_Handler
+
+  .weak  I2C2_EV_IRQHandler
+  .thumb_set I2C2_EV_IRQHandler,Default_Handler
+
+  .weak  I2C2_ER_IRQHandler
+  .thumb_set I2C2_ER_IRQHandler,Default_Handler
+
+  .weak  SPI1_IRQHandler
+  .thumb_set SPI1_IRQHandler,Default_Handler
+
+  .weak  SPI2_IRQHandler
+  .thumb_set SPI2_IRQHandler,Default_Handler
+
+  .weak  USART1_IRQHandler
+  .thumb_set USART1_IRQHandler,Default_Handler
+
+  .weak  USART2_IRQHandler
+  .thumb_set USART2_IRQHandler,Default_Handler
+
+  .weak  USART3_IRQHandler
+  .thumb_set USART3_IRQHandler,Default_Handler
+
+  .weak  EXTI15_10_IRQHandler
+  .thumb_set EXTI15_10_IRQHandler,Default_Handler
+
+  .weak  RTCAlarm_IRQHandler
+  .thumb_set RTCAlarm_IRQHandler,Default_Handler
+
+  .weak  USBWakeUp_IRQHandler
+  .thumb_set USBWakeUp_IRQHandler,Default_Handler
+
+  .weak  TIM8_BRK_IRQHandler
+  .thumb_set TIM8_BRK_IRQHandler,Default_Handler
+
+  .weak  TIM8_UP_IRQHandler
+  .thumb_set TIM8_UP_IRQHandler,Default_Handler
+
+  .weak  TIM8_TRG_COM_IRQHandler
+  .thumb_set TIM8_TRG_COM_IRQHandler,Default_Handler
+
+  .weak  TIM8_CC_IRQHandler
+  .thumb_set TIM8_CC_IRQHandler,Default_Handler
+
+  .weak  ADC3_IRQHandler
+  .thumb_set ADC3_IRQHandler,Default_Handler
+
+  .weak  FSMC_IRQHandler
+  .thumb_set FSMC_IRQHandler,Default_Handler
+
+  .weak  SDIO_IRQHandler
+  .thumb_set SDIO_IRQHandler,Default_Handler
+
+  .weak  TIM5_IRQHandler
+  .thumb_set TIM5_IRQHandler,Default_Handler
+
+  .weak  SPI3_IRQHandler
+  .thumb_set SPI3_IRQHandler,Default_Handler
+
+  .weak  UART4_IRQHandler
+  .thumb_set UART4_IRQHandler,Default_Handler
+
+  .weak  UART5_IRQHandler
+  .thumb_set UART5_IRQHandler,Default_Handler
+
+  .weak  TIM6_IRQHandler
+  .thumb_set TIM6_IRQHandler,Default_Handler
+
+  .weak  TIM7_IRQHandler
+  .thumb_set TIM7_IRQHandler,Default_Handler
+
+  .weak  DMA2_Channel1_IRQHandler
+  .thumb_set DMA2_Channel1_IRQHandler,Default_Handler
+
+  .weak  DMA2_Channel2_IRQHandler
+  .thumb_set DMA2_Channel2_IRQHandler,Default_Handler
+
+  .weak  DMA2_Channel3_IRQHandler
+  .thumb_set DMA2_Channel3_IRQHandler,Default_Handler
+
+  .weak  DMA2_Channel4_5_IRQHandler
+  .thumb_set DMA2_Channel4_5_IRQHandler,Default_Handler
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_hd_vl.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_hd_vl.s
new file mode 100644
index 0000000..daad5cc
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_hd_vl.s
@@ -0,0 +1,442 @@
+/**
+  ******************************************************************************
+  * @file      startup_stm32f10x_hd_vl.s
+  * @author    MCD Application Team
+  * @version   V3.5.0
+  * @date      11-March-2011
+  * @brief     STM32F10x High Density Value Line Devices vector table for RIDE7
+  *            toolchain.
+  *            This module performs:
+  *                - Set the initial SP
+  *                - Set the initial PC == Reset_Handler,
+  *                - Set the vector table entries with the exceptions ISR address
+  *                - Configure the clock system and the external SRAM mounted on
+  *                  STM32100E-EVAL board to be used as data memory (optional,
+  *                  to be enabled by user)
+  *                - Branches to main in the C library (which eventually
+  *                  calls main()).
+  *            After Reset the Cortex-M3 processor is in Thread mode,
+  *            priority is Privileged, and the Stack is set to Main.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+  .syntax unified
+  .cpu cortex-m3
+  .fpu softvfp
+  .thumb
+
+.global  g_pfnVectors
+.global  Default_Handler
+
+/* start address for the initialization values of the .data section.
+defined in linker script */
+.word  _sidata
+/* start address for the .data section. defined in linker script */
+.word  _sdata
+/* end address for the .data section. defined in linker script */
+.word  _edata
+/* start address for the .bss section. defined in linker script */
+.word  _sbss
+/* end address for the .bss section. defined in linker script */
+.word  _ebss
+
+.equ  BootRAM, 0xF108F85F
+/**
+ * @brief  This is the code that gets called when the processor first
+ *          starts execution following a reset event. Only the absolutely
+ *          necessary set is performed, after which the application
+ *          supplied main() routine is called.
+ * @param  None
+ * @retval None
+*/
+
+  .section  .text.Reset_Handler
+  .weak  Reset_Handler
+  .type  Reset_Handler, %function
+Reset_Handler:
+
+/* Copy the data segment initializers from flash to SRAM */
+  movs  r1, #0
+  b     LoopCopyDataInit
+
+CopyDataInit:
+  ldr   r3, =_sidata
+  ldr   r3, [r3, r1]
+  str   r3, [r0, r1]
+  adds  r1, r1, #4
+
+LoopCopyDataInit:
+  ldr   r0, =_sdata
+  ldr   r3, =_edata
+  adds  r2, r0, r1
+  cmp   r2, r3
+  bcc   CopyDataInit
+  ldr   r2, =_sbss
+  b     LoopFillZerobss
+/* Zero fill the bss segment. */
+FillZerobss:
+  movs  r3, #0
+  str   r3, [r2], #4
+
+LoopFillZerobss:
+  ldr   r3, = _ebss
+  cmp   r2, r3
+  bcc   FillZerobss
+/* Call the clock system intitialization function.*/
+  bl  SystemInit
+/* Call the application's entry point.*/
+  bl    main
+  bx    lr
+.size   Reset_Handler, .-Reset_Handler
+
+/**
+ * @brief  This is the code that gets called when the processor receives an
+ *         unexpected interrupt. This simply enters an infinite loop, preserving
+ *         the system state for examination by a debugger.
+ * @param  None
+ * @retval None
+*/
+  .section  .text.Default_Handler,"ax",%progbits
+Default_Handler:
+Infinite_Loop:
+  b  Infinite_Loop
+  .size  Default_Handler, .-Default_Handler
+/******************************************************************************
+*
+* The minimal vector table for a Cortex M3. Note that the proper constructs
+* must be placed on this to ensure that it ends up at physical address
+* 0x0000.0000.
+*
+******************************************************************************/
+  .section  .isr_vector,"a",%progbits
+  .type  g_pfnVectors, %object
+  .size  g_pfnVectors, .-g_pfnVectors
+
+g_pfnVectors:
+  .word  _estack
+  .word  Reset_Handler
+  .word  NMI_Handler
+  .word  HardFault_Handler
+  .word  MemManage_Handler
+  .word  BusFault_Handler
+  .word  UsageFault_Handler
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  SVC_Handler
+  .word  DebugMon_Handler
+  .word  0
+  .word  PendSV_Handler
+  .word  SysTick_Handler
+  .word  WWDG_IRQHandler
+  .word  PVD_IRQHandler
+  .word  TAMPER_IRQHandler
+  .word  RTC_IRQHandler
+  .word  FLASH_IRQHandler
+  .word  RCC_IRQHandler
+  .word  EXTI0_IRQHandler
+  .word  EXTI1_IRQHandler
+  .word  EXTI2_IRQHandler
+  .word  EXTI3_IRQHandler
+  .word  EXTI4_IRQHandler
+  .word  DMA1_Channel1_IRQHandler
+  .word  DMA1_Channel2_IRQHandler
+  .word  DMA1_Channel3_IRQHandler
+  .word  DMA1_Channel4_IRQHandler
+  .word  DMA1_Channel5_IRQHandler
+  .word  DMA1_Channel6_IRQHandler
+  .word  DMA1_Channel7_IRQHandler
+  .word  ADC1_IRQHandler
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  EXTI9_5_IRQHandler
+  .word  TIM1_BRK_TIM15_IRQHandler
+  .word  TIM1_UP_TIM16_IRQHandler
+  .word  TIM1_TRG_COM_TIM17_IRQHandler
+  .word  TIM1_CC_IRQHandler
+  .word  TIM2_IRQHandler
+  .word  TIM3_IRQHandler
+  .word  TIM4_IRQHandler
+  .word  I2C1_EV_IRQHandler
+  .word  I2C1_ER_IRQHandler
+  .word  I2C2_EV_IRQHandler
+  .word  I2C2_ER_IRQHandler
+  .word  SPI1_IRQHandler
+  .word  SPI2_IRQHandler
+  .word  USART1_IRQHandler
+  .word  USART2_IRQHandler
+  .word  USART3_IRQHandler
+  .word  EXTI15_10_IRQHandler
+  .word  RTCAlarm_IRQHandler
+  .word  CEC_IRQHandler
+  .word  TIM12_IRQHandler
+  .word  TIM13_IRQHandler
+  .word  TIM14_IRQHandler
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  TIM5_IRQHandler
+  .word  SPI3_IRQHandler
+  .word  UART4_IRQHandler
+  .word  UART5_IRQHandler
+  .word  TIM6_DAC_IRQHandler
+  .word  TIM7_IRQHandler
+  .word  DMA2_Channel1_IRQHandler
+  .word  DMA2_Channel2_IRQHandler
+  .word  DMA2_Channel3_IRQHandler
+  .word  DMA2_Channel4_5_IRQHandler
+  .word  DMA2_Channel5_IRQHandler
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  BootRAM       /* @0x1E0. This is for boot in RAM mode for
+                         STM32F10x High Density Value line devices. */
+
+/*******************************************************************************
+* Provide weak aliases for each Exception handler to the Default_Handler.
+* As they are weak aliases, any function with the same name will override
+* this definition.
+*******************************************************************************/
+
+  .weak  NMI_Handler
+  .thumb_set NMI_Handler,Default_Handler
+
+  .weak  HardFault_Handler
+  .thumb_set HardFault_Handler,Default_Handler
+
+  .weak  MemManage_Handler
+  .thumb_set MemManage_Handler,Default_Handler
+
+  .weak  BusFault_Handler
+  .thumb_set BusFault_Handler,Default_Handler
+
+  .weak  UsageFault_Handler
+  .thumb_set UsageFault_Handler,Default_Handler
+
+  .weak  SVC_Handler
+  .thumb_set SVC_Handler,Default_Handler
+
+  .weak  DebugMon_Handler
+  .thumb_set DebugMon_Handler,Default_Handler
+
+  .weak  PendSV_Handler
+  .thumb_set PendSV_Handler,Default_Handler
+
+  .weak  SysTick_Handler
+  .thumb_set SysTick_Handler,Default_Handler
+
+  .weak  WWDG_IRQHandler
+  .thumb_set WWDG_IRQHandler,Default_Handler
+
+  .weak  PVD_IRQHandler
+  .thumb_set PVD_IRQHandler,Default_Handler
+
+  .weak  TAMPER_IRQHandler
+  .thumb_set TAMPER_IRQHandler,Default_Handler
+
+  .weak  RTC_IRQHandler
+  .thumb_set RTC_IRQHandler,Default_Handler
+
+  .weak  FLASH_IRQHandler
+  .thumb_set FLASH_IRQHandler,Default_Handler
+
+  .weak  RCC_IRQHandler
+  .thumb_set RCC_IRQHandler,Default_Handler
+
+  .weak  EXTI0_IRQHandler
+  .thumb_set EXTI0_IRQHandler,Default_Handler
+
+  .weak  EXTI1_IRQHandler
+  .thumb_set EXTI1_IRQHandler,Default_Handler
+
+  .weak  EXTI2_IRQHandler
+  .thumb_set EXTI2_IRQHandler,Default_Handler
+
+  .weak  EXTI3_IRQHandler
+  .thumb_set EXTI3_IRQHandler,Default_Handler
+
+  .weak  EXTI4_IRQHandler
+  .thumb_set EXTI4_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel1_IRQHandler
+  .thumb_set DMA1_Channel1_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel2_IRQHandler
+  .thumb_set DMA1_Channel2_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel3_IRQHandler
+  .thumb_set DMA1_Channel3_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel4_IRQHandler
+  .thumb_set DMA1_Channel4_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel5_IRQHandler
+  .thumb_set DMA1_Channel5_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel6_IRQHandler
+  .thumb_set DMA1_Channel6_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel7_IRQHandler
+  .thumb_set DMA1_Channel7_IRQHandler,Default_Handler
+
+  .weak  ADC1_IRQHandler
+  .thumb_set ADC1_IRQHandler,Default_Handler
+
+  .weak  EXTI9_5_IRQHandler
+  .thumb_set EXTI9_5_IRQHandler,Default_Handler
+
+  .weak  TIM1_BRK_TIM15_IRQHandler
+  .thumb_set TIM1_BRK_TIM15_IRQHandler,Default_Handler
+
+  .weak  TIM1_UP_TIM16_IRQHandler
+  .thumb_set TIM1_UP_TIM16_IRQHandler,Default_Handler
+
+  .weak  TIM1_TRG_COM_TIM17_IRQHandler
+  .thumb_set TIM1_TRG_COM_TIM17_IRQHandler,Default_Handler
+
+  .weak  TIM1_CC_IRQHandler
+  .thumb_set TIM1_CC_IRQHandler,Default_Handler
+
+  .weak  TIM2_IRQHandler
+  .thumb_set TIM2_IRQHandler,Default_Handler
+
+  .weak  TIM3_IRQHandler
+  .thumb_set TIM3_IRQHandler,Default_Handler
+
+  .weak  TIM4_IRQHandler
+  .thumb_set TIM4_IRQHandler,Default_Handler
+
+  .weak  I2C1_EV_IRQHandler
+  .thumb_set I2C1_EV_IRQHandler,Default_Handler
+
+  .weak  I2C1_ER_IRQHandler
+  .thumb_set I2C1_ER_IRQHandler,Default_Handler
+
+  .weak  I2C2_EV_IRQHandler
+  .thumb_set I2C2_EV_IRQHandler,Default_Handler
+
+  .weak  I2C2_ER_IRQHandler
+  .thumb_set I2C2_ER_IRQHandler,Default_Handler
+
+  .weak  SPI1_IRQHandler
+  .thumb_set SPI1_IRQHandler,Default_Handler
+
+  .weak  SPI2_IRQHandler
+  .thumb_set SPI2_IRQHandler,Default_Handler
+
+  .weak  USART1_IRQHandler
+  .thumb_set USART1_IRQHandler,Default_Handler
+
+  .weak  USART2_IRQHandler
+  .thumb_set USART2_IRQHandler,Default_Handler
+
+  .weak  USART3_IRQHandler
+  .thumb_set USART3_IRQHandler,Default_Handler
+
+  .weak  EXTI15_10_IRQHandler
+  .thumb_set EXTI15_10_IRQHandler,Default_Handler
+
+  .weak  RTCAlarm_IRQHandler
+  .thumb_set RTCAlarm_IRQHandler,Default_Handler
+
+  .weak  CEC_IRQHandler
+  .thumb_set CEC_IRQHandler,Default_Handler
+
+  .weak  TIM12_IRQHandler
+  .thumb_set TIM12_IRQHandler,Default_Handler
+
+  .weak  TIM13_IRQHandler
+  .thumb_set TIM13_IRQHandler,Default_Handler
+
+  .weak  TIM14_IRQHandler
+  .thumb_set TIM14_IRQHandler,Default_Handler
+
+  .weak  TIM5_IRQHandler
+  .thumb_set TIM5_IRQHandler,Default_Handler
+
+  .weak  SPI3_IRQHandler
+  .thumb_set SPI3_IRQHandler,Default_Handler
+
+  .weak  UART4_IRQHandler
+  .thumb_set UART4_IRQHandler,Default_Handler
+
+  .weak  UART5_IRQHandler
+  .thumb_set UART5_IRQHandler,Default_Handler
+
+  .weak  TIM6_DAC_IRQHandler
+  .thumb_set TIM6_DAC_IRQHandler,Default_Handler
+
+  .weak  TIM7_IRQHandler
+  .thumb_set TIM7_IRQHandler,Default_Handler
+
+  .weak  DMA2_Channel1_IRQHandler
+  .thumb_set DMA2_Channel1_IRQHandler,Default_Handler
+
+  .weak  DMA2_Channel2_IRQHandler
+  .thumb_set DMA2_Channel2_IRQHandler,Default_Handler
+
+  .weak  DMA2_Channel3_IRQHandler
+  .thumb_set DMA2_Channel3_IRQHandler,Default_Handler
+
+  .weak  DMA2_Channel4_5_IRQHandler
+  .thumb_set DMA2_Channel4_5_IRQHandler,Default_Handler
+
+  .weak  DMA2_Channel5_IRQHandler
+  .thumb_set DMA2_Channel5_IRQHandler,Default_Handler
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_ld.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_ld.s
new file mode 100644
index 0000000..aaa09ec
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_ld.s
@@ -0,0 +1,343 @@
+/**
+  ******************************************************************************
+  * @file      startup_stm32f10x_ld.s
+  * @author    MCD Application Team
+  * @version   V3.5.0
+  * @date      11-March-2011
+  * @brief     STM32F10x Low Density Devices vector table for RIDE7 toolchain.
+  *            This module performs:
+  *                - Set the initial SP
+  *                - Set the initial PC == Reset_Handler,
+  *                - Set the vector table entries with the exceptions ISR address
+  *                - Configure the clock system
+  *                - Branches to main in the C library (which eventually
+  *                  calls main()).
+  *            After Reset the Cortex-M3 processor is in Thread mode,
+  *            priority is Privileged, and the Stack is set to Main.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+  .syntax unified
+	.cpu cortex-m3
+	.fpu softvfp
+	.thumb
+
+.global	g_pfnVectors
+.global	Default_Handler
+
+/* start address for the initialization values of the .data section.
+defined in linker script */
+.word	_sidata
+/* start address for the .data section. defined in linker script */
+.word	_sdata
+/* end address for the .data section. defined in linker script */
+.word	_edata
+/* start address for the .bss section. defined in linker script */
+.word	_sbss
+/* end address for the .bss section. defined in linker script */
+.word	_ebss
+
+.equ  BootRAM, 0xF108F85F
+/**
+ * @brief  This is the code that gets called when the processor first
+ *          starts execution following a reset event. Only the absolutely
+ *          necessary set is performed, after which the application
+ *          supplied main() routine is called.
+ * @param  None
+ * @retval : None
+*/
+
+    .section	.text.Reset_Handler
+	.weak	Reset_Handler
+	.type	Reset_Handler, %function
+Reset_Handler:
+
+/* Copy the data segment initializers from flash to SRAM */
+  movs	r1, #0
+  b	LoopCopyDataInit
+
+CopyDataInit:
+	ldr	r3, =_sidata
+	ldr	r3, [r3, r1]
+	str	r3, [r0, r1]
+	adds	r1, r1, #4
+
+LoopCopyDataInit:
+	ldr	r0, =_sdata
+	ldr	r3, =_edata
+	adds	r2, r0, r1
+	cmp	r2, r3
+	bcc	CopyDataInit
+	ldr	r2, =_sbss
+	b	LoopFillZerobss
+/* Zero fill the bss segment. */
+FillZerobss:
+	movs	r3, #0
+	str	r3, [r2], #4
+
+LoopFillZerobss:
+	ldr	r3, = _ebss
+	cmp	r2, r3
+	bcc	FillZerobss
+/* Call the clock system intitialization function.*/
+  bl  SystemInit
+/* Call the application's entry point.*/
+	bl	main
+	bx	lr
+.size	Reset_Handler, .-Reset_Handler
+
+/**
+ * @brief  This is the code that gets called when the processor receives an
+ *         unexpected interrupt.  This simply enters an infinite loop, preserving
+ *         the system state for examination by a debugger.
+ * @param  None
+ * @retval None
+*/
+    .section	.text.Default_Handler,"ax",%progbits
+Default_Handler:
+Infinite_Loop:
+	b	Infinite_Loop
+	.size	Default_Handler, .-Default_Handler
+/******************************************************************************
+*
+* The minimal vector table for a Cortex M3.  Note that the proper constructs
+* must be placed on this to ensure that it ends up at physical address
+* 0x0000.0000.
+*
+******************************************************************************/
+	.section	.isr_vector,"a",%progbits
+	.type	g_pfnVectors, %object
+	.size	g_pfnVectors, .-g_pfnVectors
+
+
+g_pfnVectors:
+	.word	_estack
+	.word	Reset_Handler
+	.word	NMI_Handler
+	.word	HardFault_Handler
+	.word	MemManage_Handler
+	.word	BusFault_Handler
+	.word	UsageFault_Handler
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	SVC_Handler
+	.word	DebugMon_Handler
+	.word	0
+	.word	PendSV_Handler
+	.word	SysTick_Handler
+	.word	WWDG_IRQHandler
+	.word	PVD_IRQHandler
+	.word	TAMPER_IRQHandler
+	.word	RTC_IRQHandler
+	.word	FLASH_IRQHandler
+	.word	RCC_IRQHandler
+	.word	EXTI0_IRQHandler
+	.word	EXTI1_IRQHandler
+	.word	EXTI2_IRQHandler
+	.word	EXTI3_IRQHandler
+	.word	EXTI4_IRQHandler
+	.word	DMA1_Channel1_IRQHandler
+	.word	DMA1_Channel2_IRQHandler
+	.word	DMA1_Channel3_IRQHandler
+	.word	DMA1_Channel4_IRQHandler
+	.word	DMA1_Channel5_IRQHandler
+	.word	DMA1_Channel6_IRQHandler
+	.word	DMA1_Channel7_IRQHandler
+	.word	ADC1_2_IRQHandler
+	.word	USB_HP_CAN1_TX_IRQHandler
+	.word	USB_LP_CAN1_RX0_IRQHandler
+	.word	CAN1_RX1_IRQHandler
+	.word	CAN1_SCE_IRQHandler
+	.word	EXTI9_5_IRQHandler
+	.word	TIM1_BRK_IRQHandler
+	.word	TIM1_UP_IRQHandler
+	.word	TIM1_TRG_COM_IRQHandler
+	.word	TIM1_CC_IRQHandler
+	.word	TIM2_IRQHandler
+	.word	TIM3_IRQHandler
+	.word	0
+	.word	I2C1_EV_IRQHandler
+	.word	I2C1_ER_IRQHandler
+	.word	0
+	.word	0
+	.word	SPI1_IRQHandler
+	.word	0
+	.word	USART1_IRQHandler
+	.word	USART2_IRQHandler
+	.word	0
+	.word	EXTI15_10_IRQHandler
+	.word	RTCAlarm_IRQHandler
+	.word	USBWakeUp_IRQHandler
+  .word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	BootRAM        /* @0x108. This is for boot in RAM mode for
+                          STM32F10x Low Density devices.*/
+
+/*******************************************************************************
+*
+* Provide weak aliases for each Exception handler to the Default_Handler.
+* As they are weak aliases, any function with the same name will override
+* this definition.
+*
+*******************************************************************************/
+
+  .weak	NMI_Handler
+	.thumb_set NMI_Handler,Default_Handler
+
+  .weak	HardFault_Handler
+	.thumb_set HardFault_Handler,Default_Handler
+
+  .weak	MemManage_Handler
+	.thumb_set MemManage_Handler,Default_Handler
+
+  .weak	BusFault_Handler
+	.thumb_set BusFault_Handler,Default_Handler
+
+	.weak	UsageFault_Handler
+	.thumb_set UsageFault_Handler,Default_Handler
+
+	.weak	SVC_Handler
+	.thumb_set SVC_Handler,Default_Handler
+
+	.weak	DebugMon_Handler
+	.thumb_set DebugMon_Handler,Default_Handler
+
+	.weak	PendSV_Handler
+	.thumb_set PendSV_Handler,Default_Handler
+
+	.weak	SysTick_Handler
+	.thumb_set SysTick_Handler,Default_Handler
+
+	.weak	WWDG_IRQHandler
+	.thumb_set WWDG_IRQHandler,Default_Handler
+
+	.weak	PVD_IRQHandler
+	.thumb_set PVD_IRQHandler,Default_Handler
+
+	.weak	TAMPER_IRQHandler
+	.thumb_set TAMPER_IRQHandler,Default_Handler
+
+	.weak	RTC_IRQHandler
+	.thumb_set RTC_IRQHandler,Default_Handler
+
+	.weak	FLASH_IRQHandler
+	.thumb_set FLASH_IRQHandler,Default_Handler
+
+	.weak	RCC_IRQHandler
+	.thumb_set RCC_IRQHandler,Default_Handler
+
+	.weak	EXTI0_IRQHandler
+	.thumb_set EXTI0_IRQHandler,Default_Handler
+
+	.weak	EXTI1_IRQHandler
+	.thumb_set EXTI1_IRQHandler,Default_Handler
+
+	.weak	EXTI2_IRQHandler
+	.thumb_set EXTI2_IRQHandler,Default_Handler
+
+	.weak	EXTI3_IRQHandler
+	.thumb_set EXTI3_IRQHandler,Default_Handler
+
+	.weak	EXTI4_IRQHandler
+	.thumb_set EXTI4_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel1_IRQHandler
+	.thumb_set DMA1_Channel1_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel2_IRQHandler
+	.thumb_set DMA1_Channel2_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel3_IRQHandler
+	.thumb_set DMA1_Channel3_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel4_IRQHandler
+	.thumb_set DMA1_Channel4_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel5_IRQHandler
+	.thumb_set DMA1_Channel5_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel6_IRQHandler
+	.thumb_set DMA1_Channel6_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel7_IRQHandler
+	.thumb_set DMA1_Channel7_IRQHandler,Default_Handler
+
+	.weak	ADC1_2_IRQHandler
+	.thumb_set ADC1_2_IRQHandler,Default_Handler
+
+	.weak	USB_HP_CAN1_TX_IRQHandler
+	.thumb_set USB_HP_CAN1_TX_IRQHandler,Default_Handler
+
+	.weak	USB_LP_CAN1_RX0_IRQHandler
+	.thumb_set USB_LP_CAN1_RX0_IRQHandler,Default_Handler
+
+	.weak	CAN1_RX1_IRQHandler
+	.thumb_set CAN1_RX1_IRQHandler,Default_Handler
+
+	.weak	CAN1_SCE_IRQHandler
+	.thumb_set CAN1_SCE_IRQHandler,Default_Handler
+
+	.weak	EXTI9_5_IRQHandler
+	.thumb_set EXTI9_5_IRQHandler,Default_Handler
+
+	.weak	TIM1_BRK_IRQHandler
+	.thumb_set TIM1_BRK_IRQHandler,Default_Handler
+
+	.weak	TIM1_UP_IRQHandler
+	.thumb_set TIM1_UP_IRQHandler,Default_Handler
+
+	.weak	TIM1_TRG_COM_IRQHandler
+	.thumb_set TIM1_TRG_COM_IRQHandler,Default_Handler
+
+	.weak	TIM1_CC_IRQHandler
+	.thumb_set TIM1_CC_IRQHandler,Default_Handler
+
+	.weak	TIM2_IRQHandler
+	.thumb_set TIM2_IRQHandler,Default_Handler
+
+	.weak	TIM3_IRQHandler
+	.thumb_set TIM3_IRQHandler,Default_Handler
+
+	.weak	I2C1_EV_IRQHandler
+	.thumb_set I2C1_EV_IRQHandler,Default_Handler
+
+	.weak	I2C1_ER_IRQHandler
+	.thumb_set I2C1_ER_IRQHandler,Default_Handler
+
+	.weak	SPI1_IRQHandler
+	.thumb_set SPI1_IRQHandler,Default_Handler
+
+	.weak	USART1_IRQHandler
+	.thumb_set USART1_IRQHandler,Default_Handler
+
+	.weak	USART2_IRQHandler
+	.thumb_set USART2_IRQHandler,Default_Handler
+
+	.weak	EXTI15_10_IRQHandler
+	.thumb_set EXTI15_10_IRQHandler,Default_Handler
+
+	.weak	RTCAlarm_IRQHandler
+	.thumb_set RTCAlarm_IRQHandler,Default_Handler
+
+	.weak	USBWakeUp_IRQHandler
+	.thumb_set USBWakeUp_IRQHandler,Default_Handler
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_ld_vl.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_ld_vl.s
new file mode 100644
index 0000000..d4401be
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_ld_vl.s
@@ -0,0 +1,383 @@
+/**
+  ******************************************************************************
+  * @file      startup_stm32f10x_ld_vl.s
+  * @author    MCD Application Team
+  * @version   V3.5.0
+  * @date      11-March-2011
+  * @brief     STM32F10x Low Density Value Line Devices vector table for RIDE7
+  *            toolchain.
+  *            This module performs:
+  *                - Set the initial SP
+  *                - Set the initial PC == Reset_Handler,
+  *                - Set the vector table entries with the exceptions ISR address
+  *                - Configure the clock system
+  *                - Branches to main in the C library (which eventually
+  *                  calls main()).
+  *            After Reset the Cortex-M3 processor is in Thread mode,
+  *            priority is Privileged, and the Stack is set to Main.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+  .syntax unified
+  .cpu cortex-m3
+  .fpu softvfp
+  .thumb
+
+.global  g_pfnVectors
+.global  Default_Handler
+
+/* start address for the initialization values of the .data section.
+defined in linker script */
+.word  _sidata
+/* start address for the .data section. defined in linker script */
+.word  _sdata
+/* end address for the .data section. defined in linker script */
+.word  _edata
+/* start address for the .bss section. defined in linker script */
+.word  _sbss
+/* end address for the .bss section. defined in linker script */
+.word  _ebss
+
+.equ  BootRAM, 0xF108F85F
+/**
+ * @brief  This is the code that gets called when the processor first
+ *          starts execution following a reset event. Only the absolutely
+ *          necessary set is performed, after which the application
+ *          supplied main() routine is called.
+ * @param  None
+ * @retval None
+*/
+
+  .section  .text.Reset_Handler
+  .weak  Reset_Handler
+  .type  Reset_Handler, %function
+Reset_Handler:
+
+/* Copy the data segment initializers from flash to SRAM */
+  movs  r1, #0
+  b     LoopCopyDataInit
+
+CopyDataInit:
+  ldr   r3, =_sidata
+  ldr   r3, [r3, r1]
+  str   r3, [r0, r1]
+  adds  r1, r1, #4
+
+LoopCopyDataInit:
+  ldr   r0, =_sdata
+  ldr   r3, =_edata
+  adds  r2, r0, r1
+  cmp   r2, r3
+  bcc   CopyDataInit
+  ldr   r2, =_sbss
+  b     LoopFillZerobss
+/* Zero fill the bss segment. */
+FillZerobss:
+  movs  r3, #0
+  str   r3, [r2], #4
+
+LoopFillZerobss:
+  ldr   r3, = _ebss
+  cmp   r2, r3
+  bcc   FillZerobss
+/* Call the clock system intitialization function.*/
+  bl  SystemInit
+/* Call the application's entry point.*/
+  bl    main
+  bx    lr
+.size  Reset_Handler, .-Reset_Handler
+
+/**
+ * @brief  This is the code that gets called when the processor receives an
+ *         unexpected interrupt. This simply enters an infinite loop, preserving
+ *         the system state for examination by a debugger.
+ * @param  None
+ * @retval None
+*/
+  .section  .text.Default_Handler,"ax",%progbits
+Default_Handler:
+Infinite_Loop:
+  b  Infinite_Loop
+  .size  Default_Handler, .-Default_Handler
+/******************************************************************************
+* The minimal vector table for a Cortex M3. Note that the proper constructs
+* must be placed on this to ensure that it ends up at physical address
+* 0x0000.0000.
+*
+******************************************************************************/
+  .section  .isr_vector,"a",%progbits
+  .type  g_pfnVectors, %object
+  .size  g_pfnVectors, .-g_pfnVectors
+
+g_pfnVectors:
+  .word  _estack
+  .word  Reset_Handler
+  .word  NMI_Handler
+  .word  HardFault_Handler
+  .word  MemManage_Handler
+  .word  BusFault_Handler
+  .word  UsageFault_Handler
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  SVC_Handler
+  .word  DebugMon_Handler
+  .word  0
+  .word  PendSV_Handler
+  .word  SysTick_Handler
+  .word  WWDG_IRQHandler
+  .word  PVD_IRQHandler
+  .word  TAMPER_IRQHandler
+  .word  RTC_IRQHandler
+  .word  FLASH_IRQHandler
+  .word  RCC_IRQHandler
+  .word  EXTI0_IRQHandler
+  .word  EXTI1_IRQHandler
+  .word  EXTI2_IRQHandler
+  .word  EXTI3_IRQHandler
+  .word  EXTI4_IRQHandler
+  .word  DMA1_Channel1_IRQHandler
+  .word  DMA1_Channel2_IRQHandler
+  .word  DMA1_Channel3_IRQHandler
+  .word  DMA1_Channel4_IRQHandler
+  .word  DMA1_Channel5_IRQHandler
+  .word  DMA1_Channel6_IRQHandler
+  .word  DMA1_Channel7_IRQHandler
+  .word  ADC1_IRQHandler
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  EXTI9_5_IRQHandler
+  .word  TIM1_BRK_TIM15_IRQHandler
+  .word  TIM1_UP_TIM16_IRQHandler
+  .word  TIM1_TRG_COM_TIM17_IRQHandler
+  .word  TIM1_CC_IRQHandler
+  .word  TIM2_IRQHandler
+  .word  TIM3_IRQHandler
+  .word  0
+  .word  I2C1_EV_IRQHandler
+  .word  I2C1_ER_IRQHandler
+  .word  0
+  .word  0
+  .word  SPI1_IRQHandler
+  .word  0
+  .word  USART1_IRQHandler
+  .word  USART2_IRQHandler
+  .word  0
+  .word  EXTI15_10_IRQHandler
+  .word  RTCAlarm_IRQHandler
+  .word  CEC_IRQHandler
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  TIM6_DAC_IRQHandler
+  .word  TIM7_IRQHandler
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  BootRAM          /* @0x01CC. This is for boot in RAM mode for
+                            STM32F10x Low Density Value Line devices. */
+
+/*******************************************************************************
+* Provide weak aliases for each Exception handler to the Default_Handler.
+* As they are weak aliases, any function with the same name will override
+* this definition.
+*******************************************************************************/
+
+  .weak  NMI_Handler
+  .thumb_set NMI_Handler,Default_Handler
+
+  .weak  HardFault_Handler
+  .thumb_set HardFault_Handler,Default_Handler
+
+  .weak  MemManage_Handler
+  .thumb_set MemManage_Handler,Default_Handler
+
+  .weak  BusFault_Handler
+  .thumb_set BusFault_Handler,Default_Handler
+
+  .weak  UsageFault_Handler
+  .thumb_set UsageFault_Handler,Default_Handler
+
+  .weak  SVC_Handler
+  .thumb_set SVC_Handler,Default_Handler
+
+  .weak  DebugMon_Handler
+  .thumb_set DebugMon_Handler,Default_Handler
+
+  .weak  PendSV_Handler
+  .thumb_set PendSV_Handler,Default_Handler
+
+  .weak  SysTick_Handler
+  .thumb_set SysTick_Handler,Default_Handler
+
+  .weak  WWDG_IRQHandler
+  .thumb_set WWDG_IRQHandler,Default_Handler
+
+  .weak  PVD_IRQHandler
+  .thumb_set PVD_IRQHandler,Default_Handler
+
+  .weak  TAMPER_IRQHandler
+  .thumb_set TAMPER_IRQHandler,Default_Handler
+
+  .weak  RTC_IRQHandler
+  .thumb_set RTC_IRQHandler,Default_Handler
+
+  .weak  FLASH_IRQHandler
+  .thumb_set FLASH_IRQHandler,Default_Handler
+
+  .weak  RCC_IRQHandler
+  .thumb_set RCC_IRQHandler,Default_Handler
+
+  .weak  EXTI0_IRQHandler
+  .thumb_set EXTI0_IRQHandler,Default_Handler
+
+  .weak  EXTI1_IRQHandler
+  .thumb_set EXTI1_IRQHandler,Default_Handler
+
+  .weak  EXTI2_IRQHandler
+  .thumb_set EXTI2_IRQHandler,Default_Handler
+
+  .weak  EXTI3_IRQHandler
+  .thumb_set EXTI3_IRQHandler,Default_Handler
+
+  .weak  EXTI4_IRQHandler
+  .thumb_set EXTI4_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel1_IRQHandler
+  .thumb_set DMA1_Channel1_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel2_IRQHandler
+  .thumb_set DMA1_Channel2_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel3_IRQHandler
+  .thumb_set DMA1_Channel3_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel4_IRQHandler
+  .thumb_set DMA1_Channel4_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel5_IRQHandler
+  .thumb_set DMA1_Channel5_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel6_IRQHandler
+  .thumb_set DMA1_Channel6_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel7_IRQHandler
+  .thumb_set DMA1_Channel7_IRQHandler,Default_Handler
+
+  .weak  ADC1_IRQHandler
+  .thumb_set ADC1_IRQHandler,Default_Handler
+
+  .weak  EXTI9_5_IRQHandler
+  .thumb_set EXTI9_5_IRQHandler,Default_Handler
+
+  .weak  TIM1_BRK_TIM15_IRQHandler
+  .thumb_set TIM1_BRK_TIM15_IRQHandler,Default_Handler
+
+  .weak  TIM1_UP_TIM16_IRQHandler
+  .thumb_set TIM1_UP_TIM16_IRQHandler,Default_Handler
+
+  .weak  TIM1_TRG_COM_TIM17_IRQHandler
+  .thumb_set TIM1_TRG_COM_TIM17_IRQHandler,Default_Handler
+
+  .weak  TIM1_CC_IRQHandler
+  .thumb_set TIM1_CC_IRQHandler,Default_Handler
+
+  .weak  TIM2_IRQHandler
+  .thumb_set TIM2_IRQHandler,Default_Handler
+
+  .weak  TIM3_IRQHandler
+  .thumb_set TIM3_IRQHandler,Default_Handler
+
+  .weak  I2C1_EV_IRQHandler
+  .thumb_set I2C1_EV_IRQHandler,Default_Handler
+
+  .weak  I2C1_ER_IRQHandler
+  .thumb_set I2C1_ER_IRQHandler,Default_Handler
+
+  .weak  SPI1_IRQHandler
+  .thumb_set SPI1_IRQHandler,Default_Handler
+
+  .weak  USART1_IRQHandler
+  .thumb_set USART1_IRQHandler,Default_Handler
+
+  .weak  USART2_IRQHandler
+  .thumb_set USART2_IRQHandler,Default_Handler
+
+  .weak  EXTI15_10_IRQHandler
+  .thumb_set EXTI15_10_IRQHandler,Default_Handler
+
+  .weak  RTCAlarm_IRQHandler
+  .thumb_set RTCAlarm_IRQHandler,Default_Handler
+
+  .weak  CEC_IRQHandler
+  .thumb_set CEC_IRQHandler,Default_Handler
+
+  .weak  TIM6_DAC_IRQHandler
+  .thumb_set TIM6_DAC_IRQHandler,Default_Handler
+
+  .weak  TIM7_IRQHandler
+  .thumb_set TIM7_IRQHandler,Default_Handler
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_md.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_md.s
new file mode 100644
index 0000000..4b4a050
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_md.s
@@ -0,0 +1,358 @@
+/**
+  ******************************************************************************
+  * @file      startup_stm32f10x_md.s
+  * @author    MCD Application Team
+  * @version   V3.5.0
+  * @date      11-March-2011
+  * @brief     STM32F10x Medium Density Devices vector table for RIDE7 toolchain.
+  *            This module performs:
+  *                - Set the initial SP
+  *                - Set the initial PC == Reset_Handler,
+  *                - Set the vector table entries with the exceptions ISR address
+  *                - Configure the clock system
+  *                - Branches to main in the C library (which eventually
+  *                  calls main()).
+  *            After Reset the Cortex-M3 processor is in Thread mode,
+  *            priority is Privileged, and the Stack is set to Main.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+  .syntax unified
+	.cpu cortex-m3
+	.fpu softvfp
+	.thumb
+
+.global	g_pfnVectors
+.global	Default_Handler
+
+/* start address for the initialization values of the .data section.
+defined in linker script */
+.word	_sidata
+/* start address for the .data section. defined in linker script */
+.word	_sdata
+/* end address for the .data section. defined in linker script */
+.word	_edata
+/* start address for the .bss section. defined in linker script */
+.word	_sbss
+/* end address for the .bss section. defined in linker script */
+.word	_ebss
+
+.equ  BootRAM, 0xF108F85F
+/**
+ * @brief  This is the code that gets called when the processor first
+ *          starts execution following a reset event. Only the absolutely
+ *          necessary set is performed, after which the application
+ *          supplied main() routine is called.
+ * @param  None
+ * @retval : None
+*/
+
+    .section	.text.Reset_Handler
+	.weak	Reset_Handler
+	.type	Reset_Handler, %function
+Reset_Handler:
+
+/* Copy the data segment initializers from flash to SRAM */
+  movs	r1, #0
+  b	LoopCopyDataInit
+
+CopyDataInit:
+	ldr	r3, =_sidata
+	ldr	r3, [r3, r1]
+	str	r3, [r0, r1]
+	adds	r1, r1, #4
+
+LoopCopyDataInit:
+	ldr	r0, =_sdata
+	ldr	r3, =_edata
+	adds	r2, r0, r1
+	cmp	r2, r3
+	bcc	CopyDataInit
+	ldr	r2, =_sbss
+	b	LoopFillZerobss
+/* Zero fill the bss segment. */
+FillZerobss:
+	movs	r3, #0
+	str	r3, [r2], #4
+
+LoopFillZerobss:
+	ldr	r3, = _ebss
+	cmp	r2, r3
+	bcc	FillZerobss
+/* Call the clock system intitialization function.*/
+  bl  SystemInit
+/* Call the application's entry point.*/
+	bl	main
+	bx	lr
+.size	Reset_Handler, .-Reset_Handler
+
+/**
+ * @brief  This is the code that gets called when the processor receives an
+ *         unexpected interrupt. This simply enters an infinite loop, preserving
+ *         the system state for examination by a debugger.
+ * @param  None
+ * @retval None
+*/
+    .section	.text.Default_Handler,"ax",%progbits
+Default_Handler:
+Infinite_Loop:
+	b	Infinite_Loop
+	.size	Default_Handler, .-Default_Handler
+/******************************************************************************
+*
+* The minimal vector table for a Cortex M3.  Note that the proper constructs
+* must be placed on this to ensure that it ends up at physical address
+* 0x0000.0000.
+*
+******************************************************************************/
+	.section	.isr_vector,"a",%progbits
+	.type	g_pfnVectors, %object
+	.size	g_pfnVectors, .-g_pfnVectors
+
+
+g_pfnVectors:
+	.word	_estack
+	.word	Reset_Handler
+	.word	NMI_Handler
+	.word	HardFault_Handler
+	.word	MemManage_Handler
+	.word	BusFault_Handler
+	.word	UsageFault_Handler
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	SVC_Handler
+	.word	DebugMon_Handler
+	.word	0
+	.word	PendSV_Handler
+	.word	SysTick_Handler
+	.word	WWDG_IRQHandler
+	.word	PVD_IRQHandler
+	.word	TAMPER_IRQHandler
+	.word	RTC_IRQHandler
+	.word	FLASH_IRQHandler
+	.word	RCC_IRQHandler
+	.word	EXTI0_IRQHandler
+	.word	EXTI1_IRQHandler
+	.word	EXTI2_IRQHandler
+	.word	EXTI3_IRQHandler
+	.word	EXTI4_IRQHandler
+	.word	DMA1_Channel1_IRQHandler
+	.word	DMA1_Channel2_IRQHandler
+	.word	DMA1_Channel3_IRQHandler
+	.word	DMA1_Channel4_IRQHandler
+	.word	DMA1_Channel5_IRQHandler
+	.word	DMA1_Channel6_IRQHandler
+	.word	DMA1_Channel7_IRQHandler
+	.word	ADC1_2_IRQHandler
+	.word	USB_HP_CAN1_TX_IRQHandler
+	.word	USB_LP_CAN1_RX0_IRQHandler
+	.word	CAN1_RX1_IRQHandler
+	.word	CAN1_SCE_IRQHandler
+	.word	EXTI9_5_IRQHandler
+	.word	TIM1_BRK_IRQHandler
+	.word	TIM1_UP_IRQHandler
+	.word	TIM1_TRG_COM_IRQHandler
+	.word	TIM1_CC_IRQHandler
+	.word	TIM2_IRQHandler
+	.word	TIM3_IRQHandler
+	.word	TIM4_IRQHandler
+	.word	I2C1_EV_IRQHandler
+	.word	I2C1_ER_IRQHandler
+	.word	I2C2_EV_IRQHandler
+	.word	I2C2_ER_IRQHandler
+	.word	SPI1_IRQHandler
+	.word	SPI2_IRQHandler
+	.word	USART1_IRQHandler
+	.word	USART2_IRQHandler
+	.word	USART3_IRQHandler
+	.word	EXTI15_10_IRQHandler
+	.word	RTCAlarm_IRQHandler
+	.word	USBWakeUp_IRQHandler
+  .word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	BootRAM          /* @0x108. This is for boot in RAM mode for
+                            STM32F10x Medium Density devices. */
+
+/*******************************************************************************
+*
+* Provide weak aliases for each Exception handler to the Default_Handler.
+* As they are weak aliases, any function with the same name will override
+* this definition.
+*
+*******************************************************************************/
+
+  .weak	NMI_Handler
+	.thumb_set NMI_Handler,Default_Handler
+
+  .weak	HardFault_Handler
+	.thumb_set HardFault_Handler,Default_Handler
+
+  .weak	MemManage_Handler
+	.thumb_set MemManage_Handler,Default_Handler
+
+  .weak	BusFault_Handler
+	.thumb_set BusFault_Handler,Default_Handler
+
+	.weak	UsageFault_Handler
+	.thumb_set UsageFault_Handler,Default_Handler
+
+	.weak	SVC_Handler
+	.thumb_set SVC_Handler,Default_Handler
+
+	.weak	DebugMon_Handler
+	.thumb_set DebugMon_Handler,Default_Handler
+
+	.weak	PendSV_Handler
+	.thumb_set PendSV_Handler,Default_Handler
+
+	.weak	SysTick_Handler
+	.thumb_set SysTick_Handler,Default_Handler
+
+	.weak	WWDG_IRQHandler
+	.thumb_set WWDG_IRQHandler,Default_Handler
+
+	.weak	PVD_IRQHandler
+	.thumb_set PVD_IRQHandler,Default_Handler
+
+	.weak	TAMPER_IRQHandler
+	.thumb_set TAMPER_IRQHandler,Default_Handler
+
+	.weak	RTC_IRQHandler
+	.thumb_set RTC_IRQHandler,Default_Handler
+
+	.weak	FLASH_IRQHandler
+	.thumb_set FLASH_IRQHandler,Default_Handler
+
+	.weak	RCC_IRQHandler
+	.thumb_set RCC_IRQHandler,Default_Handler
+
+	.weak	EXTI0_IRQHandler
+	.thumb_set EXTI0_IRQHandler,Default_Handler
+
+	.weak	EXTI1_IRQHandler
+	.thumb_set EXTI1_IRQHandler,Default_Handler
+
+	.weak	EXTI2_IRQHandler
+	.thumb_set EXTI2_IRQHandler,Default_Handler
+
+	.weak	EXTI3_IRQHandler
+	.thumb_set EXTI3_IRQHandler,Default_Handler
+
+	.weak	EXTI4_IRQHandler
+	.thumb_set EXTI4_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel1_IRQHandler
+	.thumb_set DMA1_Channel1_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel2_IRQHandler
+	.thumb_set DMA1_Channel2_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel3_IRQHandler
+	.thumb_set DMA1_Channel3_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel4_IRQHandler
+	.thumb_set DMA1_Channel4_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel5_IRQHandler
+	.thumb_set DMA1_Channel5_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel6_IRQHandler
+	.thumb_set DMA1_Channel6_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel7_IRQHandler
+	.thumb_set DMA1_Channel7_IRQHandler,Default_Handler
+
+	.weak	ADC1_2_IRQHandler
+	.thumb_set ADC1_2_IRQHandler,Default_Handler
+
+	.weak	USB_HP_CAN1_TX_IRQHandler
+	.thumb_set USB_HP_CAN1_TX_IRQHandler,Default_Handler
+
+	.weak	USB_LP_CAN1_RX0_IRQHandler
+	.thumb_set USB_LP_CAN1_RX0_IRQHandler,Default_Handler
+
+	.weak	CAN1_RX1_IRQHandler
+	.thumb_set CAN1_RX1_IRQHandler,Default_Handler
+
+	.weak	CAN1_SCE_IRQHandler
+	.thumb_set CAN1_SCE_IRQHandler,Default_Handler
+
+	.weak	EXTI9_5_IRQHandler
+	.thumb_set EXTI9_5_IRQHandler,Default_Handler
+
+	.weak	TIM1_BRK_IRQHandler
+	.thumb_set TIM1_BRK_IRQHandler,Default_Handler
+
+	.weak	TIM1_UP_IRQHandler
+	.thumb_set TIM1_UP_IRQHandler,Default_Handler
+
+	.weak	TIM1_TRG_COM_IRQHandler
+	.thumb_set TIM1_TRG_COM_IRQHandler,Default_Handler
+
+	.weak	TIM1_CC_IRQHandler
+	.thumb_set TIM1_CC_IRQHandler,Default_Handler
+
+	.weak	TIM2_IRQHandler
+	.thumb_set TIM2_IRQHandler,Default_Handler
+
+	.weak	TIM3_IRQHandler
+	.thumb_set TIM3_IRQHandler,Default_Handler
+
+	.weak	TIM4_IRQHandler
+	.thumb_set TIM4_IRQHandler,Default_Handler
+
+	.weak	I2C1_EV_IRQHandler
+	.thumb_set I2C1_EV_IRQHandler,Default_Handler
+
+	.weak	I2C1_ER_IRQHandler
+	.thumb_set I2C1_ER_IRQHandler,Default_Handler
+
+	.weak	I2C2_EV_IRQHandler
+	.thumb_set I2C2_EV_IRQHandler,Default_Handler
+
+	.weak	I2C2_ER_IRQHandler
+	.thumb_set I2C2_ER_IRQHandler,Default_Handler
+
+	.weak	SPI1_IRQHandler
+	.thumb_set SPI1_IRQHandler,Default_Handler
+
+	.weak	SPI2_IRQHandler
+	.thumb_set SPI2_IRQHandler,Default_Handler
+
+	.weak	USART1_IRQHandler
+	.thumb_set USART1_IRQHandler,Default_Handler
+
+	.weak	USART2_IRQHandler
+	.thumb_set USART2_IRQHandler,Default_Handler
+
+	.weak	USART3_IRQHandler
+	.thumb_set USART3_IRQHandler,Default_Handler
+
+	.weak	EXTI15_10_IRQHandler
+	.thumb_set EXTI15_10_IRQHandler,Default_Handler
+
+	.weak	RTCAlarm_IRQHandler
+	.thumb_set RTCAlarm_IRQHandler,Default_Handler
+
+	.weak	USBWakeUp_IRQHandler
+	.thumb_set USBWakeUp_IRQHandler,Default_Handler
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_md_vl.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_md_vl.s
new file mode 100644
index 0000000..8bce997
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_md_vl.s
@@ -0,0 +1,399 @@
+/**
+  ******************************************************************************
+  * @file      startup_stm32f10x_md_vl.s
+  * @author    MCD Application Team
+  * @version   V3.5.0
+  * @date      11-March-2011
+  * @brief     STM32F10x Medium Density Value Line Devices vector table for RIDE7
+  *            toolchain.
+  *            This module performs:
+  *                - Set the initial SP
+  *                - Set the initial PC == Reset_Handler,
+  *                - Set the vector table entries with the exceptions ISR address
+  *                - Configure the clock system
+  *                - Branches to main in the C library (which eventually
+  *                  calls main()).
+  *            After Reset the Cortex-M3 processor is in Thread mode,
+  *            priority is Privileged, and the Stack is set to Main.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+  .syntax unified
+  .cpu cortex-m3
+  .fpu softvfp
+  .thumb
+
+.global  g_pfnVectors
+.global  Default_Handler
+
+/* start address for the initialization values of the .data section.
+defined in linker script */
+.word  _sidata
+/* start address for the .data section. defined in linker script */
+.word  _sdata
+/* end address for the .data section. defined in linker script */
+.word  _edata
+/* start address for the .bss section. defined in linker script */
+.word  _sbss
+/* end address for the .bss section. defined in linker script */
+.word  _ebss
+
+.equ  BootRAM, 0xF108F85F
+/**
+ * @brief  This is the code that gets called when the processor first
+ *          starts execution following a reset event. Only the absolutely
+ *          necessary set is performed, after which the application
+ *          supplied main() routine is called.
+ * @param  None
+ * @retval None
+*/
+
+  .section  .text.Reset_Handler
+  .weak  Reset_Handler
+  .type  Reset_Handler, %function
+Reset_Handler:
+
+/* Copy the data segment initializers from flash to SRAM */
+  movs  r1, #0
+  b     LoopCopyDataInit
+
+CopyDataInit:
+  ldr   r3, =_sidata
+  ldr   r3, [r3, r1]
+  str   r3, [r0, r1]
+  adds  r1, r1, #4
+
+LoopCopyDataInit:
+  ldr   r0, =_sdata
+  ldr   r3, =_edata
+  adds  r2, r0, r1
+  cmp   r2, r3
+  bcc   CopyDataInit
+  ldr   r2, =_sbss
+  b     LoopFillZerobss
+/* Zero fill the bss segment. */
+FillZerobss:
+  movs  r3, #0
+  str   r3, [r2], #4
+
+LoopFillZerobss:
+  ldr   r3, = _ebss
+  cmp   r2, r3
+  bcc   FillZerobss
+/* Call the clock system intitialization function.*/
+  bl  SystemInit
+/* Call the application's entry point.*/
+  bl    main
+  bx    lr
+.size   Reset_Handler, .-Reset_Handler
+
+/**
+ * @brief  This is the code that gets called when the processor receives an
+ *         unexpected interrupt. This simply enters an infinite loop, preserving
+ *         the system state for examination by a debugger.
+ * @param  None
+ * @retval None
+*/
+  .section  .text.Default_Handler,"ax",%progbits
+Default_Handler:
+Infinite_Loop:
+  b  Infinite_Loop
+  .size  Default_Handler, .-Default_Handler
+/******************************************************************************
+*
+* The minimal vector table for a Cortex M3. Note that the proper constructs
+* must be placed on this to ensure that it ends up at physical address
+* 0x0000.0000.
+*
+******************************************************************************/
+  .section  .isr_vector,"a",%progbits
+  .type  g_pfnVectors, %object
+  .size  g_pfnVectors, .-g_pfnVectors
+
+g_pfnVectors:
+  .word  _estack
+  .word  Reset_Handler
+  .word  NMI_Handler
+  .word  HardFault_Handler
+  .word  MemManage_Handler
+  .word  BusFault_Handler
+  .word  UsageFault_Handler
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  SVC_Handler
+  .word  DebugMon_Handler
+  .word  0
+  .word  PendSV_Handler
+  .word  SysTick_Handler
+  .word  WWDG_IRQHandler
+  .word  PVD_IRQHandler
+  .word  TAMPER_IRQHandler
+  .word  RTC_IRQHandler
+  .word  FLASH_IRQHandler
+  .word  RCC_IRQHandler
+  .word  EXTI0_IRQHandler
+  .word  EXTI1_IRQHandler
+  .word  EXTI2_IRQHandler
+  .word  EXTI3_IRQHandler
+  .word  EXTI4_IRQHandler
+  .word  DMA1_Channel1_IRQHandler
+  .word  DMA1_Channel2_IRQHandler
+  .word  DMA1_Channel3_IRQHandler
+  .word  DMA1_Channel4_IRQHandler
+  .word  DMA1_Channel5_IRQHandler
+  .word  DMA1_Channel6_IRQHandler
+  .word  DMA1_Channel7_IRQHandler
+  .word  ADC1_IRQHandler
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  EXTI9_5_IRQHandler
+  .word  TIM1_BRK_TIM15_IRQHandler
+  .word  TIM1_UP_TIM16_IRQHandler
+  .word  TIM1_TRG_COM_TIM17_IRQHandler
+  .word  TIM1_CC_IRQHandler
+  .word  TIM2_IRQHandler
+  .word  TIM3_IRQHandler
+  .word  TIM4_IRQHandler
+  .word  I2C1_EV_IRQHandler
+  .word  I2C1_ER_IRQHandler
+  .word  I2C2_EV_IRQHandler
+  .word  I2C2_ER_IRQHandler
+  .word  SPI1_IRQHandler
+  .word  SPI2_IRQHandler
+  .word  USART1_IRQHandler
+  .word  USART2_IRQHandler
+  .word  USART3_IRQHandler
+  .word  EXTI15_10_IRQHandler
+  .word  RTCAlarm_IRQHandler
+  .word  CEC_IRQHandler
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  TIM6_DAC_IRQHandler
+  .word  TIM7_IRQHandler
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  BootRAM          /* @0x01CC. This is for boot in RAM mode for
+                            STM32F10x Medium Value Line Density devices. */
+
+/*******************************************************************************
+* Provide weak aliases for each Exception handler to the Default_Handler.
+* As they are weak aliases, any function with the same name will override
+* this definition.
+*******************************************************************************/
+
+  .weak  NMI_Handler
+  .thumb_set NMI_Handler,Default_Handler
+
+  .weak  HardFault_Handler
+  .thumb_set HardFault_Handler,Default_Handler
+
+  .weak  MemManage_Handler
+  .thumb_set MemManage_Handler,Default_Handler
+
+  .weak  BusFault_Handler
+  .thumb_set BusFault_Handler,Default_Handler
+
+  .weak  UsageFault_Handler
+  .thumb_set UsageFault_Handler,Default_Handler
+
+  .weak  SVC_Handler
+  .thumb_set SVC_Handler,Default_Handler
+
+  .weak  DebugMon_Handler
+  .thumb_set DebugMon_Handler,Default_Handler
+
+  .weak  PendSV_Handler
+  .thumb_set PendSV_Handler,Default_Handler
+
+  .weak  SysTick_Handler
+  .thumb_set SysTick_Handler,Default_Handler
+
+  .weak  WWDG_IRQHandler
+  .thumb_set WWDG_IRQHandler,Default_Handler
+
+  .weak  PVD_IRQHandler
+  .thumb_set PVD_IRQHandler,Default_Handler
+
+  .weak  TAMPER_IRQHandler
+  .thumb_set TAMPER_IRQHandler,Default_Handler
+
+  .weak  RTC_IRQHandler
+  .thumb_set RTC_IRQHandler,Default_Handler
+
+  .weak  FLASH_IRQHandler
+  .thumb_set FLASH_IRQHandler,Default_Handler
+
+  .weak  RCC_IRQHandler
+  .thumb_set RCC_IRQHandler,Default_Handler
+
+  .weak  EXTI0_IRQHandler
+  .thumb_set EXTI0_IRQHandler,Default_Handler
+
+  .weak  EXTI1_IRQHandler
+  .thumb_set EXTI1_IRQHandler,Default_Handler
+
+  .weak  EXTI2_IRQHandler
+  .thumb_set EXTI2_IRQHandler,Default_Handler
+
+  .weak  EXTI3_IRQHandler
+  .thumb_set EXTI3_IRQHandler,Default_Handler
+
+  .weak  EXTI4_IRQHandler
+  .thumb_set EXTI4_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel1_IRQHandler
+  .thumb_set DMA1_Channel1_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel2_IRQHandler
+  .thumb_set DMA1_Channel2_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel3_IRQHandler
+  .thumb_set DMA1_Channel3_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel4_IRQHandler
+  .thumb_set DMA1_Channel4_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel5_IRQHandler
+  .thumb_set DMA1_Channel5_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel6_IRQHandler
+  .thumb_set DMA1_Channel6_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel7_IRQHandler
+  .thumb_set DMA1_Channel7_IRQHandler,Default_Handler
+
+  .weak  ADC1_IRQHandler
+  .thumb_set ADC1_IRQHandler,Default_Handler
+
+  .weak  EXTI9_5_IRQHandler
+  .thumb_set EXTI9_5_IRQHandler,Default_Handler
+
+  .weak  TIM1_BRK_TIM15_IRQHandler
+  .thumb_set TIM1_BRK_TIM15_IRQHandler,Default_Handler
+
+  .weak  TIM1_UP_TIM16_IRQHandler
+  .thumb_set TIM1_UP_TIM16_IRQHandler,Default_Handler
+
+  .weak  TIM1_TRG_COM_TIM17_IRQHandler
+  .thumb_set TIM1_TRG_COM_TIM17_IRQHandler,Default_Handler
+
+  .weak  TIM1_CC_IRQHandler
+  .thumb_set TIM1_CC_IRQHandler,Default_Handler
+
+  .weak  TIM2_IRQHandler
+  .thumb_set TIM2_IRQHandler,Default_Handler
+
+  .weak  TIM3_IRQHandler
+  .thumb_set TIM3_IRQHandler,Default_Handler
+
+  .weak  TIM4_IRQHandler
+  .thumb_set TIM4_IRQHandler,Default_Handler
+
+  .weak  I2C1_EV_IRQHandler
+  .thumb_set I2C1_EV_IRQHandler,Default_Handler
+
+  .weak  I2C1_ER_IRQHandler
+  .thumb_set I2C1_ER_IRQHandler,Default_Handler
+
+  .weak  I2C2_EV_IRQHandler
+  .thumb_set I2C2_EV_IRQHandler,Default_Handler
+
+  .weak  I2C2_ER_IRQHandler
+  .thumb_set I2C2_ER_IRQHandler,Default_Handler
+
+  .weak  SPI1_IRQHandler
+  .thumb_set SPI1_IRQHandler,Default_Handler
+
+  .weak  SPI2_IRQHandler
+  .thumb_set SPI2_IRQHandler,Default_Handler
+
+  .weak  USART1_IRQHandler
+  .thumb_set USART1_IRQHandler,Default_Handler
+
+  .weak  USART2_IRQHandler
+  .thumb_set USART2_IRQHandler,Default_Handler
+
+  .weak  USART3_IRQHandler
+  .thumb_set USART3_IRQHandler,Default_Handler
+
+  .weak  EXTI15_10_IRQHandler
+  .thumb_set EXTI15_10_IRQHandler,Default_Handler
+
+  .weak  RTCAlarm_IRQHandler
+  .thumb_set RTCAlarm_IRQHandler,Default_Handler
+
+  .weak  CEC_IRQHandler
+  .thumb_set CEC_IRQHandler,Default_Handler
+
+  .weak  TIM6_DAC_IRQHandler
+  .thumb_set TIM6_DAC_IRQHandler,Default_Handler
+
+  .weak  TIM7_IRQHandler
+  .thumb_set TIM7_IRQHandler,Default_Handler
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_xl.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_xl.s
new file mode 100644
index 0000000..3d727a0
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_xl.s
@@ -0,0 +1,465 @@
+/**
+  ******************************************************************************
+  * @file      startup_stm32f10x_xl.s
+  * @author    MCD Application Team
+  * @version   V3.5.0
+  * @date      11-March-2011
+  * @brief     STM32F10x XL-Density Devices vector table for RIDE7 toolchain.
+  *            This module performs:
+  *                - Set the initial SP
+  *                - Set the initial PC == Reset_Handler,
+  *                - Set the vector table entries with the exceptions ISR address
+  *                - Configure the clock system and the external SRAM mounted on
+  *                  STM3210E-EVAL board to be used as data memory (optional,
+  *                  to be enabled by user)
+  *                - Branches to main in the C library (which eventually
+  *                  calls main()).
+  *            After Reset the Cortex-M3 processor is in Thread mode,
+  *            priority is Privileged, and the Stack is set to Main.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+  .syntax unified
+  .cpu cortex-m3
+  .fpu softvfp
+  .thumb
+
+.global  g_pfnVectors
+.global  Default_Handler
+
+/* start address for the initialization values of the .data section.
+defined in linker script */
+.word  _sidata
+/* start address for the .data section. defined in linker script */
+.word  _sdata
+/* end address for the .data section. defined in linker script */
+.word  _edata
+/* start address for the .bss section. defined in linker script */
+.word  _sbss
+/* end address for the .bss section. defined in linker script */
+.word  _ebss
+/* stack used for SystemInit_ExtMemCtl; always internal RAM used */
+
+.equ  BootRAM,        0xF1E0F85F
+/**
+ * @brief  This is the code that gets called when the processor first
+ *          starts execution following a reset event. Only the absolutely
+ *          necessary set is performed, after which the application
+ *          supplied main() routine is called.
+ * @param  None
+ * @retval : None
+*/
+
+    .section  .text.Reset_Handler
+  .weak  Reset_Handler
+  .type  Reset_Handler, %function
+Reset_Handler:
+
+/* Copy the data segment initializers from flash to SRAM */
+  movs  r1, #0
+  b  LoopCopyDataInit
+
+CopyDataInit:
+  ldr  r3, =_sidata
+  ldr  r3, [r3, r1]
+  str  r3, [r0, r1]
+  adds  r1, r1, #4
+
+LoopCopyDataInit:
+  ldr  r0, =_sdata
+  ldr  r3, =_edata
+  adds  r2, r0, r1
+  cmp  r2, r3
+  bcc  CopyDataInit
+  ldr  r2, =_sbss
+  b  LoopFillZerobss
+/* Zero fill the bss segment. */
+FillZerobss:
+  movs  r3, #0
+  str  r3, [r2], #4
+
+LoopFillZerobss:
+  ldr  r3, = _ebss
+  cmp  r2, r3
+  bcc  FillZerobss
+/* Call the clock system intitialization function.*/
+  bl  SystemInit
+/* Call the application's entry point.*/
+  bl  main
+  bx  lr
+.size  Reset_Handler, .-Reset_Handler
+
+/**
+ * @brief  This is the code that gets called when the processor receives an
+ *         unexpected interrupt.  This simply enters an infinite loop, preserving
+ *         the system state for examination by a debugger.
+ * @param  None
+ * @retval None
+*/
+    .section  .text.Default_Handler,"ax",%progbits
+Default_Handler:
+Infinite_Loop:
+  b  Infinite_Loop
+  .size  Default_Handler, .-Default_Handler
+/******************************************************************************
+*
+* The minimal vector table for a Cortex M3. Note that the proper constructs
+* must be placed on this to ensure that it ends up at physical address
+* 0x0000.0000.
+*
+*******************************************************************************/
+   .section  .isr_vector,"a",%progbits
+  .type  g_pfnVectors, %object
+  .size  g_pfnVectors, .-g_pfnVectors
+
+
+g_pfnVectors:
+  .word  _estack
+  .word  Reset_Handler
+  .word  NMI_Handler
+  .word  HardFault_Handler
+  .word  MemManage_Handler
+  .word  BusFault_Handler
+  .word  UsageFault_Handler
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  SVC_Handler
+  .word  DebugMon_Handler
+  .word  0
+  .word  PendSV_Handler
+  .word  SysTick_Handler
+  .word  WWDG_IRQHandler
+  .word  PVD_IRQHandler
+  .word  TAMPER_IRQHandler
+  .word  RTC_IRQHandler
+  .word  FLASH_IRQHandler
+  .word  RCC_IRQHandler
+  .word  EXTI0_IRQHandler
+  .word  EXTI1_IRQHandler
+  .word  EXTI2_IRQHandler
+  .word  EXTI3_IRQHandler
+  .word  EXTI4_IRQHandler
+  .word  DMA1_Channel1_IRQHandler
+  .word  DMA1_Channel2_IRQHandler
+  .word  DMA1_Channel3_IRQHandler
+  .word  DMA1_Channel4_IRQHandler
+  .word  DMA1_Channel5_IRQHandler
+  .word  DMA1_Channel6_IRQHandler
+  .word  DMA1_Channel7_IRQHandler
+  .word  ADC1_2_IRQHandler
+  .word  USB_HP_CAN1_TX_IRQHandler
+  .word  USB_LP_CAN1_RX0_IRQHandler
+  .word  CAN1_RX1_IRQHandler
+  .word  CAN1_SCE_IRQHandler
+  .word  EXTI9_5_IRQHandler
+  .word  TIM1_BRK_TIM9_IRQHandler
+  .word  TIM1_UP_TIM10_IRQHandler
+  .word  TIM1_TRG_COM_TIM11_IRQHandler
+  .word  TIM1_CC_IRQHandler
+  .word  TIM2_IRQHandler
+  .word  TIM3_IRQHandler
+  .word  TIM4_IRQHandler
+  .word  I2C1_EV_IRQHandler
+  .word  I2C1_ER_IRQHandler
+  .word  I2C2_EV_IRQHandler
+  .word  I2C2_ER_IRQHandler
+  .word  SPI1_IRQHandler
+  .word  SPI2_IRQHandler
+  .word  USART1_IRQHandler
+  .word  USART2_IRQHandler
+  .word  USART3_IRQHandler
+  .word  EXTI15_10_IRQHandler
+  .word  RTCAlarm_IRQHandler
+  .word  USBWakeUp_IRQHandler
+  .word  TIM8_BRK_TIM12_IRQHandler
+  .word  TIM8_UP_TIM13_IRQHandler
+  .word  TIM8_TRG_COM_TIM14_IRQHandler
+  .word  TIM8_CC_IRQHandler
+  .word  ADC3_IRQHandler
+  .word  FSMC_IRQHandler
+  .word  SDIO_IRQHandler
+  .word  TIM5_IRQHandler
+  .word  SPI3_IRQHandler
+  .word  UART4_IRQHandler
+  .word  UART5_IRQHandler
+  .word  TIM6_IRQHandler
+  .word  TIM7_IRQHandler
+  .word  DMA2_Channel1_IRQHandler
+  .word  DMA2_Channel2_IRQHandler
+  .word  DMA2_Channel3_IRQHandler
+  .word  DMA2_Channel4_5_IRQHandler
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  BootRAM       /* @0x1E0. This is for boot in RAM mode for
+                         STM32F10x XL Density devices. */
+/*******************************************************************************
+*
+* Provide weak aliases for each Exception handler to the Default_Handler.
+* As they are weak aliases, any function with the same name will override
+* this definition.
+*
+*******************************************************************************/
+
+  .weak  NMI_Handler
+  .thumb_set NMI_Handler,Default_Handler
+
+  .weak  HardFault_Handler
+  .thumb_set HardFault_Handler,Default_Handler
+
+  .weak  MemManage_Handler
+  .thumb_set MemManage_Handler,Default_Handler
+
+  .weak  BusFault_Handler
+  .thumb_set BusFault_Handler,Default_Handler
+
+  .weak  UsageFault_Handler
+  .thumb_set UsageFault_Handler,Default_Handler
+
+  .weak  SVC_Handler
+  .thumb_set SVC_Handler,Default_Handler
+
+  .weak  DebugMon_Handler
+  .thumb_set DebugMon_Handler,Default_Handler
+
+  .weak  PendSV_Handler
+  .thumb_set PendSV_Handler,Default_Handler
+
+  .weak  SysTick_Handler
+  .thumb_set SysTick_Handler,Default_Handler
+
+  .weak  WWDG_IRQHandler
+  .thumb_set WWDG_IRQHandler,Default_Handler
+
+  .weak  PVD_IRQHandler
+  .thumb_set PVD_IRQHandler,Default_Handler
+
+  .weak  TAMPER_IRQHandler
+  .thumb_set TAMPER_IRQHandler,Default_Handler
+
+  .weak  RTC_IRQHandler
+  .thumb_set RTC_IRQHandler,Default_Handler
+
+  .weak  FLASH_IRQHandler
+  .thumb_set FLASH_IRQHandler,Default_Handler
+
+  .weak  RCC_IRQHandler
+  .thumb_set RCC_IRQHandler,Default_Handler
+
+  .weak  EXTI0_IRQHandler
+  .thumb_set EXTI0_IRQHandler,Default_Handler
+
+  .weak  EXTI1_IRQHandler
+  .thumb_set EXTI1_IRQHandler,Default_Handler
+
+  .weak  EXTI2_IRQHandler
+  .thumb_set EXTI2_IRQHandler,Default_Handler
+
+  .weak  EXTI3_IRQHandler
+  .thumb_set EXTI3_IRQHandler,Default_Handler
+
+  .weak  EXTI4_IRQHandler
+  .thumb_set EXTI4_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel1_IRQHandler
+  .thumb_set DMA1_Channel1_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel2_IRQHandler
+  .thumb_set DMA1_Channel2_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel3_IRQHandler
+  .thumb_set DMA1_Channel3_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel4_IRQHandler
+  .thumb_set DMA1_Channel4_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel5_IRQHandler
+  .thumb_set DMA1_Channel5_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel6_IRQHandler
+  .thumb_set DMA1_Channel6_IRQHandler,Default_Handler
+
+  .weak  DMA1_Channel7_IRQHandler
+  .thumb_set DMA1_Channel7_IRQHandler,Default_Handler
+
+  .weak  ADC1_2_IRQHandler
+  .thumb_set ADC1_2_IRQHandler,Default_Handler
+
+  .weak  USB_HP_CAN1_TX_IRQHandler
+  .thumb_set USB_HP_CAN1_TX_IRQHandler,Default_Handler
+
+  .weak  USB_LP_CAN1_RX0_IRQHandler
+  .thumb_set USB_LP_CAN1_RX0_IRQHandler,Default_Handler
+
+  .weak  CAN1_RX1_IRQHandler
+  .thumb_set CAN1_RX1_IRQHandler,Default_Handler
+
+  .weak  CAN1_SCE_IRQHandler
+  .thumb_set CAN1_SCE_IRQHandler,Default_Handler
+
+  .weak  EXTI9_5_IRQHandler
+  .thumb_set EXTI9_5_IRQHandler,Default_Handler
+
+  .weak  TIM1_BRK_TIM9_IRQHandler
+  .thumb_set TIM1_BRK_TIM9_IRQHandler,Default_Handler
+
+  .weak  TIM1_UP_TIM10_IRQHandler
+  .thumb_set TIM1_UP_TIM10_IRQHandler,Default_Handler
+
+  .weak  TIM1_TRG_COM_TIM11_IRQHandler
+  .thumb_set TIM1_TRG_COM_TIM11_IRQHandler,Default_Handler
+
+  .weak  TIM1_CC_IRQHandler
+  .thumb_set TIM1_CC_IRQHandler,Default_Handler
+
+  .weak  TIM2_IRQHandler
+  .thumb_set TIM2_IRQHandler,Default_Handler
+
+  .weak  TIM3_IRQHandler
+  .thumb_set TIM3_IRQHandler,Default_Handler
+
+  .weak  TIM4_IRQHandler
+  .thumb_set TIM4_IRQHandler,Default_Handler
+
+  .weak  I2C1_EV_IRQHandler
+  .thumb_set I2C1_EV_IRQHandler,Default_Handler
+
+  .weak  I2C1_ER_IRQHandler
+  .thumb_set I2C1_ER_IRQHandler,Default_Handler
+
+  .weak  I2C2_EV_IRQHandler
+  .thumb_set I2C2_EV_IRQHandler,Default_Handler
+
+  .weak  I2C2_ER_IRQHandler
+  .thumb_set I2C2_ER_IRQHandler,Default_Handler
+
+  .weak  SPI1_IRQHandler
+  .thumb_set SPI1_IRQHandler,Default_Handler
+
+  .weak  SPI2_IRQHandler
+  .thumb_set SPI2_IRQHandler,Default_Handler
+
+  .weak  USART1_IRQHandler
+  .thumb_set USART1_IRQHandler,Default_Handler
+
+  .weak  USART2_IRQHandler
+  .thumb_set USART2_IRQHandler,Default_Handler
+
+  .weak  USART3_IRQHandler
+  .thumb_set USART3_IRQHandler,Default_Handler
+
+  .weak  EXTI15_10_IRQHandler
+  .thumb_set EXTI15_10_IRQHandler,Default_Handler
+
+  .weak  RTCAlarm_IRQHandler
+  .thumb_set RTCAlarm_IRQHandler,Default_Handler
+
+  .weak  USBWakeUp_IRQHandler
+  .thumb_set USBWakeUp_IRQHandler,Default_Handler
+
+  .weak  TIM8_BRK_TIM12_IRQHandler
+  .thumb_set TIM8_BRK_TIM12_IRQHandler,Default_Handler
+
+  .weak  TIM8_UP_TIM13_IRQHandler
+  .thumb_set TIM8_UP_TIM13_IRQHandler,Default_Handler
+
+  .weak  TIM8_TRG_COM_TIM14_IRQHandler
+  .thumb_set TIM8_TRG_COM_TIM14_IRQHandler,Default_Handler
+
+  .weak  TIM8_CC_IRQHandler
+  .thumb_set TIM8_CC_IRQHandler,Default_Handler
+
+  .weak  ADC3_IRQHandler
+  .thumb_set ADC3_IRQHandler,Default_Handler
+
+  .weak  FSMC_IRQHandler
+  .thumb_set FSMC_IRQHandler,Default_Handler
+
+  .weak  SDIO_IRQHandler
+  .thumb_set SDIO_IRQHandler,Default_Handler
+
+  .weak  TIM5_IRQHandler
+  .thumb_set TIM5_IRQHandler,Default_Handler
+
+  .weak  SPI3_IRQHandler
+  .thumb_set SPI3_IRQHandler,Default_Handler
+
+  .weak  UART4_IRQHandler
+  .thumb_set UART4_IRQHandler,Default_Handler
+
+  .weak  UART5_IRQHandler
+  .thumb_set UART5_IRQHandler,Default_Handler
+
+  .weak  TIM6_IRQHandler
+  .thumb_set TIM6_IRQHandler,Default_Handler
+
+  .weak  TIM7_IRQHandler
+  .thumb_set TIM7_IRQHandler,Default_Handler
+
+  .weak  DMA2_Channel1_IRQHandler
+  .thumb_set DMA2_Channel1_IRQHandler,Default_Handler
+
+  .weak  DMA2_Channel2_IRQHandler
+  .thumb_set DMA2_Channel2_IRQHandler,Default_Handler
+
+  .weak  DMA2_Channel3_IRQHandler
+  .thumb_set DMA2_Channel3_IRQHandler,Default_Handler
+
+  .weak  DMA2_Channel4_5_IRQHandler
+  .thumb_set DMA2_Channel4_5_IRQHandler,Default_Handler
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_cl.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_cl.s
new file mode 100644
index 0000000..55a7932
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_cl.s
@@ -0,0 +1,507 @@
+;******************** (C) COPYRIGHT 2011 STMicroelectronics *******************
+;* File Name          : startup_stm32f10x_cl.s
+;* Author             : MCD Application Team
+;* Version            : V3.5.0
+;* Date               : 11-March-2011
+;* Description        : STM32F10x Connectivity line devices vector table for
+;*                      EWARM toolchain.
+;*                      This module performs:
+;*                      - Set the initial SP
+;*                      - Configure the clock system
+;*                      - Set the initial PC == __iar_program_start,
+;*                      - Set the vector table entries with the exceptions ISR
+;*                        address.
+;*                      After Reset the Cortex-M3 processor is in Thread mode,
+;*                      priority is Privileged, and the Stack is set to Main.
+;********************************************************************************
+;* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+;* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+;* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+;* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+;* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+;* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+;*******************************************************************************
+;
+;
+; The modules in this file are included in the libraries, and may be replaced
+; by any user-defined modules that define the PUBLIC symbol _program_start or
+; a user defined start symbol.
+; To override the cstartup defined in the library, simply add your modified
+; version to the workbench project.
+;
+; The vector table is normally located at address 0.
+; When debugging in RAM, it can be located in RAM, aligned to at least 2^6.
+; The name "__vector_table" has special meaning for C-SPY:
+; it is where the SP start value is found, and the NVIC vector
+; table register (VTOR) is initialized to this address if != 0.
+;
+; Cortex-M version
+;
+
+        MODULE  ?cstartup
+
+        ;; Forward declaration of sections.
+        SECTION CSTACK:DATA:NOROOT(3)
+
+        SECTION .intvec:CODE:NOROOT(2)
+
+        EXTERN  __iar_program_start
+        EXTERN  SystemInit
+        PUBLIC  __vector_table
+
+        DATA
+__vector_table
+        DCD     sfe(CSTACK)
+        DCD     Reset_Handler             ; Reset Handler
+        DCD     NMI_Handler               ; NMI Handler
+        DCD     HardFault_Handler         ; Hard Fault Handler
+        DCD     MemManage_Handler         ; MPU Fault Handler
+        DCD     BusFault_Handler          ; Bus Fault Handler
+        DCD     UsageFault_Handler        ; Usage Fault Handler
+        DCD     0                         ; Reserved
+        DCD     0                         ; Reserved
+        DCD     0                         ; Reserved
+        DCD     0                         ; Reserved
+        DCD     SVC_Handler               ; SVCall Handler
+        DCD     DebugMon_Handler          ; Debug Monitor Handler
+        DCD     0                         ; Reserved
+        DCD     PendSV_Handler            ; PendSV Handler
+        DCD     SysTick_Handler           ; SysTick Handler
+
+         ; External Interrupts
+        DCD     WWDG_IRQHandler            ; Window Watchdog
+        DCD     PVD_IRQHandler             ; PVD through EXTI Line detect
+        DCD     TAMPER_IRQHandler          ; Tamper
+        DCD     RTC_IRQHandler             ; RTC
+        DCD     FLASH_IRQHandler           ; Flash
+        DCD     RCC_IRQHandler             ; RCC
+        DCD     EXTI0_IRQHandler           ; EXTI Line 0
+        DCD     EXTI1_IRQHandler           ; EXTI Line 1
+        DCD     EXTI2_IRQHandler           ; EXTI Line 2
+        DCD     EXTI3_IRQHandler           ; EXTI Line 3
+        DCD     EXTI4_IRQHandler           ; EXTI Line 4
+        DCD     DMA1_Channel1_IRQHandler   ; DMA1 Channel 1
+        DCD     DMA1_Channel2_IRQHandler   ; DMA1 Channel 2
+        DCD     DMA1_Channel3_IRQHandler   ; DMA1 Channel 3
+        DCD     DMA1_Channel4_IRQHandler   ; DMA1 Channel 4
+        DCD     DMA1_Channel5_IRQHandler   ; DMA1 Channel 5
+        DCD     DMA1_Channel6_IRQHandler   ; DMA1 Channel 6
+        DCD     DMA1_Channel7_IRQHandler   ; DMA1 Channel 7
+        DCD     ADC1_2_IRQHandler          ; ADC1 and ADC2
+        DCD     CAN1_TX_IRQHandler         ; CAN1 TX
+        DCD     CAN1_RX0_IRQHandler        ; CAN1 RX0
+        DCD     CAN1_RX1_IRQHandler        ; CAN1 RX1
+        DCD     CAN1_SCE_IRQHandler        ; CAN1 SCE
+        DCD     EXTI9_5_IRQHandler         ; EXTI Line 9..5
+        DCD     TIM1_BRK_IRQHandler        ; TIM1 Break
+        DCD     TIM1_UP_IRQHandler         ; TIM1 Update
+        DCD     TIM1_TRG_COM_IRQHandler    ; TIM1 Trigger and Commutation
+        DCD     TIM1_CC_IRQHandler         ; TIM1 Capture Compare
+        DCD     TIM2_IRQHandler            ; TIM2
+        DCD     TIM3_IRQHandler            ; TIM3
+        DCD     TIM4_IRQHandler            ; TIM4
+        DCD     I2C1_EV_IRQHandler         ; I2C1 Event
+        DCD     I2C1_ER_IRQHandler         ; I2C1 Error
+        DCD     I2C2_EV_IRQHandler         ; I2C2 Event
+        DCD     I2C2_ER_IRQHandler         ; I2C1 Error
+        DCD     SPI1_IRQHandler            ; SPI1
+        DCD     SPI2_IRQHandler            ; SPI2
+        DCD     USART1_IRQHandler          ; USART1
+        DCD     USART2_IRQHandler          ; USART2
+        DCD     USART3_IRQHandler          ; USART3
+        DCD     EXTI15_10_IRQHandler       ; EXTI Line 15..10
+        DCD     RTCAlarm_IRQHandler        ; RTC alarm through EXTI line
+        DCD     OTG_FS_WKUP_IRQHandler     ; USB OTG FS Wakeup through EXTI line
+        DCD     0                          ; Reserved
+        DCD     0                          ; Reserved
+        DCD     0                          ; Reserved
+        DCD     0                          ; Reserved
+        DCD     0                          ; Reserved
+        DCD     0                          ; Reserved
+        DCD     0                          ; Reserved
+        DCD     TIM5_IRQHandler            ; TIM5
+        DCD     SPI3_IRQHandler            ; SPI3
+        DCD     UART4_IRQHandler           ; UART4
+        DCD     UART5_IRQHandler           ; UART5
+        DCD     TIM6_IRQHandler            ; TIM6
+        DCD     TIM7_IRQHandler            ; TIM7
+        DCD     DMA2_Channel1_IRQHandler   ; DMA2 Channel1
+        DCD     DMA2_Channel2_IRQHandler   ; DMA2 Channel2
+        DCD     DMA2_Channel3_IRQHandler   ; DMA2 Channel3
+        DCD     DMA2_Channel4_IRQHandler   ; DMA2 Channel4
+        DCD     DMA2_Channel5_IRQHandler   ; DMA2 Channel5
+        DCD     ETH_IRQHandler             ; Ethernet
+        DCD     ETH_WKUP_IRQHandler        ; Ethernet Wakeup through EXTI line
+        DCD     CAN2_TX_IRQHandler         ; CAN2 TX
+        DCD     CAN2_RX0_IRQHandler        ; CAN2 RX0
+        DCD     CAN2_RX1_IRQHandler        ; CAN2 RX1
+        DCD     CAN2_SCE_IRQHandler        ; CAN2 SCE
+        DCD     OTG_FS_IRQHandler          ; USB OTG FS
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;;
+;; Default interrupt handlers.
+;;
+        THUMB
+
+        PUBWEAK Reset_Handler
+        SECTION .text:CODE:REORDER(2)
+Reset_Handler
+        LDR     R0, =SystemInit
+        BLX     R0
+        LDR     R0, =__iar_program_start
+        BX      R0
+
+        PUBWEAK NMI_Handler
+        SECTION .text:CODE:REORDER(1)
+NMI_Handler
+        B NMI_Handler
+
+        PUBWEAK HardFault_Handler
+        SECTION .text:CODE:REORDER(1)
+HardFault_Handler
+        B HardFault_Handler
+
+        PUBWEAK MemManage_Handler
+        SECTION .text:CODE:REORDER(1)
+MemManage_Handler
+        B MemManage_Handler
+
+        PUBWEAK BusFault_Handler
+        SECTION .text:CODE:REORDER(1)
+BusFault_Handler
+        B BusFault_Handler
+
+        PUBWEAK UsageFault_Handler
+        SECTION .text:CODE:REORDER(1)
+UsageFault_Handler
+        B UsageFault_Handler
+
+        PUBWEAK SVC_Handler
+        SECTION .text:CODE:REORDER(1)
+SVC_Handler
+        B SVC_Handler
+
+        PUBWEAK DebugMon_Handler
+        SECTION .text:CODE:REORDER(1)
+DebugMon_Handler
+        B DebugMon_Handler
+
+        PUBWEAK PendSV_Handler
+        SECTION .text:CODE:REORDER(1)
+PendSV_Handler
+        B PendSV_Handler
+
+        PUBWEAK SysTick_Handler
+        SECTION .text:CODE:REORDER(1)
+SysTick_Handler
+        B SysTick_Handler
+
+        PUBWEAK WWDG_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+WWDG_IRQHandler
+        B WWDG_IRQHandler
+
+        PUBWEAK PVD_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+PVD_IRQHandler
+        B PVD_IRQHandler
+
+        PUBWEAK TAMPER_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TAMPER_IRQHandler
+        B TAMPER_IRQHandler
+
+        PUBWEAK RTC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+RTC_IRQHandler
+        B RTC_IRQHandler
+
+        PUBWEAK FLASH_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+FLASH_IRQHandler
+        B FLASH_IRQHandler
+
+        PUBWEAK RCC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+RCC_IRQHandler
+        B RCC_IRQHandler
+
+        PUBWEAK EXTI0_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI0_IRQHandler
+        B EXTI0_IRQHandler
+
+        PUBWEAK EXTI1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI1_IRQHandler
+        B EXTI1_IRQHandler
+
+        PUBWEAK EXTI2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI2_IRQHandler
+        B EXTI2_IRQHandler
+
+        PUBWEAK EXTI3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI3_IRQHandler
+        B EXTI3_IRQHandler
+
+
+        PUBWEAK EXTI4_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI4_IRQHandler
+        B EXTI4_IRQHandler
+
+        PUBWEAK DMA1_Channel1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel1_IRQHandler
+        B DMA1_Channel1_IRQHandler
+
+        PUBWEAK DMA1_Channel2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel2_IRQHandler
+        B DMA1_Channel2_IRQHandler
+
+        PUBWEAK DMA1_Channel3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel3_IRQHandler
+        B DMA1_Channel3_IRQHandler
+
+        PUBWEAK DMA1_Channel4_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel4_IRQHandler
+        B DMA1_Channel4_IRQHandler
+
+        PUBWEAK DMA1_Channel5_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel5_IRQHandler
+        B DMA1_Channel5_IRQHandler
+
+        PUBWEAK DMA1_Channel6_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel6_IRQHandler
+        B DMA1_Channel6_IRQHandler
+
+        PUBWEAK DMA1_Channel7_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel7_IRQHandler
+        B DMA1_Channel7_IRQHandler
+
+        PUBWEAK ADC1_2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+ADC1_2_IRQHandler
+        B ADC1_2_IRQHandler
+
+        PUBWEAK CAN1_TX_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+CAN1_TX_IRQHandler
+        B CAN1_TX_IRQHandler
+
+        PUBWEAK CAN1_RX0_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+CAN1_RX0_IRQHandler
+        B CAN1_RX0_IRQHandler
+
+        PUBWEAK CAN1_RX1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+CAN1_RX1_IRQHandler
+        B CAN1_RX1_IRQHandler
+
+        PUBWEAK CAN1_SCE_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+CAN1_SCE_IRQHandler
+        B CAN1_SCE_IRQHandler
+
+        PUBWEAK EXTI9_5_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI9_5_IRQHandler
+        B EXTI9_5_IRQHandler
+
+        PUBWEAK TIM1_BRK_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_BRK_IRQHandler
+        B TIM1_BRK_IRQHandler
+
+        PUBWEAK TIM1_UP_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_UP_IRQHandler
+        B TIM1_UP_IRQHandler
+
+        PUBWEAK TIM1_TRG_COM_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_TRG_COM_IRQHandler
+        B TIM1_TRG_COM_IRQHandler
+
+        PUBWEAK TIM1_CC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_CC_IRQHandler
+        B TIM1_CC_IRQHandler
+
+        PUBWEAK TIM2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM2_IRQHandler
+        B TIM2_IRQHandler
+
+        PUBWEAK TIM3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM3_IRQHandler
+        B TIM3_IRQHandler
+
+        PUBWEAK TIM4_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM4_IRQHandler
+        B TIM4_IRQHandler
+
+        PUBWEAK I2C1_EV_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+I2C1_EV_IRQHandler
+        B I2C1_EV_IRQHandler
+
+        PUBWEAK I2C1_ER_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+I2C1_ER_IRQHandler
+        B I2C1_ER_IRQHandler
+
+        PUBWEAK I2C2_EV_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+I2C2_EV_IRQHandler
+        B I2C2_EV_IRQHandler
+
+        PUBWEAK I2C2_ER_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+I2C2_ER_IRQHandler
+        B I2C2_ER_IRQHandler
+
+        PUBWEAK SPI1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+SPI1_IRQHandler
+        B SPI1_IRQHandler
+
+        PUBWEAK SPI2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+SPI2_IRQHandler
+        B SPI2_IRQHandler
+
+        PUBWEAK USART1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USART1_IRQHandler
+        B USART1_IRQHandler
+
+        PUBWEAK USART2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USART2_IRQHandler
+        B USART2_IRQHandler
+
+        PUBWEAK USART3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USART3_IRQHandler
+        B USART3_IRQHandler
+
+        PUBWEAK EXTI15_10_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI15_10_IRQHandler
+        B EXTI15_10_IRQHandler
+
+        PUBWEAK RTCAlarm_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+RTCAlarm_IRQHandler
+        B RTCAlarm_IRQHandler
+
+        PUBWEAK OTG_FS_WKUP_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+OTG_FS_WKUP_IRQHandler
+        B OTG_FS_WKUP_IRQHandler
+
+        PUBWEAK TIM5_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM5_IRQHandler
+        B TIM5_IRQHandler
+
+        PUBWEAK SPI3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+SPI3_IRQHandler
+        B SPI3_IRQHandler
+
+        PUBWEAK UART4_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+UART4_IRQHandler
+        B UART4_IRQHandler
+
+        PUBWEAK UART5_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+UART5_IRQHandler
+        B UART5_IRQHandler
+
+        PUBWEAK TIM6_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM6_IRQHandler
+        B TIM6_IRQHandler
+
+        PUBWEAK TIM7_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM7_IRQHandler
+        B TIM7_IRQHandler
+
+        PUBWEAK DMA2_Channel1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA2_Channel1_IRQHandler
+        B DMA2_Channel1_IRQHandler
+
+        PUBWEAK DMA2_Channel2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA2_Channel2_IRQHandler
+        B DMA2_Channel2_IRQHandler
+
+        PUBWEAK DMA2_Channel3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA2_Channel3_IRQHandler
+        B DMA2_Channel3_IRQHandler
+
+        PUBWEAK DMA2_Channel4_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA2_Channel4_IRQHandler
+        B DMA2_Channel4_IRQHandler
+
+        PUBWEAK DMA2_Channel5_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA2_Channel5_IRQHandler
+        B DMA2_Channel5_IRQHandler
+
+        PUBWEAK ETH_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+ETH_IRQHandler
+        B ETH_IRQHandler
+
+        PUBWEAK ETH_WKUP_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+ETH_WKUP_IRQHandler
+        B ETH_WKUP_IRQHandler
+
+        PUBWEAK CAN2_TX_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+CAN2_TX_IRQHandler
+        B CAN2_TX_IRQHandler
+
+        PUBWEAK CAN2_RX0_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+CAN2_RX0_IRQHandler
+        B CAN2_RX0_IRQHandler
+
+        PUBWEAK CAN2_RX1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+CAN2_RX1_IRQHandler
+        B CAN2_RX1_IRQHandler
+
+        PUBWEAK CAN2_SCE_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+CAN2_SCE_IRQHandler
+        B CAN2_SCE_IRQHandler
+
+        PUBWEAK OTG_FS_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+OTG_FS_IRQHandler
+        B OTG_FS_IRQHandler
+
+        END
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_hd.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_hd.s
new file mode 100644
index 0000000..37ee7a2
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_hd.s
@@ -0,0 +1,496 @@
+;******************** (C) COPYRIGHT 2011 STMicroelectronics ********************
+;* File Name          : startup_stm32f10x_hd.s
+;* Author             : MCD Application Team
+;* Version            : V3.5.0
+;* Date               : 11-March-2011
+;* Description        : STM32F10x High Density Devices vector table for EWARM
+;*                      toolchain.
+;*                      This module performs:
+;*                      - Set the initial SP
+;*                      - Configure the clock system and the external SRAM
+;*                        mounted on STM3210E-EVAL board to be used as data
+;*                        memory (optional, to be enabled by user)
+;*                      - Set the initial PC == __iar_program_start,
+;*                      - Set the vector table entries with the exceptions ISR address,
+;*                      After Reset the Cortex-M3 processor is in Thread mode,
+;*                      priority is Privileged, and the Stack is set to Main.
+;********************************************************************************
+;* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+;* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+;* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+;* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+;* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+;* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+;*******************************************************************************
+;
+;
+; The modules in this file are included in the libraries, and may be replaced
+; by any user-defined modules that define the PUBLIC symbol _program_start or
+; a user defined start symbol.
+; To override the cstartup defined in the library, simply add your modified
+; version to the workbench project.
+;
+; The vector table is normally located at address 0.
+; When debugging in RAM, it can be located in RAM, aligned to at least 2^6.
+; The name "__vector_table" has special meaning for C-SPY:
+; it is where the SP start value is found, and the NVIC vector
+; table register (VTOR) is initialized to this address if != 0.
+;
+; Cortex-M version
+;
+
+    MODULE  ?cstartup
+
+        ;; Forward declaration of sections.
+        SECTION CSTACK:DATA:NOROOT(3)
+
+        SECTION .intvec:CODE:NOROOT(2)
+
+        EXTERN  __iar_program_start
+        EXTERN  SystemInit
+        PUBLIC  __vector_table
+
+        DATA
+
+__vector_table
+        DCD     sfe(CSTACK)
+        DCD     Reset_Handler             ; Reset Handler
+        DCD     NMI_Handler               ; NMI Handler
+        DCD     HardFault_Handler         ; Hard Fault Handler
+        DCD     MemManage_Handler         ; MPU Fault Handler
+        DCD     BusFault_Handler          ; Bus Fault Handler
+        DCD     UsageFault_Handler        ; Usage Fault Handler
+        DCD     0                         ; Reserved
+        DCD     0                         ; Reserved
+        DCD     0                         ; Reserved
+        DCD     0                         ; Reserved
+        DCD     SVC_Handler               ; SVCall Handler
+        DCD     DebugMon_Handler          ; Debug Monitor Handler
+        DCD     0                         ; Reserved
+        DCD     PendSV_Handler            ; PendSV Handler
+        DCD     SysTick_Handler           ; SysTick Handler
+
+         ; External Interrupts
+        DCD     WWDG_IRQHandler           ; Window Watchdog
+        DCD     PVD_IRQHandler            ; PVD through EXTI Line detect
+        DCD     TAMPER_IRQHandler         ; Tamper
+        DCD     RTC_IRQHandler            ; RTC
+        DCD     FLASH_IRQHandler          ; Flash
+        DCD     RCC_IRQHandler            ; RCC
+        DCD     EXTI0_IRQHandler          ; EXTI Line 0
+        DCD     EXTI1_IRQHandler          ; EXTI Line 1
+        DCD     EXTI2_IRQHandler          ; EXTI Line 2
+        DCD     EXTI3_IRQHandler          ; EXTI Line 3
+        DCD     EXTI4_IRQHandler          ; EXTI Line 4
+        DCD     DMA1_Channel1_IRQHandler  ; DMA1 Channel 1
+        DCD     DMA1_Channel2_IRQHandler  ; DMA1 Channel 2
+        DCD     DMA1_Channel3_IRQHandler  ; DMA1 Channel 3
+        DCD     DMA1_Channel4_IRQHandler  ; DMA1 Channel 4
+        DCD     DMA1_Channel5_IRQHandler  ; DMA1 Channel 5
+        DCD     DMA1_Channel6_IRQHandler  ; DMA1 Channel 6
+        DCD     DMA1_Channel7_IRQHandler  ; DMA1 Channel 7
+        DCD     ADC1_2_IRQHandler         ; ADC1 & ADC2
+        DCD     USB_HP_CAN1_TX_IRQHandler  ; USB High Priority or CAN1 TX
+        DCD     USB_LP_CAN1_RX0_IRQHandler ; USB Low  Priority or CAN1 RX0
+        DCD     CAN1_RX1_IRQHandler       ; CAN1 RX1
+        DCD     CAN1_SCE_IRQHandler       ; CAN1 SCE
+        DCD     EXTI9_5_IRQHandler        ; EXTI Line 9..5
+        DCD     TIM1_BRK_IRQHandler       ; TIM1 Break
+        DCD     TIM1_UP_IRQHandler        ; TIM1 Update
+        DCD     TIM1_TRG_COM_IRQHandler   ; TIM1 Trigger and Commutation
+        DCD     TIM1_CC_IRQHandler        ; TIM1 Capture Compare
+        DCD     TIM2_IRQHandler           ; TIM2
+        DCD     TIM3_IRQHandler           ; TIM3
+        DCD     TIM4_IRQHandler           ; TIM4
+        DCD     I2C1_EV_IRQHandler        ; I2C1 Event
+        DCD     I2C1_ER_IRQHandler        ; I2C1 Error
+        DCD     I2C2_EV_IRQHandler        ; I2C2 Event
+        DCD     I2C2_ER_IRQHandler        ; I2C2 Error
+        DCD     SPI1_IRQHandler           ; SPI1
+        DCD     SPI2_IRQHandler           ; SPI2
+        DCD     USART1_IRQHandler         ; USART1
+        DCD     USART2_IRQHandler         ; USART2
+        DCD     USART3_IRQHandler         ; USART3
+        DCD     EXTI15_10_IRQHandler      ; EXTI Line 15..10
+        DCD     RTCAlarm_IRQHandler       ; RTC Alarm through EXTI Line
+        DCD     USBWakeUp_IRQHandler      ; USB Wakeup from suspend
+        DCD     TIM8_BRK_IRQHandler       ; TIM8 Break
+        DCD     TIM8_UP_IRQHandler        ; TIM8 Update
+        DCD     TIM8_TRG_COM_IRQHandler   ; TIM8 Trigger and Commutation
+        DCD     TIM8_CC_IRQHandler        ; TIM8 Capture Compare
+        DCD     ADC3_IRQHandler           ; ADC3
+        DCD     FSMC_IRQHandler           ; FSMC
+        DCD     SDIO_IRQHandler           ; SDIO
+        DCD     TIM5_IRQHandler           ; TIM5
+        DCD     SPI3_IRQHandler           ; SPI3
+        DCD     UART4_IRQHandler          ; UART4
+        DCD     UART5_IRQHandler          ; UART5
+        DCD     TIM6_IRQHandler           ; TIM6
+        DCD     TIM7_IRQHandler           ; TIM7
+        DCD     DMA2_Channel1_IRQHandler  ; DMA2 Channel1
+        DCD     DMA2_Channel2_IRQHandler  ; DMA2 Channel2
+        DCD     DMA2_Channel3_IRQHandler  ; DMA2 Channel3
+        DCD     DMA2_Channel4_5_IRQHandler ; DMA2 Channel4 & Channel5
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;;
+;; Default interrupt handlers.
+;;
+        THUMB
+
+        PUBWEAK Reset_Handler
+        SECTION .text:CODE:REORDER(2)
+Reset_Handler
+        LDR     R0, =SystemInit
+        BLX     R0
+        LDR     R0, =__iar_program_start
+        BX      R0
+
+        PUBWEAK NMI_Handler
+        SECTION .text:CODE:REORDER(1)
+NMI_Handler
+        B NMI_Handler
+
+        PUBWEAK HardFault_Handler
+        SECTION .text:CODE:REORDER(1)
+HardFault_Handler
+        B HardFault_Handler
+
+        PUBWEAK MemManage_Handler
+        SECTION .text:CODE:REORDER(1)
+MemManage_Handler
+        B MemManage_Handler
+
+        PUBWEAK BusFault_Handler
+        SECTION .text:CODE:REORDER(1)
+BusFault_Handler
+        B BusFault_Handler
+
+        PUBWEAK UsageFault_Handler
+        SECTION .text:CODE:REORDER(1)
+UsageFault_Handler
+        B UsageFault_Handler
+
+        PUBWEAK SVC_Handler
+        SECTION .text:CODE:REORDER(1)
+SVC_Handler
+        B SVC_Handler
+
+        PUBWEAK DebugMon_Handler
+        SECTION .text:CODE:REORDER(1)
+DebugMon_Handler
+        B DebugMon_Handler
+
+        PUBWEAK PendSV_Handler
+        SECTION .text:CODE:REORDER(1)
+PendSV_Handler
+        B PendSV_Handler
+
+        PUBWEAK SysTick_Handler
+        SECTION .text:CODE:REORDER(1)
+SysTick_Handler
+        B SysTick_Handler
+
+        PUBWEAK WWDG_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+WWDG_IRQHandler
+        B WWDG_IRQHandler
+
+        PUBWEAK PVD_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+PVD_IRQHandler
+        B PVD_IRQHandler
+
+        PUBWEAK TAMPER_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TAMPER_IRQHandler
+        B TAMPER_IRQHandler
+
+        PUBWEAK RTC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+RTC_IRQHandler
+        B RTC_IRQHandler
+
+        PUBWEAK FLASH_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+FLASH_IRQHandler
+        B FLASH_IRQHandler
+
+        PUBWEAK RCC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+RCC_IRQHandler
+        B RCC_IRQHandler
+
+        PUBWEAK EXTI0_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI0_IRQHandler
+        B EXTI0_IRQHandler
+
+        PUBWEAK EXTI1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI1_IRQHandler
+        B EXTI1_IRQHandler
+
+        PUBWEAK EXTI2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI2_IRQHandler
+        B EXTI2_IRQHandler
+
+        PUBWEAK EXTI3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI3_IRQHandler
+        B EXTI3_IRQHandler
+
+        PUBWEAK EXTI4_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI4_IRQHandler
+        B EXTI4_IRQHandler
+
+        PUBWEAK DMA1_Channel1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel1_IRQHandler
+        B DMA1_Channel1_IRQHandler
+
+        PUBWEAK DMA1_Channel2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel2_IRQHandler
+        B DMA1_Channel2_IRQHandler
+
+        PUBWEAK DMA1_Channel3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel3_IRQHandler
+        B DMA1_Channel3_IRQHandler
+
+        PUBWEAK DMA1_Channel4_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel4_IRQHandler
+        B DMA1_Channel4_IRQHandler
+
+        PUBWEAK DMA1_Channel5_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel5_IRQHandler
+        B DMA1_Channel5_IRQHandler
+
+        PUBWEAK DMA1_Channel6_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel6_IRQHandler
+        B DMA1_Channel6_IRQHandler
+
+        PUBWEAK DMA1_Channel7_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel7_IRQHandler
+        B DMA1_Channel7_IRQHandler
+
+        PUBWEAK ADC1_2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+ADC1_2_IRQHandler
+        B ADC1_2_IRQHandler
+
+        PUBWEAK USB_HP_CAN1_TX_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USB_HP_CAN1_TX_IRQHandler
+        B USB_HP_CAN1_TX_IRQHandler
+
+        PUBWEAK USB_LP_CAN1_RX0_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USB_LP_CAN1_RX0_IRQHandler
+        B USB_LP_CAN1_RX0_IRQHandler
+
+        PUBWEAK CAN1_RX1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+CAN1_RX1_IRQHandler
+        B CAN1_RX1_IRQHandler
+
+        PUBWEAK CAN1_SCE_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+CAN1_SCE_IRQHandler
+        B CAN1_SCE_IRQHandler
+
+        PUBWEAK EXTI9_5_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI9_5_IRQHandler
+        B EXTI9_5_IRQHandler
+
+        PUBWEAK TIM1_BRK_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_BRK_IRQHandler
+        B TIM1_BRK_IRQHandler
+
+        PUBWEAK TIM1_UP_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_UP_IRQHandler
+        B TIM1_UP_IRQHandler
+
+        PUBWEAK TIM1_TRG_COM_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_TRG_COM_IRQHandler
+        B TIM1_TRG_COM_IRQHandler
+
+        PUBWEAK TIM1_CC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_CC_IRQHandler
+        B TIM1_CC_IRQHandler
+
+        PUBWEAK TIM2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM2_IRQHandler
+        B TIM2_IRQHandler
+
+        PUBWEAK TIM3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM3_IRQHandler
+        B TIM3_IRQHandler
+
+        PUBWEAK TIM4_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM4_IRQHandler
+        B TIM4_IRQHandler
+
+        PUBWEAK I2C1_EV_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+I2C1_EV_IRQHandler
+        B I2C1_EV_IRQHandler
+
+        PUBWEAK I2C1_ER_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+I2C1_ER_IRQHandler
+        B I2C1_ER_IRQHandler
+
+        PUBWEAK I2C2_EV_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+I2C2_EV_IRQHandler
+        B I2C2_EV_IRQHandler
+
+        PUBWEAK I2C2_ER_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+I2C2_ER_IRQHandler
+        B I2C2_ER_IRQHandler
+
+        PUBWEAK SPI1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+SPI1_IRQHandler
+        B SPI1_IRQHandler
+
+        PUBWEAK SPI2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+SPI2_IRQHandler
+        B SPI2_IRQHandler
+
+        PUBWEAK USART1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USART1_IRQHandler
+        B USART1_IRQHandler
+
+        PUBWEAK USART2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USART2_IRQHandler
+        B USART2_IRQHandler
+
+        PUBWEAK USART3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USART3_IRQHandler
+        B USART3_IRQHandler
+
+        PUBWEAK EXTI15_10_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI15_10_IRQHandler
+        B EXTI15_10_IRQHandler
+
+        PUBWEAK RTCAlarm_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+RTCAlarm_IRQHandler
+        B RTCAlarm_IRQHandler
+
+        PUBWEAK USBWakeUp_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USBWakeUp_IRQHandler
+        B USBWakeUp_IRQHandler
+
+        PUBWEAK TIM8_BRK_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM8_BRK_IRQHandler
+        B TIM8_BRK_IRQHandler
+
+        PUBWEAK TIM8_UP_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM8_UP_IRQHandler
+        B TIM8_UP_IRQHandler
+
+        PUBWEAK TIM8_TRG_COM_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM8_TRG_COM_IRQHandler
+        B TIM8_TRG_COM_IRQHandler
+
+        PUBWEAK TIM8_CC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM8_CC_IRQHandler
+        B TIM8_CC_IRQHandler
+
+        PUBWEAK ADC3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+ADC3_IRQHandler
+        B ADC3_IRQHandler
+
+        PUBWEAK FSMC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+FSMC_IRQHandler
+        B FSMC_IRQHandler
+
+        PUBWEAK SDIO_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+SDIO_IRQHandler
+        B SDIO_IRQHandler
+
+        PUBWEAK TIM5_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM5_IRQHandler
+        B TIM5_IRQHandler
+
+        PUBWEAK SPI3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+SPI3_IRQHandler
+        B SPI3_IRQHandler
+
+        PUBWEAK UART4_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+UART4_IRQHandler
+        B UART4_IRQHandler
+
+        PUBWEAK UART5_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+UART5_IRQHandler
+        B UART5_IRQHandler
+
+        PUBWEAK TIM6_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM6_IRQHandler
+        B TIM6_IRQHandler
+
+        PUBWEAK TIM7_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM7_IRQHandler
+        B TIM7_IRQHandler
+
+        PUBWEAK DMA2_Channel1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA2_Channel1_IRQHandler
+        B DMA2_Channel1_IRQHandler
+
+        PUBWEAK DMA2_Channel2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA2_Channel2_IRQHandler
+        B DMA2_Channel2_IRQHandler
+
+        PUBWEAK DMA2_Channel3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA2_Channel3_IRQHandler
+        B DMA2_Channel3_IRQHandler
+
+        PUBWEAK DMA2_Channel4_5_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA2_Channel4_5_IRQHandler
+        B DMA2_Channel4_5_IRQHandler
+
+
+        END
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_hd_vl.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_hd_vl.s
new file mode 100644
index 0000000..33f592f
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_hd_vl.s
@@ -0,0 +1,461 @@
+;******************** (C) COPYRIGHT 2011 STMicroelectronics ********************
+;* File Name          : startup_stm32f10x_hd_vl.s
+;* Author             : MCD Application Team
+;* Version            : V3.5.0
+;* Date               : 11-March-2011
+;* Description        : STM32F10x High Density Value Line Devices vector table
+;*                      for EWARM toolchain.
+;*                      This module performs:
+;*                      - Set the initial SP
+;*                      - Configure the clock system and the external SRAM
+;*                        mounted on STM32100E-EVAL board to be used as data
+;*                        memory (optional, to be enabled by user)
+;*                      - Set the initial PC == __iar_program_start,
+;*                      - Set the vector table entries with the exceptions ISR
+;*                        address.
+;*                      After Reset the Cortex-M3 processor is in Thread mode,
+;*                      priority is Privileged, and the Stack is set to Main.
+;********************************************************************************
+;* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+;* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+;* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+;* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+;* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+;* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+;*******************************************************************************
+;
+;
+; The modules in this file are included in the libraries, and may be replaced
+; by any user-defined modules that define the PUBLIC symbol _program_start or
+; a user defined start symbol.
+; To override the cstartup defined in the library, simply add your modified
+; version to the workbench project.
+;
+; The vector table is normally located at address 0.
+; When debugging in RAM, it can be located in RAM, aligned to at least 2^6.
+; The name "__vector_table" has special meaning for C-SPY:
+; it is where the SP start value is found, and the NVIC vector
+; table register (VTOR) is initialized to this address if != 0.
+;
+; Cortex-M version
+;
+
+        MODULE  ?cstartup
+
+        ;; Forward declaration of sections.
+        SECTION CSTACK:DATA:NOROOT(3)
+
+        SECTION .intvec:CODE:NOROOT(2)
+
+        EXTERN  __iar_program_start
+        EXTERN  SystemInit
+        PUBLIC  __vector_table
+
+        DATA
+__vector_table
+        DCD     sfe(CSTACK)
+        DCD     Reset_Handler             ; Reset Handler
+        DCD     NMI_Handler               ; NMI Handler
+        DCD     HardFault_Handler         ; Hard Fault Handler
+        DCD     MemManage_Handler         ; MPU Fault Handler
+        DCD     BusFault_Handler          ; Bus Fault Handler
+        DCD     UsageFault_Handler        ; Usage Fault Handler
+        DCD     0                         ; Reserved
+        DCD     0                         ; Reserved
+        DCD     0                         ; Reserved
+        DCD     0                         ; Reserved
+        DCD     SVC_Handler               ; SVCall Handler
+        DCD     DebugMon_Handler          ; Debug Monitor Handler
+        DCD     0                         ; Reserved
+        DCD     PendSV_Handler            ; PendSV Handler
+        DCD     SysTick_Handler           ; SysTick Handler
+
+         ; External Interrupts
+        DCD     WWDG_IRQHandler               ; Window Watchdog
+        DCD     PVD_IRQHandler                ; PVD through EXTI Line detect
+        DCD     TAMPER_IRQHandler             ; Tamper
+        DCD     RTC_IRQHandler                ; RTC
+        DCD     FLASH_IRQHandler              ; Flash
+        DCD     RCC_IRQHandler                ; RCC
+        DCD     EXTI0_IRQHandler              ; EXTI Line 0
+        DCD     EXTI1_IRQHandler              ; EXTI Line 1
+        DCD     EXTI2_IRQHandler              ; EXTI Line 2
+        DCD     EXTI3_IRQHandler              ; EXTI Line 3
+        DCD     EXTI4_IRQHandler              ; EXTI Line 4
+        DCD     DMA1_Channel1_IRQHandler      ; DMA1 Channel 1
+        DCD     DMA1_Channel2_IRQHandler      ; DMA1 Channel 2
+        DCD     DMA1_Channel3_IRQHandler      ; DMA1 Channel 3
+        DCD     DMA1_Channel4_IRQHandler      ; DMA1 Channel 4
+        DCD     DMA1_Channel5_IRQHandler      ; DMA1 Channel 5
+        DCD     DMA1_Channel6_IRQHandler      ; DMA1 Channel 6
+        DCD     DMA1_Channel7_IRQHandler      ; DMA1 Channel 7
+        DCD     ADC1_IRQHandler               ; ADC1
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     EXTI9_5_IRQHandler            ; EXTI Line 9..5
+        DCD     TIM1_BRK_TIM15_IRQHandler     ; TIM1 Break and TIM15
+        DCD     TIM1_UP_TIM16_IRQHandler      ; TIM1 Update and TIM16
+        DCD     TIM1_TRG_COM_TIM17_IRQHandler ; TIM1 Trigger and Commutation and TIM17
+        DCD     TIM1_CC_IRQHandler            ; TIM1 Capture Compare
+        DCD     TIM2_IRQHandler               ; TIM2
+        DCD     TIM3_IRQHandler               ; TIM3
+        DCD     TIM4_IRQHandler               ; TIM4
+        DCD     I2C1_EV_IRQHandler            ; I2C1 Event
+        DCD     I2C1_ER_IRQHandler            ; I2C1 Error
+        DCD     I2C2_EV_IRQHandler            ; I2C2 Event
+        DCD     I2C2_ER_IRQHandler            ; I2C2 Error
+        DCD     SPI1_IRQHandler               ; SPI1
+        DCD     SPI2_IRQHandler               ; SPI2
+        DCD     USART1_IRQHandler             ; USART1
+        DCD     USART2_IRQHandler             ; USART2
+        DCD     USART3_IRQHandler             ; USART3
+        DCD     EXTI15_10_IRQHandler          ; EXTI Line 15..10
+        DCD     RTCAlarm_IRQHandler           ; RTC Alarm through EXTI Line
+        DCD     CEC_IRQHandler                ; HDMI-CEC
+        DCD     TIM12_IRQHandler              ; TIM12
+        DCD     TIM13_IRQHandler              ; TIM13
+        DCD     TIM14_IRQHandler              ; TIM14
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     TIM5_IRQHandler               ; TIM5
+        DCD     SPI3_IRQHandler               ; SPI3
+        DCD     UART4_IRQHandler              ; UART4
+        DCD     UART5_IRQHandler              ; UART5
+        DCD     TIM6_DAC_IRQHandler           ; TIM6 and DAC underrun
+        DCD     TIM7_IRQHandler               ; TIM7
+        DCD     DMA2_Channel1_IRQHandler      ; DMA2 Channel1
+        DCD     DMA2_Channel2_IRQHandler      ; DMA2 Channel2
+        DCD     DMA2_Channel3_IRQHandler      ; DMA2 Channel3
+        DCD     DMA2_Channel4_5_IRQHandler    ; DMA2 Channel4 & Channel5
+        DCD     DMA2_Channel5_IRQHandler      ; DMA2 Channel5
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;;
+;; Default interrupt handlers.
+;;
+        THUMB
+
+        PUBWEAK Reset_Handler
+        SECTION .text:CODE:REORDER(2)
+Reset_Handler
+        LDR     R0, =SystemInit
+        BLX     R0
+        LDR     R0, =__iar_program_start
+        BX      R0
+
+        PUBWEAK NMI_Handler
+        SECTION .text:CODE:REORDER(1)
+NMI_Handler
+        B NMI_Handler
+
+        PUBWEAK HardFault_Handler
+        SECTION .text:CODE:REORDER(1)
+HardFault_Handler
+        B HardFault_Handler
+
+        PUBWEAK MemManage_Handler
+        SECTION .text:CODE:REORDER(1)
+MemManage_Handler
+        B MemManage_Handler
+
+        PUBWEAK BusFault_Handler
+        SECTION .text:CODE:REORDER(1)
+BusFault_Handler
+        B BusFault_Handler
+
+        PUBWEAK UsageFault_Handler
+        SECTION .text:CODE:REORDER(1)
+UsageFault_Handler
+        B UsageFault_Handler
+
+        PUBWEAK SVC_Handler
+        SECTION .text:CODE:REORDER(1)
+SVC_Handler
+        B SVC_Handler
+
+        PUBWEAK DebugMon_Handler
+        SECTION .text:CODE:REORDER(1)
+DebugMon_Handler
+        B DebugMon_Handler
+
+        PUBWEAK PendSV_Handler
+        SECTION .text:CODE:REORDER(1)
+PendSV_Handler
+        B PendSV_Handler
+
+        PUBWEAK SysTick_Handler
+        SECTION .text:CODE:REORDER(1)
+SysTick_Handler
+        B SysTick_Handler
+
+        PUBWEAK WWDG_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+WWDG_IRQHandler
+        B WWDG_IRQHandler
+
+        PUBWEAK PVD_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+PVD_IRQHandler
+        B PVD_IRQHandler
+
+        PUBWEAK TAMPER_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TAMPER_IRQHandler
+        B TAMPER_IRQHandler
+
+        PUBWEAK RTC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+RTC_IRQHandler
+        B RTC_IRQHandler
+
+        PUBWEAK FLASH_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+FLASH_IRQHandler
+        B FLASH_IRQHandler
+
+        PUBWEAK RCC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+RCC_IRQHandler
+        B RCC_IRQHandler
+
+        PUBWEAK EXTI0_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI0_IRQHandler
+        B EXTI0_IRQHandler
+
+        PUBWEAK EXTI1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI1_IRQHandler
+        B EXTI1_IRQHandler
+
+        PUBWEAK EXTI2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI2_IRQHandler
+        B EXTI2_IRQHandler
+
+        PUBWEAK EXTI3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI3_IRQHandler
+        B EXTI3_IRQHandler
+
+        PUBWEAK EXTI4_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI4_IRQHandler
+        B EXTI4_IRQHandler
+
+        PUBWEAK DMA1_Channel1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel1_IRQHandler
+        B DMA1_Channel1_IRQHandler
+
+        PUBWEAK DMA1_Channel2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel2_IRQHandler
+        B DMA1_Channel2_IRQHandler
+
+        PUBWEAK DMA1_Channel3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel3_IRQHandler
+        B DMA1_Channel3_IRQHandler
+
+        PUBWEAK DMA1_Channel4_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel4_IRQHandler
+        B DMA1_Channel4_IRQHandler
+
+        PUBWEAK DMA1_Channel5_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel5_IRQHandler
+        B DMA1_Channel5_IRQHandler
+
+        PUBWEAK DMA1_Channel6_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel6_IRQHandler
+        B DMA1_Channel6_IRQHandler
+
+        PUBWEAK DMA1_Channel7_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel7_IRQHandler
+        B DMA1_Channel7_IRQHandler
+
+        PUBWEAK ADC1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+ADC1_IRQHandler
+        B ADC1_IRQHandler
+
+        PUBWEAK EXTI9_5_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI9_5_IRQHandler
+        B EXTI9_5_IRQHandler
+
+        PUBWEAK TIM1_BRK_TIM15_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_BRK_TIM15_IRQHandler
+        B TIM1_BRK_TIM15_IRQHandler
+
+        PUBWEAK TIM1_UP_TIM16_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_UP_TIM16_IRQHandler
+        B TIM1_UP_TIM16_IRQHandler
+
+        PUBWEAK TIM1_TRG_COM_TIM17_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_TRG_COM_TIM17_IRQHandler
+        B TIM1_TRG_COM_TIM17_IRQHandler
+
+        PUBWEAK TIM1_CC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_CC_IRQHandler
+        B TIM1_CC_IRQHandler
+
+        PUBWEAK TIM2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM2_IRQHandler
+        B TIM2_IRQHandler
+
+        PUBWEAK TIM3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM3_IRQHandler
+        B TIM3_IRQHandler
+
+        PUBWEAK TIM4_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM4_IRQHandler
+        B TIM4_IRQHandler
+
+        PUBWEAK I2C1_EV_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+I2C1_EV_IRQHandler
+        B I2C1_EV_IRQHandler
+
+        PUBWEAK I2C1_ER_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+I2C1_ER_IRQHandler
+        B I2C1_ER_IRQHandler
+
+        PUBWEAK I2C2_EV_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+I2C2_EV_IRQHandler
+        B I2C2_EV_IRQHandler
+
+        PUBWEAK I2C2_ER_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+I2C2_ER_IRQHandler
+        B I2C2_ER_IRQHandler
+
+        PUBWEAK SPI1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+SPI1_IRQHandler
+        B SPI1_IRQHandler
+
+        PUBWEAK SPI2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+SPI2_IRQHandler
+        B SPI2_IRQHandler
+
+        PUBWEAK USART1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USART1_IRQHandler
+        B USART1_IRQHandler
+
+        PUBWEAK USART2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USART2_IRQHandler
+        B USART2_IRQHandler
+
+        PUBWEAK USART3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USART3_IRQHandler
+        B USART3_IRQHandler
+
+        PUBWEAK EXTI15_10_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI15_10_IRQHandler
+        B EXTI15_10_IRQHandler
+
+        PUBWEAK RTCAlarm_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+RTCAlarm_IRQHandler
+        B RTCAlarm_IRQHandler
+
+        PUBWEAK CEC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+CEC_IRQHandler
+        B CEC_IRQHandler
+
+        PUBWEAK TIM12_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM12_IRQHandler
+        B TIM12_IRQHandler
+
+        PUBWEAK TIM13_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM13_IRQHandler
+        B TIM13_IRQHandler
+
+        PUBWEAK TIM14_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM14_IRQHandler
+        B TIM14_IRQHandler
+
+        PUBWEAK TIM5_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM5_IRQHandler
+        B TIM5_IRQHandler
+
+        PUBWEAK SPI3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+SPI3_IRQHandler
+        B SPI3_IRQHandler
+
+        PUBWEAK UART4_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+UART4_IRQHandler
+        B UART4_IRQHandler
+
+        PUBWEAK UART5_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+UART5_IRQHandler
+        B UART5_IRQHandler
+
+        PUBWEAK TIM6_DAC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM6_DAC_IRQHandler
+        B TIM6_DAC_IRQHandler
+
+        PUBWEAK TIM7_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM7_IRQHandler
+        B TIM7_IRQHandler
+
+        PUBWEAK DMA2_Channel1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA2_Channel1_IRQHandler
+        B DMA2_Channel1_IRQHandler
+
+        PUBWEAK DMA2_Channel2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA2_Channel2_IRQHandler
+        B DMA2_Channel2_IRQHandler
+
+        PUBWEAK DMA2_Channel3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA2_Channel3_IRQHandler
+        B DMA2_Channel3_IRQHandler
+
+        PUBWEAK DMA2_Channel4_5_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA2_Channel4_5_IRQHandler
+        B DMA2_Channel4_5_IRQHandler
+
+        PUBWEAK DMA2_Channel5_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA2_Channel5_IRQHandler
+        B DMA2_Channel5_IRQHandler
+
+        END
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_ld.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_ld.s
new file mode 100644
index 0000000..e2b2b4d
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_ld.s
@@ -0,0 +1,366 @@
+;******************** (C) COPYRIGHT 2011 STMicroelectronics ********************
+;* File Name          : startup_stm32f10x_ld.s
+;* Author             : MCD Application Team
+;* Version            : V3.5.0
+;* Date               : 11-March-2011
+;* Description        : STM32F10x Low Density Devices vector table for EWARM
+;*                      toolchain.
+;*                      This module performs:
+;*                      - Set the initial SP
+;*                      - Configure the clock system
+;*                      - Set the initial PC == __iar_program_start,
+;*                      - Set the vector table entries with the exceptions ISR
+;*                        address.
+;*                      After Reset the Cortex-M3 processor is in Thread mode,
+;*                      priority is Privileged, and the Stack is set to Main.
+;********************************************************************************
+;* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+;* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+;* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+;* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+;* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+;* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+;*******************************************************************************
+;
+;
+; The modules in this file are included in the libraries, and may be replaced
+; by any user-defined modules that define the PUBLIC symbol _program_start or
+; a user defined start symbol.
+; To override the cstartup defined in the library, simply add your modified
+; version to the workbench project.
+;
+; The vector table is normally located at address 0.
+; When debugging in RAM, it can be located in RAM, aligned to at least 2^6.
+; The name "__vector_table" has special meaning for C-SPY:
+; it is where the SP start value is found, and the NVIC vector
+; table register (VTOR) is initialized to this address if != 0.
+;
+; Cortex-M version
+;
+
+        MODULE  ?cstartup
+
+        ;; Forward declaration of sections.
+        SECTION CSTACK:DATA:NOROOT(3)
+
+        SECTION .intvec:CODE:NOROOT(2)
+
+        EXTERN  __iar_program_start
+        EXTERN  SystemInit
+        PUBLIC  __vector_table
+
+        DATA
+__vector_table
+        DCD     sfe(CSTACK)
+        DCD     Reset_Handler             ; Reset Handler
+        DCD     NMI_Handler               ; NMI Handler
+        DCD     HardFault_Handler         ; Hard Fault Handler
+        DCD     MemManage_Handler         ; MPU Fault Handler
+        DCD     BusFault_Handler          ; Bus Fault Handler
+        DCD     UsageFault_Handler        ; Usage Fault Handler
+        DCD     0                         ; Reserved
+        DCD     0                         ; Reserved
+        DCD     0                         ; Reserved
+        DCD     0                         ; Reserved
+        DCD     SVC_Handler               ; SVCall Handler
+        DCD     DebugMon_Handler          ; Debug Monitor Handler
+        DCD     0                         ; Reserved
+        DCD     PendSV_Handler            ; PendSV Handler
+        DCD     SysTick_Handler           ; SysTick Handler
+
+         ; External Interrupts
+        DCD     WWDG_IRQHandler           ; Window Watchdog
+        DCD     PVD_IRQHandler            ; PVD through EXTI Line detect
+        DCD     TAMPER_IRQHandler         ; Tamper
+        DCD     RTC_IRQHandler            ; RTC
+        DCD     FLASH_IRQHandler          ; Flash
+        DCD     RCC_IRQHandler            ; RCC
+        DCD     EXTI0_IRQHandler          ; EXTI Line 0
+        DCD     EXTI1_IRQHandler          ; EXTI Line 1
+        DCD     EXTI2_IRQHandler          ; EXTI Line 2
+        DCD     EXTI3_IRQHandler          ; EXTI Line 3
+        DCD     EXTI4_IRQHandler          ; EXTI Line 4
+        DCD     DMA1_Channel1_IRQHandler  ; DMA1 Channel 1
+        DCD     DMA1_Channel2_IRQHandler  ; DMA1 Channel 2
+        DCD     DMA1_Channel3_IRQHandler  ; DMA1 Channel 3
+        DCD     DMA1_Channel4_IRQHandler  ; DMA1 Channel 4
+        DCD     DMA1_Channel5_IRQHandler  ; DMA1 Channel 5
+        DCD     DMA1_Channel6_IRQHandler  ; DMA1 Channel 6
+        DCD     DMA1_Channel7_IRQHandler  ; DMA1 Channel 7
+        DCD     ADC1_2_IRQHandler         ; ADC1 & ADC2
+        DCD     USB_HP_CAN1_TX_IRQHandler  ; USB High Priority or CAN1 TX
+        DCD     USB_LP_CAN1_RX0_IRQHandler ; USB Low  Priority or CAN1 RX0
+        DCD     CAN1_RX1_IRQHandler       ; CAN1 RX1
+        DCD     CAN1_SCE_IRQHandler       ; CAN1 SCE
+        DCD     EXTI9_5_IRQHandler        ; EXTI Line 9..5
+        DCD     TIM1_BRK_IRQHandler       ; TIM1 Break
+        DCD     TIM1_UP_IRQHandler        ; TIM1 Update
+        DCD     TIM1_TRG_COM_IRQHandler   ; TIM1 Trigger and Commutation
+        DCD     TIM1_CC_IRQHandler        ; TIM1 Capture Compare
+        DCD     TIM2_IRQHandler           ; TIM2
+        DCD     TIM3_IRQHandler           ; TIM3
+        DCD     0                         ; Reserved
+        DCD     I2C1_EV_IRQHandler        ; I2C1 Event
+        DCD     I2C1_ER_IRQHandler        ; I2C1 Error
+        DCD     0                         ; Reserved
+        DCD     0                         ; Reserved
+        DCD     SPI1_IRQHandler           ; SPI1
+        DCD     0                         ; Reserved
+        DCD     USART1_IRQHandler         ; USART1
+        DCD     USART2_IRQHandler         ; USART2
+        DCD     0                         ; Reserved
+        DCD     EXTI15_10_IRQHandler      ; EXTI Line 15..10
+        DCD     RTCAlarm_IRQHandler       ; RTC Alarm through EXTI Line
+        DCD     USBWakeUp_IRQHandler      ; USB Wakeup from suspend
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;;
+;; Default interrupt handlers.
+;;
+        THUMB
+
+        PUBWEAK Reset_Handler
+        SECTION .text:CODE:REORDER(2)
+Reset_Handler
+        LDR     R0, =SystemInit
+        BLX     R0
+        LDR     R0, =__iar_program_start
+        BX      R0
+
+        PUBWEAK NMI_Handler
+        SECTION .text:CODE:REORDER(1)
+NMI_Handler
+        B NMI_Handler
+
+        PUBWEAK HardFault_Handler
+        SECTION .text:CODE:REORDER(1)
+HardFault_Handler
+        B HardFault_Handler
+
+        PUBWEAK MemManage_Handler
+        SECTION .text:CODE:REORDER(1)
+MemManage_Handler
+        B MemManage_Handler
+
+        PUBWEAK BusFault_Handler
+        SECTION .text:CODE:REORDER(1)
+BusFault_Handler
+        B BusFault_Handler
+
+        PUBWEAK UsageFault_Handler
+        SECTION .text:CODE:REORDER(1)
+UsageFault_Handler
+        B UsageFault_Handler
+
+        PUBWEAK SVC_Handler
+        SECTION .text:CODE:REORDER(1)
+SVC_Handler
+        B SVC_Handler
+
+        PUBWEAK DebugMon_Handler
+        SECTION .text:CODE:REORDER(1)
+DebugMon_Handler
+        B DebugMon_Handler
+
+        PUBWEAK PendSV_Handler
+        SECTION .text:CODE:REORDER(1)
+PendSV_Handler
+        B PendSV_Handler
+
+        PUBWEAK SysTick_Handler
+        SECTION .text:CODE:REORDER(1)
+SysTick_Handler
+        B SysTick_Handler
+
+        PUBWEAK WWDG_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+WWDG_IRQHandler
+        B WWDG_IRQHandler
+
+        PUBWEAK PVD_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+PVD_IRQHandler
+        B PVD_IRQHandler
+
+        PUBWEAK TAMPER_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TAMPER_IRQHandler
+        B TAMPER_IRQHandler
+
+        PUBWEAK RTC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+RTC_IRQHandler
+        B RTC_IRQHandler
+
+        PUBWEAK FLASH_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+FLASH_IRQHandler
+        B FLASH_IRQHandler
+
+        PUBWEAK RCC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+RCC_IRQHandler
+        B RCC_IRQHandler
+
+        PUBWEAK EXTI0_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI0_IRQHandler
+        B EXTI0_IRQHandler
+
+        PUBWEAK EXTI1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI1_IRQHandler
+        B EXTI1_IRQHandler
+
+        PUBWEAK EXTI2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI2_IRQHandler
+        B EXTI2_IRQHandler
+
+        PUBWEAK EXTI3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI3_IRQHandler
+        B EXTI3_IRQHandler
+
+        PUBWEAK EXTI4_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI4_IRQHandler
+        B EXTI4_IRQHandler
+
+        PUBWEAK DMA1_Channel1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel1_IRQHandler
+        B DMA1_Channel1_IRQHandler
+
+        PUBWEAK DMA1_Channel2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel2_IRQHandler
+        B DMA1_Channel2_IRQHandler
+
+        PUBWEAK DMA1_Channel3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel3_IRQHandler
+        B DMA1_Channel3_IRQHandler
+
+        PUBWEAK DMA1_Channel4_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel4_IRQHandler
+        B DMA1_Channel4_IRQHandler
+
+        PUBWEAK DMA1_Channel5_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel5_IRQHandler
+        B DMA1_Channel5_IRQHandler
+
+        PUBWEAK DMA1_Channel6_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel6_IRQHandler
+        B DMA1_Channel6_IRQHandler
+
+        PUBWEAK DMA1_Channel7_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel7_IRQHandler
+        B DMA1_Channel7_IRQHandler
+
+        PUBWEAK ADC1_2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+ADC1_2_IRQHandler
+        B ADC1_2_IRQHandler
+
+        PUBWEAK USB_HP_CAN1_TX_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USB_HP_CAN1_TX_IRQHandler
+        B USB_HP_CAN1_TX_IRQHandler
+
+        PUBWEAK USB_LP_CAN1_RX0_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USB_LP_CAN1_RX0_IRQHandler
+        B USB_LP_CAN1_RX0_IRQHandler
+
+        PUBWEAK CAN1_RX1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+CAN1_RX1_IRQHandler
+        B CAN1_RX1_IRQHandler
+
+        PUBWEAK CAN1_SCE_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+CAN1_SCE_IRQHandler
+        B CAN1_SCE_IRQHandler
+
+        PUBWEAK EXTI9_5_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI9_5_IRQHandler
+        B EXTI9_5_IRQHandler
+
+        PUBWEAK TIM1_BRK_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_BRK_IRQHandler
+        B TIM1_BRK_IRQHandler
+
+        PUBWEAK TIM1_UP_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_UP_IRQHandler
+        B TIM1_UP_IRQHandler
+
+        PUBWEAK TIM1_TRG_COM_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_TRG_COM_IRQHandler
+        B TIM1_TRG_COM_IRQHandler
+
+        PUBWEAK TIM1_CC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_CC_IRQHandler
+        B TIM1_CC_IRQHandler
+
+        PUBWEAK TIM2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM2_IRQHandler
+        B TIM2_IRQHandler
+
+        PUBWEAK TIM3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM3_IRQHandler
+        B TIM3_IRQHandler
+
+        PUBWEAK I2C1_EV_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+I2C1_EV_IRQHandler
+        B I2C1_EV_IRQHandler
+
+        PUBWEAK I2C1_ER_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+I2C1_ER_IRQHandler
+        B I2C1_ER_IRQHandler
+
+        PUBWEAK SPI1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+SPI1_IRQHandler
+        B SPI1_IRQHandler
+
+        PUBWEAK USART1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USART1_IRQHandler
+        B USART1_IRQHandler
+
+        PUBWEAK USART2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USART2_IRQHandler
+        B USART2_IRQHandler
+
+        PUBWEAK EXTI15_10_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI15_10_IRQHandler
+        B EXTI15_10_IRQHandler
+
+        PUBWEAK RTCAlarm_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+RTCAlarm_IRQHandler
+        B RTCAlarm_IRQHandler
+
+        PUBWEAK USBWakeUp_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USBWakeUp_IRQHandler
+        B USBWakeUp_IRQHandler
+
+        END
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_ld_vl.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_ld_vl.s
new file mode 100644
index 0000000..a4a4933
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_ld_vl.s
@@ -0,0 +1,369 @@
+;******************** (C) COPYRIGHT 2011 STMicroelectronics ********************
+;* File Name          : startup_stm32f10x_ld_vl.s
+;* Author             : MCD Application Team
+;* Version            : V3.5.0
+;* Date               : 11-March-2011
+;* Description        : STM32F10x Low Density Value Line Devices vector table
+;*                      for EWARM toolchain.
+;*                      This module performs:
+;*                      - Set the initial SP
+;*                      - Configure the clock system
+;*                      - Set the initial PC == __iar_program_start,
+;*                      - Set the vector table entries with the exceptions ISR
+;*                        address.
+;*                      After Reset the Cortex-M3 processor is in Thread mode,
+;*                      priority is Privileged, and the Stack is set to Main.
+;********************************************************************************
+;* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+;* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+;* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+;* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+;* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+;* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+;*******************************************************************************
+;
+;
+; The modules in this file are included in the libraries, and may be replaced
+; by any user-defined modules that define the PUBLIC symbol _program_start or
+; a user defined start symbol.
+; To override the cstartup defined in the library, simply add your modified
+; version to the workbench project.
+;
+; The vector table is normally located at address 0.
+; When debugging in RAM, it can be located in RAM, aligned to at least 2^6.
+; The name "__vector_table" has special meaning for C-SPY:
+; it is where the SP start value is found, and the NVIC vector
+; table register (VTOR) is initialized to this address if != 0.
+;
+; Cortex-M version
+;
+
+        MODULE  ?cstartup
+
+        ;; Forward declaration of sections.
+        SECTION CSTACK:DATA:NOROOT(3)
+
+        SECTION .intvec:CODE:NOROOT(2)
+
+        EXTERN  __iar_program_start
+        EXTERN  SystemInit
+        PUBLIC  __vector_table
+
+        DATA
+__vector_table
+        DCD     sfe(CSTACK)
+        DCD     Reset_Handler             ; Reset Handler
+        DCD     NMI_Handler               ; NMI Handler
+        DCD     HardFault_Handler         ; Hard Fault Handler
+        DCD     MemManage_Handler         ; MPU Fault Handler
+        DCD     BusFault_Handler          ; Bus Fault Handler
+        DCD     UsageFault_Handler        ; Usage Fault Handler
+        DCD     0                         ; Reserved
+        DCD     0                         ; Reserved
+        DCD     0                         ; Reserved
+        DCD     0                         ; Reserved
+        DCD     SVC_Handler               ; SVCall Handler
+        DCD     DebugMon_Handler          ; Debug Monitor Handler
+        DCD     0                         ; Reserved
+        DCD     PendSV_Handler            ; PendSV Handler
+        DCD     SysTick_Handler           ; SysTick Handler
+
+         ; External Interrupts
+        DCD     WWDG_IRQHandler               ; Window Watchdog
+        DCD     PVD_IRQHandler                ; PVD through EXTI Line detect
+        DCD     TAMPER_IRQHandler             ; Tamper
+        DCD     RTC_IRQHandler                ; RTC
+        DCD     FLASH_IRQHandler              ; Flash
+        DCD     RCC_IRQHandler                ; RCC
+        DCD     EXTI0_IRQHandler              ; EXTI Line 0
+        DCD     EXTI1_IRQHandler              ; EXTI Line 1
+        DCD     EXTI2_IRQHandler              ; EXTI Line 2
+        DCD     EXTI3_IRQHandler              ; EXTI Line 3
+        DCD     EXTI4_IRQHandler              ; EXTI Line 4
+        DCD     DMA1_Channel1_IRQHandler      ; DMA1 Channel 1
+        DCD     DMA1_Channel2_IRQHandler      ; DMA1 Channel 2
+        DCD     DMA1_Channel3_IRQHandler      ; DMA1 Channel 3
+        DCD     DMA1_Channel4_IRQHandler      ; DMA1 Channel 4
+        DCD     DMA1_Channel5_IRQHandler      ; DMA1 Channel 5
+        DCD     DMA1_Channel6_IRQHandler      ; DMA1 Channel 6
+        DCD     DMA1_Channel7_IRQHandler      ; DMA1 Channel 7
+        DCD     ADC1_IRQHandler               ; ADC1
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     EXTI9_5_IRQHandler            ; EXTI Line 9..5
+        DCD     TIM1_BRK_TIM15_IRQHandler     ; TIM1 Break and TIM15
+        DCD     TIM1_UP_TIM16_IRQHandler      ; TIM1 Update and TIM16
+        DCD     TIM1_TRG_COM_TIM17_IRQHandler ; TIM1 Trigger and Commutation and TIM17
+        DCD     TIM1_CC_IRQHandler            ; TIM1 Capture Compare
+        DCD     TIM2_IRQHandler               ; TIM2
+        DCD     TIM3_IRQHandler               ; TIM3
+        DCD     0                             ; Reserved
+        DCD     I2C1_EV_IRQHandler            ; I2C1 Event
+        DCD     I2C1_ER_IRQHandler            ; I2C1 Error
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     SPI1_IRQHandler               ; SPI1
+        DCD     0                             ; Reserved
+        DCD     USART1_IRQHandler             ; USART1
+        DCD     USART2_IRQHandler             ; USART2
+        DCD     0                             ; Reserved
+        DCD     EXTI15_10_IRQHandler          ; EXTI Line 15..10
+        DCD     RTCAlarm_IRQHandler           ; RTC Alarm through EXTI Line
+        DCD     CEC_IRQHandler                ; HDMI-CEC
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     TIM6_DAC_IRQHandler           ; TIM6 and DAC underrun
+        DCD     TIM7_IRQHandler               ; TIM7
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;;
+;; Default interrupt handlers.
+;;
+        THUMB
+
+        PUBWEAK Reset_Handler
+        SECTION .text:CODE:REORDER(2)
+Reset_Handler
+        LDR     R0, =SystemInit
+        BLX     R0
+        LDR     R0, =__iar_program_start
+        BX      R0
+
+        PUBWEAK NMI_Handler
+        SECTION .text:CODE:REORDER(1)
+NMI_Handler
+        B NMI_Handler
+
+        PUBWEAK HardFault_Handler
+        SECTION .text:CODE:REORDER(1)
+HardFault_Handler
+        B HardFault_Handler
+
+        PUBWEAK MemManage_Handler
+        SECTION .text:CODE:REORDER(1)
+MemManage_Handler
+        B MemManage_Handler
+
+        PUBWEAK BusFault_Handler
+        SECTION .text:CODE:REORDER(1)
+BusFault_Handler
+        B BusFault_Handler
+
+        PUBWEAK UsageFault_Handler
+        SECTION .text:CODE:REORDER(1)
+UsageFault_Handler
+        B UsageFault_Handler
+
+        PUBWEAK SVC_Handler
+        SECTION .text:CODE:REORDER(1)
+SVC_Handler
+        B SVC_Handler
+
+        PUBWEAK DebugMon_Handler
+        SECTION .text:CODE:REORDER(1)
+DebugMon_Handler
+        B DebugMon_Handler
+
+        PUBWEAK PendSV_Handler
+        SECTION .text:CODE:REORDER(1)
+PendSV_Handler
+        B PendSV_Handler
+
+        PUBWEAK SysTick_Handler
+        SECTION .text:CODE:REORDER(1)
+SysTick_Handler
+        B SysTick_Handler
+
+        PUBWEAK WWDG_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+WWDG_IRQHandler
+        B WWDG_IRQHandler
+
+        PUBWEAK PVD_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+PVD_IRQHandler
+        B PVD_IRQHandler
+
+        PUBWEAK TAMPER_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TAMPER_IRQHandler
+        B TAMPER_IRQHandler
+
+        PUBWEAK RTC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+RTC_IRQHandler
+        B RTC_IRQHandler
+
+        PUBWEAK FLASH_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+FLASH_IRQHandler
+        B FLASH_IRQHandler
+
+        PUBWEAK RCC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+RCC_IRQHandler
+        B RCC_IRQHandler
+
+        PUBWEAK EXTI0_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI0_IRQHandler
+        B EXTI0_IRQHandler
+
+        PUBWEAK EXTI1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI1_IRQHandler
+        B EXTI1_IRQHandler
+
+        PUBWEAK EXTI2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI2_IRQHandler
+        B EXTI2_IRQHandler
+
+        PUBWEAK EXTI3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI3_IRQHandler
+        B EXTI3_IRQHandler
+
+        PUBWEAK EXTI4_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI4_IRQHandler
+        B EXTI4_IRQHandler
+
+        PUBWEAK DMA1_Channel1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel1_IRQHandler
+        B DMA1_Channel1_IRQHandler
+
+        PUBWEAK DMA1_Channel2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel2_IRQHandler
+        B DMA1_Channel2_IRQHandler
+
+        PUBWEAK DMA1_Channel3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel3_IRQHandler
+        B DMA1_Channel3_IRQHandler
+
+        PUBWEAK DMA1_Channel4_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel4_IRQHandler
+        B DMA1_Channel4_IRQHandler
+
+        PUBWEAK DMA1_Channel5_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel5_IRQHandler
+        B DMA1_Channel5_IRQHandler
+
+        PUBWEAK DMA1_Channel6_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel6_IRQHandler
+        B DMA1_Channel6_IRQHandler
+
+        PUBWEAK DMA1_Channel7_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel7_IRQHandler
+        B DMA1_Channel7_IRQHandler
+
+        PUBWEAK ADC1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+ADC1_IRQHandler
+        B ADC1_IRQHandler
+
+        PUBWEAK EXTI9_5_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI9_5_IRQHandler
+        B EXTI9_5_IRQHandler
+
+        PUBWEAK TIM1_BRK_TIM15_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_BRK_TIM15_IRQHandler
+        B TIM1_BRK_TIM15_IRQHandler
+
+        PUBWEAK TIM1_UP_TIM16_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_UP_TIM16_IRQHandler
+        B TIM1_UP_TIM16_IRQHandler
+
+        PUBWEAK TIM1_TRG_COM_TIM17_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_TRG_COM_TIM17_IRQHandler
+        B TIM1_TRG_COM_TIM17_IRQHandler
+
+        PUBWEAK TIM1_CC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_CC_IRQHandler
+        B TIM1_CC_IRQHandler
+
+        PUBWEAK TIM2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM2_IRQHandler
+        B TIM2_IRQHandler
+
+        PUBWEAK TIM3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM3_IRQHandler
+        B TIM3_IRQHandler
+
+        PUBWEAK I2C1_EV_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+I2C1_EV_IRQHandler
+        B I2C1_EV_IRQHandler
+
+        PUBWEAK I2C1_ER_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+I2C1_ER_IRQHandler
+        B I2C1_ER_IRQHandler
+
+        PUBWEAK SPI1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+SPI1_IRQHandler
+        B SPI1_IRQHandler
+
+        PUBWEAK USART1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USART1_IRQHandler
+        B USART1_IRQHandler
+
+        PUBWEAK USART2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USART2_IRQHandler
+        B USART2_IRQHandler
+
+        PUBWEAK EXTI15_10_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI15_10_IRQHandler
+        B EXTI15_10_IRQHandler
+
+        PUBWEAK RTCAlarm_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+RTCAlarm_IRQHandler
+        B RTCAlarm_IRQHandler
+
+        PUBWEAK CEC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+CEC_IRQHandler
+        B CEC_IRQHandler
+
+        PUBWEAK TIM6_DAC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM6_DAC_IRQHandler
+        B TIM6_DAC_IRQHandler
+
+        PUBWEAK TIM7_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM7_IRQHandler
+        B TIM7_IRQHandler
+
+        END
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_md.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_md.s
new file mode 100644
index 0000000..5863eb9
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_md.s
@@ -0,0 +1,391 @@
+;******************** (C) COPYRIGHT 2011 STMicroelectronics ********************
+;* File Name          : startup_stm32f10x_md.s
+;* Author             : MCD Application Team
+;* Version            : V3.5.0
+;* Date               : 11-March-2011
+;* Description        : STM32F10x Medium Density Devices vector table for
+;*                      EWARM toolchain.
+;*                      This module performs:
+;*                      - Set the initial SP
+;*                      - Configure the clock system
+;*                      - Set the initial PC == __iar_program_start,
+;*                      - Set the vector table entries with the exceptions ISR
+;*                        address.
+;*                      After Reset the Cortex-M3 processor is in Thread mode,
+;*                      priority is Privileged, and the Stack is set to Main.
+;********************************************************************************
+;* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+;* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+;* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+;* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+;* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+;* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+;*******************************************************************************
+;
+;
+; The modules in this file are included in the libraries, and may be replaced
+; by any user-defined modules that define the PUBLIC symbol _program_start or
+; a user defined start symbol.
+; To override the cstartup defined in the library, simply add your modified
+; version to the workbench project.
+;
+; The vector table is normally located at address 0.
+; When debugging in RAM, it can be located in RAM, aligned to at least 2^6.
+; The name "__vector_table" has special meaning for C-SPY:
+; it is where the SP start value is found, and the NVIC vector
+; table register (VTOR) is initialized to this address if != 0.
+;
+; Cortex-M version
+;
+
+        MODULE  ?cstartup
+
+        ;; Forward declaration of sections.
+        SECTION CSTACK:DATA:NOROOT(3)
+
+        SECTION .intvec:CODE:NOROOT(2)
+
+        EXTERN  __iar_program_start
+        EXTERN  SystemInit
+        PUBLIC  __vector_table
+
+        DATA
+__vector_table
+        DCD     sfe(CSTACK)
+        DCD     Reset_Handler             ; Reset Handler
+        DCD     NMI_Handler               ; NMI Handler
+        DCD     HardFault_Handler         ; Hard Fault Handler
+        DCD     MemManage_Handler         ; MPU Fault Handler
+        DCD     BusFault_Handler          ; Bus Fault Handler
+        DCD     UsageFault_Handler        ; Usage Fault Handler
+        DCD     0                         ; Reserved
+        DCD     0                         ; Reserved
+        DCD     0                         ; Reserved
+        DCD     0                         ; Reserved
+        DCD     SVC_Handler               ; SVCall Handler
+        DCD     DebugMon_Handler          ; Debug Monitor Handler
+        DCD     0                         ; Reserved
+        DCD     PendSV_Handler            ; PendSV Handler
+        DCD     SysTick_Handler           ; SysTick Handler
+
+         ; External Interrupts
+        DCD     WWDG_IRQHandler           ; Window Watchdog
+        DCD     PVD_IRQHandler            ; PVD through EXTI Line detect
+        DCD     TAMPER_IRQHandler         ; Tamper
+        DCD     RTC_IRQHandler            ; RTC
+        DCD     FLASH_IRQHandler          ; Flash
+        DCD     RCC_IRQHandler            ; RCC
+        DCD     EXTI0_IRQHandler          ; EXTI Line 0
+        DCD     EXTI1_IRQHandler          ; EXTI Line 1
+        DCD     EXTI2_IRQHandler          ; EXTI Line 2
+        DCD     EXTI3_IRQHandler          ; EXTI Line 3
+        DCD     EXTI4_IRQHandler          ; EXTI Line 4
+        DCD     DMA1_Channel1_IRQHandler  ; DMA1 Channel 1
+        DCD     DMA1_Channel2_IRQHandler  ; DMA1 Channel 2
+        DCD     DMA1_Channel3_IRQHandler  ; DMA1 Channel 3
+        DCD     DMA1_Channel4_IRQHandler  ; DMA1 Channel 4
+        DCD     DMA1_Channel5_IRQHandler  ; DMA1 Channel 5
+        DCD     DMA1_Channel6_IRQHandler  ; DMA1 Channel 6
+        DCD     DMA1_Channel7_IRQHandler  ; DMA1 Channel 7
+        DCD     ADC1_2_IRQHandler         ; ADC1 & ADC2
+        DCD     USB_HP_CAN1_TX_IRQHandler  ; USB High Priority or CAN1 TX
+        DCD     USB_LP_CAN1_RX0_IRQHandler ; USB Low  Priority or CAN1 RX0
+        DCD     CAN1_RX1_IRQHandler       ; CAN1 RX1
+        DCD     CAN1_SCE_IRQHandler       ; CAN1 SCE
+        DCD     EXTI9_5_IRQHandler        ; EXTI Line 9..5
+        DCD     TIM1_BRK_IRQHandler       ; TIM1 Break
+        DCD     TIM1_UP_IRQHandler        ; TIM1 Update
+        DCD     TIM1_TRG_COM_IRQHandler   ; TIM1 Trigger and Commutation
+        DCD     TIM1_CC_IRQHandler        ; TIM1 Capture Compare
+        DCD     TIM2_IRQHandler           ; TIM2
+        DCD     TIM3_IRQHandler           ; TIM3
+        DCD     TIM4_IRQHandler           ; TIM4
+        DCD     I2C1_EV_IRQHandler        ; I2C1 Event
+        DCD     I2C1_ER_IRQHandler        ; I2C1 Error
+        DCD     I2C2_EV_IRQHandler        ; I2C2 Event
+        DCD     I2C2_ER_IRQHandler        ; I2C2 Error
+        DCD     SPI1_IRQHandler           ; SPI1
+        DCD     SPI2_IRQHandler           ; SPI2
+        DCD     USART1_IRQHandler         ; USART1
+        DCD     USART2_IRQHandler         ; USART2
+        DCD     USART3_IRQHandler         ; USART3
+        DCD     EXTI15_10_IRQHandler      ; EXTI Line 15..10
+        DCD     RTCAlarm_IRQHandler       ; RTC Alarm through EXTI Line
+        DCD     USBWakeUp_IRQHandler      ; USB Wakeup from suspend
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;;
+;; Default interrupt handlers.
+;;
+        THUMB
+
+        PUBWEAK Reset_Handler
+        SECTION .text:CODE:REORDER(2)
+Reset_Handler
+        LDR     R0, =SystemInit
+        BLX     R0
+        LDR     R0, =__iar_program_start
+        BX      R0
+
+        PUBWEAK NMI_Handler
+        SECTION .text:CODE:REORDER(1)
+NMI_Handler
+        B NMI_Handler
+
+        PUBWEAK HardFault_Handler
+        SECTION .text:CODE:REORDER(1)
+HardFault_Handler
+        B HardFault_Handler
+
+        PUBWEAK MemManage_Handler
+        SECTION .text:CODE:REORDER(1)
+MemManage_Handler
+        B MemManage_Handler
+
+        PUBWEAK BusFault_Handler
+        SECTION .text:CODE:REORDER(1)
+BusFault_Handler
+        B BusFault_Handler
+
+        PUBWEAK UsageFault_Handler
+        SECTION .text:CODE:REORDER(1)
+UsageFault_Handler
+        B UsageFault_Handler
+
+        PUBWEAK SVC_Handler
+        SECTION .text:CODE:REORDER(1)
+SVC_Handler
+        B SVC_Handler
+
+        PUBWEAK DebugMon_Handler
+        SECTION .text:CODE:REORDER(1)
+DebugMon_Handler
+        B DebugMon_Handler
+
+        PUBWEAK PendSV_Handler
+        SECTION .text:CODE:REORDER(1)
+PendSV_Handler
+        B PendSV_Handler
+
+        PUBWEAK SysTick_Handler
+        SECTION .text:CODE:REORDER(1)
+SysTick_Handler
+        B SysTick_Handler
+
+        PUBWEAK WWDG_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+WWDG_IRQHandler
+        B WWDG_IRQHandler
+
+        PUBWEAK PVD_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+PVD_IRQHandler
+        B PVD_IRQHandler
+
+        PUBWEAK TAMPER_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TAMPER_IRQHandler
+        B TAMPER_IRQHandler
+
+        PUBWEAK RTC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+RTC_IRQHandler
+        B RTC_IRQHandler
+
+        PUBWEAK FLASH_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+FLASH_IRQHandler
+        B FLASH_IRQHandler
+
+        PUBWEAK RCC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+RCC_IRQHandler
+        B RCC_IRQHandler
+
+        PUBWEAK EXTI0_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI0_IRQHandler
+        B EXTI0_IRQHandler
+
+        PUBWEAK EXTI1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI1_IRQHandler
+        B EXTI1_IRQHandler
+
+        PUBWEAK EXTI2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI2_IRQHandler
+        B EXTI2_IRQHandler
+
+        PUBWEAK EXTI3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI3_IRQHandler
+        B EXTI3_IRQHandler
+
+        PUBWEAK EXTI4_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI4_IRQHandler
+        B EXTI4_IRQHandler
+
+        PUBWEAK DMA1_Channel1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel1_IRQHandler
+        B DMA1_Channel1_IRQHandler
+
+        PUBWEAK DMA1_Channel2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel2_IRQHandler
+        B DMA1_Channel2_IRQHandler
+
+        PUBWEAK DMA1_Channel3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel3_IRQHandler
+        B DMA1_Channel3_IRQHandler
+
+        PUBWEAK DMA1_Channel4_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel4_IRQHandler
+        B DMA1_Channel4_IRQHandler
+
+        PUBWEAK DMA1_Channel5_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel5_IRQHandler
+        B DMA1_Channel5_IRQHandler
+
+        PUBWEAK DMA1_Channel6_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel6_IRQHandler
+        B DMA1_Channel6_IRQHandler
+
+        PUBWEAK DMA1_Channel7_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel7_IRQHandler
+        B DMA1_Channel7_IRQHandler
+
+        PUBWEAK ADC1_2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+ADC1_2_IRQHandler
+        B ADC1_2_IRQHandler
+
+        PUBWEAK USB_HP_CAN1_TX_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USB_HP_CAN1_TX_IRQHandler
+        B USB_HP_CAN1_TX_IRQHandler
+
+        PUBWEAK USB_LP_CAN1_RX0_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USB_LP_CAN1_RX0_IRQHandler
+        B USB_LP_CAN1_RX0_IRQHandler
+
+        PUBWEAK CAN1_RX1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+CAN1_RX1_IRQHandler
+        B CAN1_RX1_IRQHandler
+
+        PUBWEAK CAN1_SCE_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+CAN1_SCE_IRQHandler
+        B CAN1_SCE_IRQHandler
+
+        PUBWEAK EXTI9_5_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI9_5_IRQHandler
+        B EXTI9_5_IRQHandler
+
+        PUBWEAK TIM1_BRK_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_BRK_IRQHandler
+        B TIM1_BRK_IRQHandler
+
+        PUBWEAK TIM1_UP_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_UP_IRQHandler
+        B TIM1_UP_IRQHandler
+
+        PUBWEAK TIM1_TRG_COM_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_TRG_COM_IRQHandler
+        B TIM1_TRG_COM_IRQHandler
+
+        PUBWEAK TIM1_CC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_CC_IRQHandler
+        B TIM1_CC_IRQHandler
+
+        PUBWEAK TIM2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM2_IRQHandler
+        B TIM2_IRQHandler
+
+        PUBWEAK TIM3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM3_IRQHandler
+        B TIM3_IRQHandler
+
+        PUBWEAK TIM4_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM4_IRQHandler
+        B TIM4_IRQHandler
+
+        PUBWEAK I2C1_EV_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+I2C1_EV_IRQHandler
+        B I2C1_EV_IRQHandler
+
+        PUBWEAK I2C1_ER_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+I2C1_ER_IRQHandler
+        B I2C1_ER_IRQHandler
+
+        PUBWEAK I2C2_EV_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+I2C2_EV_IRQHandler
+        B I2C2_EV_IRQHandler
+
+        PUBWEAK I2C2_ER_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+I2C2_ER_IRQHandler
+        B I2C2_ER_IRQHandler
+
+        PUBWEAK SPI1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+SPI1_IRQHandler
+        B SPI1_IRQHandler
+
+        PUBWEAK SPI2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+SPI2_IRQHandler
+        B SPI2_IRQHandler
+
+        PUBWEAK USART1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USART1_IRQHandler
+        B USART1_IRQHandler
+
+        PUBWEAK USART2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USART2_IRQHandler
+        B USART2_IRQHandler
+
+        PUBWEAK USART3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USART3_IRQHandler
+        B USART3_IRQHandler
+
+        PUBWEAK EXTI15_10_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI15_10_IRQHandler
+        B EXTI15_10_IRQHandler
+
+        PUBWEAK RTCAlarm_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+RTCAlarm_IRQHandler
+        B RTCAlarm_IRQHandler
+
+        PUBWEAK USBWakeUp_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USBWakeUp_IRQHandler
+        B USBWakeUp_IRQHandler
+
+        END
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_md_vl.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_md_vl.s
new file mode 100644
index 0000000..add509d
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_md_vl.s
@@ -0,0 +1,394 @@
+;******************** (C) COPYRIGHT 2011 STMicroelectronics ********************
+;* File Name          : startup_stm32f10x_md_vl.s
+;* Author             : MCD Application Team
+;* Version            : V3.5.0
+;* Date               : 11-March-2011
+;* Description        : STM32F10x Medium Density Value Line Devices vector table
+;*                      for EWARM toolchain.
+;*                      This module performs:
+;*                      - Set the initial SP
+;*                      - Configure the clock system
+;*                      - Set the initial PC == __iar_program_start,
+;*                      - Set the vector table entries with the exceptions ISR
+;*                        address.
+;*                      After Reset the Cortex-M3 processor is in Thread mode,
+;*                      priority is Privileged, and the Stack is set to Main.
+;********************************************************************************
+;* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+;* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+;* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+;* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+;* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+;* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+;*******************************************************************************
+;
+;
+; The modules in this file are included in the libraries, and may be replaced
+; by any user-defined modules that define the PUBLIC symbol _program_start or
+; a user defined start symbol.
+; To override the cstartup defined in the library, simply add your modified
+; version to the workbench project.
+;
+; The vector table is normally located at address 0.
+; When debugging in RAM, it can be located in RAM, aligned to at least 2^6.
+; The name "__vector_table" has special meaning for C-SPY:
+; it is where the SP start value is found, and the NVIC vector
+; table register (VTOR) is initialized to this address if != 0.
+;
+; Cortex-M version
+;
+
+        MODULE  ?cstartup
+
+        ;; Forward declaration of sections.
+        SECTION CSTACK:DATA:NOROOT(3)
+
+        SECTION .intvec:CODE:NOROOT(2)
+
+        EXTERN  __iar_program_start
+        EXTERN  SystemInit
+        PUBLIC  __vector_table
+
+        DATA
+__vector_table
+        DCD     sfe(CSTACK)
+        DCD     Reset_Handler             ; Reset Handler
+        DCD     NMI_Handler               ; NMI Handler
+        DCD     HardFault_Handler         ; Hard Fault Handler
+        DCD     MemManage_Handler         ; MPU Fault Handler
+        DCD     BusFault_Handler          ; Bus Fault Handler
+        DCD     UsageFault_Handler        ; Usage Fault Handler
+        DCD     0                         ; Reserved
+        DCD     0                         ; Reserved
+        DCD     0                         ; Reserved
+        DCD     0                         ; Reserved
+        DCD     SVC_Handler               ; SVCall Handler
+        DCD     DebugMon_Handler          ; Debug Monitor Handler
+        DCD     0                         ; Reserved
+        DCD     PendSV_Handler            ; PendSV Handler
+        DCD     SysTick_Handler           ; SysTick Handler
+
+         ; External Interrupts
+        DCD     WWDG_IRQHandler               ; Window Watchdog
+        DCD     PVD_IRQHandler                ; PVD through EXTI Line detect
+        DCD     TAMPER_IRQHandler             ; Tamper
+        DCD     RTC_IRQHandler                ; RTC
+        DCD     FLASH_IRQHandler              ; Flash
+        DCD     RCC_IRQHandler                ; RCC
+        DCD     EXTI0_IRQHandler              ; EXTI Line 0
+        DCD     EXTI1_IRQHandler              ; EXTI Line 1
+        DCD     EXTI2_IRQHandler              ; EXTI Line 2
+        DCD     EXTI3_IRQHandler              ; EXTI Line 3
+        DCD     EXTI4_IRQHandler              ; EXTI Line 4
+        DCD     DMA1_Channel1_IRQHandler      ; DMA1 Channel 1
+        DCD     DMA1_Channel2_IRQHandler      ; DMA1 Channel 2
+        DCD     DMA1_Channel3_IRQHandler      ; DMA1 Channel 3
+        DCD     DMA1_Channel4_IRQHandler      ; DMA1 Channel 4
+        DCD     DMA1_Channel5_IRQHandler      ; DMA1 Channel 5
+        DCD     DMA1_Channel6_IRQHandler      ; DMA1 Channel 6
+        DCD     DMA1_Channel7_IRQHandler      ; DMA1 Channel 7
+        DCD     ADC1_IRQHandler               ; ADC1
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     EXTI9_5_IRQHandler            ; EXTI Line 9..5
+        DCD     TIM1_BRK_TIM15_IRQHandler     ; TIM1 Break and TIM15
+        DCD     TIM1_UP_TIM16_IRQHandler      ; TIM1 Update and TIM16
+        DCD     TIM1_TRG_COM_TIM17_IRQHandler ; TIM1 Trigger and Commutation and TIM17
+        DCD     TIM1_CC_IRQHandler            ; TIM1 Capture Compare
+        DCD     TIM2_IRQHandler               ; TIM2
+        DCD     TIM3_IRQHandler               ; TIM3
+        DCD     TIM4_IRQHandler               ; TIM4
+        DCD     I2C1_EV_IRQHandler            ; I2C1 Event
+        DCD     I2C1_ER_IRQHandler            ; I2C1 Error
+        DCD     I2C2_EV_IRQHandler            ; I2C2 Event
+        DCD     I2C2_ER_IRQHandler            ; I2C2 Error
+        DCD     SPI1_IRQHandler               ; SPI1
+        DCD     SPI2_IRQHandler               ; SPI2
+        DCD     USART1_IRQHandler             ; USART1
+        DCD     USART2_IRQHandler             ; USART2
+        DCD     USART3_IRQHandler             ; USART3
+        DCD     EXTI15_10_IRQHandler          ; EXTI Line 15..10
+        DCD     RTCAlarm_IRQHandler           ; RTC Alarm through EXTI Line
+        DCD     CEC_IRQHandler                ; HDMI-CEC
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     0                             ; Reserved
+        DCD     TIM6_DAC_IRQHandler           ; TIM6 and DAC underrun
+        DCD     TIM7_IRQHandler               ; TIM7
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;;
+;; Default interrupt handlers.
+;;
+        THUMB
+
+        PUBWEAK Reset_Handler
+        SECTION .text:CODE:REORDER(2)
+Reset_Handler
+        LDR     R0, =SystemInit
+        BLX     R0
+        LDR     R0, =__iar_program_start
+        BX      R0
+
+        PUBWEAK NMI_Handler
+        SECTION .text:CODE:REORDER(1)
+NMI_Handler
+        B NMI_Handler
+
+        PUBWEAK HardFault_Handler
+        SECTION .text:CODE:REORDER(1)
+HardFault_Handler
+        B HardFault_Handler
+
+        PUBWEAK MemManage_Handler
+        SECTION .text:CODE:REORDER(1)
+MemManage_Handler
+        B MemManage_Handler
+
+        PUBWEAK BusFault_Handler
+        SECTION .text:CODE:REORDER(1)
+BusFault_Handler
+        B BusFault_Handler
+
+        PUBWEAK UsageFault_Handler
+        SECTION .text:CODE:REORDER(1)
+UsageFault_Handler
+        B UsageFault_Handler
+
+        PUBWEAK SVC_Handler
+        SECTION .text:CODE:REORDER(1)
+SVC_Handler
+        B SVC_Handler
+
+        PUBWEAK DebugMon_Handler
+        SECTION .text:CODE:REORDER(1)
+DebugMon_Handler
+        B DebugMon_Handler
+
+        PUBWEAK PendSV_Handler
+        SECTION .text:CODE:REORDER(1)
+PendSV_Handler
+        B PendSV_Handler
+
+        PUBWEAK SysTick_Handler
+        SECTION .text:CODE:REORDER(1)
+SysTick_Handler
+        B SysTick_Handler
+
+        PUBWEAK WWDG_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+WWDG_IRQHandler
+        B WWDG_IRQHandler
+
+        PUBWEAK PVD_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+PVD_IRQHandler
+        B PVD_IRQHandler
+
+        PUBWEAK TAMPER_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TAMPER_IRQHandler
+        B TAMPER_IRQHandler
+
+        PUBWEAK RTC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+RTC_IRQHandler
+        B RTC_IRQHandler
+
+        PUBWEAK FLASH_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+FLASH_IRQHandler
+        B FLASH_IRQHandler
+
+        PUBWEAK RCC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+RCC_IRQHandler
+        B RCC_IRQHandler
+
+        PUBWEAK EXTI0_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI0_IRQHandler
+        B EXTI0_IRQHandler
+
+        PUBWEAK EXTI1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI1_IRQHandler
+        B EXTI1_IRQHandler
+
+        PUBWEAK EXTI2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI2_IRQHandler
+        B EXTI2_IRQHandler
+
+        PUBWEAK EXTI3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI3_IRQHandler
+        B EXTI3_IRQHandler
+
+        PUBWEAK EXTI4_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI4_IRQHandler
+        B EXTI4_IRQHandler
+
+        PUBWEAK DMA1_Channel1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel1_IRQHandler
+        B DMA1_Channel1_IRQHandler
+
+        PUBWEAK DMA1_Channel2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel2_IRQHandler
+        B DMA1_Channel2_IRQHandler
+
+        PUBWEAK DMA1_Channel3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel3_IRQHandler
+        B DMA1_Channel3_IRQHandler
+
+        PUBWEAK DMA1_Channel4_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel4_IRQHandler
+        B DMA1_Channel4_IRQHandler
+
+        PUBWEAK DMA1_Channel5_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel5_IRQHandler
+        B DMA1_Channel5_IRQHandler
+
+        PUBWEAK DMA1_Channel6_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel6_IRQHandler
+        B DMA1_Channel6_IRQHandler
+
+        PUBWEAK DMA1_Channel7_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel7_IRQHandler
+        B DMA1_Channel7_IRQHandler
+
+        PUBWEAK ADC1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+ADC1_IRQHandler
+        B ADC1_IRQHandler
+
+        PUBWEAK EXTI9_5_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI9_5_IRQHandler
+        B EXTI9_5_IRQHandler
+
+        PUBWEAK TIM1_BRK_TIM15_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_BRK_TIM15_IRQHandler
+        B TIM1_BRK_TIM15_IRQHandler
+
+        PUBWEAK TIM1_UP_TIM16_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_UP_TIM16_IRQHandler
+        B TIM1_UP_TIM16_IRQHandler
+
+        PUBWEAK TIM1_TRG_COM_TIM17_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_TRG_COM_TIM17_IRQHandler
+        B TIM1_TRG_COM_TIM17_IRQHandler
+
+        PUBWEAK TIM1_CC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_CC_IRQHandler
+        B TIM1_CC_IRQHandler
+
+        PUBWEAK TIM2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM2_IRQHandler
+        B TIM2_IRQHandler
+
+        PUBWEAK TIM3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM3_IRQHandler
+        B TIM3_IRQHandler
+
+        PUBWEAK TIM4_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM4_IRQHandler
+        B TIM4_IRQHandler
+
+        PUBWEAK I2C1_EV_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+I2C1_EV_IRQHandler
+        B I2C1_EV_IRQHandler
+
+        PUBWEAK I2C1_ER_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+I2C1_ER_IRQHandler
+        B I2C1_ER_IRQHandler
+
+        PUBWEAK I2C2_EV_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+I2C2_EV_IRQHandler
+        B I2C2_EV_IRQHandler
+
+        PUBWEAK I2C2_ER_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+I2C2_ER_IRQHandler
+        B I2C2_ER_IRQHandler
+
+        PUBWEAK SPI1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+SPI1_IRQHandler
+        B SPI1_IRQHandler
+
+        PUBWEAK SPI2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+SPI2_IRQHandler
+        B SPI2_IRQHandler
+
+        PUBWEAK USART1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USART1_IRQHandler
+        B USART1_IRQHandler
+
+        PUBWEAK USART2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USART2_IRQHandler
+        B USART2_IRQHandler
+
+        PUBWEAK USART3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USART3_IRQHandler
+        B USART3_IRQHandler
+
+        PUBWEAK EXTI15_10_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI15_10_IRQHandler
+        B EXTI15_10_IRQHandler
+
+        PUBWEAK RTCAlarm_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+RTCAlarm_IRQHandler
+        B RTCAlarm_IRQHandler
+
+        PUBWEAK CEC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+CEC_IRQHandler
+        B CEC_IRQHandler
+
+        PUBWEAK TIM6_DAC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM6_DAC_IRQHandler
+        B TIM6_DAC_IRQHandler
+
+        PUBWEAK TIM7_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM7_IRQHandler
+        B TIM7_IRQHandler
+
+        END
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_xl.s b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_xl.s
new file mode 100644
index 0000000..a7f49c5
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/startup_stm32f10x_xl.s
@@ -0,0 +1,496 @@
+;******************** (C) COPYRIGHT 2011 STMicroelectronics ********************
+;* File Name          : startup_stm32f10x_xl.s
+;* Author             : MCD Application Team
+;* Version            : V3.5.0
+;* Date               : 11-March-2011
+;* Description        : STM32F10x XL-Density Devices vector table for EWARM
+;*                      toolchain.
+;*                      This module performs:
+;*                      - Set the initial SP
+;*                      - Configure the clock system and the external SRAM
+;*                        mounted on STM3210E-EVAL board to be used as data
+;*                        memory (optional, to be enabled by user)
+;*                      - Set the initial PC == __iar_program_start,
+;*                      - Set the vector table entries with the exceptions ISR address,
+;*                      After Reset the Cortex-M3 processor is in Thread mode,
+;*                      priority is Privileged, and the Stack is set to Main.
+;********************************************************************************
+;* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+;* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+;* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+;* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+;* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+;* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+;*******************************************************************************
+;
+;
+; The modules in this file are included in the libraries, and may be replaced
+; by any user-defined modules that define the PUBLIC symbol _program_start or
+; a user defined start symbol.
+; To override the cstartup defined in the library, simply add your modified
+; version to the workbench project.
+;
+; The vector table is normally located at address 0.
+; When debugging in RAM, it can be located in RAM, aligned to at least 2^6.
+; The name "__vector_table" has special meaning for C-SPY:
+; it is where the SP start value is found, and the NVIC vector
+; table register (VTOR) is initialized to this address if != 0.
+;
+; Cortex-M version
+;
+
+    MODULE  ?cstartup
+
+        ;; Forward declaration of sections.
+        SECTION CSTACK:DATA:NOROOT(3)
+
+        SECTION .intvec:CODE:NOROOT(2)
+
+        EXTERN  __iar_program_start
+        EXTERN  SystemInit
+        PUBLIC  __vector_table
+
+        DATA
+
+__vector_table
+        DCD     sfe(CSTACK)
+        DCD     Reset_Handler             ; Reset Handler
+        DCD     NMI_Handler               ; NMI Handler
+        DCD     HardFault_Handler         ; Hard Fault Handler
+        DCD     MemManage_Handler         ; MPU Fault Handler
+        DCD     BusFault_Handler          ; Bus Fault Handler
+        DCD     UsageFault_Handler        ; Usage Fault Handler
+        DCD     0                         ; Reserved
+        DCD     0                         ; Reserved
+        DCD     0                         ; Reserved
+        DCD     0                         ; Reserved
+        DCD     SVC_Handler               ; SVCall Handler
+        DCD     DebugMon_Handler          ; Debug Monitor Handler
+        DCD     0                         ; Reserved
+        DCD     PendSV_Handler            ; PendSV Handler
+        DCD     SysTick_Handler           ; SysTick Handler
+
+         ; External Interrupts
+        DCD     WWDG_IRQHandler               ; Window Watchdog
+        DCD     PVD_IRQHandler                ; PVD through EXTI Line detect
+        DCD     TAMPER_IRQHandler             ; Tamper
+        DCD     RTC_IRQHandler                ; RTC
+        DCD     FLASH_IRQHandler              ; Flash
+        DCD     RCC_IRQHandler                ; RCC
+        DCD     EXTI0_IRQHandler              ; EXTI Line 0
+        DCD     EXTI1_IRQHandler              ; EXTI Line 1
+        DCD     EXTI2_IRQHandler              ; EXTI Line 2
+        DCD     EXTI3_IRQHandler              ; EXTI Line 3
+        DCD     EXTI4_IRQHandler              ; EXTI Line 4
+        DCD     DMA1_Channel1_IRQHandler      ; DMA1 Channel 1
+        DCD     DMA1_Channel2_IRQHandler      ; DMA1 Channel 2
+        DCD     DMA1_Channel3_IRQHandler      ; DMA1 Channel 3
+        DCD     DMA1_Channel4_IRQHandler      ; DMA1 Channel 4
+        DCD     DMA1_Channel5_IRQHandler      ; DMA1 Channel 5
+        DCD     DMA1_Channel6_IRQHandler      ; DMA1 Channel 6
+        DCD     DMA1_Channel7_IRQHandler      ; DMA1 Channel 7
+        DCD     ADC1_2_IRQHandler             ; ADC1 & ADC2
+        DCD     USB_HP_CAN1_TX_IRQHandler     ; USB High Priority or CAN1 TX
+        DCD     USB_LP_CAN1_RX0_IRQHandler    ; USB Low  Priority or CAN1 RX0
+        DCD     CAN1_RX1_IRQHandler           ; CAN1 RX1
+        DCD     CAN1_SCE_IRQHandler           ; CAN1 SCE
+        DCD     EXTI9_5_IRQHandler            ; EXTI Line 9..5
+        DCD     TIM1_BRK_TIM9_IRQHandler      ; TIM1 Break and TIM9
+        DCD     TIM1_UP_TIM10_IRQHandler      ; TIM1 Update and TIM10
+        DCD     TIM1_TRG_COM_TIM11_IRQHandler ; TIM1 Trigger and Commutation and TIM11
+        DCD     TIM1_CC_IRQHandler            ; TIM1 Capture Compare
+        DCD     TIM2_IRQHandler               ; TIM2
+        DCD     TIM3_IRQHandler               ; TIM3
+        DCD     TIM4_IRQHandler               ; TIM4
+        DCD     I2C1_EV_IRQHandler            ; I2C1 Event
+        DCD     I2C1_ER_IRQHandler            ; I2C1 Error
+        DCD     I2C2_EV_IRQHandler            ; I2C2 Event
+        DCD     I2C2_ER_IRQHandler            ; I2C2 Error
+        DCD     SPI1_IRQHandler               ; SPI1
+        DCD     SPI2_IRQHandler               ; SPI2
+        DCD     USART1_IRQHandler             ; USART1
+        DCD     USART2_IRQHandler             ; USART2
+        DCD     USART3_IRQHandler             ; USART3
+        DCD     EXTI15_10_IRQHandler          ; EXTI Line 15..10
+        DCD     RTCAlarm_IRQHandler           ; RTC Alarm through EXTI Line
+        DCD     USBWakeUp_IRQHandler          ; USB Wakeup from suspend
+        DCD     TIM8_BRK_TIM12_IRQHandler     ; TIM8 Break and TIM12
+        DCD     TIM8_UP_TIM13_IRQHandler      ; TIM8 Update and TIM13
+        DCD     TIM8_TRG_COM_TIM14_IRQHandler ; TIM8 Trigger and Commutation and TIM14
+        DCD     TIM8_CC_IRQHandler            ; TIM8 Capture Compare
+        DCD     ADC3_IRQHandler               ; ADC3
+        DCD     FSMC_IRQHandler               ; FSMC
+        DCD     SDIO_IRQHandler               ; SDIO
+        DCD     TIM5_IRQHandler               ; TIM5
+        DCD     SPI3_IRQHandler               ; SPI3
+        DCD     UART4_IRQHandler              ; UART4
+        DCD     UART5_IRQHandler              ; UART5
+        DCD     TIM6_IRQHandler               ; TIM6
+        DCD     TIM7_IRQHandler               ; TIM7
+        DCD     DMA2_Channel1_IRQHandler      ; DMA2 Channel1
+        DCD     DMA2_Channel2_IRQHandler      ; DMA2 Channel2
+        DCD     DMA2_Channel3_IRQHandler      ; DMA2 Channel3
+        DCD     DMA2_Channel4_5_IRQHandler    ; DMA2 Channel4 & Channel5
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;;
+;; Default interrupt handlers.
+;;
+        THUMB
+
+        PUBWEAK Reset_Handler
+        SECTION .text:CODE:REORDER(2)
+Reset_Handler
+        LDR     R0, =SystemInit
+        BLX     R0
+        LDR     R0, =__iar_program_start
+        BX      R0
+
+        PUBWEAK NMI_Handler
+        SECTION .text:CODE:REORDER(1)
+NMI_Handler
+        B NMI_Handler
+
+        PUBWEAK HardFault_Handler
+        SECTION .text:CODE:REORDER(1)
+HardFault_Handler
+        B HardFault_Handler
+
+        PUBWEAK MemManage_Handler
+        SECTION .text:CODE:REORDER(1)
+MemManage_Handler
+        B MemManage_Handler
+
+        PUBWEAK BusFault_Handler
+        SECTION .text:CODE:REORDER(1)
+BusFault_Handler
+        B BusFault_Handler
+
+        PUBWEAK UsageFault_Handler
+        SECTION .text:CODE:REORDER(1)
+UsageFault_Handler
+        B UsageFault_Handler
+
+        PUBWEAK SVC_Handler
+        SECTION .text:CODE:REORDER(1)
+SVC_Handler
+        B SVC_Handler
+
+        PUBWEAK DebugMon_Handler
+        SECTION .text:CODE:REORDER(1)
+DebugMon_Handler
+        B DebugMon_Handler
+
+        PUBWEAK PendSV_Handler
+        SECTION .text:CODE:REORDER(1)
+PendSV_Handler
+        B PendSV_Handler
+
+        PUBWEAK SysTick_Handler
+        SECTION .text:CODE:REORDER(1)
+SysTick_Handler
+        B SysTick_Handler
+
+        PUBWEAK WWDG_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+WWDG_IRQHandler
+        B WWDG_IRQHandler
+
+        PUBWEAK PVD_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+PVD_IRQHandler
+        B PVD_IRQHandler
+
+        PUBWEAK TAMPER_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TAMPER_IRQHandler
+        B TAMPER_IRQHandler
+
+        PUBWEAK RTC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+RTC_IRQHandler
+        B RTC_IRQHandler
+
+        PUBWEAK FLASH_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+FLASH_IRQHandler
+        B FLASH_IRQHandler
+
+        PUBWEAK RCC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+RCC_IRQHandler
+        B RCC_IRQHandler
+
+        PUBWEAK EXTI0_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI0_IRQHandler
+        B EXTI0_IRQHandler
+
+        PUBWEAK EXTI1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI1_IRQHandler
+        B EXTI1_IRQHandler
+
+        PUBWEAK EXTI2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI2_IRQHandler
+        B EXTI2_IRQHandler
+
+        PUBWEAK EXTI3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI3_IRQHandler
+        B EXTI3_IRQHandler
+
+        PUBWEAK EXTI4_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI4_IRQHandler
+        B EXTI4_IRQHandler
+
+        PUBWEAK DMA1_Channel1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel1_IRQHandler
+        B DMA1_Channel1_IRQHandler
+
+        PUBWEAK DMA1_Channel2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel2_IRQHandler
+        B DMA1_Channel2_IRQHandler
+
+        PUBWEAK DMA1_Channel3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel3_IRQHandler
+        B DMA1_Channel3_IRQHandler
+
+        PUBWEAK DMA1_Channel4_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel4_IRQHandler
+        B DMA1_Channel4_IRQHandler
+
+        PUBWEAK DMA1_Channel5_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel5_IRQHandler
+        B DMA1_Channel5_IRQHandler
+
+        PUBWEAK DMA1_Channel6_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel6_IRQHandler
+        B DMA1_Channel6_IRQHandler
+
+        PUBWEAK DMA1_Channel7_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA1_Channel7_IRQHandler
+        B DMA1_Channel7_IRQHandler
+
+        PUBWEAK ADC1_2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+ADC1_2_IRQHandler
+        B ADC1_2_IRQHandler
+
+        PUBWEAK USB_HP_CAN1_TX_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USB_HP_CAN1_TX_IRQHandler
+        B USB_HP_CAN1_TX_IRQHandler
+
+        PUBWEAK USB_LP_CAN1_RX0_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USB_LP_CAN1_RX0_IRQHandler
+        B USB_LP_CAN1_RX0_IRQHandler
+
+        PUBWEAK CAN1_RX1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+CAN1_RX1_IRQHandler
+        B CAN1_RX1_IRQHandler
+
+        PUBWEAK CAN1_SCE_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+CAN1_SCE_IRQHandler
+        B CAN1_SCE_IRQHandler
+
+        PUBWEAK EXTI9_5_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI9_5_IRQHandler
+        B EXTI9_5_IRQHandler
+
+        PUBWEAK TIM1_BRK_TIM9_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_BRK_TIM9_IRQHandler
+        B TIM1_BRK_TIM9_IRQHandler
+
+        PUBWEAK TIM1_UP_TIM10_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_UP_TIM10_IRQHandler
+        B TIM1_UP_TIM10_IRQHandler
+
+        PUBWEAK TIM1_TRG_COM_TIM11_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_TRG_COM_TIM11_IRQHandler
+        B TIM1_TRG_COM_TIM11_IRQHandler
+
+        PUBWEAK TIM1_CC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM1_CC_IRQHandler
+        B TIM1_CC_IRQHandler
+
+        PUBWEAK TIM2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM2_IRQHandler
+        B TIM2_IRQHandler
+
+        PUBWEAK TIM3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM3_IRQHandler
+        B TIM3_IRQHandler
+
+        PUBWEAK TIM4_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM4_IRQHandler
+        B TIM4_IRQHandler
+
+        PUBWEAK I2C1_EV_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+I2C1_EV_IRQHandler
+        B I2C1_EV_IRQHandler
+
+        PUBWEAK I2C1_ER_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+I2C1_ER_IRQHandler
+        B I2C1_ER_IRQHandler
+
+        PUBWEAK I2C2_EV_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+I2C2_EV_IRQHandler
+        B I2C2_EV_IRQHandler
+
+        PUBWEAK I2C2_ER_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+I2C2_ER_IRQHandler
+        B I2C2_ER_IRQHandler
+
+        PUBWEAK SPI1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+SPI1_IRQHandler
+        B SPI1_IRQHandler
+
+        PUBWEAK SPI2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+SPI2_IRQHandler
+        B SPI2_IRQHandler
+
+        PUBWEAK USART1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USART1_IRQHandler
+        B USART1_IRQHandler
+
+        PUBWEAK USART2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USART2_IRQHandler
+        B USART2_IRQHandler
+
+        PUBWEAK USART3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USART3_IRQHandler
+        B USART3_IRQHandler
+
+        PUBWEAK EXTI15_10_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+EXTI15_10_IRQHandler
+        B EXTI15_10_IRQHandler
+
+        PUBWEAK RTCAlarm_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+RTCAlarm_IRQHandler
+        B RTCAlarm_IRQHandler
+
+        PUBWEAK USBWakeUp_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+USBWakeUp_IRQHandler
+        B USBWakeUp_IRQHandler
+
+        PUBWEAK TIM8_BRK_TIM12_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM8_BRK_TIM12_IRQHandler
+        B TIM8_BRK_TIM12_IRQHandler
+
+        PUBWEAK TIM8_UP_TIM13_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM8_UP_TIM13_IRQHandler
+        B TIM8_UP_TIM13_IRQHandler
+
+        PUBWEAK TIM8_TRG_COM_TIM14_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM8_TRG_COM_TIM14_IRQHandler
+        B TIM8_TRG_COM_TIM14_IRQHandler
+
+        PUBWEAK TIM8_CC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM8_CC_IRQHandler
+        B TIM8_CC_IRQHandler
+
+        PUBWEAK ADC3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+ADC3_IRQHandler
+        B ADC3_IRQHandler
+
+        PUBWEAK FSMC_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+FSMC_IRQHandler
+        B FSMC_IRQHandler
+
+        PUBWEAK SDIO_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+SDIO_IRQHandler
+        B SDIO_IRQHandler
+
+        PUBWEAK TIM5_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM5_IRQHandler
+        B TIM5_IRQHandler
+
+        PUBWEAK SPI3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+SPI3_IRQHandler
+        B SPI3_IRQHandler
+
+        PUBWEAK UART4_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+UART4_IRQHandler
+        B UART4_IRQHandler
+
+        PUBWEAK UART5_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+UART5_IRQHandler
+        B UART5_IRQHandler
+
+        PUBWEAK TIM6_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM6_IRQHandler
+        B TIM6_IRQHandler
+
+        PUBWEAK TIM7_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+TIM7_IRQHandler
+        B TIM7_IRQHandler
+
+        PUBWEAK DMA2_Channel1_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA2_Channel1_IRQHandler
+        B DMA2_Channel1_IRQHandler
+
+        PUBWEAK DMA2_Channel2_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA2_Channel2_IRQHandler
+        B DMA2_Channel2_IRQHandler
+
+        PUBWEAK DMA2_Channel3_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA2_Channel3_IRQHandler
+        B DMA2_Channel3_IRQHandler
+
+        PUBWEAK DMA2_Channel4_5_IRQHandler
+        SECTION .text:CODE:REORDER(1)
+DMA2_Channel4_5_IRQHandler
+        B DMA2_Channel4_5_IRQHandler
+
+
+        END
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/stm32f10x.h b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/stm32f10x.h
new file mode 100644
index 0000000..af0c7c9
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/stm32f10x.h
@@ -0,0 +1,8336 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x.h
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer Header File.
+  *          This file contains all the peripheral register's definitions, bits
+  *          definitions and memory mapping for STM32F10x Connectivity line,
+  *          High density, High density value line, Medium density,
+  *          Medium density Value line, Low density, Low density Value line
+  *          and XL-density devices.
+  *
+  *          The file is the unique include file that the application programmer
+  *          is using in the C source code, usually in main.c. This file contains:
+  *           - Configuration section that allows to select:
+  *              - The device used in the target application
+  *              - To use or not the peripherals drivers in application code(i.e.
+  *                code will be based on direct access to peripherals registers
+  *                rather than drivers API), this option is controlled by
+  *                "#define USE_STDPERIPH_DRIVER"
+  *              - To change few application-specific parameters such as the HSE
+  *                crystal frequency
+  *           - Data structures and the address mapping for all peripherals
+  *           - Peripheral's registers declarations and bits definition
+  *           - Macros to access peripherals registers hardware
+  *
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/** @addtogroup CMSIS
+  * @{
+  */
+
+/** @addtogroup stm32f10x
+  * @{
+  */
+
+#ifndef __STM32F10x_H
+#define __STM32F10x_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/** @addtogroup Library_configuration_section
+  * @{
+  */
+
+/* Uncomment the line below according to the target STM32 device used in your
+   application
+  */
+
+#if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD) && !defined (STM32F10X_HD_VL) && !defined (STM32F10X_XL) && !defined (STM32F10X_CL)
+  /* #define STM32F10X_LD */     /*!< STM32F10X_LD: STM32 Low density devices */
+  /* #define STM32F10X_LD_VL */  /*!< STM32F10X_LD_VL: STM32 Low density Value Line devices */
+  /* #define STM32F10X_MD */     /*!< STM32F10X_MD: STM32 Medium density devices */
+  /* #define STM32F10X_MD_VL */  /*!< STM32F10X_MD_VL: STM32 Medium density Value Line devices */
+  /* #define STM32F10X_HD */     /*!< STM32F10X_HD: STM32 High density devices */
+  /* #define STM32F10X_HD_VL */  /*!< STM32F10X_HD_VL: STM32 High density value line devices */
+  /* #define STM32F10X_XL */     /*!< STM32F10X_XL: STM32 XL-density devices */
+  /* #define STM32F10X_CL */     /*!< STM32F10X_CL: STM32 Connectivity line devices */
+#endif
+/*  Tip: To avoid modifying this file each time you need to switch between these
+        devices, you can define the device in your toolchain compiler preprocessor.
+
+ - Low-density devices are STM32F101xx, STM32F102xx and STM32F103xx microcontrollers
+   where the Flash memory density ranges between 16 and 32 Kbytes.
+ - Low-density value line devices are STM32F100xx microcontrollers where the Flash
+   memory density ranges between 16 and 32 Kbytes.
+ - Medium-density devices are STM32F101xx, STM32F102xx and STM32F103xx microcontrollers
+   where the Flash memory density ranges between 64 and 128 Kbytes.
+ - Medium-density value line devices are STM32F100xx microcontrollers where the
+   Flash memory density ranges between 64 and 128 Kbytes.
+ - High-density devices are STM32F101xx and STM32F103xx microcontrollers where
+   the Flash memory density ranges between 256 and 512 Kbytes.
+ - High-density value line devices are STM32F100xx microcontrollers where the
+   Flash memory density ranges between 256 and 512 Kbytes.
+ - XL-density devices are STM32F101xx and STM32F103xx microcontrollers where
+   the Flash memory density ranges between 512 and 1024 Kbytes.
+ - Connectivity line devices are STM32F105xx and STM32F107xx microcontrollers.
+  */
+
+#if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD) && !defined (STM32F10X_HD_VL) && !defined (STM32F10X_XL) && !defined (STM32F10X_CL)
+ #error "Please select first the target STM32F10x device used in your application (in stm32f10x.h file)"
+#endif
+
+#if !defined  USE_STDPERIPH_DRIVER
+/**
+ * @brief Comment the line below if you will not use the peripherals drivers.
+   In this case, these drivers will not be included and the application code will
+   be based on direct access to peripherals registers
+   */
+  /*#define USE_STDPERIPH_DRIVER*/
+#endif
+
+/**
+ * @brief In the following line adjust the value of External High Speed oscillator (HSE)
+   used in your application
+
+   Tip: To avoid modifying this file each time you need to use different HSE, you
+        can define the HSE value in your toolchain compiler preprocessor.
+  */
+#if !defined  HSE_VALUE
+ #ifdef STM32F10X_CL
+  #define HSE_VALUE    ((uint32_t)25000000) /*!< Value of the External oscillator in Hz */
+ #else
+  #define HSE_VALUE    ((uint32_t)8000000) /*!< Value of the External oscillator in Hz */
+ #endif /* STM32F10X_CL */
+#endif /* HSE_VALUE */
+
+
+/**
+ * @brief In the following line adjust the External High Speed oscillator (HSE) Startup
+   Timeout value
+   */
+#define HSE_STARTUP_TIMEOUT   ((uint16_t)0x0500) /*!< Time out for HSE start up */
+
+#define HSI_VALUE    ((uint32_t)8000000) /*!< Value of the Internal oscillator in Hz*/
+
+/**
+ * @brief STM32F10x Standard Peripheral Library version number
+   */
+#define __STM32F10X_STDPERIPH_VERSION_MAIN   (0x03) /*!< [31:24] main version */
+#define __STM32F10X_STDPERIPH_VERSION_SUB1   (0x05) /*!< [23:16] sub1 version */
+#define __STM32F10X_STDPERIPH_VERSION_SUB2   (0x00) /*!< [15:8]  sub2 version */
+#define __STM32F10X_STDPERIPH_VERSION_RC     (0x00) /*!< [7:0]  release candidate */
+#define __STM32F10X_STDPERIPH_VERSION       ( (__STM32F10X_STDPERIPH_VERSION_MAIN << 24)\
+                                             |(__STM32F10X_STDPERIPH_VERSION_SUB1 << 16)\
+                                             |(__STM32F10X_STDPERIPH_VERSION_SUB2 << 8)\
+                                             |(__STM32F10X_STDPERIPH_VERSION_RC))
+
+/**
+  * @}
+  */
+
+/** @addtogroup Configuration_section_for_CMSIS
+  * @{
+  */
+
+/**
+ * @brief Configuration of the Cortex-M3 Processor and Core Peripherals
+ */
+#ifdef STM32F10X_XL
+ #define __MPU_PRESENT             1 /*!< STM32 XL-density devices provide an MPU */
+#else
+ #define __MPU_PRESENT             0 /*!< Other STM32 devices does not provide an MPU */
+#endif /* STM32F10X_XL */
+#define __NVIC_PRIO_BITS          4 /*!< STM32 uses 4 Bits for the Priority Levels    */
+#define __Vendor_SysTickConfig    0 /*!< Set to 1 if different SysTick Config is used */
+
+/**
+ * @brief STM32F10x Interrupt Number Definition, according to the selected device
+ *        in @ref Library_configuration_section
+ */
+typedef enum IRQn
+{
+/******  Cortex-M3 Processor Exceptions Numbers ***************************************************/
+  NonMaskableInt_IRQn         = -14,    /*!< 2 Non Maskable Interrupt                             */
+  MemoryManagement_IRQn       = -12,    /*!< 4 Cortex-M3 Memory Management Interrupt              */
+  BusFault_IRQn               = -11,    /*!< 5 Cortex-M3 Bus Fault Interrupt                      */
+  UsageFault_IRQn             = -10,    /*!< 6 Cortex-M3 Usage Fault Interrupt                    */
+  SVCall_IRQn                 = -5,     /*!< 11 Cortex-M3 SV Call Interrupt                       */
+  DebugMonitor_IRQn           = -4,     /*!< 12 Cortex-M3 Debug Monitor Interrupt                 */
+  PendSV_IRQn                 = -2,     /*!< 14 Cortex-M3 Pend SV Interrupt                       */
+  SysTick_IRQn                = -1,     /*!< 15 Cortex-M3 System Tick Interrupt                   */
+
+/******  STM32 specific Interrupt Numbers *********************************************************/
+  WWDG_IRQn                   = 0,      /*!< Window WatchDog Interrupt                            */
+  PVD_IRQn                    = 1,      /*!< PVD through EXTI Line detection Interrupt            */
+  TAMPER_IRQn                 = 2,      /*!< Tamper Interrupt                                     */
+  RTC_IRQn                    = 3,      /*!< RTC global Interrupt                                 */
+  FLASH_IRQn                  = 4,      /*!< FLASH global Interrupt                               */
+  RCC_IRQn                    = 5,      /*!< RCC global Interrupt                                 */
+  EXTI0_IRQn                  = 6,      /*!< EXTI Line0 Interrupt                                 */
+  EXTI1_IRQn                  = 7,      /*!< EXTI Line1 Interrupt                                 */
+  EXTI2_IRQn                  = 8,      /*!< EXTI Line2 Interrupt                                 */
+  EXTI3_IRQn                  = 9,      /*!< EXTI Line3 Interrupt                                 */
+  EXTI4_IRQn                  = 10,     /*!< EXTI Line4 Interrupt                                 */
+  DMA1_Channel1_IRQn          = 11,     /*!< DMA1 Channel 1 global Interrupt                      */
+  DMA1_Channel2_IRQn          = 12,     /*!< DMA1 Channel 2 global Interrupt                      */
+  DMA1_Channel3_IRQn          = 13,     /*!< DMA1 Channel 3 global Interrupt                      */
+  DMA1_Channel4_IRQn          = 14,     /*!< DMA1 Channel 4 global Interrupt                      */
+  DMA1_Channel5_IRQn          = 15,     /*!< DMA1 Channel 5 global Interrupt                      */
+  DMA1_Channel6_IRQn          = 16,     /*!< DMA1 Channel 6 global Interrupt                      */
+  DMA1_Channel7_IRQn          = 17,     /*!< DMA1 Channel 7 global Interrupt                      */
+
+#ifdef STM32F10X_LD
+  ADC1_2_IRQn                 = 18,     /*!< ADC1 and ADC2 global Interrupt                       */
+  USB_HP_CAN1_TX_IRQn         = 19,     /*!< USB Device High Priority or CAN1 TX Interrupts       */
+  USB_LP_CAN1_RX0_IRQn        = 20,     /*!< USB Device Low Priority or CAN1 RX0 Interrupts       */
+  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                   */
+  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                   */
+  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
+  TIM1_BRK_IRQn               = 24,     /*!< TIM1 Break Interrupt                                 */
+  TIM1_UP_IRQn                = 25,     /*!< TIM1 Update Interrupt                                */
+  TIM1_TRG_COM_IRQn           = 26,     /*!< TIM1 Trigger and Commutation Interrupt               */
+  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
+  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
+  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
+  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
+  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
+  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
+  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
+  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
+  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
+  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
+  USBWakeUp_IRQn              = 42      /*!< USB Device WakeUp from suspend through EXTI Line Interrupt */
+#endif /* STM32F10X_LD */
+
+#ifdef STM32F10X_LD_VL
+  ADC1_IRQn                   = 18,     /*!< ADC1 global Interrupt                                */
+  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
+  TIM1_BRK_TIM15_IRQn         = 24,     /*!< TIM1 Break and TIM15 Interrupts                      */
+  TIM1_UP_TIM16_IRQn          = 25,     /*!< TIM1 Update and TIM16 Interrupts                     */
+  TIM1_TRG_COM_TIM17_IRQn     = 26,     /*!< TIM1 Trigger and Commutation and TIM17 Interrupt     */
+  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
+  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
+  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
+  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
+  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
+  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
+  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
+  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
+  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
+  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
+  CEC_IRQn                    = 42,     /*!< HDMI-CEC Interrupt                                   */
+  TIM6_DAC_IRQn               = 54,     /*!< TIM6 and DAC underrun Interrupt                      */
+  TIM7_IRQn                   = 55      /*!< TIM7 Interrupt                                       */
+#endif /* STM32F10X_LD_VL */
+
+#ifdef STM32F10X_MD
+  ADC1_2_IRQn                 = 18,     /*!< ADC1 and ADC2 global Interrupt                       */
+  USB_HP_CAN1_TX_IRQn         = 19,     /*!< USB Device High Priority or CAN1 TX Interrupts       */
+  USB_LP_CAN1_RX0_IRQn        = 20,     /*!< USB Device Low Priority or CAN1 RX0 Interrupts       */
+  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                   */
+  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                   */
+  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
+  TIM1_BRK_IRQn               = 24,     /*!< TIM1 Break Interrupt                                 */
+  TIM1_UP_IRQn                = 25,     /*!< TIM1 Update Interrupt                                */
+  TIM1_TRG_COM_IRQn           = 26,     /*!< TIM1 Trigger and Commutation Interrupt               */
+  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
+  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
+  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
+  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                */
+  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
+  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
+  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                 */
+  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                 */
+  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
+  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                */
+  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
+  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
+  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                              */
+  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
+  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
+  USBWakeUp_IRQn              = 42      /*!< USB Device WakeUp from suspend through EXTI Line Interrupt */
+#endif /* STM32F10X_MD */
+
+#ifdef STM32F10X_MD_VL
+  ADC1_IRQn                   = 18,     /*!< ADC1 global Interrupt                                */
+  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
+  TIM1_BRK_TIM15_IRQn         = 24,     /*!< TIM1 Break and TIM15 Interrupts                      */
+  TIM1_UP_TIM16_IRQn          = 25,     /*!< TIM1 Update and TIM16 Interrupts                     */
+  TIM1_TRG_COM_TIM17_IRQn     = 26,     /*!< TIM1 Trigger and Commutation and TIM17 Interrupt     */
+  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
+  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
+  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
+  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                */
+  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
+  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
+  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                 */
+  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                 */
+  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
+  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                */
+  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
+  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
+  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                              */
+  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
+  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
+  CEC_IRQn                    = 42,     /*!< HDMI-CEC Interrupt                                   */
+  TIM6_DAC_IRQn               = 54,     /*!< TIM6 and DAC underrun Interrupt                      */
+  TIM7_IRQn                   = 55      /*!< TIM7 Interrupt                                       */
+#endif /* STM32F10X_MD_VL */
+
+#ifdef STM32F10X_HD
+  ADC1_2_IRQn                 = 18,     /*!< ADC1 and ADC2 global Interrupt                       */
+  USB_HP_CAN1_TX_IRQn         = 19,     /*!< USB Device High Priority or CAN1 TX Interrupts       */
+  USB_LP_CAN1_RX0_IRQn        = 20,     /*!< USB Device Low Priority or CAN1 RX0 Interrupts       */
+  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                   */
+  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                   */
+  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
+  TIM1_BRK_IRQn               = 24,     /*!< TIM1 Break Interrupt                                 */
+  TIM1_UP_IRQn                = 25,     /*!< TIM1 Update Interrupt                                */
+  TIM1_TRG_COM_IRQn           = 26,     /*!< TIM1 Trigger and Commutation Interrupt               */
+  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
+  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
+  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
+  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                */
+  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
+  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
+  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                 */
+  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                 */
+  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
+  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                */
+  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
+  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
+  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                              */
+  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
+  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
+  USBWakeUp_IRQn              = 42,     /*!< USB Device WakeUp from suspend through EXTI Line Interrupt */
+  TIM8_BRK_IRQn               = 43,     /*!< TIM8 Break Interrupt                                 */
+  TIM8_UP_IRQn                = 44,     /*!< TIM8 Update Interrupt                                */
+  TIM8_TRG_COM_IRQn           = 45,     /*!< TIM8 Trigger and Commutation Interrupt               */
+  TIM8_CC_IRQn                = 46,     /*!< TIM8 Capture Compare Interrupt                       */
+  ADC3_IRQn                   = 47,     /*!< ADC3 global Interrupt                                */
+  FSMC_IRQn                   = 48,     /*!< FSMC global Interrupt                                */
+  SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                */
+  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                */
+  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                */
+  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                               */
+  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                               */
+  TIM6_IRQn                   = 54,     /*!< TIM6 global Interrupt                                */
+  TIM7_IRQn                   = 55,     /*!< TIM7 global Interrupt                                */
+  DMA2_Channel1_IRQn          = 56,     /*!< DMA2 Channel 1 global Interrupt                      */
+  DMA2_Channel2_IRQn          = 57,     /*!< DMA2 Channel 2 global Interrupt                      */
+  DMA2_Channel3_IRQn          = 58,     /*!< DMA2 Channel 3 global Interrupt                      */
+  DMA2_Channel4_5_IRQn        = 59      /*!< DMA2 Channel 4 and Channel 5 global Interrupt        */
+#endif /* STM32F10X_HD */
+
+#ifdef STM32F10X_HD_VL
+  ADC1_IRQn                   = 18,     /*!< ADC1 global Interrupt                                */
+  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
+  TIM1_BRK_TIM15_IRQn         = 24,     /*!< TIM1 Break and TIM15 Interrupts                      */
+  TIM1_UP_TIM16_IRQn          = 25,     /*!< TIM1 Update and TIM16 Interrupts                     */
+  TIM1_TRG_COM_TIM17_IRQn     = 26,     /*!< TIM1 Trigger and Commutation and TIM17 Interrupt     */
+  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
+  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
+  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
+  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                */
+  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
+  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
+  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                 */
+  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                 */
+  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
+  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                */
+  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
+  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
+  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                              */
+  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
+  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
+  CEC_IRQn                    = 42,     /*!< HDMI-CEC Interrupt                                   */
+  TIM12_IRQn                  = 43,     /*!< TIM12 global Interrupt                               */
+  TIM13_IRQn                  = 44,     /*!< TIM13 global Interrupt                               */
+  TIM14_IRQn                  = 45,     /*!< TIM14 global Interrupt                               */
+  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                */
+  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                */
+  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                               */
+  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                               */
+  TIM6_DAC_IRQn               = 54,     /*!< TIM6 and DAC underrun Interrupt                      */
+  TIM7_IRQn                   = 55,     /*!< TIM7 Interrupt                                       */
+  DMA2_Channel1_IRQn          = 56,     /*!< DMA2 Channel 1 global Interrupt                      */
+  DMA2_Channel2_IRQn          = 57,     /*!< DMA2 Channel 2 global Interrupt                      */
+  DMA2_Channel3_IRQn          = 58,     /*!< DMA2 Channel 3 global Interrupt                      */
+  DMA2_Channel4_5_IRQn        = 59,     /*!< DMA2 Channel 4 and Channel 5 global Interrupt        */
+  DMA2_Channel5_IRQn          = 60      /*!< DMA2 Channel 5 global Interrupt (DMA2 Channel 5 is
+                                             mapped at position 60 only if the MISC_REMAP bit in
+                                             the AFIO_MAPR2 register is set)                      */
+#endif /* STM32F10X_HD_VL */
+
+#ifdef STM32F10X_XL
+  ADC1_2_IRQn                 = 18,     /*!< ADC1 and ADC2 global Interrupt                       */
+  USB_HP_CAN1_TX_IRQn         = 19,     /*!< USB Device High Priority or CAN1 TX Interrupts       */
+  USB_LP_CAN1_RX0_IRQn        = 20,     /*!< USB Device Low Priority or CAN1 RX0 Interrupts       */
+  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                   */
+  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                   */
+  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
+  TIM1_BRK_TIM9_IRQn          = 24,     /*!< TIM1 Break Interrupt and TIM9 global Interrupt       */
+  TIM1_UP_TIM10_IRQn          = 25,     /*!< TIM1 Update Interrupt and TIM10 global Interrupt     */
+  TIM1_TRG_COM_TIM11_IRQn     = 26,     /*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */
+  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
+  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
+  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
+  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                */
+  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
+  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
+  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                 */
+  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                 */
+  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
+  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                */
+  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
+  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
+  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                              */
+  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
+  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
+  USBWakeUp_IRQn              = 42,     /*!< USB Device WakeUp from suspend through EXTI Line Interrupt */
+  TIM8_BRK_TIM12_IRQn         = 43,     /*!< TIM8 Break Interrupt and TIM12 global Interrupt      */
+  TIM8_UP_TIM13_IRQn          = 44,     /*!< TIM8 Update Interrupt and TIM13 global Interrupt     */
+  TIM8_TRG_COM_TIM14_IRQn     = 45,     /*!< TIM8 Trigger and Commutation Interrupt and TIM14 global interrupt */
+  TIM8_CC_IRQn                = 46,     /*!< TIM8 Capture Compare Interrupt                       */
+  ADC3_IRQn                   = 47,     /*!< ADC3 global Interrupt                                */
+  FSMC_IRQn                   = 48,     /*!< FSMC global Interrupt                                */
+  SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                */
+  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                */
+  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                */
+  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                               */
+  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                               */
+  TIM6_IRQn                   = 54,     /*!< TIM6 global Interrupt                                */
+  TIM7_IRQn                   = 55,     /*!< TIM7 global Interrupt                                */
+  DMA2_Channel1_IRQn          = 56,     /*!< DMA2 Channel 1 global Interrupt                      */
+  DMA2_Channel2_IRQn          = 57,     /*!< DMA2 Channel 2 global Interrupt                      */
+  DMA2_Channel3_IRQn          = 58,     /*!< DMA2 Channel 3 global Interrupt                      */
+  DMA2_Channel4_5_IRQn        = 59      /*!< DMA2 Channel 4 and Channel 5 global Interrupt        */
+#endif /* STM32F10X_XL */
+
+#ifdef STM32F10X_CL
+  ADC1_2_IRQn                 = 18,     /*!< ADC1 and ADC2 global Interrupt                       */
+  CAN1_TX_IRQn                = 19,     /*!< USB Device High Priority or CAN1 TX Interrupts       */
+  CAN1_RX0_IRQn               = 20,     /*!< USB Device Low Priority or CAN1 RX0 Interrupts       */
+  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                   */
+  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                   */
+  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
+  TIM1_BRK_IRQn               = 24,     /*!< TIM1 Break Interrupt                                 */
+  TIM1_UP_IRQn                = 25,     /*!< TIM1 Update Interrupt                                */
+  TIM1_TRG_COM_IRQn           = 26,     /*!< TIM1 Trigger and Commutation Interrupt               */
+  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
+  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
+  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
+  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                */
+  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
+  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
+  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                 */
+  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                 */
+  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
+  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                */
+  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
+  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
+  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                              */
+  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
+  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
+  OTG_FS_WKUP_IRQn            = 42,     /*!< USB OTG FS WakeUp from suspend through EXTI Line Interrupt */
+  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                */
+  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                */
+  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                               */
+  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                               */
+  TIM6_IRQn                   = 54,     /*!< TIM6 global Interrupt                                */
+  TIM7_IRQn                   = 55,     /*!< TIM7 global Interrupt                                */
+  DMA2_Channel1_IRQn          = 56,     /*!< DMA2 Channel 1 global Interrupt                      */
+  DMA2_Channel2_IRQn          = 57,     /*!< DMA2 Channel 2 global Interrupt                      */
+  DMA2_Channel3_IRQn          = 58,     /*!< DMA2 Channel 3 global Interrupt                      */
+  DMA2_Channel4_IRQn          = 59,     /*!< DMA2 Channel 4 global Interrupt                      */
+  DMA2_Channel5_IRQn          = 60,     /*!< DMA2 Channel 5 global Interrupt                      */
+  ETH_IRQn                    = 61,     /*!< Ethernet global Interrupt                            */
+  ETH_WKUP_IRQn               = 62,     /*!< Ethernet Wakeup through EXTI line Interrupt          */
+  CAN2_TX_IRQn                = 63,     /*!< CAN2 TX Interrupt                                    */
+  CAN2_RX0_IRQn               = 64,     /*!< CAN2 RX0 Interrupt                                   */
+  CAN2_RX1_IRQn               = 65,     /*!< CAN2 RX1 Interrupt                                   */
+  CAN2_SCE_IRQn               = 66,     /*!< CAN2 SCE Interrupt                                   */
+  OTG_FS_IRQn                 = 67      /*!< USB OTG FS global Interrupt                          */
+#endif /* STM32F10X_CL */
+} IRQn_Type;
+
+/**
+  * @}
+  */
+
+#include "core_cm3.h"
+#include "system_stm32f10x.h"
+#include <stdint.h>
+
+/** @addtogroup Exported_types
+  * @{
+  */
+
+/*!< STM32F10x Standard Peripheral Library old types (maintained for legacy purpose) */
+typedef int32_t  s32;
+typedef int16_t s16;
+typedef int8_t  s8;
+
+typedef const int32_t sc32;  /*!< Read Only */
+typedef const int16_t sc16;  /*!< Read Only */
+typedef const int8_t sc8;   /*!< Read Only */
+
+typedef __IO int32_t  vs32;
+typedef __IO int16_t  vs16;
+typedef __IO int8_t   vs8;
+
+typedef __I int32_t vsc32;  /*!< Read Only */
+typedef __I int16_t vsc16;  /*!< Read Only */
+typedef __I int8_t vsc8;   /*!< Read Only */
+
+typedef uint32_t  u32;
+typedef uint16_t u16;
+typedef uint8_t  u8;
+
+typedef const uint32_t uc32;  /*!< Read Only */
+typedef const uint16_t uc16;  /*!< Read Only */
+typedef const uint8_t uc8;   /*!< Read Only */
+
+typedef __IO uint32_t  vu32;
+typedef __IO uint16_t vu16;
+typedef __IO uint8_t  vu8;
+
+typedef __I uint32_t vuc32;  /*!< Read Only */
+typedef __I uint16_t vuc16;  /*!< Read Only */
+typedef __I uint8_t vuc8;   /*!< Read Only */
+
+typedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus;
+
+typedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
+#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
+
+typedef enum {ERROR = 0, SUCCESS = !ERROR} ErrorStatus;
+
+/*!< STM32F10x Standard Peripheral Library old definitions (maintained for legacy purpose) */
+#define HSEStartUp_TimeOut   HSE_STARTUP_TIMEOUT
+#define HSE_Value            HSE_VALUE
+#define HSI_Value            HSI_VALUE
+/**
+  * @}
+  */
+
+/** @addtogroup Peripheral_registers_structures
+  * @{
+  */
+
+/**
+  * @brief Analog to Digital Converter
+  */
+
+typedef struct
+{
+  __IO uint32_t SR;
+  __IO uint32_t CR1;
+  __IO uint32_t CR2;
+  __IO uint32_t SMPR1;
+  __IO uint32_t SMPR2;
+  __IO uint32_t JOFR1;
+  __IO uint32_t JOFR2;
+  __IO uint32_t JOFR3;
+  __IO uint32_t JOFR4;
+  __IO uint32_t HTR;
+  __IO uint32_t LTR;
+  __IO uint32_t SQR1;
+  __IO uint32_t SQR2;
+  __IO uint32_t SQR3;
+  __IO uint32_t JSQR;
+  __IO uint32_t JDR1;
+  __IO uint32_t JDR2;
+  __IO uint32_t JDR3;
+  __IO uint32_t JDR4;
+  __IO uint32_t DR;
+} ADC_TypeDef;
+
+/**
+  * @brief Backup Registers
+  */
+
+typedef struct
+{
+  uint32_t  RESERVED0;
+  __IO uint16_t DR1;
+  uint16_t  RESERVED1;
+  __IO uint16_t DR2;
+  uint16_t  RESERVED2;
+  __IO uint16_t DR3;
+  uint16_t  RESERVED3;
+  __IO uint16_t DR4;
+  uint16_t  RESERVED4;
+  __IO uint16_t DR5;
+  uint16_t  RESERVED5;
+  __IO uint16_t DR6;
+  uint16_t  RESERVED6;
+  __IO uint16_t DR7;
+  uint16_t  RESERVED7;
+  __IO uint16_t DR8;
+  uint16_t  RESERVED8;
+  __IO uint16_t DR9;
+  uint16_t  RESERVED9;
+  __IO uint16_t DR10;
+  uint16_t  RESERVED10;
+  __IO uint16_t RTCCR;
+  uint16_t  RESERVED11;
+  __IO uint16_t CR;
+  uint16_t  RESERVED12;
+  __IO uint16_t CSR;
+  uint16_t  RESERVED13[5];
+  __IO uint16_t DR11;
+  uint16_t  RESERVED14;
+  __IO uint16_t DR12;
+  uint16_t  RESERVED15;
+  __IO uint16_t DR13;
+  uint16_t  RESERVED16;
+  __IO uint16_t DR14;
+  uint16_t  RESERVED17;
+  __IO uint16_t DR15;
+  uint16_t  RESERVED18;
+  __IO uint16_t DR16;
+  uint16_t  RESERVED19;
+  __IO uint16_t DR17;
+  uint16_t  RESERVED20;
+  __IO uint16_t DR18;
+  uint16_t  RESERVED21;
+  __IO uint16_t DR19;
+  uint16_t  RESERVED22;
+  __IO uint16_t DR20;
+  uint16_t  RESERVED23;
+  __IO uint16_t DR21;
+  uint16_t  RESERVED24;
+  __IO uint16_t DR22;
+  uint16_t  RESERVED25;
+  __IO uint16_t DR23;
+  uint16_t  RESERVED26;
+  __IO uint16_t DR24;
+  uint16_t  RESERVED27;
+  __IO uint16_t DR25;
+  uint16_t  RESERVED28;
+  __IO uint16_t DR26;
+  uint16_t  RESERVED29;
+  __IO uint16_t DR27;
+  uint16_t  RESERVED30;
+  __IO uint16_t DR28;
+  uint16_t  RESERVED31;
+  __IO uint16_t DR29;
+  uint16_t  RESERVED32;
+  __IO uint16_t DR30;
+  uint16_t  RESERVED33;
+  __IO uint16_t DR31;
+  uint16_t  RESERVED34;
+  __IO uint16_t DR32;
+  uint16_t  RESERVED35;
+  __IO uint16_t DR33;
+  uint16_t  RESERVED36;
+  __IO uint16_t DR34;
+  uint16_t  RESERVED37;
+  __IO uint16_t DR35;
+  uint16_t  RESERVED38;
+  __IO uint16_t DR36;
+  uint16_t  RESERVED39;
+  __IO uint16_t DR37;
+  uint16_t  RESERVED40;
+  __IO uint16_t DR38;
+  uint16_t  RESERVED41;
+  __IO uint16_t DR39;
+  uint16_t  RESERVED42;
+  __IO uint16_t DR40;
+  uint16_t  RESERVED43;
+  __IO uint16_t DR41;
+  uint16_t  RESERVED44;
+  __IO uint16_t DR42;
+  uint16_t  RESERVED45;
+} BKP_TypeDef;
+
+/**
+  * @brief Controller Area Network TxMailBox
+  */
+
+typedef struct
+{
+  __IO uint32_t TIR;
+  __IO uint32_t TDTR;
+  __IO uint32_t TDLR;
+  __IO uint32_t TDHR;
+} CAN_TxMailBox_TypeDef;
+
+/**
+  * @brief Controller Area Network FIFOMailBox
+  */
+
+typedef struct
+{
+  __IO uint32_t RIR;
+  __IO uint32_t RDTR;
+  __IO uint32_t RDLR;
+  __IO uint32_t RDHR;
+} CAN_FIFOMailBox_TypeDef;
+
+/**
+  * @brief Controller Area Network FilterRegister
+  */
+
+typedef struct
+{
+  __IO uint32_t FR1;
+  __IO uint32_t FR2;
+} CAN_FilterRegister_TypeDef;
+
+/**
+  * @brief Controller Area Network
+  */
+
+typedef struct
+{
+  __IO uint32_t MCR;
+  __IO uint32_t MSR;
+  __IO uint32_t TSR;
+  __IO uint32_t RF0R;
+  __IO uint32_t RF1R;
+  __IO uint32_t IER;
+  __IO uint32_t ESR;
+  __IO uint32_t BTR;
+  uint32_t  RESERVED0[88];
+  CAN_TxMailBox_TypeDef sTxMailBox[3];
+  CAN_FIFOMailBox_TypeDef sFIFOMailBox[2];
+  uint32_t  RESERVED1[12];
+  __IO uint32_t FMR;
+  __IO uint32_t FM1R;
+  uint32_t  RESERVED2;
+  __IO uint32_t FS1R;
+  uint32_t  RESERVED3;
+  __IO uint32_t FFA1R;
+  uint32_t  RESERVED4;
+  __IO uint32_t FA1R;
+  uint32_t  RESERVED5[8];
+#ifndef STM32F10X_CL
+  CAN_FilterRegister_TypeDef sFilterRegister[14];
+#else
+  CAN_FilterRegister_TypeDef sFilterRegister[28];
+#endif /* STM32F10X_CL */
+} CAN_TypeDef;
+
+/**
+  * @brief Consumer Electronics Control (CEC)
+  */
+typedef struct
+{
+  __IO uint32_t CFGR;
+  __IO uint32_t OAR;
+  __IO uint32_t PRES;
+  __IO uint32_t ESR;
+  __IO uint32_t CSR;
+  __IO uint32_t TXD;
+  __IO uint32_t RXD;
+} CEC_TypeDef;
+
+/**
+  * @brief CRC calculation unit
+  */
+
+typedef struct
+{
+  __IO uint32_t DR;
+  __IO uint8_t  IDR;
+  uint8_t   RESERVED0;
+  uint16_t  RESERVED1;
+  __IO uint32_t CR;
+} CRC_TypeDef;
+
+/**
+  * @brief Digital to Analog Converter
+  */
+
+typedef struct
+{
+  __IO uint32_t CR;
+  __IO uint32_t SWTRIGR;
+  __IO uint32_t DHR12R1;
+  __IO uint32_t DHR12L1;
+  __IO uint32_t DHR8R1;
+  __IO uint32_t DHR12R2;
+  __IO uint32_t DHR12L2;
+  __IO uint32_t DHR8R2;
+  __IO uint32_t DHR12RD;
+  __IO uint32_t DHR12LD;
+  __IO uint32_t DHR8RD;
+  __IO uint32_t DOR1;
+  __IO uint32_t DOR2;
+#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
+  __IO uint32_t SR;
+#endif
+} DAC_TypeDef;
+
+/**
+  * @brief Debug MCU
+  */
+
+typedef struct
+{
+  __IO uint32_t IDCODE;
+  __IO uint32_t CR;
+}DBGMCU_TypeDef;
+
+/**
+  * @brief DMA Controller
+  */
+
+typedef struct
+{
+  __IO uint32_t CCR;
+  __IO uint32_t CNDTR;
+  __IO uint32_t CPAR;
+  __IO uint32_t CMAR;
+} DMA_Channel_TypeDef;
+
+typedef struct
+{
+  __IO uint32_t ISR;
+  __IO uint32_t IFCR;
+} DMA_TypeDef;
+
+/**
+  * @brief Ethernet MAC
+  */
+
+typedef struct
+{
+  __IO uint32_t MACCR;
+  __IO uint32_t MACFFR;
+  __IO uint32_t MACHTHR;
+  __IO uint32_t MACHTLR;
+  __IO uint32_t MACMIIAR;
+  __IO uint32_t MACMIIDR;
+  __IO uint32_t MACFCR;
+  __IO uint32_t MACVLANTR;             /*    8 */
+       uint32_t RESERVED0[2];
+  __IO uint32_t MACRWUFFR;             /*   11 */
+  __IO uint32_t MACPMTCSR;
+       uint32_t RESERVED1[2];
+  __IO uint32_t MACSR;                 /*   15 */
+  __IO uint32_t MACIMR;
+  __IO uint32_t MACA0HR;
+  __IO uint32_t MACA0LR;
+  __IO uint32_t MACA1HR;
+  __IO uint32_t MACA1LR;
+  __IO uint32_t MACA2HR;
+  __IO uint32_t MACA2LR;
+  __IO uint32_t MACA3HR;
+  __IO uint32_t MACA3LR;               /*   24 */
+       uint32_t RESERVED2[40];
+  __IO uint32_t MMCCR;                 /*   65 */
+  __IO uint32_t MMCRIR;
+  __IO uint32_t MMCTIR;
+  __IO uint32_t MMCRIMR;
+  __IO uint32_t MMCTIMR;               /*   69 */
+       uint32_t RESERVED3[14];
+  __IO uint32_t MMCTGFSCCR;            /*   84 */
+  __IO uint32_t MMCTGFMSCCR;
+       uint32_t RESERVED4[5];
+  __IO uint32_t MMCTGFCR;
+       uint32_t RESERVED5[10];
+  __IO uint32_t MMCRFCECR;
+  __IO uint32_t MMCRFAECR;
+       uint32_t RESERVED6[10];
+  __IO uint32_t MMCRGUFCR;
+       uint32_t RESERVED7[334];
+  __IO uint32_t PTPTSCR;
+  __IO uint32_t PTPSSIR;
+  __IO uint32_t PTPTSHR;
+  __IO uint32_t PTPTSLR;
+  __IO uint32_t PTPTSHUR;
+  __IO uint32_t PTPTSLUR;
+  __IO uint32_t PTPTSAR;
+  __IO uint32_t PTPTTHR;
+  __IO uint32_t PTPTTLR;
+       uint32_t RESERVED8[567];
+  __IO uint32_t DMABMR;
+  __IO uint32_t DMATPDR;
+  __IO uint32_t DMARPDR;
+  __IO uint32_t DMARDLAR;
+  __IO uint32_t DMATDLAR;
+  __IO uint32_t DMASR;
+  __IO uint32_t DMAOMR;
+  __IO uint32_t DMAIER;
+  __IO uint32_t DMAMFBOCR;
+       uint32_t RESERVED9[9];
+  __IO uint32_t DMACHTDR;
+  __IO uint32_t DMACHRDR;
+  __IO uint32_t DMACHTBAR;
+  __IO uint32_t DMACHRBAR;
+} ETH_TypeDef;
+
+/**
+  * @brief External Interrupt/Event Controller
+  */
+
+typedef struct
+{
+  __IO uint32_t IMR;
+  __IO uint32_t EMR;
+  __IO uint32_t RTSR;
+  __IO uint32_t FTSR;
+  __IO uint32_t SWIER;
+  __IO uint32_t PR;
+} EXTI_TypeDef;
+
+/**
+  * @brief FLASH Registers
+  */
+
+typedef struct
+{
+  __IO uint32_t ACR;
+  __IO uint32_t KEYR;
+  __IO uint32_t OPTKEYR;
+  __IO uint32_t SR;
+  __IO uint32_t CR;
+  __IO uint32_t AR;
+  __IO uint32_t RESERVED;
+  __IO uint32_t OBR;
+  __IO uint32_t WRPR;
+#ifdef STM32F10X_XL
+  uint32_t RESERVED1[8];
+  __IO uint32_t KEYR2;
+  uint32_t RESERVED2;
+  __IO uint32_t SR2;
+  __IO uint32_t CR2;
+  __IO uint32_t AR2;
+#endif /* STM32F10X_XL */
+} FLASH_TypeDef;
+
+/**
+  * @brief Option Bytes Registers
+  */
+
+typedef struct
+{
+  __IO uint16_t RDP;
+  __IO uint16_t USER;
+  __IO uint16_t Data0;
+  __IO uint16_t Data1;
+  __IO uint16_t WRP0;
+  __IO uint16_t WRP1;
+  __IO uint16_t WRP2;
+  __IO uint16_t WRP3;
+} OB_TypeDef;
+
+/**
+  * @brief Flexible Static Memory Controller
+  */
+
+typedef struct
+{
+  __IO uint32_t BTCR[8];
+} FSMC_Bank1_TypeDef;
+
+/**
+  * @brief Flexible Static Memory Controller Bank1E
+  */
+
+typedef struct
+{
+  __IO uint32_t BWTR[7];
+} FSMC_Bank1E_TypeDef;
+
+/**
+  * @brief Flexible Static Memory Controller Bank2
+  */
+
+typedef struct
+{
+  __IO uint32_t PCR2;
+  __IO uint32_t SR2;
+  __IO uint32_t PMEM2;
+  __IO uint32_t PATT2;
+  uint32_t  RESERVED0;
+  __IO uint32_t ECCR2;
+} FSMC_Bank2_TypeDef;
+
+/**
+  * @brief Flexible Static Memory Controller Bank3
+  */
+
+typedef struct
+{
+  __IO uint32_t PCR3;
+  __IO uint32_t SR3;
+  __IO uint32_t PMEM3;
+  __IO uint32_t PATT3;
+  uint32_t  RESERVED0;
+  __IO uint32_t ECCR3;
+} FSMC_Bank3_TypeDef;
+
+/**
+  * @brief Flexible Static Memory Controller Bank4
+  */
+
+typedef struct
+{
+  __IO uint32_t PCR4;
+  __IO uint32_t SR4;
+  __IO uint32_t PMEM4;
+  __IO uint32_t PATT4;
+  __IO uint32_t PIO4;
+} FSMC_Bank4_TypeDef;
+
+/**
+  * @brief General Purpose I/O
+  */
+
+typedef struct
+{
+  __IO uint32_t CRL;
+  __IO uint32_t CRH;
+  __IO uint32_t IDR;
+  __IO uint32_t ODR;
+  __IO uint32_t BSRR;
+  __IO uint32_t BRR;
+  __IO uint32_t LCKR;
+} GPIO_TypeDef;
+
+/**
+  * @brief Alternate Function I/O
+  */
+
+typedef struct
+{
+  __IO uint32_t EVCR;
+  __IO uint32_t MAPR;
+  __IO uint32_t EXTICR[4];
+  uint32_t RESERVED0;
+  __IO uint32_t MAPR2;
+} AFIO_TypeDef;
+/**
+  * @brief Inter Integrated Circuit Interface
+  */
+
+typedef struct
+{
+  __IO uint16_t CR1;
+  uint16_t  RESERVED0;
+  __IO uint16_t CR2;
+  uint16_t  RESERVED1;
+  __IO uint16_t OAR1;
+  uint16_t  RESERVED2;
+  __IO uint16_t OAR2;
+  uint16_t  RESERVED3;
+  __IO uint16_t DR;
+  uint16_t  RESERVED4;
+  __IO uint16_t SR1;
+  uint16_t  RESERVED5;
+  __IO uint16_t SR2;
+  uint16_t  RESERVED6;
+  __IO uint16_t CCR;
+  uint16_t  RESERVED7;
+  __IO uint16_t TRISE;
+  uint16_t  RESERVED8;
+} I2C_TypeDef;
+
+/**
+  * @brief Independent WATCHDOG
+  */
+
+typedef struct
+{
+  __IO uint32_t KR;
+  __IO uint32_t PR;
+  __IO uint32_t RLR;
+  __IO uint32_t SR;
+} IWDG_TypeDef;
+
+/**
+  * @brief Power Control
+  */
+
+typedef struct
+{
+  __IO uint32_t CR;
+  __IO uint32_t CSR;
+} PWR_TypeDef;
+
+/**
+  * @brief Reset and Clock Control
+  */
+
+typedef struct
+{
+  __IO uint32_t CR;
+  __IO uint32_t CFGR;
+  __IO uint32_t CIR;
+  __IO uint32_t APB2RSTR;
+  __IO uint32_t APB1RSTR;
+  __IO uint32_t AHBENR;
+  __IO uint32_t APB2ENR;
+  __IO uint32_t APB1ENR;
+  __IO uint32_t BDCR;
+  __IO uint32_t CSR;
+
+#ifdef STM32F10X_CL
+  __IO uint32_t AHBRSTR;
+  __IO uint32_t CFGR2;
+#endif /* STM32F10X_CL */
+
+#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
+  uint32_t RESERVED0;
+  __IO uint32_t CFGR2;
+#endif /* STM32F10X_LD_VL || STM32F10X_MD_VL || STM32F10X_HD_VL */
+} RCC_TypeDef;
+
+/**
+  * @brief Real-Time Clock
+  */
+
+typedef struct
+{
+  __IO uint16_t CRH;
+  uint16_t  RESERVED0;
+  __IO uint16_t CRL;
+  uint16_t  RESERVED1;
+  __IO uint16_t PRLH;
+  uint16_t  RESERVED2;
+  __IO uint16_t PRLL;
+  uint16_t  RESERVED3;
+  __IO uint16_t DIVH;
+  uint16_t  RESERVED4;
+  __IO uint16_t DIVL;
+  uint16_t  RESERVED5;
+  __IO uint16_t CNTH;
+  uint16_t  RESERVED6;
+  __IO uint16_t CNTL;
+  uint16_t  RESERVED7;
+  __IO uint16_t ALRH;
+  uint16_t  RESERVED8;
+  __IO uint16_t ALRL;
+  uint16_t  RESERVED9;
+} RTC_TypeDef;
+
+/**
+  * @brief SD host Interface
+  */
+
+typedef struct
+{
+  __IO uint32_t POWER;
+  __IO uint32_t CLKCR;
+  __IO uint32_t ARG;
+  __IO uint32_t CMD;
+  __I uint32_t RESPCMD;
+  __I uint32_t RESP1;
+  __I uint32_t RESP2;
+  __I uint32_t RESP3;
+  __I uint32_t RESP4;
+  __IO uint32_t DTIMER;
+  __IO uint32_t DLEN;
+  __IO uint32_t DCTRL;
+  __I uint32_t DCOUNT;
+  __I uint32_t STA;
+  __IO uint32_t ICR;
+  __IO uint32_t MASK;
+  uint32_t  RESERVED0[2];
+  __I uint32_t FIFOCNT;
+  uint32_t  RESERVED1[13];
+  __IO uint32_t FIFO;
+} SDIO_TypeDef;
+
+/**
+  * @brief Serial Peripheral Interface
+  */
+
+typedef struct
+{
+  __IO uint16_t CR1;
+  uint16_t  RESERVED0;
+  __IO uint16_t CR2;
+  uint16_t  RESERVED1;
+  __IO uint16_t SR;
+  uint16_t  RESERVED2;
+  __IO uint16_t DR;
+  uint16_t  RESERVED3;
+  __IO uint16_t CRCPR;
+  uint16_t  RESERVED4;
+  __IO uint16_t RXCRCR;
+  uint16_t  RESERVED5;
+  __IO uint16_t TXCRCR;
+  uint16_t  RESERVED6;
+  __IO uint16_t I2SCFGR;
+  uint16_t  RESERVED7;
+  __IO uint16_t I2SPR;
+  uint16_t  RESERVED8;
+} SPI_TypeDef;
+
+/**
+  * @brief TIM
+  */
+
+typedef struct
+{
+  __IO uint16_t CR1;
+  uint16_t  RESERVED0;
+  __IO uint16_t CR2;
+  uint16_t  RESERVED1;
+  __IO uint16_t SMCR;
+  uint16_t  RESERVED2;
+  __IO uint16_t DIER;
+  uint16_t  RESERVED3;
+  __IO uint16_t SR;
+  uint16_t  RESERVED4;
+  __IO uint16_t EGR;
+  uint16_t  RESERVED5;
+  __IO uint16_t CCMR1;
+  uint16_t  RESERVED6;
+  __IO uint16_t CCMR2;
+  uint16_t  RESERVED7;
+  __IO uint16_t CCER;
+  uint16_t  RESERVED8;
+  __IO uint16_t CNT;
+  uint16_t  RESERVED9;
+  __IO uint16_t PSC;
+  uint16_t  RESERVED10;
+  __IO uint16_t ARR;
+  uint16_t  RESERVED11;
+  __IO uint16_t RCR;
+  uint16_t  RESERVED12;
+  __IO uint16_t CCR1;
+  uint16_t  RESERVED13;
+  __IO uint16_t CCR2;
+  uint16_t  RESERVED14;
+  __IO uint16_t CCR3;
+  uint16_t  RESERVED15;
+  __IO uint16_t CCR4;
+  uint16_t  RESERVED16;
+  __IO uint16_t BDTR;
+  uint16_t  RESERVED17;
+  __IO uint16_t DCR;
+  uint16_t  RESERVED18;
+  __IO uint16_t DMAR;
+  uint16_t  RESERVED19;
+} TIM_TypeDef;
+
+/**
+  * @brief Universal Synchronous Asynchronous Receiver Transmitter
+  */
+
+typedef struct
+{
+  __IO uint16_t SR;
+  uint16_t  RESERVED0;
+  __IO uint16_t DR;
+  uint16_t  RESERVED1;
+  __IO uint16_t BRR;
+  uint16_t  RESERVED2;
+  __IO uint16_t CR1;
+  uint16_t  RESERVED3;
+  __IO uint16_t CR2;
+  uint16_t  RESERVED4;
+  __IO uint16_t CR3;
+  uint16_t  RESERVED5;
+  __IO uint16_t GTPR;
+  uint16_t  RESERVED6;
+} USART_TypeDef;
+
+/**
+  * @brief Window WATCHDOG
+  */
+
+typedef struct
+{
+  __IO uint32_t CR;
+  __IO uint32_t CFR;
+  __IO uint32_t SR;
+} WWDG_TypeDef;
+
+/**
+  * @}
+  */
+
+/** @addtogroup Peripheral_memory_map
+  * @{
+  */
+
+
+#define FLASH_BASE            ((uint32_t)0x08000000) /*!< FLASH base address in the alias region */
+#define SRAM_BASE             ((uint32_t)0x20000000) /*!< SRAM base address in the alias region */
+#define PERIPH_BASE           ((uint32_t)0x40000000) /*!< Peripheral base address in the alias region */
+
+#define SRAM_BB_BASE          ((uint32_t)0x22000000) /*!< SRAM base address in the bit-band region */
+#define PERIPH_BB_BASE        ((uint32_t)0x42000000) /*!< Peripheral base address in the bit-band region */
+
+#define FSMC_R_BASE           ((uint32_t)0xA0000000) /*!< FSMC registers base address */
+
+/*!< Peripheral memory map */
+#define APB1PERIPH_BASE       PERIPH_BASE
+#define APB2PERIPH_BASE       (PERIPH_BASE + 0x10000)
+#define AHBPERIPH_BASE        (PERIPH_BASE + 0x20000)
+
+#define TIM2_BASE             (APB1PERIPH_BASE + 0x0000)
+#define TIM3_BASE             (APB1PERIPH_BASE + 0x0400)
+#define TIM4_BASE             (APB1PERIPH_BASE + 0x0800)
+#define TIM5_BASE             (APB1PERIPH_BASE + 0x0C00)
+#define TIM6_BASE             (APB1PERIPH_BASE + 0x1000)
+#define TIM7_BASE             (APB1PERIPH_BASE + 0x1400)
+#define TIM12_BASE            (APB1PERIPH_BASE + 0x1800)
+#define TIM13_BASE            (APB1PERIPH_BASE + 0x1C00)
+#define TIM14_BASE            (APB1PERIPH_BASE + 0x2000)
+#define RTC_BASE              (APB1PERIPH_BASE + 0x2800)
+#define WWDG_BASE             (APB1PERIPH_BASE + 0x2C00)
+#define IWDG_BASE             (APB1PERIPH_BASE + 0x3000)
+#define SPI2_BASE             (APB1PERIPH_BASE + 0x3800)
+#define SPI3_BASE             (APB1PERIPH_BASE + 0x3C00)
+#define USART2_BASE           (APB1PERIPH_BASE + 0x4400)
+#define USART3_BASE           (APB1PERIPH_BASE + 0x4800)
+#define UART4_BASE            (APB1PERIPH_BASE + 0x4C00)
+#define UART5_BASE            (APB1PERIPH_BASE + 0x5000)
+#define I2C1_BASE             (APB1PERIPH_BASE + 0x5400)
+#define I2C2_BASE             (APB1PERIPH_BASE + 0x5800)
+#define CAN1_BASE             (APB1PERIPH_BASE + 0x6400)
+#define CAN2_BASE             (APB1PERIPH_BASE + 0x6800)
+#define BKP_BASE              (APB1PERIPH_BASE + 0x6C00)
+#define PWR_BASE              (APB1PERIPH_BASE + 0x7000)
+#define DAC_BASE              (APB1PERIPH_BASE + 0x7400)
+#define CEC_BASE              (APB1PERIPH_BASE + 0x7800)
+
+#define AFIO_BASE             (APB2PERIPH_BASE + 0x0000)
+#define EXTI_BASE             (APB2PERIPH_BASE + 0x0400)
+#define GPIOA_BASE            (APB2PERIPH_BASE + 0x0800)
+#define GPIOB_BASE            (APB2PERIPH_BASE + 0x0C00)
+#define GPIOC_BASE            (APB2PERIPH_BASE + 0x1000)
+#define GPIOD_BASE            (APB2PERIPH_BASE + 0x1400)
+#define GPIOE_BASE            (APB2PERIPH_BASE + 0x1800)
+#define GPIOF_BASE            (APB2PERIPH_BASE + 0x1C00)
+#define GPIOG_BASE            (APB2PERIPH_BASE + 0x2000)
+#define ADC1_BASE             (APB2PERIPH_BASE + 0x2400)
+#define ADC2_BASE             (APB2PERIPH_BASE + 0x2800)
+#define TIM1_BASE             (APB2PERIPH_BASE + 0x2C00)
+#define SPI1_BASE             (APB2PERIPH_BASE + 0x3000)
+#define TIM8_BASE             (APB2PERIPH_BASE + 0x3400)
+#define USART1_BASE           (APB2PERIPH_BASE + 0x3800)
+#define ADC3_BASE             (APB2PERIPH_BASE + 0x3C00)
+#define TIM15_BASE            (APB2PERIPH_BASE + 0x4000)
+#define TIM16_BASE            (APB2PERIPH_BASE + 0x4400)
+#define TIM17_BASE            (APB2PERIPH_BASE + 0x4800)
+#define TIM9_BASE             (APB2PERIPH_BASE + 0x4C00)
+#define TIM10_BASE            (APB2PERIPH_BASE + 0x5000)
+#define TIM11_BASE            (APB2PERIPH_BASE + 0x5400)
+
+#define SDIO_BASE             (PERIPH_BASE + 0x18000)
+
+#define DMA1_BASE             (AHBPERIPH_BASE + 0x0000)
+#define DMA1_Channel1_BASE    (AHBPERIPH_BASE + 0x0008)
+#define DMA1_Channel2_BASE    (AHBPERIPH_BASE + 0x001C)
+#define DMA1_Channel3_BASE    (AHBPERIPH_BASE + 0x0030)
+#define DMA1_Channel4_BASE    (AHBPERIPH_BASE + 0x0044)
+#define DMA1_Channel5_BASE    (AHBPERIPH_BASE + 0x0058)
+#define DMA1_Channel6_BASE    (AHBPERIPH_BASE + 0x006C)
+#define DMA1_Channel7_BASE    (AHBPERIPH_BASE + 0x0080)
+#define DMA2_BASE             (AHBPERIPH_BASE + 0x0400)
+#define DMA2_Channel1_BASE    (AHBPERIPH_BASE + 0x0408)
+#define DMA2_Channel2_BASE    (AHBPERIPH_BASE + 0x041C)
+#define DMA2_Channel3_BASE    (AHBPERIPH_BASE + 0x0430)
+#define DMA2_Channel4_BASE    (AHBPERIPH_BASE + 0x0444)
+#define DMA2_Channel5_BASE    (AHBPERIPH_BASE + 0x0458)
+#define RCC_BASE              (AHBPERIPH_BASE + 0x1000)
+#define CRC_BASE              (AHBPERIPH_BASE + 0x3000)
+
+#define FLASH_R_BASE          (AHBPERIPH_BASE + 0x2000) /*!< Flash registers base address */
+#define OB_BASE               ((uint32_t)0x1FFFF800)    /*!< Flash Option Bytes base address */
+
+#define ETH_BASE              (AHBPERIPH_BASE + 0x8000)
+#define ETH_MAC_BASE          (ETH_BASE)
+#define ETH_MMC_BASE          (ETH_BASE + 0x0100)
+#define ETH_PTP_BASE          (ETH_BASE + 0x0700)
+#define ETH_DMA_BASE          (ETH_BASE + 0x1000)
+
+#define FSMC_Bank1_R_BASE     (FSMC_R_BASE + 0x0000) /*!< FSMC Bank1 registers base address */
+#define FSMC_Bank1E_R_BASE    (FSMC_R_BASE + 0x0104) /*!< FSMC Bank1E registers base address */
+#define FSMC_Bank2_R_BASE     (FSMC_R_BASE + 0x0060) /*!< FSMC Bank2 registers base address */
+#define FSMC_Bank3_R_BASE     (FSMC_R_BASE + 0x0080) /*!< FSMC Bank3 registers base address */
+#define FSMC_Bank4_R_BASE     (FSMC_R_BASE + 0x00A0) /*!< FSMC Bank4 registers base address */
+
+#define DBGMCU_BASE          ((uint32_t)0xE0042000) /*!< Debug MCU registers base address */
+
+/**
+  * @}
+  */
+
+/** @addtogroup Peripheral_declaration
+  * @{
+  */
+
+#define TIM2                ((TIM_TypeDef *) TIM2_BASE)
+#define TIM3                ((TIM_TypeDef *) TIM3_BASE)
+#define TIM4                ((TIM_TypeDef *) TIM4_BASE)
+#define TIM5                ((TIM_TypeDef *) TIM5_BASE)
+#define TIM6                ((TIM_TypeDef *) TIM6_BASE)
+#define TIM7                ((TIM_TypeDef *) TIM7_BASE)
+#define TIM12               ((TIM_TypeDef *) TIM12_BASE)
+#define TIM13               ((TIM_TypeDef *) TIM13_BASE)
+#define TIM14               ((TIM_TypeDef *) TIM14_BASE)
+#define RTC                 ((RTC_TypeDef *) RTC_BASE)
+#define WWDG                ((WWDG_TypeDef *) WWDG_BASE)
+#define IWDG                ((IWDG_TypeDef *) IWDG_BASE)
+#define SPI2                ((SPI_TypeDef *) SPI2_BASE)
+#define SPI3                ((SPI_TypeDef *) SPI3_BASE)
+#define USART2              ((USART_TypeDef *) USART2_BASE)
+#define USART3              ((USART_TypeDef *) USART3_BASE)
+#define UART4               ((USART_TypeDef *) UART4_BASE)
+#define UART5               ((USART_TypeDef *) UART5_BASE)
+#define I2C1                ((I2C_TypeDef *) I2C1_BASE)
+#define I2C2                ((I2C_TypeDef *) I2C2_BASE)
+#define CAN1                ((CAN_TypeDef *) CAN1_BASE)
+#define CAN2                ((CAN_TypeDef *) CAN2_BASE)
+#define BKP                 ((BKP_TypeDef *) BKP_BASE)
+#define PWR                 ((PWR_TypeDef *) PWR_BASE)
+#define DAC                 ((DAC_TypeDef *) DAC_BASE)
+#define CEC                 ((CEC_TypeDef *) CEC_BASE)
+#define AFIO                ((AFIO_TypeDef *) AFIO_BASE)
+#define EXTI                ((EXTI_TypeDef *) EXTI_BASE)
+#define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
+#define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)
+#define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)
+#define GPIOD               ((GPIO_TypeDef *) GPIOD_BASE)
+#define GPIOE               ((GPIO_TypeDef *) GPIOE_BASE)
+#define GPIOF               ((GPIO_TypeDef *) GPIOF_BASE)
+#define GPIOG               ((GPIO_TypeDef *) GPIOG_BASE)
+#define ADC1                ((ADC_TypeDef *) ADC1_BASE)
+#define ADC2                ((ADC_TypeDef *) ADC2_BASE)
+#define TIM1                ((TIM_TypeDef *) TIM1_BASE)
+#define SPI1                ((SPI_TypeDef *) SPI1_BASE)
+#define TIM8                ((TIM_TypeDef *) TIM8_BASE)
+#define USART1              ((USART_TypeDef *) USART1_BASE)
+#define ADC3                ((ADC_TypeDef *) ADC3_BASE)
+#define TIM15               ((TIM_TypeDef *) TIM15_BASE)
+#define TIM16               ((TIM_TypeDef *) TIM16_BASE)
+#define TIM17               ((TIM_TypeDef *) TIM17_BASE)
+#define TIM9                ((TIM_TypeDef *) TIM9_BASE)
+#define TIM10               ((TIM_TypeDef *) TIM10_BASE)
+#define TIM11               ((TIM_TypeDef *) TIM11_BASE)
+#define SDIO                ((SDIO_TypeDef *) SDIO_BASE)
+#define DMA1                ((DMA_TypeDef *) DMA1_BASE)
+#define DMA2                ((DMA_TypeDef *) DMA2_BASE)
+#define DMA1_Channel1       ((DMA_Channel_TypeDef *) DMA1_Channel1_BASE)
+#define DMA1_Channel2       ((DMA_Channel_TypeDef *) DMA1_Channel2_BASE)
+#define DMA1_Channel3       ((DMA_Channel_TypeDef *) DMA1_Channel3_BASE)
+#define DMA1_Channel4       ((DMA_Channel_TypeDef *) DMA1_Channel4_BASE)
+#define DMA1_Channel5       ((DMA_Channel_TypeDef *) DMA1_Channel5_BASE)
+#define DMA1_Channel6       ((DMA_Channel_TypeDef *) DMA1_Channel6_BASE)
+#define DMA1_Channel7       ((DMA_Channel_TypeDef *) DMA1_Channel7_BASE)
+#define DMA2_Channel1       ((DMA_Channel_TypeDef *) DMA2_Channel1_BASE)
+#define DMA2_Channel2       ((DMA_Channel_TypeDef *) DMA2_Channel2_BASE)
+#define DMA2_Channel3       ((DMA_Channel_TypeDef *) DMA2_Channel3_BASE)
+#define DMA2_Channel4       ((DMA_Channel_TypeDef *) DMA2_Channel4_BASE)
+#define DMA2_Channel5       ((DMA_Channel_TypeDef *) DMA2_Channel5_BASE)
+#define RCC                 ((RCC_TypeDef *) RCC_BASE)
+#define CRC                 ((CRC_TypeDef *) CRC_BASE)
+#define FLASH               ((FLASH_TypeDef *) FLASH_R_BASE)
+#define OB                  ((OB_TypeDef *) OB_BASE)
+#define ETH                 ((ETH_TypeDef *) ETH_BASE)
+#define FSMC_Bank1          ((FSMC_Bank1_TypeDef *) FSMC_Bank1_R_BASE)
+#define FSMC_Bank1E         ((FSMC_Bank1E_TypeDef *) FSMC_Bank1E_R_BASE)
+#define FSMC_Bank2          ((FSMC_Bank2_TypeDef *) FSMC_Bank2_R_BASE)
+#define FSMC_Bank3          ((FSMC_Bank3_TypeDef *) FSMC_Bank3_R_BASE)
+#define FSMC_Bank4          ((FSMC_Bank4_TypeDef *) FSMC_Bank4_R_BASE)
+#define DBGMCU              ((DBGMCU_TypeDef *) DBGMCU_BASE)
+
+/**
+  * @}
+  */
+
+/** @addtogroup Exported_constants
+  * @{
+  */
+
+  /** @addtogroup Peripheral_Registers_Bits_Definition
+  * @{
+  */
+
+/******************************************************************************/
+/*                         Peripheral Registers_Bits_Definition               */
+/******************************************************************************/
+
+/******************************************************************************/
+/*                                                                            */
+/*                          CRC calculation unit                              */
+/*                                                                            */
+/******************************************************************************/
+
+/*******************  Bit definition for CRC_DR register  *********************/
+#define  CRC_DR_DR                           ((uint32_t)0xFFFFFFFF) /*!< Data register bits */
+
+
+/*******************  Bit definition for CRC_IDR register  ********************/
+#define  CRC_IDR_IDR                         ((uint8_t)0xFF)        /*!< General-purpose 8-bit data register bits */
+
+
+/********************  Bit definition for CRC_CR register  ********************/
+#define  CRC_CR_RESET                        ((uint8_t)0x01)        /*!< RESET bit */
+
+/******************************************************************************/
+/*                                                                            */
+/*                             Power Control                                  */
+/*                                                                            */
+/******************************************************************************/
+
+/********************  Bit definition for PWR_CR register  ********************/
+#define  PWR_CR_LPDS                         ((uint16_t)0x0001)     /*!< Low-Power Deepsleep */
+#define  PWR_CR_PDDS                         ((uint16_t)0x0002)     /*!< Power Down Deepsleep */
+#define  PWR_CR_CWUF                         ((uint16_t)0x0004)     /*!< Clear Wakeup Flag */
+#define  PWR_CR_CSBF                         ((uint16_t)0x0008)     /*!< Clear Standby Flag */
+#define  PWR_CR_PVDE                         ((uint16_t)0x0010)     /*!< Power Voltage Detector Enable */
+
+#define  PWR_CR_PLS                          ((uint16_t)0x00E0)     /*!< PLS[2:0] bits (PVD Level Selection) */
+#define  PWR_CR_PLS_0                        ((uint16_t)0x0020)     /*!< Bit 0 */
+#define  PWR_CR_PLS_1                        ((uint16_t)0x0040)     /*!< Bit 1 */
+#define  PWR_CR_PLS_2                        ((uint16_t)0x0080)     /*!< Bit 2 */
+
+/*!< PVD level configuration */
+#define  PWR_CR_PLS_2V2                      ((uint16_t)0x0000)     /*!< PVD level 2.2V */
+#define  PWR_CR_PLS_2V3                      ((uint16_t)0x0020)     /*!< PVD level 2.3V */
+#define  PWR_CR_PLS_2V4                      ((uint16_t)0x0040)     /*!< PVD level 2.4V */
+#define  PWR_CR_PLS_2V5                      ((uint16_t)0x0060)     /*!< PVD level 2.5V */
+#define  PWR_CR_PLS_2V6                      ((uint16_t)0x0080)     /*!< PVD level 2.6V */
+#define  PWR_CR_PLS_2V7                      ((uint16_t)0x00A0)     /*!< PVD level 2.7V */
+#define  PWR_CR_PLS_2V8                      ((uint16_t)0x00C0)     /*!< PVD level 2.8V */
+#define  PWR_CR_PLS_2V9                      ((uint16_t)0x00E0)     /*!< PVD level 2.9V */
+
+#define  PWR_CR_DBP                          ((uint16_t)0x0100)     /*!< Disable Backup Domain write protection */
+
+
+/*******************  Bit definition for PWR_CSR register  ********************/
+#define  PWR_CSR_WUF                         ((uint16_t)0x0001)     /*!< Wakeup Flag */
+#define  PWR_CSR_SBF                         ((uint16_t)0x0002)     /*!< Standby Flag */
+#define  PWR_CSR_PVDO                        ((uint16_t)0x0004)     /*!< PVD Output */
+#define  PWR_CSR_EWUP                        ((uint16_t)0x0100)     /*!< Enable WKUP pin */
+
+/******************************************************************************/
+/*                                                                            */
+/*                            Backup registers                                */
+/*                                                                            */
+/******************************************************************************/
+
+/*******************  Bit definition for BKP_DR1 register  ********************/
+#define  BKP_DR1_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR2 register  ********************/
+#define  BKP_DR2_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR3 register  ********************/
+#define  BKP_DR3_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR4 register  ********************/
+#define  BKP_DR4_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR5 register  ********************/
+#define  BKP_DR5_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR6 register  ********************/
+#define  BKP_DR6_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR7 register  ********************/
+#define  BKP_DR7_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR8 register  ********************/
+#define  BKP_DR8_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR9 register  ********************/
+#define  BKP_DR9_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR10 register  *******************/
+#define  BKP_DR10_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR11 register  *******************/
+#define  BKP_DR11_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR12 register  *******************/
+#define  BKP_DR12_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR13 register  *******************/
+#define  BKP_DR13_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR14 register  *******************/
+#define  BKP_DR14_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR15 register  *******************/
+#define  BKP_DR15_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR16 register  *******************/
+#define  BKP_DR16_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR17 register  *******************/
+#define  BKP_DR17_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/******************  Bit definition for BKP_DR18 register  ********************/
+#define  BKP_DR18_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR19 register  *******************/
+#define  BKP_DR19_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR20 register  *******************/
+#define  BKP_DR20_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR21 register  *******************/
+#define  BKP_DR21_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR22 register  *******************/
+#define  BKP_DR22_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR23 register  *******************/
+#define  BKP_DR23_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR24 register  *******************/
+#define  BKP_DR24_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR25 register  *******************/
+#define  BKP_DR25_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR26 register  *******************/
+#define  BKP_DR26_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR27 register  *******************/
+#define  BKP_DR27_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR28 register  *******************/
+#define  BKP_DR28_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR29 register  *******************/
+#define  BKP_DR29_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR30 register  *******************/
+#define  BKP_DR30_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR31 register  *******************/
+#define  BKP_DR31_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR32 register  *******************/
+#define  BKP_DR32_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR33 register  *******************/
+#define  BKP_DR33_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR34 register  *******************/
+#define  BKP_DR34_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR35 register  *******************/
+#define  BKP_DR35_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR36 register  *******************/
+#define  BKP_DR36_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR37 register  *******************/
+#define  BKP_DR37_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR38 register  *******************/
+#define  BKP_DR38_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR39 register  *******************/
+#define  BKP_DR39_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR40 register  *******************/
+#define  BKP_DR40_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR41 register  *******************/
+#define  BKP_DR41_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/*******************  Bit definition for BKP_DR42 register  *******************/
+#define  BKP_DR42_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
+
+/******************  Bit definition for BKP_RTCCR register  *******************/
+#define  BKP_RTCCR_CAL                       ((uint16_t)0x007F)     /*!< Calibration value */
+#define  BKP_RTCCR_CCO                       ((uint16_t)0x0080)     /*!< Calibration Clock Output */
+#define  BKP_RTCCR_ASOE                      ((uint16_t)0x0100)     /*!< Alarm or Second Output Enable */
+#define  BKP_RTCCR_ASOS                      ((uint16_t)0x0200)     /*!< Alarm or Second Output Selection */
+
+/********************  Bit definition for BKP_CR register  ********************/
+#define  BKP_CR_TPE                          ((uint8_t)0x01)        /*!< TAMPER pin enable */
+#define  BKP_CR_TPAL                         ((uint8_t)0x02)        /*!< TAMPER pin active level */
+
+/*******************  Bit definition for BKP_CSR register  ********************/
+#define  BKP_CSR_CTE                         ((uint16_t)0x0001)     /*!< Clear Tamper event */
+#define  BKP_CSR_CTI                         ((uint16_t)0x0002)     /*!< Clear Tamper Interrupt */
+#define  BKP_CSR_TPIE                        ((uint16_t)0x0004)     /*!< TAMPER Pin interrupt enable */
+#define  BKP_CSR_TEF                         ((uint16_t)0x0100)     /*!< Tamper Event Flag */
+#define  BKP_CSR_TIF                         ((uint16_t)0x0200)     /*!< Tamper Interrupt Flag */
+
+/******************************************************************************/
+/*                                                                            */
+/*                         Reset and Clock Control                            */
+/*                                                                            */
+/******************************************************************************/
+
+/********************  Bit definition for RCC_CR register  ********************/
+#define  RCC_CR_HSION                        ((uint32_t)0x00000001)        /*!< Internal High Speed clock enable */
+#define  RCC_CR_HSIRDY                       ((uint32_t)0x00000002)        /*!< Internal High Speed clock ready flag */
+#define  RCC_CR_HSITRIM                      ((uint32_t)0x000000F8)        /*!< Internal High Speed clock trimming */
+#define  RCC_CR_HSICAL                       ((uint32_t)0x0000FF00)        /*!< Internal High Speed clock Calibration */
+#define  RCC_CR_HSEON                        ((uint32_t)0x00010000)        /*!< External High Speed clock enable */
+#define  RCC_CR_HSERDY                       ((uint32_t)0x00020000)        /*!< External High Speed clock ready flag */
+#define  RCC_CR_HSEBYP                       ((uint32_t)0x00040000)        /*!< External High Speed clock Bypass */
+#define  RCC_CR_CSSON                        ((uint32_t)0x00080000)        /*!< Clock Security System enable */
+#define  RCC_CR_PLLON                        ((uint32_t)0x01000000)        /*!< PLL enable */
+#define  RCC_CR_PLLRDY                       ((uint32_t)0x02000000)        /*!< PLL clock ready flag */
+
+#ifdef STM32F10X_CL
+ #define  RCC_CR_PLL2ON                       ((uint32_t)0x04000000)        /*!< PLL2 enable */
+ #define  RCC_CR_PLL2RDY                      ((uint32_t)0x08000000)        /*!< PLL2 clock ready flag */
+ #define  RCC_CR_PLL3ON                       ((uint32_t)0x10000000)        /*!< PLL3 enable */
+ #define  RCC_CR_PLL3RDY                      ((uint32_t)0x20000000)        /*!< PLL3 clock ready flag */
+#endif /* STM32F10X_CL */
+
+/*******************  Bit definition for RCC_CFGR register  *******************/
+/*!< SW configuration */
+#define  RCC_CFGR_SW                         ((uint32_t)0x00000003)        /*!< SW[1:0] bits (System clock Switch) */
+#define  RCC_CFGR_SW_0                       ((uint32_t)0x00000001)        /*!< Bit 0 */
+#define  RCC_CFGR_SW_1                       ((uint32_t)0x00000002)        /*!< Bit 1 */
+
+#define  RCC_CFGR_SW_HSI                     ((uint32_t)0x00000000)        /*!< HSI selected as system clock */
+#define  RCC_CFGR_SW_HSE                     ((uint32_t)0x00000001)        /*!< HSE selected as system clock */
+#define  RCC_CFGR_SW_PLL                     ((uint32_t)0x00000002)        /*!< PLL selected as system clock */
+
+/*!< SWS configuration */
+#define  RCC_CFGR_SWS                        ((uint32_t)0x0000000C)        /*!< SWS[1:0] bits (System Clock Switch Status) */
+#define  RCC_CFGR_SWS_0                      ((uint32_t)0x00000004)        /*!< Bit 0 */
+#define  RCC_CFGR_SWS_1                      ((uint32_t)0x00000008)        /*!< Bit 1 */
+
+#define  RCC_CFGR_SWS_HSI                    ((uint32_t)0x00000000)        /*!< HSI oscillator used as system clock */
+#define  RCC_CFGR_SWS_HSE                    ((uint32_t)0x00000004)        /*!< HSE oscillator used as system clock */
+#define  RCC_CFGR_SWS_PLL                    ((uint32_t)0x00000008)        /*!< PLL used as system clock */
+
+/*!< HPRE configuration */
+#define  RCC_CFGR_HPRE                       ((uint32_t)0x000000F0)        /*!< HPRE[3:0] bits (AHB prescaler) */
+#define  RCC_CFGR_HPRE_0                     ((uint32_t)0x00000010)        /*!< Bit 0 */
+#define  RCC_CFGR_HPRE_1                     ((uint32_t)0x00000020)        /*!< Bit 1 */
+#define  RCC_CFGR_HPRE_2                     ((uint32_t)0x00000040)        /*!< Bit 2 */
+#define  RCC_CFGR_HPRE_3                     ((uint32_t)0x00000080)        /*!< Bit 3 */
+
+#define  RCC_CFGR_HPRE_DIV1                  ((uint32_t)0x00000000)        /*!< SYSCLK not divided */
+#define  RCC_CFGR_HPRE_DIV2                  ((uint32_t)0x00000080)        /*!< SYSCLK divided by 2 */
+#define  RCC_CFGR_HPRE_DIV4                  ((uint32_t)0x00000090)        /*!< SYSCLK divided by 4 */
+#define  RCC_CFGR_HPRE_DIV8                  ((uint32_t)0x000000A0)        /*!< SYSCLK divided by 8 */
+#define  RCC_CFGR_HPRE_DIV16                 ((uint32_t)0x000000B0)        /*!< SYSCLK divided by 16 */
+#define  RCC_CFGR_HPRE_DIV64                 ((uint32_t)0x000000C0)        /*!< SYSCLK divided by 64 */
+#define  RCC_CFGR_HPRE_DIV128                ((uint32_t)0x000000D0)        /*!< SYSCLK divided by 128 */
+#define  RCC_CFGR_HPRE_DIV256                ((uint32_t)0x000000E0)        /*!< SYSCLK divided by 256 */
+#define  RCC_CFGR_HPRE_DIV512                ((uint32_t)0x000000F0)        /*!< SYSCLK divided by 512 */
+
+/*!< PPRE1 configuration */
+#define  RCC_CFGR_PPRE1                      ((uint32_t)0x00000700)        /*!< PRE1[2:0] bits (APB1 prescaler) */
+#define  RCC_CFGR_PPRE1_0                    ((uint32_t)0x00000100)        /*!< Bit 0 */
+#define  RCC_CFGR_PPRE1_1                    ((uint32_t)0x00000200)        /*!< Bit 1 */
+#define  RCC_CFGR_PPRE1_2                    ((uint32_t)0x00000400)        /*!< Bit 2 */
+
+#define  RCC_CFGR_PPRE1_DIV1                 ((uint32_t)0x00000000)        /*!< HCLK not divided */
+#define  RCC_CFGR_PPRE1_DIV2                 ((uint32_t)0x00000400)        /*!< HCLK divided by 2 */
+#define  RCC_CFGR_PPRE1_DIV4                 ((uint32_t)0x00000500)        /*!< HCLK divided by 4 */
+#define  RCC_CFGR_PPRE1_DIV8                 ((uint32_t)0x00000600)        /*!< HCLK divided by 8 */
+#define  RCC_CFGR_PPRE1_DIV16                ((uint32_t)0x00000700)        /*!< HCLK divided by 16 */
+
+/*!< PPRE2 configuration */
+#define  RCC_CFGR_PPRE2                      ((uint32_t)0x00003800)        /*!< PRE2[2:0] bits (APB2 prescaler) */
+#define  RCC_CFGR_PPRE2_0                    ((uint32_t)0x00000800)        /*!< Bit 0 */
+#define  RCC_CFGR_PPRE2_1                    ((uint32_t)0x00001000)        /*!< Bit 1 */
+#define  RCC_CFGR_PPRE2_2                    ((uint32_t)0x00002000)        /*!< Bit 2 */
+
+#define  RCC_CFGR_PPRE2_DIV1                 ((uint32_t)0x00000000)        /*!< HCLK not divided */
+#define  RCC_CFGR_PPRE2_DIV2                 ((uint32_t)0x00002000)        /*!< HCLK divided by 2 */
+#define  RCC_CFGR_PPRE2_DIV4                 ((uint32_t)0x00002800)        /*!< HCLK divided by 4 */
+#define  RCC_CFGR_PPRE2_DIV8                 ((uint32_t)0x00003000)        /*!< HCLK divided by 8 */
+#define  RCC_CFGR_PPRE2_DIV16                ((uint32_t)0x00003800)        /*!< HCLK divided by 16 */
+
+/*!< ADCPPRE configuration */
+#define  RCC_CFGR_ADCPRE                     ((uint32_t)0x0000C000)        /*!< ADCPRE[1:0] bits (ADC prescaler) */
+#define  RCC_CFGR_ADCPRE_0                   ((uint32_t)0x00004000)        /*!< Bit 0 */
+#define  RCC_CFGR_ADCPRE_1                   ((uint32_t)0x00008000)        /*!< Bit 1 */
+
+#define  RCC_CFGR_ADCPRE_DIV2                ((uint32_t)0x00000000)        /*!< PCLK2 divided by 2 */
+#define  RCC_CFGR_ADCPRE_DIV4                ((uint32_t)0x00004000)        /*!< PCLK2 divided by 4 */
+#define  RCC_CFGR_ADCPRE_DIV6                ((uint32_t)0x00008000)        /*!< PCLK2 divided by 6 */
+#define  RCC_CFGR_ADCPRE_DIV8                ((uint32_t)0x0000C000)        /*!< PCLK2 divided by 8 */
+
+#define  RCC_CFGR_PLLSRC                     ((uint32_t)0x00010000)        /*!< PLL entry clock source */
+
+#define  RCC_CFGR_PLLXTPRE                   ((uint32_t)0x00020000)        /*!< HSE divider for PLL entry */
+
+/*!< PLLMUL configuration */
+#define  RCC_CFGR_PLLMULL                    ((uint32_t)0x003C0000)        /*!< PLLMUL[3:0] bits (PLL multiplication factor) */
+#define  RCC_CFGR_PLLMULL_0                  ((uint32_t)0x00040000)        /*!< Bit 0 */
+#define  RCC_CFGR_PLLMULL_1                  ((uint32_t)0x00080000)        /*!< Bit 1 */
+#define  RCC_CFGR_PLLMULL_2                  ((uint32_t)0x00100000)        /*!< Bit 2 */
+#define  RCC_CFGR_PLLMULL_3                  ((uint32_t)0x00200000)        /*!< Bit 3 */
+
+#ifdef STM32F10X_CL
+ #define  RCC_CFGR_PLLSRC_HSI_Div2           ((uint32_t)0x00000000)        /*!< HSI clock divided by 2 selected as PLL entry clock source */
+ #define  RCC_CFGR_PLLSRC_PREDIV1            ((uint32_t)0x00010000)        /*!< PREDIV1 clock selected as PLL entry clock source */
+
+ #define  RCC_CFGR_PLLXTPRE_PREDIV1          ((uint32_t)0x00000000)        /*!< PREDIV1 clock not divided for PLL entry */
+ #define  RCC_CFGR_PLLXTPRE_PREDIV1_Div2     ((uint32_t)0x00020000)        /*!< PREDIV1 clock divided by 2 for PLL entry */
+
+ #define  RCC_CFGR_PLLMULL4                  ((uint32_t)0x00080000)        /*!< PLL input clock * 4 */
+ #define  RCC_CFGR_PLLMULL5                  ((uint32_t)0x000C0000)        /*!< PLL input clock * 5 */
+ #define  RCC_CFGR_PLLMULL6                  ((uint32_t)0x00100000)        /*!< PLL input clock * 6 */
+ #define  RCC_CFGR_PLLMULL7                  ((uint32_t)0x00140000)        /*!< PLL input clock * 7 */
+ #define  RCC_CFGR_PLLMULL8                  ((uint32_t)0x00180000)        /*!< PLL input clock * 8 */
+ #define  RCC_CFGR_PLLMULL9                  ((uint32_t)0x001C0000)        /*!< PLL input clock * 9 */
+ #define  RCC_CFGR_PLLMULL6_5                ((uint32_t)0x00340000)        /*!< PLL input clock * 6.5 */
+
+ #define  RCC_CFGR_OTGFSPRE                  ((uint32_t)0x00400000)        /*!< USB OTG FS prescaler */
+
+/*!< MCO configuration */
+ #define  RCC_CFGR_MCO                       ((uint32_t)0x0F000000)        /*!< MCO[3:0] bits (Microcontroller Clock Output) */
+ #define  RCC_CFGR_MCO_0                     ((uint32_t)0x01000000)        /*!< Bit 0 */
+ #define  RCC_CFGR_MCO_1                     ((uint32_t)0x02000000)        /*!< Bit 1 */
+ #define  RCC_CFGR_MCO_2                     ((uint32_t)0x04000000)        /*!< Bit 2 */
+ #define  RCC_CFGR_MCO_3                     ((uint32_t)0x08000000)        /*!< Bit 3 */
+
+ #define  RCC_CFGR_MCO_NOCLOCK               ((uint32_t)0x00000000)        /*!< No clock */
+ #define  RCC_CFGR_MCO_SYSCLK                ((uint32_t)0x04000000)        /*!< System clock selected as MCO source */
+ #define  RCC_CFGR_MCO_HSI                   ((uint32_t)0x05000000)        /*!< HSI clock selected as MCO source */
+ #define  RCC_CFGR_MCO_HSE                   ((uint32_t)0x06000000)        /*!< HSE clock selected as MCO source */
+ #define  RCC_CFGR_MCO_PLLCLK_Div2           ((uint32_t)0x07000000)        /*!< PLL clock divided by 2 selected as MCO source */
+ #define  RCC_CFGR_MCO_PLL2CLK               ((uint32_t)0x08000000)        /*!< PLL2 clock selected as MCO source*/
+ #define  RCC_CFGR_MCO_PLL3CLK_Div2          ((uint32_t)0x09000000)        /*!< PLL3 clock divided by 2 selected as MCO source*/
+ #define  RCC_CFGR_MCO_Ext_HSE               ((uint32_t)0x0A000000)        /*!< XT1 external 3-25 MHz oscillator clock selected as MCO source */
+ #define  RCC_CFGR_MCO_PLL3CLK               ((uint32_t)0x0B000000)        /*!< PLL3 clock selected as MCO source */
+#elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
+ #define  RCC_CFGR_PLLSRC_HSI_Div2           ((uint32_t)0x00000000)        /*!< HSI clock divided by 2 selected as PLL entry clock source */
+ #define  RCC_CFGR_PLLSRC_PREDIV1            ((uint32_t)0x00010000)        /*!< PREDIV1 clock selected as PLL entry clock source */
+
+ #define  RCC_CFGR_PLLXTPRE_PREDIV1          ((uint32_t)0x00000000)        /*!< PREDIV1 clock not divided for PLL entry */
+ #define  RCC_CFGR_PLLXTPRE_PREDIV1_Div2     ((uint32_t)0x00020000)        /*!< PREDIV1 clock divided by 2 for PLL entry */
+
+ #define  RCC_CFGR_PLLMULL2                  ((uint32_t)0x00000000)        /*!< PLL input clock*2 */
+ #define  RCC_CFGR_PLLMULL3                  ((uint32_t)0x00040000)        /*!< PLL input clock*3 */
+ #define  RCC_CFGR_PLLMULL4                  ((uint32_t)0x00080000)        /*!< PLL input clock*4 */
+ #define  RCC_CFGR_PLLMULL5                  ((uint32_t)0x000C0000)        /*!< PLL input clock*5 */
+ #define  RCC_CFGR_PLLMULL6                  ((uint32_t)0x00100000)        /*!< PLL input clock*6 */
+ #define  RCC_CFGR_PLLMULL7                  ((uint32_t)0x00140000)        /*!< PLL input clock*7 */
+ #define  RCC_CFGR_PLLMULL8                  ((uint32_t)0x00180000)        /*!< PLL input clock*8 */
+ #define  RCC_CFGR_PLLMULL9                  ((uint32_t)0x001C0000)        /*!< PLL input clock*9 */
+ #define  RCC_CFGR_PLLMULL10                 ((uint32_t)0x00200000)        /*!< PLL input clock10 */
+ #define  RCC_CFGR_PLLMULL11                 ((uint32_t)0x00240000)        /*!< PLL input clock*11 */
+ #define  RCC_CFGR_PLLMULL12                 ((uint32_t)0x00280000)        /*!< PLL input clock*12 */
+ #define  RCC_CFGR_PLLMULL13                 ((uint32_t)0x002C0000)        /*!< PLL input clock*13 */
+ #define  RCC_CFGR_PLLMULL14                 ((uint32_t)0x00300000)        /*!< PLL input clock*14 */
+ #define  RCC_CFGR_PLLMULL15                 ((uint32_t)0x00340000)        /*!< PLL input clock*15 */
+ #define  RCC_CFGR_PLLMULL16                 ((uint32_t)0x00380000)        /*!< PLL input clock*16 */
+
+/*!< MCO configuration */
+ #define  RCC_CFGR_MCO                       ((uint32_t)0x07000000)        /*!< MCO[2:0] bits (Microcontroller Clock Output) */
+ #define  RCC_CFGR_MCO_0                     ((uint32_t)0x01000000)        /*!< Bit 0 */
+ #define  RCC_CFGR_MCO_1                     ((uint32_t)0x02000000)        /*!< Bit 1 */
+ #define  RCC_CFGR_MCO_2                     ((uint32_t)0x04000000)        /*!< Bit 2 */
+
+ #define  RCC_CFGR_MCO_NOCLOCK               ((uint32_t)0x00000000)        /*!< No clock */
+ #define  RCC_CFGR_MCO_SYSCLK                ((uint32_t)0x04000000)        /*!< System clock selected as MCO source */
+ #define  RCC_CFGR_MCO_HSI                   ((uint32_t)0x05000000)        /*!< HSI clock selected as MCO source */
+ #define  RCC_CFGR_MCO_HSE                   ((uint32_t)0x06000000)        /*!< HSE clock selected as MCO source  */
+ #define  RCC_CFGR_MCO_PLL                   ((uint32_t)0x07000000)        /*!< PLL clock divided by 2 selected as MCO source */
+#else
+ #define  RCC_CFGR_PLLSRC_HSI_Div2           ((uint32_t)0x00000000)        /*!< HSI clock divided by 2 selected as PLL entry clock source */
+ #define  RCC_CFGR_PLLSRC_HSE                ((uint32_t)0x00010000)        /*!< HSE clock selected as PLL entry clock source */
+
+ #define  RCC_CFGR_PLLXTPRE_HSE              ((uint32_t)0x00000000)        /*!< HSE clock not divided for PLL entry */
+ #define  RCC_CFGR_PLLXTPRE_HSE_Div2         ((uint32_t)0x00020000)        /*!< HSE clock divided by 2 for PLL entry */
+
+ #define  RCC_CFGR_PLLMULL2                  ((uint32_t)0x00000000)        /*!< PLL input clock*2 */
+ #define  RCC_CFGR_PLLMULL3                  ((uint32_t)0x00040000)        /*!< PLL input clock*3 */
+ #define  RCC_CFGR_PLLMULL4                  ((uint32_t)0x00080000)        /*!< PLL input clock*4 */
+ #define  RCC_CFGR_PLLMULL5                  ((uint32_t)0x000C0000)        /*!< PLL input clock*5 */
+ #define  RCC_CFGR_PLLMULL6                  ((uint32_t)0x00100000)        /*!< PLL input clock*6 */
+ #define  RCC_CFGR_PLLMULL7                  ((uint32_t)0x00140000)        /*!< PLL input clock*7 */
+ #define  RCC_CFGR_PLLMULL8                  ((uint32_t)0x00180000)        /*!< PLL input clock*8 */
+ #define  RCC_CFGR_PLLMULL9                  ((uint32_t)0x001C0000)        /*!< PLL input clock*9 */
+ #define  RCC_CFGR_PLLMULL10                 ((uint32_t)0x00200000)        /*!< PLL input clock10 */
+ #define  RCC_CFGR_PLLMULL11                 ((uint32_t)0x00240000)        /*!< PLL input clock*11 */
+ #define  RCC_CFGR_PLLMULL12                 ((uint32_t)0x00280000)        /*!< PLL input clock*12 */
+ #define  RCC_CFGR_PLLMULL13                 ((uint32_t)0x002C0000)        /*!< PLL input clock*13 */
+ #define  RCC_CFGR_PLLMULL14                 ((uint32_t)0x00300000)        /*!< PLL input clock*14 */
+ #define  RCC_CFGR_PLLMULL15                 ((uint32_t)0x00340000)        /*!< PLL input clock*15 */
+ #define  RCC_CFGR_PLLMULL16                 ((uint32_t)0x00380000)        /*!< PLL input clock*16 */
+ #define  RCC_CFGR_USBPRE                    ((uint32_t)0x00400000)        /*!< USB Device prescaler */
+
+/*!< MCO configuration */
+ #define  RCC_CFGR_MCO                       ((uint32_t)0x07000000)        /*!< MCO[2:0] bits (Microcontroller Clock Output) */
+ #define  RCC_CFGR_MCO_0                     ((uint32_t)0x01000000)        /*!< Bit 0 */
+ #define  RCC_CFGR_MCO_1                     ((uint32_t)0x02000000)        /*!< Bit 1 */
+ #define  RCC_CFGR_MCO_2                     ((uint32_t)0x04000000)        /*!< Bit 2 */
+
+ #define  RCC_CFGR_MCO_NOCLOCK               ((uint32_t)0x00000000)        /*!< No clock */
+ #define  RCC_CFGR_MCO_SYSCLK                ((uint32_t)0x04000000)        /*!< System clock selected as MCO source */
+ #define  RCC_CFGR_MCO_HSI                   ((uint32_t)0x05000000)        /*!< HSI clock selected as MCO source */
+ #define  RCC_CFGR_MCO_HSE                   ((uint32_t)0x06000000)        /*!< HSE clock selected as MCO source  */
+ #define  RCC_CFGR_MCO_PLL                   ((uint32_t)0x07000000)        /*!< PLL clock divided by 2 selected as MCO source */
+#endif /* STM32F10X_CL */
+
+/*!<******************  Bit definition for RCC_CIR register  ********************/
+#define  RCC_CIR_LSIRDYF                     ((uint32_t)0x00000001)        /*!< LSI Ready Interrupt flag */
+#define  RCC_CIR_LSERDYF                     ((uint32_t)0x00000002)        /*!< LSE Ready Interrupt flag */
+#define  RCC_CIR_HSIRDYF                     ((uint32_t)0x00000004)        /*!< HSI Ready Interrupt flag */
+#define  RCC_CIR_HSERDYF                     ((uint32_t)0x00000008)        /*!< HSE Ready Interrupt flag */
+#define  RCC_CIR_PLLRDYF                     ((uint32_t)0x00000010)        /*!< PLL Ready Interrupt flag */
+#define  RCC_CIR_CSSF                        ((uint32_t)0x00000080)        /*!< Clock Security System Interrupt flag */
+#define  RCC_CIR_LSIRDYIE                    ((uint32_t)0x00000100)        /*!< LSI Ready Interrupt Enable */
+#define  RCC_CIR_LSERDYIE                    ((uint32_t)0x00000200)        /*!< LSE Ready Interrupt Enable */
+#define  RCC_CIR_HSIRDYIE                    ((uint32_t)0x00000400)        /*!< HSI Ready Interrupt Enable */
+#define  RCC_CIR_HSERDYIE                    ((uint32_t)0x00000800)        /*!< HSE Ready Interrupt Enable */
+#define  RCC_CIR_PLLRDYIE                    ((uint32_t)0x00001000)        /*!< PLL Ready Interrupt Enable */
+#define  RCC_CIR_LSIRDYC                     ((uint32_t)0x00010000)        /*!< LSI Ready Interrupt Clear */
+#define  RCC_CIR_LSERDYC                     ((uint32_t)0x00020000)        /*!< LSE Ready Interrupt Clear */
+#define  RCC_CIR_HSIRDYC                     ((uint32_t)0x00040000)        /*!< HSI Ready Interrupt Clear */
+#define  RCC_CIR_HSERDYC                     ((uint32_t)0x00080000)        /*!< HSE Ready Interrupt Clear */
+#define  RCC_CIR_PLLRDYC                     ((uint32_t)0x00100000)        /*!< PLL Ready Interrupt Clear */
+#define  RCC_CIR_CSSC                        ((uint32_t)0x00800000)        /*!< Clock Security System Interrupt Clear */
+
+#ifdef STM32F10X_CL
+ #define  RCC_CIR_PLL2RDYF                    ((uint32_t)0x00000020)        /*!< PLL2 Ready Interrupt flag */
+ #define  RCC_CIR_PLL3RDYF                    ((uint32_t)0x00000040)        /*!< PLL3 Ready Interrupt flag */
+ #define  RCC_CIR_PLL2RDYIE                   ((uint32_t)0x00002000)        /*!< PLL2 Ready Interrupt Enable */
+ #define  RCC_CIR_PLL3RDYIE                   ((uint32_t)0x00004000)        /*!< PLL3 Ready Interrupt Enable */
+ #define  RCC_CIR_PLL2RDYC                    ((uint32_t)0x00200000)        /*!< PLL2 Ready Interrupt Clear */
+ #define  RCC_CIR_PLL3RDYC                    ((uint32_t)0x00400000)        /*!< PLL3 Ready Interrupt Clear */
+#endif /* STM32F10X_CL */
+
+/*****************  Bit definition for RCC_APB2RSTR register  *****************/
+#define  RCC_APB2RSTR_AFIORST                ((uint32_t)0x00000001)        /*!< Alternate Function I/O reset */
+#define  RCC_APB2RSTR_IOPARST                ((uint32_t)0x00000004)        /*!< I/O port A reset */
+#define  RCC_APB2RSTR_IOPBRST                ((uint32_t)0x00000008)        /*!< I/O port B reset */
+#define  RCC_APB2RSTR_IOPCRST                ((uint32_t)0x00000010)        /*!< I/O port C reset */
+#define  RCC_APB2RSTR_IOPDRST                ((uint32_t)0x00000020)        /*!< I/O port D reset */
+#define  RCC_APB2RSTR_ADC1RST                ((uint32_t)0x00000200)        /*!< ADC 1 interface reset */
+
+#if !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD_VL)
+#define  RCC_APB2RSTR_ADC2RST                ((uint32_t)0x00000400)        /*!< ADC 2 interface reset */
+#endif
+
+#define  RCC_APB2RSTR_TIM1RST                ((uint32_t)0x00000800)        /*!< TIM1 Timer reset */
+#define  RCC_APB2RSTR_SPI1RST                ((uint32_t)0x00001000)        /*!< SPI 1 reset */
+#define  RCC_APB2RSTR_USART1RST              ((uint32_t)0x00004000)        /*!< USART1 reset */
+
+#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
+#define  RCC_APB2RSTR_TIM15RST               ((uint32_t)0x00010000)        /*!< TIM15 Timer reset */
+#define  RCC_APB2RSTR_TIM16RST               ((uint32_t)0x00020000)        /*!< TIM16 Timer reset */
+#define  RCC_APB2RSTR_TIM17RST               ((uint32_t)0x00040000)        /*!< TIM17 Timer reset */
+#endif
+
+#if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL)
+ #define  RCC_APB2RSTR_IOPERST               ((uint32_t)0x00000040)        /*!< I/O port E reset */
+#endif /* STM32F10X_LD && STM32F10X_LD_VL */
+
+#if defined (STM32F10X_HD) || defined (STM32F10X_XL)
+ #define  RCC_APB2RSTR_IOPFRST               ((uint32_t)0x00000080)        /*!< I/O port F reset */
+ #define  RCC_APB2RSTR_IOPGRST               ((uint32_t)0x00000100)        /*!< I/O port G reset */
+ #define  RCC_APB2RSTR_TIM8RST               ((uint32_t)0x00002000)        /*!< TIM8 Timer reset */
+ #define  RCC_APB2RSTR_ADC3RST               ((uint32_t)0x00008000)        /*!< ADC3 interface reset */
+#endif
+
+#if defined (STM32F10X_HD_VL)
+ #define  RCC_APB2RSTR_IOPFRST               ((uint32_t)0x00000080)        /*!< I/O port F reset */
+ #define  RCC_APB2RSTR_IOPGRST               ((uint32_t)0x00000100)        /*!< I/O port G reset */
+#endif
+
+#ifdef STM32F10X_XL
+ #define  RCC_APB2RSTR_TIM9RST               ((uint32_t)0x00080000)         /*!< TIM9 Timer reset */
+ #define  RCC_APB2RSTR_TIM10RST              ((uint32_t)0x00100000)         /*!< TIM10 Timer reset */
+ #define  RCC_APB2RSTR_TIM11RST              ((uint32_t)0x00200000)         /*!< TIM11 Timer reset */
+#endif /* STM32F10X_XL */
+
+/*****************  Bit definition for RCC_APB1RSTR register  *****************/
+#define  RCC_APB1RSTR_TIM2RST                ((uint32_t)0x00000001)        /*!< Timer 2 reset */
+#define  RCC_APB1RSTR_TIM3RST                ((uint32_t)0x00000002)        /*!< Timer 3 reset */
+#define  RCC_APB1RSTR_WWDGRST                ((uint32_t)0x00000800)        /*!< Window Watchdog reset */
+#define  RCC_APB1RSTR_USART2RST              ((uint32_t)0x00020000)        /*!< USART 2 reset */
+#define  RCC_APB1RSTR_I2C1RST                ((uint32_t)0x00200000)        /*!< I2C 1 reset */
+
+#if !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD_VL)
+#define  RCC_APB1RSTR_CAN1RST                ((uint32_t)0x02000000)        /*!< CAN1 reset */
+#endif
+
+#define  RCC_APB1RSTR_BKPRST                 ((uint32_t)0x08000000)        /*!< Backup interface reset */
+#define  RCC_APB1RSTR_PWRRST                 ((uint32_t)0x10000000)        /*!< Power interface reset */
+
+#if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL)
+ #define  RCC_APB1RSTR_TIM4RST               ((uint32_t)0x00000004)        /*!< Timer 4 reset */
+ #define  RCC_APB1RSTR_SPI2RST               ((uint32_t)0x00004000)        /*!< SPI 2 reset */
+ #define  RCC_APB1RSTR_USART3RST             ((uint32_t)0x00040000)        /*!< USART 3 reset */
+ #define  RCC_APB1RSTR_I2C2RST               ((uint32_t)0x00400000)        /*!< I2C 2 reset */
+#endif /* STM32F10X_LD && STM32F10X_LD_VL */
+
+#if defined (STM32F10X_HD) || defined (STM32F10X_MD) || defined (STM32F10X_LD) || defined  (STM32F10X_XL)
+ #define  RCC_APB1RSTR_USBRST                ((uint32_t)0x00800000)        /*!< USB Device reset */
+#endif
+
+#if defined (STM32F10X_HD) || defined  (STM32F10X_CL) || defined  (STM32F10X_XL)
+ #define  RCC_APB1RSTR_TIM5RST                ((uint32_t)0x00000008)        /*!< Timer 5 reset */
+ #define  RCC_APB1RSTR_TIM6RST                ((uint32_t)0x00000010)        /*!< Timer 6 reset */
+ #define  RCC_APB1RSTR_TIM7RST                ((uint32_t)0x00000020)        /*!< Timer 7 reset */
+ #define  RCC_APB1RSTR_SPI3RST                ((uint32_t)0x00008000)        /*!< SPI 3 reset */
+ #define  RCC_APB1RSTR_UART4RST               ((uint32_t)0x00080000)        /*!< UART 4 reset */
+ #define  RCC_APB1RSTR_UART5RST               ((uint32_t)0x00100000)        /*!< UART 5 reset */
+ #define  RCC_APB1RSTR_DACRST                 ((uint32_t)0x20000000)        /*!< DAC interface reset */
+#endif
+
+#if defined (STM32F10X_LD_VL) || defined  (STM32F10X_MD_VL) || defined  (STM32F10X_HD_VL)
+ #define  RCC_APB1RSTR_TIM6RST                ((uint32_t)0x00000010)        /*!< Timer 6 reset */
+ #define  RCC_APB1RSTR_TIM7RST                ((uint32_t)0x00000020)        /*!< Timer 7 reset */
+ #define  RCC_APB1RSTR_DACRST                 ((uint32_t)0x20000000)        /*!< DAC interface reset */
+ #define  RCC_APB1RSTR_CECRST                 ((uint32_t)0x40000000)        /*!< CEC interface reset */
+#endif
+
+#if defined  (STM32F10X_HD_VL)
+ #define  RCC_APB1RSTR_TIM5RST                ((uint32_t)0x00000008)        /*!< Timer 5 reset */
+ #define  RCC_APB1RSTR_TIM12RST               ((uint32_t)0x00000040)        /*!< TIM12 Timer reset */
+ #define  RCC_APB1RSTR_TIM13RST               ((uint32_t)0x00000080)        /*!< TIM13 Timer reset */
+ #define  RCC_APB1RSTR_TIM14RST               ((uint32_t)0x00000100)        /*!< TIM14 Timer reset */
+ #define  RCC_APB1RSTR_SPI3RST                ((uint32_t)0x00008000)        /*!< SPI 3 reset */
+ #define  RCC_APB1RSTR_UART4RST               ((uint32_t)0x00080000)        /*!< UART 4 reset */
+ #define  RCC_APB1RSTR_UART5RST               ((uint32_t)0x00100000)        /*!< UART 5 reset */
+#endif
+
+#ifdef STM32F10X_CL
+ #define  RCC_APB1RSTR_CAN2RST                ((uint32_t)0x04000000)        /*!< CAN2 reset */
+#endif /* STM32F10X_CL */
+
+#ifdef STM32F10X_XL
+ #define  RCC_APB1RSTR_TIM12RST               ((uint32_t)0x00000040)         /*!< TIM12 Timer reset */
+ #define  RCC_APB1RSTR_TIM13RST               ((uint32_t)0x00000080)         /*!< TIM13 Timer reset */
+ #define  RCC_APB1RSTR_TIM14RST               ((uint32_t)0x00000100)         /*!< TIM14 Timer reset */
+#endif /* STM32F10X_XL */
+
+/******************  Bit definition for RCC_AHBENR register  ******************/
+#define  RCC_AHBENR_DMA1EN                   ((uint16_t)0x0001)            /*!< DMA1 clock enable */
+#define  RCC_AHBENR_SRAMEN                   ((uint16_t)0x0004)            /*!< SRAM interface clock enable */
+#define  RCC_AHBENR_FLITFEN                  ((uint16_t)0x0010)            /*!< FLITF clock enable */
+#define  RCC_AHBENR_CRCEN                    ((uint16_t)0x0040)            /*!< CRC clock enable */
+
+#if defined (STM32F10X_HD) || defined  (STM32F10X_CL) || defined  (STM32F10X_HD_VL)
+ #define  RCC_AHBENR_DMA2EN                  ((uint16_t)0x0002)            /*!< DMA2 clock enable */
+#endif
+
+#if defined (STM32F10X_HD) || defined (STM32F10X_XL)
+ #define  RCC_AHBENR_FSMCEN                  ((uint16_t)0x0100)            /*!< FSMC clock enable */
+ #define  RCC_AHBENR_SDIOEN                  ((uint16_t)0x0400)            /*!< SDIO clock enable */
+#endif
+
+#if defined (STM32F10X_HD_VL)
+ #define  RCC_AHBENR_FSMCEN                  ((uint16_t)0x0100)            /*!< FSMC clock enable */
+#endif
+
+#ifdef STM32F10X_CL
+ #define  RCC_AHBENR_OTGFSEN                 ((uint32_t)0x00001000)         /*!< USB OTG FS clock enable */
+ #define  RCC_AHBENR_ETHMACEN                ((uint32_t)0x00004000)         /*!< ETHERNET MAC clock enable */
+ #define  RCC_AHBENR_ETHMACTXEN              ((uint32_t)0x00008000)         /*!< ETHERNET MAC Tx clock enable */
+ #define  RCC_AHBENR_ETHMACRXEN              ((uint32_t)0x00010000)         /*!< ETHERNET MAC Rx clock enable */
+#endif /* STM32F10X_CL */
+
+/******************  Bit definition for RCC_APB2ENR register  *****************/
+#define  RCC_APB2ENR_AFIOEN                  ((uint32_t)0x00000001)         /*!< Alternate Function I/O clock enable */
+#define  RCC_APB2ENR_IOPAEN                  ((uint32_t)0x00000004)         /*!< I/O port A clock enable */
+#define  RCC_APB2ENR_IOPBEN                  ((uint32_t)0x00000008)         /*!< I/O port B clock enable */
+#define  RCC_APB2ENR_IOPCEN                  ((uint32_t)0x00000010)         /*!< I/O port C clock enable */
+#define  RCC_APB2ENR_IOPDEN                  ((uint32_t)0x00000020)         /*!< I/O port D clock enable */
+#define  RCC_APB2ENR_ADC1EN                  ((uint32_t)0x00000200)         /*!< ADC 1 interface clock enable */
+
+#if !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD_VL)
+#define  RCC_APB2ENR_ADC2EN                  ((uint32_t)0x00000400)         /*!< ADC 2 interface clock enable */
+#endif
+
+#define  RCC_APB2ENR_TIM1EN                  ((uint32_t)0x00000800)         /*!< TIM1 Timer clock enable */
+#define  RCC_APB2ENR_SPI1EN                  ((uint32_t)0x00001000)         /*!< SPI 1 clock enable */
+#define  RCC_APB2ENR_USART1EN                ((uint32_t)0x00004000)         /*!< USART1 clock enable */
+
+#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
+#define  RCC_APB2ENR_TIM15EN                 ((uint32_t)0x00010000)         /*!< TIM15 Timer clock enable */
+#define  RCC_APB2ENR_TIM16EN                 ((uint32_t)0x00020000)         /*!< TIM16 Timer clock enable */
+#define  RCC_APB2ENR_TIM17EN                 ((uint32_t)0x00040000)         /*!< TIM17 Timer clock enable */
+#endif
+
+#if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL)
+ #define  RCC_APB2ENR_IOPEEN                 ((uint32_t)0x00000040)         /*!< I/O port E clock enable */
+#endif /* STM32F10X_LD && STM32F10X_LD_VL */
+
+#if defined (STM32F10X_HD) || defined (STM32F10X_XL)
+ #define  RCC_APB2ENR_IOPFEN                 ((uint32_t)0x00000080)         /*!< I/O port F clock enable */
+ #define  RCC_APB2ENR_IOPGEN                 ((uint32_t)0x00000100)         /*!< I/O port G clock enable */
+ #define  RCC_APB2ENR_TIM8EN                 ((uint32_t)0x00002000)         /*!< TIM8 Timer clock enable */
+ #define  RCC_APB2ENR_ADC3EN                 ((uint32_t)0x00008000)         /*!< DMA1 clock enable */
+#endif
+
+#if defined (STM32F10X_HD_VL)
+ #define  RCC_APB2ENR_IOPFEN                 ((uint32_t)0x00000080)         /*!< I/O port F clock enable */
+ #define  RCC_APB2ENR_IOPGEN                 ((uint32_t)0x00000100)         /*!< I/O port G clock enable */
+#endif
+
+#ifdef STM32F10X_XL
+ #define  RCC_APB2ENR_TIM9EN                 ((uint32_t)0x00080000)         /*!< TIM9 Timer clock enable  */
+ #define  RCC_APB2ENR_TIM10EN                ((uint32_t)0x00100000)         /*!< TIM10 Timer clock enable  */
+ #define  RCC_APB2ENR_TIM11EN                ((uint32_t)0x00200000)         /*!< TIM11 Timer clock enable */
+#endif
+
+/*****************  Bit definition for RCC_APB1ENR register  ******************/
+#define  RCC_APB1ENR_TIM2EN                  ((uint32_t)0x00000001)        /*!< Timer 2 clock enabled*/
+#define  RCC_APB1ENR_TIM3EN                  ((uint32_t)0x00000002)        /*!< Timer 3 clock enable */
+#define  RCC_APB1ENR_WWDGEN                  ((uint32_t)0x00000800)        /*!< Window Watchdog clock enable */
+#define  RCC_APB1ENR_USART2EN                ((uint32_t)0x00020000)        /*!< USART 2 clock enable */
+#define  RCC_APB1ENR_I2C1EN                  ((uint32_t)0x00200000)        /*!< I2C 1 clock enable */
+
+#if !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD_VL)
+#define  RCC_APB1ENR_CAN1EN                  ((uint32_t)0x02000000)        /*!< CAN1 clock enable */
+#endif
+
+#define  RCC_APB1ENR_BKPEN                   ((uint32_t)0x08000000)        /*!< Backup interface clock enable */
+#define  RCC_APB1ENR_PWREN                   ((uint32_t)0x10000000)        /*!< Power interface clock enable */
+
+#if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL)
+ #define  RCC_APB1ENR_TIM4EN                 ((uint32_t)0x00000004)        /*!< Timer 4 clock enable */
+ #define  RCC_APB1ENR_SPI2EN                 ((uint32_t)0x00004000)        /*!< SPI 2 clock enable */
+ #define  RCC_APB1ENR_USART3EN               ((uint32_t)0x00040000)        /*!< USART 3 clock enable */
+ #define  RCC_APB1ENR_I2C2EN                 ((uint32_t)0x00400000)        /*!< I2C 2 clock enable */
+#endif /* STM32F10X_LD && STM32F10X_LD_VL */
+
+#if defined (STM32F10X_HD) || defined (STM32F10X_MD) || defined  (STM32F10X_LD)
+ #define  RCC_APB1ENR_USBEN                  ((uint32_t)0x00800000)        /*!< USB Device clock enable */
+#endif
+
+#if defined (STM32F10X_HD) || defined  (STM32F10X_CL)
+ #define  RCC_APB1ENR_TIM5EN                 ((uint32_t)0x00000008)        /*!< Timer 5 clock enable */
+ #define  RCC_APB1ENR_TIM6EN                 ((uint32_t)0x00000010)        /*!< Timer 6 clock enable */
+ #define  RCC_APB1ENR_TIM7EN                 ((uint32_t)0x00000020)        /*!< Timer 7 clock enable */
+ #define  RCC_APB1ENR_SPI3EN                 ((uint32_t)0x00008000)        /*!< SPI 3 clock enable */
+ #define  RCC_APB1ENR_UART4EN                ((uint32_t)0x00080000)        /*!< UART 4 clock enable */
+ #define  RCC_APB1ENR_UART5EN                ((uint32_t)0x00100000)        /*!< UART 5 clock enable */
+ #define  RCC_APB1ENR_DACEN                  ((uint32_t)0x20000000)        /*!< DAC interface clock enable */
+#endif
+
+#if defined (STM32F10X_LD_VL) || defined  (STM32F10X_MD_VL) || defined  (STM32F10X_HD_VL)
+ #define  RCC_APB1ENR_TIM6EN                 ((uint32_t)0x00000010)        /*!< Timer 6 clock enable */
+ #define  RCC_APB1ENR_TIM7EN                 ((uint32_t)0x00000020)        /*!< Timer 7 clock enable */
+ #define  RCC_APB1ENR_DACEN                  ((uint32_t)0x20000000)        /*!< DAC interface clock enable */
+ #define  RCC_APB1ENR_CECEN                  ((uint32_t)0x40000000)        /*!< CEC interface clock enable */
+#endif
+
+#ifdef STM32F10X_HD_VL
+ #define  RCC_APB1ENR_TIM5EN                 ((uint32_t)0x00000008)        /*!< Timer 5 clock enable */
+ #define  RCC_APB1ENR_TIM12EN                ((uint32_t)0x00000040)         /*!< TIM12 Timer clock enable  */
+ #define  RCC_APB1ENR_TIM13EN                ((uint32_t)0x00000080)         /*!< TIM13 Timer clock enable  */
+ #define  RCC_APB1ENR_TIM14EN                ((uint32_t)0x00000100)         /*!< TIM14 Timer clock enable */
+ #define  RCC_APB1ENR_SPI3EN                 ((uint32_t)0x00008000)        /*!< SPI 3 clock enable */
+ #define  RCC_APB1ENR_UART4EN                ((uint32_t)0x00080000)        /*!< UART 4 clock enable */
+ #define  RCC_APB1ENR_UART5EN                ((uint32_t)0x00100000)        /*!< UART 5 clock enable */
+#endif /* STM32F10X_HD_VL */
+
+#ifdef STM32F10X_CL
+ #define  RCC_APB1ENR_CAN2EN                  ((uint32_t)0x04000000)        /*!< CAN2 clock enable */
+#endif /* STM32F10X_CL */
+
+#ifdef STM32F10X_XL
+ #define  RCC_APB1ENR_TIM12EN                ((uint32_t)0x00000040)         /*!< TIM12 Timer clock enable  */
+ #define  RCC_APB1ENR_TIM13EN                ((uint32_t)0x00000080)         /*!< TIM13 Timer clock enable  */
+ #define  RCC_APB1ENR_TIM14EN                ((uint32_t)0x00000100)         /*!< TIM14 Timer clock enable */
+#endif /* STM32F10X_XL */
+
+/*******************  Bit definition for RCC_BDCR register  *******************/
+#define  RCC_BDCR_LSEON                      ((uint32_t)0x00000001)        /*!< External Low Speed oscillator enable */
+#define  RCC_BDCR_LSERDY                     ((uint32_t)0x00000002)        /*!< External Low Speed oscillator Ready */
+#define  RCC_BDCR_LSEBYP                     ((uint32_t)0x00000004)        /*!< External Low Speed oscillator Bypass */
+
+#define  RCC_BDCR_RTCSEL                     ((uint32_t)0x00000300)        /*!< RTCSEL[1:0] bits (RTC clock source selection) */
+#define  RCC_BDCR_RTCSEL_0                   ((uint32_t)0x00000100)        /*!< Bit 0 */
+#define  RCC_BDCR_RTCSEL_1                   ((uint32_t)0x00000200)        /*!< Bit 1 */
+
+/*!< RTC congiguration */
+#define  RCC_BDCR_RTCSEL_NOCLOCK             ((uint32_t)0x00000000)        /*!< No clock */
+#define  RCC_BDCR_RTCSEL_LSE                 ((uint32_t)0x00000100)        /*!< LSE oscillator clock used as RTC clock */
+#define  RCC_BDCR_RTCSEL_LSI                 ((uint32_t)0x00000200)        /*!< LSI oscillator clock used as RTC clock */
+#define  RCC_BDCR_RTCSEL_HSE                 ((uint32_t)0x00000300)        /*!< HSE oscillator clock divided by 128 used as RTC clock */
+
+#define  RCC_BDCR_RTCEN                      ((uint32_t)0x00008000)        /*!< RTC clock enable */
+#define  RCC_BDCR_BDRST                      ((uint32_t)0x00010000)        /*!< Backup domain software reset  */
+
+/*******************  Bit definition for RCC_CSR register  ********************/
+#define  RCC_CSR_LSION                       ((uint32_t)0x00000001)        /*!< Internal Low Speed oscillator enable */
+#define  RCC_CSR_LSIRDY                      ((uint32_t)0x00000002)        /*!< Internal Low Speed oscillator Ready */
+#define  RCC_CSR_RMVF                        ((uint32_t)0x01000000)        /*!< Remove reset flag */
+#define  RCC_CSR_PINRSTF                     ((uint32_t)0x04000000)        /*!< PIN reset flag */
+#define  RCC_CSR_PORRSTF                     ((uint32_t)0x08000000)        /*!< POR/PDR reset flag */
+#define  RCC_CSR_SFTRSTF                     ((uint32_t)0x10000000)        /*!< Software Reset flag */
+#define  RCC_CSR_IWDGRSTF                    ((uint32_t)0x20000000)        /*!< Independent Watchdog reset flag */
+#define  RCC_CSR_WWDGRSTF                    ((uint32_t)0x40000000)        /*!< Window watchdog reset flag */
+#define  RCC_CSR_LPWRRSTF                    ((uint32_t)0x80000000)        /*!< Low-Power reset flag */
+
+#ifdef STM32F10X_CL
+/*******************  Bit definition for RCC_AHBRSTR register  ****************/
+ #define  RCC_AHBRSTR_OTGFSRST               ((uint32_t)0x00001000)         /*!< USB OTG FS reset */
+ #define  RCC_AHBRSTR_ETHMACRST              ((uint32_t)0x00004000)         /*!< ETHERNET MAC reset */
+
+/*******************  Bit definition for RCC_CFGR2 register  ******************/
+/*!< PREDIV1 configuration */
+ #define  RCC_CFGR2_PREDIV1                  ((uint32_t)0x0000000F)        /*!< PREDIV1[3:0] bits */
+ #define  RCC_CFGR2_PREDIV1_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
+ #define  RCC_CFGR2_PREDIV1_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
+ #define  RCC_CFGR2_PREDIV1_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
+ #define  RCC_CFGR2_PREDIV1_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
+
+ #define  RCC_CFGR2_PREDIV1_DIV1             ((uint32_t)0x00000000)        /*!< PREDIV1 input clock not divided */
+ #define  RCC_CFGR2_PREDIV1_DIV2             ((uint32_t)0x00000001)        /*!< PREDIV1 input clock divided by 2 */
+ #define  RCC_CFGR2_PREDIV1_DIV3             ((uint32_t)0x00000002)        /*!< PREDIV1 input clock divided by 3 */
+ #define  RCC_CFGR2_PREDIV1_DIV4             ((uint32_t)0x00000003)        /*!< PREDIV1 input clock divided by 4 */
+ #define  RCC_CFGR2_PREDIV1_DIV5             ((uint32_t)0x00000004)        /*!< PREDIV1 input clock divided by 5 */
+ #define  RCC_CFGR2_PREDIV1_DIV6             ((uint32_t)0x00000005)        /*!< PREDIV1 input clock divided by 6 */
+ #define  RCC_CFGR2_PREDIV1_DIV7             ((uint32_t)0x00000006)        /*!< PREDIV1 input clock divided by 7 */
+ #define  RCC_CFGR2_PREDIV1_DIV8             ((uint32_t)0x00000007)        /*!< PREDIV1 input clock divided by 8 */
+ #define  RCC_CFGR2_PREDIV1_DIV9             ((uint32_t)0x00000008)        /*!< PREDIV1 input clock divided by 9 */
+ #define  RCC_CFGR2_PREDIV1_DIV10            ((uint32_t)0x00000009)        /*!< PREDIV1 input clock divided by 10 */
+ #define  RCC_CFGR2_PREDIV1_DIV11            ((uint32_t)0x0000000A)        /*!< PREDIV1 input clock divided by 11 */
+ #define  RCC_CFGR2_PREDIV1_DIV12            ((uint32_t)0x0000000B)        /*!< PREDIV1 input clock divided by 12 */
+ #define  RCC_CFGR2_PREDIV1_DIV13            ((uint32_t)0x0000000C)        /*!< PREDIV1 input clock divided by 13 */
+ #define  RCC_CFGR2_PREDIV1_DIV14            ((uint32_t)0x0000000D)        /*!< PREDIV1 input clock divided by 14 */
+ #define  RCC_CFGR2_PREDIV1_DIV15            ((uint32_t)0x0000000E)        /*!< PREDIV1 input clock divided by 15 */
+ #define  RCC_CFGR2_PREDIV1_DIV16            ((uint32_t)0x0000000F)        /*!< PREDIV1 input clock divided by 16 */
+
+/*!< PREDIV2 configuration */
+ #define  RCC_CFGR2_PREDIV2                  ((uint32_t)0x000000F0)        /*!< PREDIV2[3:0] bits */
+ #define  RCC_CFGR2_PREDIV2_0                ((uint32_t)0x00000010)        /*!< Bit 0 */
+ #define  RCC_CFGR2_PREDIV2_1                ((uint32_t)0x00000020)        /*!< Bit 1 */
+ #define  RCC_CFGR2_PREDIV2_2                ((uint32_t)0x00000040)        /*!< Bit 2 */
+ #define  RCC_CFGR2_PREDIV2_3                ((uint32_t)0x00000080)        /*!< Bit 3 */
+
+ #define  RCC_CFGR2_PREDIV2_DIV1             ((uint32_t)0x00000000)        /*!< PREDIV2 input clock not divided */
+ #define  RCC_CFGR2_PREDIV2_DIV2             ((uint32_t)0x00000010)        /*!< PREDIV2 input clock divided by 2 */
+ #define  RCC_CFGR2_PREDIV2_DIV3             ((uint32_t)0x00000020)        /*!< PREDIV2 input clock divided by 3 */
+ #define  RCC_CFGR2_PREDIV2_DIV4             ((uint32_t)0x00000030)        /*!< PREDIV2 input clock divided by 4 */
+ #define  RCC_CFGR2_PREDIV2_DIV5             ((uint32_t)0x00000040)        /*!< PREDIV2 input clock divided by 5 */
+ #define  RCC_CFGR2_PREDIV2_DIV6             ((uint32_t)0x00000050)        /*!< PREDIV2 input clock divided by 6 */
+ #define  RCC_CFGR2_PREDIV2_DIV7             ((uint32_t)0x00000060)        /*!< PREDIV2 input clock divided by 7 */
+ #define  RCC_CFGR2_PREDIV2_DIV8             ((uint32_t)0x00000070)        /*!< PREDIV2 input clock divided by 8 */
+ #define  RCC_CFGR2_PREDIV2_DIV9             ((uint32_t)0x00000080)        /*!< PREDIV2 input clock divided by 9 */
+ #define  RCC_CFGR2_PREDIV2_DIV10            ((uint32_t)0x00000090)        /*!< PREDIV2 input clock divided by 10 */
+ #define  RCC_CFGR2_PREDIV2_DIV11            ((uint32_t)0x000000A0)        /*!< PREDIV2 input clock divided by 11 */
+ #define  RCC_CFGR2_PREDIV2_DIV12            ((uint32_t)0x000000B0)        /*!< PREDIV2 input clock divided by 12 */
+ #define  RCC_CFGR2_PREDIV2_DIV13            ((uint32_t)0x000000C0)        /*!< PREDIV2 input clock divided by 13 */
+ #define  RCC_CFGR2_PREDIV2_DIV14            ((uint32_t)0x000000D0)        /*!< PREDIV2 input clock divided by 14 */
+ #define  RCC_CFGR2_PREDIV2_DIV15            ((uint32_t)0x000000E0)        /*!< PREDIV2 input clock divided by 15 */
+ #define  RCC_CFGR2_PREDIV2_DIV16            ((uint32_t)0x000000F0)        /*!< PREDIV2 input clock divided by 16 */
+
+/*!< PLL2MUL configuration */
+ #define  RCC_CFGR2_PLL2MUL                  ((uint32_t)0x00000F00)        /*!< PLL2MUL[3:0] bits */
+ #define  RCC_CFGR2_PLL2MUL_0                ((uint32_t)0x00000100)        /*!< Bit 0 */
+ #define  RCC_CFGR2_PLL2MUL_1                ((uint32_t)0x00000200)        /*!< Bit 1 */
+ #define  RCC_CFGR2_PLL2MUL_2                ((uint32_t)0x00000400)        /*!< Bit 2 */
+ #define  RCC_CFGR2_PLL2MUL_3                ((uint32_t)0x00000800)        /*!< Bit 3 */
+
+ #define  RCC_CFGR2_PLL2MUL8                 ((uint32_t)0x00000600)        /*!< PLL2 input clock * 8 */
+ #define  RCC_CFGR2_PLL2MUL9                 ((uint32_t)0x00000700)        /*!< PLL2 input clock * 9 */
+ #define  RCC_CFGR2_PLL2MUL10                ((uint32_t)0x00000800)        /*!< PLL2 input clock * 10 */
+ #define  RCC_CFGR2_PLL2MUL11                ((uint32_t)0x00000900)        /*!< PLL2 input clock * 11 */
+ #define  RCC_CFGR2_PLL2MUL12                ((uint32_t)0x00000A00)        /*!< PLL2 input clock * 12 */
+ #define  RCC_CFGR2_PLL2MUL13                ((uint32_t)0x00000B00)        /*!< PLL2 input clock * 13 */
+ #define  RCC_CFGR2_PLL2MUL14                ((uint32_t)0x00000C00)        /*!< PLL2 input clock * 14 */
+ #define  RCC_CFGR2_PLL2MUL16                ((uint32_t)0x00000E00)        /*!< PLL2 input clock * 16 */
+ #define  RCC_CFGR2_PLL2MUL20                ((uint32_t)0x00000F00)        /*!< PLL2 input clock * 20 */
+
+/*!< PLL3MUL configuration */
+ #define  RCC_CFGR2_PLL3MUL                  ((uint32_t)0x0000F000)        /*!< PLL3MUL[3:0] bits */
+ #define  RCC_CFGR2_PLL3MUL_0                ((uint32_t)0x00001000)        /*!< Bit 0 */
+ #define  RCC_CFGR2_PLL3MUL_1                ((uint32_t)0x00002000)        /*!< Bit 1 */
+ #define  RCC_CFGR2_PLL3MUL_2                ((uint32_t)0x00004000)        /*!< Bit 2 */
+ #define  RCC_CFGR2_PLL3MUL_3                ((uint32_t)0x00008000)        /*!< Bit 3 */
+
+ #define  RCC_CFGR2_PLL3MUL8                 ((uint32_t)0x00006000)        /*!< PLL3 input clock * 8 */
+ #define  RCC_CFGR2_PLL3MUL9                 ((uint32_t)0x00007000)        /*!< PLL3 input clock * 9 */
+ #define  RCC_CFGR2_PLL3MUL10                ((uint32_t)0x00008000)        /*!< PLL3 input clock * 10 */
+ #define  RCC_CFGR2_PLL3MUL11                ((uint32_t)0x00009000)        /*!< PLL3 input clock * 11 */
+ #define  RCC_CFGR2_PLL3MUL12                ((uint32_t)0x0000A000)        /*!< PLL3 input clock * 12 */
+ #define  RCC_CFGR2_PLL3MUL13                ((uint32_t)0x0000B000)        /*!< PLL3 input clock * 13 */
+ #define  RCC_CFGR2_PLL3MUL14                ((uint32_t)0x0000C000)        /*!< PLL3 input clock * 14 */
+ #define  RCC_CFGR2_PLL3MUL16                ((uint32_t)0x0000E000)        /*!< PLL3 input clock * 16 */
+ #define  RCC_CFGR2_PLL3MUL20                ((uint32_t)0x0000F000)        /*!< PLL3 input clock * 20 */
+
+ #define  RCC_CFGR2_PREDIV1SRC               ((uint32_t)0x00010000)        /*!< PREDIV1 entry clock source */
+ #define  RCC_CFGR2_PREDIV1SRC_PLL2          ((uint32_t)0x00010000)        /*!< PLL2 selected as PREDIV1 entry clock source */
+ #define  RCC_CFGR2_PREDIV1SRC_HSE           ((uint32_t)0x00000000)        /*!< HSE selected as PREDIV1 entry clock source */
+ #define  RCC_CFGR2_I2S2SRC                  ((uint32_t)0x00020000)        /*!< I2S2 entry clock source */
+ #define  RCC_CFGR2_I2S3SRC                  ((uint32_t)0x00040000)        /*!< I2S3 clock source */
+#endif /* STM32F10X_CL */
+
+#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
+/*******************  Bit definition for RCC_CFGR2 register  ******************/
+/*!< PREDIV1 configuration */
+ #define  RCC_CFGR2_PREDIV1                  ((uint32_t)0x0000000F)        /*!< PREDIV1[3:0] bits */
+ #define  RCC_CFGR2_PREDIV1_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
+ #define  RCC_CFGR2_PREDIV1_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
+ #define  RCC_CFGR2_PREDIV1_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
+ #define  RCC_CFGR2_PREDIV1_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
+
+ #define  RCC_CFGR2_PREDIV1_DIV1             ((uint32_t)0x00000000)        /*!< PREDIV1 input clock not divided */
+ #define  RCC_CFGR2_PREDIV1_DIV2             ((uint32_t)0x00000001)        /*!< PREDIV1 input clock divided by 2 */
+ #define  RCC_CFGR2_PREDIV1_DIV3             ((uint32_t)0x00000002)        /*!< PREDIV1 input clock divided by 3 */
+ #define  RCC_CFGR2_PREDIV1_DIV4             ((uint32_t)0x00000003)        /*!< PREDIV1 input clock divided by 4 */
+ #define  RCC_CFGR2_PREDIV1_DIV5             ((uint32_t)0x00000004)        /*!< PREDIV1 input clock divided by 5 */
+ #define  RCC_CFGR2_PREDIV1_DIV6             ((uint32_t)0x00000005)        /*!< PREDIV1 input clock divided by 6 */
+ #define  RCC_CFGR2_PREDIV1_DIV7             ((uint32_t)0x00000006)        /*!< PREDIV1 input clock divided by 7 */
+ #define  RCC_CFGR2_PREDIV1_DIV8             ((uint32_t)0x00000007)        /*!< PREDIV1 input clock divided by 8 */
+ #define  RCC_CFGR2_PREDIV1_DIV9             ((uint32_t)0x00000008)        /*!< PREDIV1 input clock divided by 9 */
+ #define  RCC_CFGR2_PREDIV1_DIV10            ((uint32_t)0x00000009)        /*!< PREDIV1 input clock divided by 10 */
+ #define  RCC_CFGR2_PREDIV1_DIV11            ((uint32_t)0x0000000A)        /*!< PREDIV1 input clock divided by 11 */
+ #define  RCC_CFGR2_PREDIV1_DIV12            ((uint32_t)0x0000000B)        /*!< PREDIV1 input clock divided by 12 */
+ #define  RCC_CFGR2_PREDIV1_DIV13            ((uint32_t)0x0000000C)        /*!< PREDIV1 input clock divided by 13 */
+ #define  RCC_CFGR2_PREDIV1_DIV14            ((uint32_t)0x0000000D)        /*!< PREDIV1 input clock divided by 14 */
+ #define  RCC_CFGR2_PREDIV1_DIV15            ((uint32_t)0x0000000E)        /*!< PREDIV1 input clock divided by 15 */
+ #define  RCC_CFGR2_PREDIV1_DIV16            ((uint32_t)0x0000000F)        /*!< PREDIV1 input clock divided by 16 */
+#endif
+
+/******************************************************************************/
+/*                                                                            */
+/*                General Purpose and Alternate Function I/O                  */
+/*                                                                            */
+/******************************************************************************/
+
+/*******************  Bit definition for GPIO_CRL register  *******************/
+#define  GPIO_CRL_MODE                       ((uint32_t)0x33333333)        /*!< Port x mode bits */
+
+#define  GPIO_CRL_MODE0                      ((uint32_t)0x00000003)        /*!< MODE0[1:0] bits (Port x mode bits, pin 0) */
+#define  GPIO_CRL_MODE0_0                    ((uint32_t)0x00000001)        /*!< Bit 0 */
+#define  GPIO_CRL_MODE0_1                    ((uint32_t)0x00000002)        /*!< Bit 1 */
+
+#define  GPIO_CRL_MODE1                      ((uint32_t)0x00000030)        /*!< MODE1[1:0] bits (Port x mode bits, pin 1) */
+#define  GPIO_CRL_MODE1_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
+#define  GPIO_CRL_MODE1_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
+
+#define  GPIO_CRL_MODE2                      ((uint32_t)0x00000300)        /*!< MODE2[1:0] bits (Port x mode bits, pin 2) */
+#define  GPIO_CRL_MODE2_0                    ((uint32_t)0x00000100)        /*!< Bit 0 */
+#define  GPIO_CRL_MODE2_1                    ((uint32_t)0x00000200)        /*!< Bit 1 */
+
+#define  GPIO_CRL_MODE3                      ((uint32_t)0x00003000)        /*!< MODE3[1:0] bits (Port x mode bits, pin 3) */
+#define  GPIO_CRL_MODE3_0                    ((uint32_t)0x00001000)        /*!< Bit 0 */
+#define  GPIO_CRL_MODE3_1                    ((uint32_t)0x00002000)        /*!< Bit 1 */
+
+#define  GPIO_CRL_MODE4                      ((uint32_t)0x00030000)        /*!< MODE4[1:0] bits (Port x mode bits, pin 4) */
+#define  GPIO_CRL_MODE4_0                    ((uint32_t)0x00010000)        /*!< Bit 0 */
+#define  GPIO_CRL_MODE4_1                    ((uint32_t)0x00020000)        /*!< Bit 1 */
+
+#define  GPIO_CRL_MODE5                      ((uint32_t)0x00300000)        /*!< MODE5[1:0] bits (Port x mode bits, pin 5) */
+#define  GPIO_CRL_MODE5_0                    ((uint32_t)0x00100000)        /*!< Bit 0 */
+#define  GPIO_CRL_MODE5_1                    ((uint32_t)0x00200000)        /*!< Bit 1 */
+
+#define  GPIO_CRL_MODE6                      ((uint32_t)0x03000000)        /*!< MODE6[1:0] bits (Port x mode bits, pin 6) */
+#define  GPIO_CRL_MODE6_0                    ((uint32_t)0x01000000)        /*!< Bit 0 */
+#define  GPIO_CRL_MODE6_1                    ((uint32_t)0x02000000)        /*!< Bit 1 */
+
+#define  GPIO_CRL_MODE7                      ((uint32_t)0x30000000)        /*!< MODE7[1:0] bits (Port x mode bits, pin 7) */
+#define  GPIO_CRL_MODE7_0                    ((uint32_t)0x10000000)        /*!< Bit 0 */
+#define  GPIO_CRL_MODE7_1                    ((uint32_t)0x20000000)        /*!< Bit 1 */
+
+#define  GPIO_CRL_CNF                        ((uint32_t)0xCCCCCCCC)        /*!< Port x configuration bits */
+
+#define  GPIO_CRL_CNF0                       ((uint32_t)0x0000000C)        /*!< CNF0[1:0] bits (Port x configuration bits, pin 0) */
+#define  GPIO_CRL_CNF0_0                     ((uint32_t)0x00000004)        /*!< Bit 0 */
+#define  GPIO_CRL_CNF0_1                     ((uint32_t)0x00000008)        /*!< Bit 1 */
+
+#define  GPIO_CRL_CNF1                       ((uint32_t)0x000000C0)        /*!< CNF1[1:0] bits (Port x configuration bits, pin 1) */
+#define  GPIO_CRL_CNF1_0                     ((uint32_t)0x00000040)        /*!< Bit 0 */
+#define  GPIO_CRL_CNF1_1                     ((uint32_t)0x00000080)        /*!< Bit 1 */
+
+#define  GPIO_CRL_CNF2                       ((uint32_t)0x00000C00)        /*!< CNF2[1:0] bits (Port x configuration bits, pin 2) */
+#define  GPIO_CRL_CNF2_0                     ((uint32_t)0x00000400)        /*!< Bit 0 */
+#define  GPIO_CRL_CNF2_1                     ((uint32_t)0x00000800)        /*!< Bit 1 */
+
+#define  GPIO_CRL_CNF3                       ((uint32_t)0x0000C000)        /*!< CNF3[1:0] bits (Port x configuration bits, pin 3) */
+#define  GPIO_CRL_CNF3_0                     ((uint32_t)0x00004000)        /*!< Bit 0 */
+#define  GPIO_CRL_CNF3_1                     ((uint32_t)0x00008000)        /*!< Bit 1 */
+
+#define  GPIO_CRL_CNF4                       ((uint32_t)0x000C0000)        /*!< CNF4[1:0] bits (Port x configuration bits, pin 4) */
+#define  GPIO_CRL_CNF4_0                     ((uint32_t)0x00040000)        /*!< Bit 0 */
+#define  GPIO_CRL_CNF4_1                     ((uint32_t)0x00080000)        /*!< Bit 1 */
+
+#define  GPIO_CRL_CNF5                       ((uint32_t)0x00C00000)        /*!< CNF5[1:0] bits (Port x configuration bits, pin 5) */
+#define  GPIO_CRL_CNF5_0                     ((uint32_t)0x00400000)        /*!< Bit 0 */
+#define  GPIO_CRL_CNF5_1                     ((uint32_t)0x00800000)        /*!< Bit 1 */
+
+#define  GPIO_CRL_CNF6                       ((uint32_t)0x0C000000)        /*!< CNF6[1:0] bits (Port x configuration bits, pin 6) */
+#define  GPIO_CRL_CNF6_0                     ((uint32_t)0x04000000)        /*!< Bit 0 */
+#define  GPIO_CRL_CNF6_1                     ((uint32_t)0x08000000)        /*!< Bit 1 */
+
+#define  GPIO_CRL_CNF7                       ((uint32_t)0xC0000000)        /*!< CNF7[1:0] bits (Port x configuration bits, pin 7) */
+#define  GPIO_CRL_CNF7_0                     ((uint32_t)0x40000000)        /*!< Bit 0 */
+#define  GPIO_CRL_CNF7_1                     ((uint32_t)0x80000000)        /*!< Bit 1 */
+
+/*******************  Bit definition for GPIO_CRH register  *******************/
+#define  GPIO_CRH_MODE                       ((uint32_t)0x33333333)        /*!< Port x mode bits */
+
+#define  GPIO_CRH_MODE8                      ((uint32_t)0x00000003)        /*!< MODE8[1:0] bits (Port x mode bits, pin 8) */
+#define  GPIO_CRH_MODE8_0                    ((uint32_t)0x00000001)        /*!< Bit 0 */
+#define  GPIO_CRH_MODE8_1                    ((uint32_t)0x00000002)        /*!< Bit 1 */
+
+#define  GPIO_CRH_MODE9                      ((uint32_t)0x00000030)        /*!< MODE9[1:0] bits (Port x mode bits, pin 9) */
+#define  GPIO_CRH_MODE9_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
+#define  GPIO_CRH_MODE9_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
+
+#define  GPIO_CRH_MODE10                     ((uint32_t)0x00000300)        /*!< MODE10[1:0] bits (Port x mode bits, pin 10) */
+#define  GPIO_CRH_MODE10_0                   ((uint32_t)0x00000100)        /*!< Bit 0 */
+#define  GPIO_CRH_MODE10_1                   ((uint32_t)0x00000200)        /*!< Bit 1 */
+
+#define  GPIO_CRH_MODE11                     ((uint32_t)0x00003000)        /*!< MODE11[1:0] bits (Port x mode bits, pin 11) */
+#define  GPIO_CRH_MODE11_0                   ((uint32_t)0x00001000)        /*!< Bit 0 */
+#define  GPIO_CRH_MODE11_1                   ((uint32_t)0x00002000)        /*!< Bit 1 */
+
+#define  GPIO_CRH_MODE12                     ((uint32_t)0x00030000)        /*!< MODE12[1:0] bits (Port x mode bits, pin 12) */
+#define  GPIO_CRH_MODE12_0                   ((uint32_t)0x00010000)        /*!< Bit 0 */
+#define  GPIO_CRH_MODE12_1                   ((uint32_t)0x00020000)        /*!< Bit 1 */
+
+#define  GPIO_CRH_MODE13                     ((uint32_t)0x00300000)        /*!< MODE13[1:0] bits (Port x mode bits, pin 13) */
+#define  GPIO_CRH_MODE13_0                   ((uint32_t)0x00100000)        /*!< Bit 0 */
+#define  GPIO_CRH_MODE13_1                   ((uint32_t)0x00200000)        /*!< Bit 1 */
+
+#define  GPIO_CRH_MODE14                     ((uint32_t)0x03000000)        /*!< MODE14[1:0] bits (Port x mode bits, pin 14) */
+#define  GPIO_CRH_MODE14_0                   ((uint32_t)0x01000000)        /*!< Bit 0 */
+#define  GPIO_CRH_MODE14_1                   ((uint32_t)0x02000000)        /*!< Bit 1 */
+
+#define  GPIO_CRH_MODE15                     ((uint32_t)0x30000000)        /*!< MODE15[1:0] bits (Port x mode bits, pin 15) */
+#define  GPIO_CRH_MODE15_0                   ((uint32_t)0x10000000)        /*!< Bit 0 */
+#define  GPIO_CRH_MODE15_1                   ((uint32_t)0x20000000)        /*!< Bit 1 */
+
+#define  GPIO_CRH_CNF                        ((uint32_t)0xCCCCCCCC)        /*!< Port x configuration bits */
+
+#define  GPIO_CRH_CNF8                       ((uint32_t)0x0000000C)        /*!< CNF8[1:0] bits (Port x configuration bits, pin 8) */
+#define  GPIO_CRH_CNF8_0                     ((uint32_t)0x00000004)        /*!< Bit 0 */
+#define  GPIO_CRH_CNF8_1                     ((uint32_t)0x00000008)        /*!< Bit 1 */
+
+#define  GPIO_CRH_CNF9                       ((uint32_t)0x000000C0)        /*!< CNF9[1:0] bits (Port x configuration bits, pin 9) */
+#define  GPIO_CRH_CNF9_0                     ((uint32_t)0x00000040)        /*!< Bit 0 */
+#define  GPIO_CRH_CNF9_1                     ((uint32_t)0x00000080)        /*!< Bit 1 */
+
+#define  GPIO_CRH_CNF10                      ((uint32_t)0x00000C00)        /*!< CNF10[1:0] bits (Port x configuration bits, pin 10) */
+#define  GPIO_CRH_CNF10_0                    ((uint32_t)0x00000400)        /*!< Bit 0 */
+#define  GPIO_CRH_CNF10_1                    ((uint32_t)0x00000800)        /*!< Bit 1 */
+
+#define  GPIO_CRH_CNF11                      ((uint32_t)0x0000C000)        /*!< CNF11[1:0] bits (Port x configuration bits, pin 11) */
+#define  GPIO_CRH_CNF11_0                    ((uint32_t)0x00004000)        /*!< Bit 0 */
+#define  GPIO_CRH_CNF11_1                    ((uint32_t)0x00008000)        /*!< Bit 1 */
+
+#define  GPIO_CRH_CNF12                      ((uint32_t)0x000C0000)        /*!< CNF12[1:0] bits (Port x configuration bits, pin 12) */
+#define  GPIO_CRH_CNF12_0                    ((uint32_t)0x00040000)        /*!< Bit 0 */
+#define  GPIO_CRH_CNF12_1                    ((uint32_t)0x00080000)        /*!< Bit 1 */
+
+#define  GPIO_CRH_CNF13                      ((uint32_t)0x00C00000)        /*!< CNF13[1:0] bits (Port x configuration bits, pin 13) */
+#define  GPIO_CRH_CNF13_0                    ((uint32_t)0x00400000)        /*!< Bit 0 */
+#define  GPIO_CRH_CNF13_1                    ((uint32_t)0x00800000)        /*!< Bit 1 */
+
+#define  GPIO_CRH_CNF14                      ((uint32_t)0x0C000000)        /*!< CNF14[1:0] bits (Port x configuration bits, pin 14) */
+#define  GPIO_CRH_CNF14_0                    ((uint32_t)0x04000000)        /*!< Bit 0 */
+#define  GPIO_CRH_CNF14_1                    ((uint32_t)0x08000000)        /*!< Bit 1 */
+
+#define  GPIO_CRH_CNF15                      ((uint32_t)0xC0000000)        /*!< CNF15[1:0] bits (Port x configuration bits, pin 15) */
+#define  GPIO_CRH_CNF15_0                    ((uint32_t)0x40000000)        /*!< Bit 0 */
+#define  GPIO_CRH_CNF15_1                    ((uint32_t)0x80000000)        /*!< Bit 1 */
+
+/*!<******************  Bit definition for GPIO_IDR register  *******************/
+#define GPIO_IDR_IDR0                        ((uint16_t)0x0001)            /*!< Port input data, bit 0 */
+#define GPIO_IDR_IDR1                        ((uint16_t)0x0002)            /*!< Port input data, bit 1 */
+#define GPIO_IDR_IDR2                        ((uint16_t)0x0004)            /*!< Port input data, bit 2 */
+#define GPIO_IDR_IDR3                        ((uint16_t)0x0008)            /*!< Port input data, bit 3 */
+#define GPIO_IDR_IDR4                        ((uint16_t)0x0010)            /*!< Port input data, bit 4 */
+#define GPIO_IDR_IDR5                        ((uint16_t)0x0020)            /*!< Port input data, bit 5 */
+#define GPIO_IDR_IDR6                        ((uint16_t)0x0040)            /*!< Port input data, bit 6 */
+#define GPIO_IDR_IDR7                        ((uint16_t)0x0080)            /*!< Port input data, bit 7 */
+#define GPIO_IDR_IDR8                        ((uint16_t)0x0100)            /*!< Port input data, bit 8 */
+#define GPIO_IDR_IDR9                        ((uint16_t)0x0200)            /*!< Port input data, bit 9 */
+#define GPIO_IDR_IDR10                       ((uint16_t)0x0400)            /*!< Port input data, bit 10 */
+#define GPIO_IDR_IDR11                       ((uint16_t)0x0800)            /*!< Port input data, bit 11 */
+#define GPIO_IDR_IDR12                       ((uint16_t)0x1000)            /*!< Port input data, bit 12 */
+#define GPIO_IDR_IDR13                       ((uint16_t)0x2000)            /*!< Port input data, bit 13 */
+#define GPIO_IDR_IDR14                       ((uint16_t)0x4000)            /*!< Port input data, bit 14 */
+#define GPIO_IDR_IDR15                       ((uint16_t)0x8000)            /*!< Port input data, bit 15 */
+
+/*******************  Bit definition for GPIO_ODR register  *******************/
+#define GPIO_ODR_ODR0                        ((uint16_t)0x0001)            /*!< Port output data, bit 0 */
+#define GPIO_ODR_ODR1                        ((uint16_t)0x0002)            /*!< Port output data, bit 1 */
+#define GPIO_ODR_ODR2                        ((uint16_t)0x0004)            /*!< Port output data, bit 2 */
+#define GPIO_ODR_ODR3                        ((uint16_t)0x0008)            /*!< Port output data, bit 3 */
+#define GPIO_ODR_ODR4                        ((uint16_t)0x0010)            /*!< Port output data, bit 4 */
+#define GPIO_ODR_ODR5                        ((uint16_t)0x0020)            /*!< Port output data, bit 5 */
+#define GPIO_ODR_ODR6                        ((uint16_t)0x0040)            /*!< Port output data, bit 6 */
+#define GPIO_ODR_ODR7                        ((uint16_t)0x0080)            /*!< Port output data, bit 7 */
+#define GPIO_ODR_ODR8                        ((uint16_t)0x0100)            /*!< Port output data, bit 8 */
+#define GPIO_ODR_ODR9                        ((uint16_t)0x0200)            /*!< Port output data, bit 9 */
+#define GPIO_ODR_ODR10                       ((uint16_t)0x0400)            /*!< Port output data, bit 10 */
+#define GPIO_ODR_ODR11                       ((uint16_t)0x0800)            /*!< Port output data, bit 11 */
+#define GPIO_ODR_ODR12                       ((uint16_t)0x1000)            /*!< Port output data, bit 12 */
+#define GPIO_ODR_ODR13                       ((uint16_t)0x2000)            /*!< Port output data, bit 13 */
+#define GPIO_ODR_ODR14                       ((uint16_t)0x4000)            /*!< Port output data, bit 14 */
+#define GPIO_ODR_ODR15                       ((uint16_t)0x8000)            /*!< Port output data, bit 15 */
+
+/******************  Bit definition for GPIO_BSRR register  *******************/
+#define GPIO_BSRR_BS0                        ((uint32_t)0x00000001)        /*!< Port x Set bit 0 */
+#define GPIO_BSRR_BS1                        ((uint32_t)0x00000002)        /*!< Port x Set bit 1 */
+#define GPIO_BSRR_BS2                        ((uint32_t)0x00000004)        /*!< Port x Set bit 2 */
+#define GPIO_BSRR_BS3                        ((uint32_t)0x00000008)        /*!< Port x Set bit 3 */
+#define GPIO_BSRR_BS4                        ((uint32_t)0x00000010)        /*!< Port x Set bit 4 */
+#define GPIO_BSRR_BS5                        ((uint32_t)0x00000020)        /*!< Port x Set bit 5 */
+#define GPIO_BSRR_BS6                        ((uint32_t)0x00000040)        /*!< Port x Set bit 6 */
+#define GPIO_BSRR_BS7                        ((uint32_t)0x00000080)        /*!< Port x Set bit 7 */
+#define GPIO_BSRR_BS8                        ((uint32_t)0x00000100)        /*!< Port x Set bit 8 */
+#define GPIO_BSRR_BS9                        ((uint32_t)0x00000200)        /*!< Port x Set bit 9 */
+#define GPIO_BSRR_BS10                       ((uint32_t)0x00000400)        /*!< Port x Set bit 10 */
+#define GPIO_BSRR_BS11                       ((uint32_t)0x00000800)        /*!< Port x Set bit 11 */
+#define GPIO_BSRR_BS12                       ((uint32_t)0x00001000)        /*!< Port x Set bit 12 */
+#define GPIO_BSRR_BS13                       ((uint32_t)0x00002000)        /*!< Port x Set bit 13 */
+#define GPIO_BSRR_BS14                       ((uint32_t)0x00004000)        /*!< Port x Set bit 14 */
+#define GPIO_BSRR_BS15                       ((uint32_t)0x00008000)        /*!< Port x Set bit 15 */
+
+#define GPIO_BSRR_BR0                        ((uint32_t)0x00010000)        /*!< Port x Reset bit 0 */
+#define GPIO_BSRR_BR1                        ((uint32_t)0x00020000)        /*!< Port x Reset bit 1 */
+#define GPIO_BSRR_BR2                        ((uint32_t)0x00040000)        /*!< Port x Reset bit 2 */
+#define GPIO_BSRR_BR3                        ((uint32_t)0x00080000)        /*!< Port x Reset bit 3 */
+#define GPIO_BSRR_BR4                        ((uint32_t)0x00100000)        /*!< Port x Reset bit 4 */
+#define GPIO_BSRR_BR5                        ((uint32_t)0x00200000)        /*!< Port x Reset bit 5 */
+#define GPIO_BSRR_BR6                        ((uint32_t)0x00400000)        /*!< Port x Reset bit 6 */
+#define GPIO_BSRR_BR7                        ((uint32_t)0x00800000)        /*!< Port x Reset bit 7 */
+#define GPIO_BSRR_BR8                        ((uint32_t)0x01000000)        /*!< Port x Reset bit 8 */
+#define GPIO_BSRR_BR9                        ((uint32_t)0x02000000)        /*!< Port x Reset bit 9 */
+#define GPIO_BSRR_BR10                       ((uint32_t)0x04000000)        /*!< Port x Reset bit 10 */
+#define GPIO_BSRR_BR11                       ((uint32_t)0x08000000)        /*!< Port x Reset bit 11 */
+#define GPIO_BSRR_BR12                       ((uint32_t)0x10000000)        /*!< Port x Reset bit 12 */
+#define GPIO_BSRR_BR13                       ((uint32_t)0x20000000)        /*!< Port x Reset bit 13 */
+#define GPIO_BSRR_BR14                       ((uint32_t)0x40000000)        /*!< Port x Reset bit 14 */
+#define GPIO_BSRR_BR15                       ((uint32_t)0x80000000)        /*!< Port x Reset bit 15 */
+
+/*******************  Bit definition for GPIO_BRR register  *******************/
+#define GPIO_BRR_BR0                         ((uint16_t)0x0001)            /*!< Port x Reset bit 0 */
+#define GPIO_BRR_BR1                         ((uint16_t)0x0002)            /*!< Port x Reset bit 1 */
+#define GPIO_BRR_BR2                         ((uint16_t)0x0004)            /*!< Port x Reset bit 2 */
+#define GPIO_BRR_BR3                         ((uint16_t)0x0008)            /*!< Port x Reset bit 3 */
+#define GPIO_BRR_BR4                         ((uint16_t)0x0010)            /*!< Port x Reset bit 4 */
+#define GPIO_BRR_BR5                         ((uint16_t)0x0020)            /*!< Port x Reset bit 5 */
+#define GPIO_BRR_BR6                         ((uint16_t)0x0040)            /*!< Port x Reset bit 6 */
+#define GPIO_BRR_BR7                         ((uint16_t)0x0080)            /*!< Port x Reset bit 7 */
+#define GPIO_BRR_BR8                         ((uint16_t)0x0100)            /*!< Port x Reset bit 8 */
+#define GPIO_BRR_BR9                         ((uint16_t)0x0200)            /*!< Port x Reset bit 9 */
+#define GPIO_BRR_BR10                        ((uint16_t)0x0400)            /*!< Port x Reset bit 10 */
+#define GPIO_BRR_BR11                        ((uint16_t)0x0800)            /*!< Port x Reset bit 11 */
+#define GPIO_BRR_BR12                        ((uint16_t)0x1000)            /*!< Port x Reset bit 12 */
+#define GPIO_BRR_BR13                        ((uint16_t)0x2000)            /*!< Port x Reset bit 13 */
+#define GPIO_BRR_BR14                        ((uint16_t)0x4000)            /*!< Port x Reset bit 14 */
+#define GPIO_BRR_BR15                        ((uint16_t)0x8000)            /*!< Port x Reset bit 15 */
+
+/******************  Bit definition for GPIO_LCKR register  *******************/
+#define GPIO_LCKR_LCK0                       ((uint32_t)0x00000001)        /*!< Port x Lock bit 0 */
+#define GPIO_LCKR_LCK1                       ((uint32_t)0x00000002)        /*!< Port x Lock bit 1 */
+#define GPIO_LCKR_LCK2                       ((uint32_t)0x00000004)        /*!< Port x Lock bit 2 */
+#define GPIO_LCKR_LCK3                       ((uint32_t)0x00000008)        /*!< Port x Lock bit 3 */
+#define GPIO_LCKR_LCK4                       ((uint32_t)0x00000010)        /*!< Port x Lock bit 4 */
+#define GPIO_LCKR_LCK5                       ((uint32_t)0x00000020)        /*!< Port x Lock bit 5 */
+#define GPIO_LCKR_LCK6                       ((uint32_t)0x00000040)        /*!< Port x Lock bit 6 */
+#define GPIO_LCKR_LCK7                       ((uint32_t)0x00000080)        /*!< Port x Lock bit 7 */
+#define GPIO_LCKR_LCK8                       ((uint32_t)0x00000100)        /*!< Port x Lock bit 8 */
+#define GPIO_LCKR_LCK9                       ((uint32_t)0x00000200)        /*!< Port x Lock bit 9 */
+#define GPIO_LCKR_LCK10                      ((uint32_t)0x00000400)        /*!< Port x Lock bit 10 */
+#define GPIO_LCKR_LCK11                      ((uint32_t)0x00000800)        /*!< Port x Lock bit 11 */
+#define GPIO_LCKR_LCK12                      ((uint32_t)0x00001000)        /*!< Port x Lock bit 12 */
+#define GPIO_LCKR_LCK13                      ((uint32_t)0x00002000)        /*!< Port x Lock bit 13 */
+#define GPIO_LCKR_LCK14                      ((uint32_t)0x00004000)        /*!< Port x Lock bit 14 */
+#define GPIO_LCKR_LCK15                      ((uint32_t)0x00008000)        /*!< Port x Lock bit 15 */
+#define GPIO_LCKR_LCKK                       ((uint32_t)0x00010000)        /*!< Lock key */
+
+/*----------------------------------------------------------------------------*/
+
+/******************  Bit definition for AFIO_EVCR register  *******************/
+#define AFIO_EVCR_PIN                        ((uint8_t)0x0F)               /*!< PIN[3:0] bits (Pin selection) */
+#define AFIO_EVCR_PIN_0                      ((uint8_t)0x01)               /*!< Bit 0 */
+#define AFIO_EVCR_PIN_1                      ((uint8_t)0x02)               /*!< Bit 1 */
+#define AFIO_EVCR_PIN_2                      ((uint8_t)0x04)               /*!< Bit 2 */
+#define AFIO_EVCR_PIN_3                      ((uint8_t)0x08)               /*!< Bit 3 */
+
+/*!< PIN configuration */
+#define AFIO_EVCR_PIN_PX0                    ((uint8_t)0x00)               /*!< Pin 0 selected */
+#define AFIO_EVCR_PIN_PX1                    ((uint8_t)0x01)               /*!< Pin 1 selected */
+#define AFIO_EVCR_PIN_PX2                    ((uint8_t)0x02)               /*!< Pin 2 selected */
+#define AFIO_EVCR_PIN_PX3                    ((uint8_t)0x03)               /*!< Pin 3 selected */
+#define AFIO_EVCR_PIN_PX4                    ((uint8_t)0x04)               /*!< Pin 4 selected */
+#define AFIO_EVCR_PIN_PX5                    ((uint8_t)0x05)               /*!< Pin 5 selected */
+#define AFIO_EVCR_PIN_PX6                    ((uint8_t)0x06)               /*!< Pin 6 selected */
+#define AFIO_EVCR_PIN_PX7                    ((uint8_t)0x07)               /*!< Pin 7 selected */
+#define AFIO_EVCR_PIN_PX8                    ((uint8_t)0x08)               /*!< Pin 8 selected */
+#define AFIO_EVCR_PIN_PX9                    ((uint8_t)0x09)               /*!< Pin 9 selected */
+#define AFIO_EVCR_PIN_PX10                   ((uint8_t)0x0A)               /*!< Pin 10 selected */
+#define AFIO_EVCR_PIN_PX11                   ((uint8_t)0x0B)               /*!< Pin 11 selected */
+#define AFIO_EVCR_PIN_PX12                   ((uint8_t)0x0C)               /*!< Pin 12 selected */
+#define AFIO_EVCR_PIN_PX13                   ((uint8_t)0x0D)               /*!< Pin 13 selected */
+#define AFIO_EVCR_PIN_PX14                   ((uint8_t)0x0E)               /*!< Pin 14 selected */
+#define AFIO_EVCR_PIN_PX15                   ((uint8_t)0x0F)               /*!< Pin 15 selected */
+
+#define AFIO_EVCR_PORT                       ((uint8_t)0x70)               /*!< PORT[2:0] bits (Port selection) */
+#define AFIO_EVCR_PORT_0                     ((uint8_t)0x10)               /*!< Bit 0 */
+#define AFIO_EVCR_PORT_1                     ((uint8_t)0x20)               /*!< Bit 1 */
+#define AFIO_EVCR_PORT_2                     ((uint8_t)0x40)               /*!< Bit 2 */
+
+/*!< PORT configuration */
+#define AFIO_EVCR_PORT_PA                    ((uint8_t)0x00)               /*!< Port A selected */
+#define AFIO_EVCR_PORT_PB                    ((uint8_t)0x10)               /*!< Port B selected */
+#define AFIO_EVCR_PORT_PC                    ((uint8_t)0x20)               /*!< Port C selected */
+#define AFIO_EVCR_PORT_PD                    ((uint8_t)0x30)               /*!< Port D selected */
+#define AFIO_EVCR_PORT_PE                    ((uint8_t)0x40)               /*!< Port E selected */
+
+#define AFIO_EVCR_EVOE                       ((uint8_t)0x80)               /*!< Event Output Enable */
+
+/******************  Bit definition for AFIO_MAPR register  *******************/
+#define AFIO_MAPR_SPI1_REMAP                 ((uint32_t)0x00000001)        /*!< SPI1 remapping */
+#define AFIO_MAPR_I2C1_REMAP                 ((uint32_t)0x00000002)        /*!< I2C1 remapping */
+#define AFIO_MAPR_USART1_REMAP               ((uint32_t)0x00000004)        /*!< USART1 remapping */
+#define AFIO_MAPR_USART2_REMAP               ((uint32_t)0x00000008)        /*!< USART2 remapping */
+
+#define AFIO_MAPR_USART3_REMAP               ((uint32_t)0x00000030)        /*!< USART3_REMAP[1:0] bits (USART3 remapping) */
+#define AFIO_MAPR_USART3_REMAP_0             ((uint32_t)0x00000010)        /*!< Bit 0 */
+#define AFIO_MAPR_USART3_REMAP_1             ((uint32_t)0x00000020)        /*!< Bit 1 */
+
+/* USART3_REMAP configuration */
+#define AFIO_MAPR_USART3_REMAP_NOREMAP       ((uint32_t)0x00000000)        /*!< No remap (TX/PB10, RX/PB11, CK/PB12, CTS/PB13, RTS/PB14) */
+#define AFIO_MAPR_USART3_REMAP_PARTIALREMAP  ((uint32_t)0x00000010)        /*!< Partial remap (TX/PC10, RX/PC11, CK/PC12, CTS/PB13, RTS/PB14) */
+#define AFIO_MAPR_USART3_REMAP_FULLREMAP     ((uint32_t)0x00000030)        /*!< Full remap (TX/PD8, RX/PD9, CK/PD10, CTS/PD11, RTS/PD12) */
+
+#define AFIO_MAPR_TIM1_REMAP                 ((uint32_t)0x000000C0)        /*!< TIM1_REMAP[1:0] bits (TIM1 remapping) */
+#define AFIO_MAPR_TIM1_REMAP_0               ((uint32_t)0x00000040)        /*!< Bit 0 */
+#define AFIO_MAPR_TIM1_REMAP_1               ((uint32_t)0x00000080)        /*!< Bit 1 */
+
+/*!< TIM1_REMAP configuration */
+#define AFIO_MAPR_TIM1_REMAP_NOREMAP         ((uint32_t)0x00000000)        /*!< No remap (ETR/PA12, CH1/PA8, CH2/PA9, CH3/PA10, CH4/PA11, BKIN/PB12, CH1N/PB13, CH2N/PB14, CH3N/PB15) */
+#define AFIO_MAPR_TIM1_REMAP_PARTIALREMAP    ((uint32_t)0x00000040)        /*!< Partial remap (ETR/PA12, CH1/PA8, CH2/PA9, CH3/PA10, CH4/PA11, BKIN/PA6, CH1N/PA7, CH2N/PB0, CH3N/PB1) */
+#define AFIO_MAPR_TIM1_REMAP_FULLREMAP       ((uint32_t)0x000000C0)        /*!< Full remap (ETR/PE7, CH1/PE9, CH2/PE11, CH3/PE13, CH4/PE14, BKIN/PE15, CH1N/PE8, CH2N/PE10, CH3N/PE12) */
+
+#define AFIO_MAPR_TIM2_REMAP                 ((uint32_t)0x00000300)        /*!< TIM2_REMAP[1:0] bits (TIM2 remapping) */
+#define AFIO_MAPR_TIM2_REMAP_0               ((uint32_t)0x00000100)        /*!< Bit 0 */
+#define AFIO_MAPR_TIM2_REMAP_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
+
+/*!< TIM2_REMAP configuration */
+#define AFIO_MAPR_TIM2_REMAP_NOREMAP         ((uint32_t)0x00000000)        /*!< No remap (CH1/ETR/PA0, CH2/PA1, CH3/PA2, CH4/PA3) */
+#define AFIO_MAPR_TIM2_REMAP_PARTIALREMAP1   ((uint32_t)0x00000100)        /*!< Partial remap (CH1/ETR/PA15, CH2/PB3, CH3/PA2, CH4/PA3) */
+#define AFIO_MAPR_TIM2_REMAP_PARTIALREMAP2   ((uint32_t)0x00000200)        /*!< Partial remap (CH1/ETR/PA0, CH2/PA1, CH3/PB10, CH4/PB11) */
+#define AFIO_MAPR_TIM2_REMAP_FULLREMAP       ((uint32_t)0x00000300)        /*!< Full remap (CH1/ETR/PA15, CH2/PB3, CH3/PB10, CH4/PB11) */
+
+#define AFIO_MAPR_TIM3_REMAP                 ((uint32_t)0x00000C00)        /*!< TIM3_REMAP[1:0] bits (TIM3 remapping) */
+#define AFIO_MAPR_TIM3_REMAP_0               ((uint32_t)0x00000400)        /*!< Bit 0 */
+#define AFIO_MAPR_TIM3_REMAP_1               ((uint32_t)0x00000800)        /*!< Bit 1 */
+
+/*!< TIM3_REMAP configuration */
+#define AFIO_MAPR_TIM3_REMAP_NOREMAP         ((uint32_t)0x00000000)        /*!< No remap (CH1/PA6, CH2/PA7, CH3/PB0, CH4/PB1) */
+#define AFIO_MAPR_TIM3_REMAP_PARTIALREMAP    ((uint32_t)0x00000800)        /*!< Partial remap (CH1/PB4, CH2/PB5, CH3/PB0, CH4/PB1) */
+#define AFIO_MAPR_TIM3_REMAP_FULLREMAP       ((uint32_t)0x00000C00)        /*!< Full remap (CH1/PC6, CH2/PC7, CH3/PC8, CH4/PC9) */
+
+#define AFIO_MAPR_TIM4_REMAP                 ((uint32_t)0x00001000)        /*!< TIM4_REMAP bit (TIM4 remapping) */
+
+#define AFIO_MAPR_CAN_REMAP                  ((uint32_t)0x00006000)        /*!< CAN_REMAP[1:0] bits (CAN Alternate function remapping) */
+#define AFIO_MAPR_CAN_REMAP_0                ((uint32_t)0x00002000)        /*!< Bit 0 */
+#define AFIO_MAPR_CAN_REMAP_1                ((uint32_t)0x00004000)        /*!< Bit 1 */
+
+/*!< CAN_REMAP configuration */
+#define AFIO_MAPR_CAN_REMAP_REMAP1           ((uint32_t)0x00000000)        /*!< CANRX mapped to PA11, CANTX mapped to PA12 */
+#define AFIO_MAPR_CAN_REMAP_REMAP2           ((uint32_t)0x00004000)        /*!< CANRX mapped to PB8, CANTX mapped to PB9 */
+#define AFIO_MAPR_CAN_REMAP_REMAP3           ((uint32_t)0x00006000)        /*!< CANRX mapped to PD0, CANTX mapped to PD1 */
+
+#define AFIO_MAPR_PD01_REMAP                 ((uint32_t)0x00008000)        /*!< Port D0/Port D1 mapping on OSC_IN/OSC_OUT */
+#define AFIO_MAPR_TIM5CH4_IREMAP             ((uint32_t)0x00010000)        /*!< TIM5 Channel4 Internal Remap */
+#define AFIO_MAPR_ADC1_ETRGINJ_REMAP         ((uint32_t)0x00020000)        /*!< ADC 1 External Trigger Injected Conversion remapping */
+#define AFIO_MAPR_ADC1_ETRGREG_REMAP         ((uint32_t)0x00040000)        /*!< ADC 1 External Trigger Regular Conversion remapping */
+#define AFIO_MAPR_ADC2_ETRGINJ_REMAP         ((uint32_t)0x00080000)        /*!< ADC 2 External Trigger Injected Conversion remapping */
+#define AFIO_MAPR_ADC2_ETRGREG_REMAP         ((uint32_t)0x00100000)        /*!< ADC 2 External Trigger Regular Conversion remapping */
+
+/*!< SWJ_CFG configuration */
+#define AFIO_MAPR_SWJ_CFG                    ((uint32_t)0x07000000)        /*!< SWJ_CFG[2:0] bits (Serial Wire JTAG configuration) */
+#define AFIO_MAPR_SWJ_CFG_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
+#define AFIO_MAPR_SWJ_CFG_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
+#define AFIO_MAPR_SWJ_CFG_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
+
+#define AFIO_MAPR_SWJ_CFG_RESET              ((uint32_t)0x00000000)        /*!< Full SWJ (JTAG-DP + SW-DP) : Reset State */
+#define AFIO_MAPR_SWJ_CFG_NOJNTRST           ((uint32_t)0x01000000)        /*!< Full SWJ (JTAG-DP + SW-DP) but without JNTRST */
+#define AFIO_MAPR_SWJ_CFG_JTAGDISABLE        ((uint32_t)0x02000000)        /*!< JTAG-DP Disabled and SW-DP Enabled */
+#define AFIO_MAPR_SWJ_CFG_DISABLE            ((uint32_t)0x04000000)        /*!< JTAG-DP Disabled and SW-DP Disabled */
+
+#ifdef STM32F10X_CL
+/*!< ETH_REMAP configuration */
+ #define AFIO_MAPR_ETH_REMAP                  ((uint32_t)0x00200000)        /*!< SPI3_REMAP bit (Ethernet MAC I/O remapping) */
+
+/*!< CAN2_REMAP configuration */
+ #define AFIO_MAPR_CAN2_REMAP                 ((uint32_t)0x00400000)        /*!< CAN2_REMAP bit (CAN2 I/O remapping) */
+
+/*!< MII_RMII_SEL configuration */
+ #define AFIO_MAPR_MII_RMII_SEL               ((uint32_t)0x00800000)        /*!< MII_RMII_SEL bit (Ethernet MII or RMII selection) */
+
+/*!< SPI3_REMAP configuration */
+ #define AFIO_MAPR_SPI3_REMAP                 ((uint32_t)0x10000000)        /*!< SPI3_REMAP bit (SPI3 remapping) */
+
+/*!< TIM2ITR1_IREMAP configuration */
+ #define AFIO_MAPR_TIM2ITR1_IREMAP            ((uint32_t)0x20000000)        /*!< TIM2ITR1_IREMAP bit (TIM2 internal trigger 1 remapping) */
+
+/*!< PTP_PPS_REMAP configuration */
+ #define AFIO_MAPR_PTP_PPS_REMAP              ((uint32_t)0x40000000)        /*!< PTP_PPS_REMAP bit (Ethernet PTP PPS remapping) */
+#endif
+
+/*****************  Bit definition for AFIO_EXTICR1 register  *****************/
+#define AFIO_EXTICR1_EXTI0                   ((uint16_t)0x000F)            /*!< EXTI 0 configuration */
+#define AFIO_EXTICR1_EXTI1                   ((uint16_t)0x00F0)            /*!< EXTI 1 configuration */
+#define AFIO_EXTICR1_EXTI2                   ((uint16_t)0x0F00)            /*!< EXTI 2 configuration */
+#define AFIO_EXTICR1_EXTI3                   ((uint16_t)0xF000)            /*!< EXTI 3 configuration */
+
+/*!< EXTI0 configuration */
+#define AFIO_EXTICR1_EXTI0_PA                ((uint16_t)0x0000)            /*!< PA[0] pin */
+#define AFIO_EXTICR1_EXTI0_PB                ((uint16_t)0x0001)            /*!< PB[0] pin */
+#define AFIO_EXTICR1_EXTI0_PC                ((uint16_t)0x0002)            /*!< PC[0] pin */
+#define AFIO_EXTICR1_EXTI0_PD                ((uint16_t)0x0003)            /*!< PD[0] pin */
+#define AFIO_EXTICR1_EXTI0_PE                ((uint16_t)0x0004)            /*!< PE[0] pin */
+#define AFIO_EXTICR1_EXTI0_PF                ((uint16_t)0x0005)            /*!< PF[0] pin */
+#define AFIO_EXTICR1_EXTI0_PG                ((uint16_t)0x0006)            /*!< PG[0] pin */
+
+/*!< EXTI1 configuration */
+#define AFIO_EXTICR1_EXTI1_PA                ((uint16_t)0x0000)            /*!< PA[1] pin */
+#define AFIO_EXTICR1_EXTI1_PB                ((uint16_t)0x0010)            /*!< PB[1] pin */
+#define AFIO_EXTICR1_EXTI1_PC                ((uint16_t)0x0020)            /*!< PC[1] pin */
+#define AFIO_EXTICR1_EXTI1_PD                ((uint16_t)0x0030)            /*!< PD[1] pin */
+#define AFIO_EXTICR1_EXTI1_PE                ((uint16_t)0x0040)            /*!< PE[1] pin */
+#define AFIO_EXTICR1_EXTI1_PF                ((uint16_t)0x0050)            /*!< PF[1] pin */
+#define AFIO_EXTICR1_EXTI1_PG                ((uint16_t)0x0060)            /*!< PG[1] pin */
+
+/*!< EXTI2 configuration */
+#define AFIO_EXTICR1_EXTI2_PA                ((uint16_t)0x0000)            /*!< PA[2] pin */
+#define AFIO_EXTICR1_EXTI2_PB                ((uint16_t)0x0100)            /*!< PB[2] pin */
+#define AFIO_EXTICR1_EXTI2_PC                ((uint16_t)0x0200)            /*!< PC[2] pin */
+#define AFIO_EXTICR1_EXTI2_PD                ((uint16_t)0x0300)            /*!< PD[2] pin */
+#define AFIO_EXTICR1_EXTI2_PE                ((uint16_t)0x0400)            /*!< PE[2] pin */
+#define AFIO_EXTICR1_EXTI2_PF                ((uint16_t)0x0500)            /*!< PF[2] pin */
+#define AFIO_EXTICR1_EXTI2_PG                ((uint16_t)0x0600)            /*!< PG[2] pin */
+
+/*!< EXTI3 configuration */
+#define AFIO_EXTICR1_EXTI3_PA                ((uint16_t)0x0000)            /*!< PA[3] pin */
+#define AFIO_EXTICR1_EXTI3_PB                ((uint16_t)0x1000)            /*!< PB[3] pin */
+#define AFIO_EXTICR1_EXTI3_PC                ((uint16_t)0x2000)            /*!< PC[3] pin */
+#define AFIO_EXTICR1_EXTI3_PD                ((uint16_t)0x3000)            /*!< PD[3] pin */
+#define AFIO_EXTICR1_EXTI3_PE                ((uint16_t)0x4000)            /*!< PE[3] pin */
+#define AFIO_EXTICR1_EXTI3_PF                ((uint16_t)0x5000)            /*!< PF[3] pin */
+#define AFIO_EXTICR1_EXTI3_PG                ((uint16_t)0x6000)            /*!< PG[3] pin */
+
+/*****************  Bit definition for AFIO_EXTICR2 register  *****************/
+#define AFIO_EXTICR2_EXTI4                   ((uint16_t)0x000F)            /*!< EXTI 4 configuration */
+#define AFIO_EXTICR2_EXTI5                   ((uint16_t)0x00F0)            /*!< EXTI 5 configuration */
+#define AFIO_EXTICR2_EXTI6                   ((uint16_t)0x0F00)            /*!< EXTI 6 configuration */
+#define AFIO_EXTICR2_EXTI7                   ((uint16_t)0xF000)            /*!< EXTI 7 configuration */
+
+/*!< EXTI4 configuration */
+#define AFIO_EXTICR2_EXTI4_PA                ((uint16_t)0x0000)            /*!< PA[4] pin */
+#define AFIO_EXTICR2_EXTI4_PB                ((uint16_t)0x0001)            /*!< PB[4] pin */
+#define AFIO_EXTICR2_EXTI4_PC                ((uint16_t)0x0002)            /*!< PC[4] pin */
+#define AFIO_EXTICR2_EXTI4_PD                ((uint16_t)0x0003)            /*!< PD[4] pin */
+#define AFIO_EXTICR2_EXTI4_PE                ((uint16_t)0x0004)            /*!< PE[4] pin */
+#define AFIO_EXTICR2_EXTI4_PF                ((uint16_t)0x0005)            /*!< PF[4] pin */
+#define AFIO_EXTICR2_EXTI4_PG                ((uint16_t)0x0006)            /*!< PG[4] pin */
+
+/* EXTI5 configuration */
+#define AFIO_EXTICR2_EXTI5_PA                ((uint16_t)0x0000)            /*!< PA[5] pin */
+#define AFIO_EXTICR2_EXTI5_PB                ((uint16_t)0x0010)            /*!< PB[5] pin */
+#define AFIO_EXTICR2_EXTI5_PC                ((uint16_t)0x0020)            /*!< PC[5] pin */
+#define AFIO_EXTICR2_EXTI5_PD                ((uint16_t)0x0030)            /*!< PD[5] pin */
+#define AFIO_EXTICR2_EXTI5_PE                ((uint16_t)0x0040)            /*!< PE[5] pin */
+#define AFIO_EXTICR2_EXTI5_PF                ((uint16_t)0x0050)            /*!< PF[5] pin */
+#define AFIO_EXTICR2_EXTI5_PG                ((uint16_t)0x0060)            /*!< PG[5] pin */
+
+/*!< EXTI6 configuration */
+#define AFIO_EXTICR2_EXTI6_PA                ((uint16_t)0x0000)            /*!< PA[6] pin */
+#define AFIO_EXTICR2_EXTI6_PB                ((uint16_t)0x0100)            /*!< PB[6] pin */
+#define AFIO_EXTICR2_EXTI6_PC                ((uint16_t)0x0200)            /*!< PC[6] pin */
+#define AFIO_EXTICR2_EXTI6_PD                ((uint16_t)0x0300)            /*!< PD[6] pin */
+#define AFIO_EXTICR2_EXTI6_PE                ((uint16_t)0x0400)            /*!< PE[6] pin */
+#define AFIO_EXTICR2_EXTI6_PF                ((uint16_t)0x0500)            /*!< PF[6] pin */
+#define AFIO_EXTICR2_EXTI6_PG                ((uint16_t)0x0600)            /*!< PG[6] pin */
+
+/*!< EXTI7 configuration */
+#define AFIO_EXTICR2_EXTI7_PA                ((uint16_t)0x0000)            /*!< PA[7] pin */
+#define AFIO_EXTICR2_EXTI7_PB                ((uint16_t)0x1000)            /*!< PB[7] pin */
+#define AFIO_EXTICR2_EXTI7_PC                ((uint16_t)0x2000)            /*!< PC[7] pin */
+#define AFIO_EXTICR2_EXTI7_PD                ((uint16_t)0x3000)            /*!< PD[7] pin */
+#define AFIO_EXTICR2_EXTI7_PE                ((uint16_t)0x4000)            /*!< PE[7] pin */
+#define AFIO_EXTICR2_EXTI7_PF                ((uint16_t)0x5000)            /*!< PF[7] pin */
+#define AFIO_EXTICR2_EXTI7_PG                ((uint16_t)0x6000)            /*!< PG[7] pin */
+
+/*****************  Bit definition for AFIO_EXTICR3 register  *****************/
+#define AFIO_EXTICR3_EXTI8                   ((uint16_t)0x000F)            /*!< EXTI 8 configuration */
+#define AFIO_EXTICR3_EXTI9                   ((uint16_t)0x00F0)            /*!< EXTI 9 configuration */
+#define AFIO_EXTICR3_EXTI10                  ((uint16_t)0x0F00)            /*!< EXTI 10 configuration */
+#define AFIO_EXTICR3_EXTI11                  ((uint16_t)0xF000)            /*!< EXTI 11 configuration */
+
+/*!< EXTI8 configuration */
+#define AFIO_EXTICR3_EXTI8_PA                ((uint16_t)0x0000)            /*!< PA[8] pin */
+#define AFIO_EXTICR3_EXTI8_PB                ((uint16_t)0x0001)            /*!< PB[8] pin */
+#define AFIO_EXTICR3_EXTI8_PC                ((uint16_t)0x0002)            /*!< PC[8] pin */
+#define AFIO_EXTICR3_EXTI8_PD                ((uint16_t)0x0003)            /*!< PD[8] pin */
+#define AFIO_EXTICR3_EXTI8_PE                ((uint16_t)0x0004)            /*!< PE[8] pin */
+#define AFIO_EXTICR3_EXTI8_PF                ((uint16_t)0x0005)            /*!< PF[8] pin */
+#define AFIO_EXTICR3_EXTI8_PG                ((uint16_t)0x0006)            /*!< PG[8] pin */
+
+/*!< EXTI9 configuration */
+#define AFIO_EXTICR3_EXTI9_PA                ((uint16_t)0x0000)            /*!< PA[9] pin */
+#define AFIO_EXTICR3_EXTI9_PB                ((uint16_t)0x0010)            /*!< PB[9] pin */
+#define AFIO_EXTICR3_EXTI9_PC                ((uint16_t)0x0020)            /*!< PC[9] pin */
+#define AFIO_EXTICR3_EXTI9_PD                ((uint16_t)0x0030)            /*!< PD[9] pin */
+#define AFIO_EXTICR3_EXTI9_PE                ((uint16_t)0x0040)            /*!< PE[9] pin */
+#define AFIO_EXTICR3_EXTI9_PF                ((uint16_t)0x0050)            /*!< PF[9] pin */
+#define AFIO_EXTICR3_EXTI9_PG                ((uint16_t)0x0060)            /*!< PG[9] pin */
+
+/*!< EXTI10 configuration */
+#define AFIO_EXTICR3_EXTI10_PA               ((uint16_t)0x0000)            /*!< PA[10] pin */
+#define AFIO_EXTICR3_EXTI10_PB               ((uint16_t)0x0100)            /*!< PB[10] pin */
+#define AFIO_EXTICR3_EXTI10_PC               ((uint16_t)0x0200)            /*!< PC[10] pin */
+#define AFIO_EXTICR3_EXTI10_PD               ((uint16_t)0x0300)            /*!< PD[10] pin */
+#define AFIO_EXTICR3_EXTI10_PE               ((uint16_t)0x0400)            /*!< PE[10] pin */
+#define AFIO_EXTICR3_EXTI10_PF               ((uint16_t)0x0500)            /*!< PF[10] pin */
+#define AFIO_EXTICR3_EXTI10_PG               ((uint16_t)0x0600)            /*!< PG[10] pin */
+
+/*!< EXTI11 configuration */
+#define AFIO_EXTICR3_EXTI11_PA               ((uint16_t)0x0000)            /*!< PA[11] pin */
+#define AFIO_EXTICR3_EXTI11_PB               ((uint16_t)0x1000)            /*!< PB[11] pin */
+#define AFIO_EXTICR3_EXTI11_PC               ((uint16_t)0x2000)            /*!< PC[11] pin */
+#define AFIO_EXTICR3_EXTI11_PD               ((uint16_t)0x3000)            /*!< PD[11] pin */
+#define AFIO_EXTICR3_EXTI11_PE               ((uint16_t)0x4000)            /*!< PE[11] pin */
+#define AFIO_EXTICR3_EXTI11_PF               ((uint16_t)0x5000)            /*!< PF[11] pin */
+#define AFIO_EXTICR3_EXTI11_PG               ((uint16_t)0x6000)            /*!< PG[11] pin */
+
+/*****************  Bit definition for AFIO_EXTICR4 register  *****************/
+#define AFIO_EXTICR4_EXTI12                  ((uint16_t)0x000F)            /*!< EXTI 12 configuration */
+#define AFIO_EXTICR4_EXTI13                  ((uint16_t)0x00F0)            /*!< EXTI 13 configuration */
+#define AFIO_EXTICR4_EXTI14                  ((uint16_t)0x0F00)            /*!< EXTI 14 configuration */
+#define AFIO_EXTICR4_EXTI15                  ((uint16_t)0xF000)            /*!< EXTI 15 configuration */
+
+/* EXTI12 configuration */
+#define AFIO_EXTICR4_EXTI12_PA               ((uint16_t)0x0000)            /*!< PA[12] pin */
+#define AFIO_EXTICR4_EXTI12_PB               ((uint16_t)0x0001)            /*!< PB[12] pin */
+#define AFIO_EXTICR4_EXTI12_PC               ((uint16_t)0x0002)            /*!< PC[12] pin */
+#define AFIO_EXTICR4_EXTI12_PD               ((uint16_t)0x0003)            /*!< PD[12] pin */
+#define AFIO_EXTICR4_EXTI12_PE               ((uint16_t)0x0004)            /*!< PE[12] pin */
+#define AFIO_EXTICR4_EXTI12_PF               ((uint16_t)0x0005)            /*!< PF[12] pin */
+#define AFIO_EXTICR4_EXTI12_PG               ((uint16_t)0x0006)            /*!< PG[12] pin */
+
+/* EXTI13 configuration */
+#define AFIO_EXTICR4_EXTI13_PA               ((uint16_t)0x0000)            /*!< PA[13] pin */
+#define AFIO_EXTICR4_EXTI13_PB               ((uint16_t)0x0010)            /*!< PB[13] pin */
+#define AFIO_EXTICR4_EXTI13_PC               ((uint16_t)0x0020)            /*!< PC[13] pin */
+#define AFIO_EXTICR4_EXTI13_PD               ((uint16_t)0x0030)            /*!< PD[13] pin */
+#define AFIO_EXTICR4_EXTI13_PE               ((uint16_t)0x0040)            /*!< PE[13] pin */
+#define AFIO_EXTICR4_EXTI13_PF               ((uint16_t)0x0050)            /*!< PF[13] pin */
+#define AFIO_EXTICR4_EXTI13_PG               ((uint16_t)0x0060)            /*!< PG[13] pin */
+
+/*!< EXTI14 configuration */
+#define AFIO_EXTICR4_EXTI14_PA               ((uint16_t)0x0000)            /*!< PA[14] pin */
+#define AFIO_EXTICR4_EXTI14_PB               ((uint16_t)0x0100)            /*!< PB[14] pin */
+#define AFIO_EXTICR4_EXTI14_PC               ((uint16_t)0x0200)            /*!< PC[14] pin */
+#define AFIO_EXTICR4_EXTI14_PD               ((uint16_t)0x0300)            /*!< PD[14] pin */
+#define AFIO_EXTICR4_EXTI14_PE               ((uint16_t)0x0400)            /*!< PE[14] pin */
+#define AFIO_EXTICR4_EXTI14_PF               ((uint16_t)0x0500)            /*!< PF[14] pin */
+#define AFIO_EXTICR4_EXTI14_PG               ((uint16_t)0x0600)            /*!< PG[14] pin */
+
+/*!< EXTI15 configuration */
+#define AFIO_EXTICR4_EXTI15_PA               ((uint16_t)0x0000)            /*!< PA[15] pin */
+#define AFIO_EXTICR4_EXTI15_PB               ((uint16_t)0x1000)            /*!< PB[15] pin */
+#define AFIO_EXTICR4_EXTI15_PC               ((uint16_t)0x2000)            /*!< PC[15] pin */
+#define AFIO_EXTICR4_EXTI15_PD               ((uint16_t)0x3000)            /*!< PD[15] pin */
+#define AFIO_EXTICR4_EXTI15_PE               ((uint16_t)0x4000)            /*!< PE[15] pin */
+#define AFIO_EXTICR4_EXTI15_PF               ((uint16_t)0x5000)            /*!< PF[15] pin */
+#define AFIO_EXTICR4_EXTI15_PG               ((uint16_t)0x6000)            /*!< PG[15] pin */
+
+#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
+/******************  Bit definition for AFIO_MAPR2 register  ******************/
+#define AFIO_MAPR2_TIM15_REMAP               ((uint32_t)0x00000001)        /*!< TIM15 remapping */
+#define AFIO_MAPR2_TIM16_REMAP               ((uint32_t)0x00000002)        /*!< TIM16 remapping */
+#define AFIO_MAPR2_TIM17_REMAP               ((uint32_t)0x00000004)        /*!< TIM17 remapping */
+#define AFIO_MAPR2_CEC_REMAP                 ((uint32_t)0x00000008)        /*!< CEC remapping */
+#define AFIO_MAPR2_TIM1_DMA_REMAP            ((uint32_t)0x00000010)        /*!< TIM1_DMA remapping */
+#endif
+
+#ifdef STM32F10X_HD_VL
+#define AFIO_MAPR2_TIM13_REMAP               ((uint32_t)0x00000100)        /*!< TIM13 remapping */
+#define AFIO_MAPR2_TIM14_REMAP               ((uint32_t)0x00000200)        /*!< TIM14 remapping */
+#define AFIO_MAPR2_FSMC_NADV_REMAP           ((uint32_t)0x00000400)        /*!< FSMC NADV remapping */
+#define AFIO_MAPR2_TIM67_DAC_DMA_REMAP       ((uint32_t)0x00000800)        /*!< TIM6/TIM7 and DAC DMA remapping */
+#define AFIO_MAPR2_TIM12_REMAP               ((uint32_t)0x00001000)        /*!< TIM12 remapping */
+#define AFIO_MAPR2_MISC_REMAP                ((uint32_t)0x00002000)        /*!< Miscellaneous remapping */
+#endif
+
+#ifdef STM32F10X_XL
+/******************  Bit definition for AFIO_MAPR2 register  ******************/
+#define AFIO_MAPR2_TIM9_REMAP                ((uint32_t)0x00000020)        /*!< TIM9 remapping */
+#define AFIO_MAPR2_TIM10_REMAP               ((uint32_t)0x00000040)        /*!< TIM10 remapping */
+#define AFIO_MAPR2_TIM11_REMAP               ((uint32_t)0x00000080)        /*!< TIM11 remapping */
+#define AFIO_MAPR2_TIM13_REMAP               ((uint32_t)0x00000100)        /*!< TIM13 remapping */
+#define AFIO_MAPR2_TIM14_REMAP               ((uint32_t)0x00000200)        /*!< TIM14 remapping */
+#define AFIO_MAPR2_FSMC_NADV_REMAP           ((uint32_t)0x00000400)        /*!< FSMC NADV remapping */
+#endif
+
+/******************************************************************************/
+/*                                                                            */
+/*                               SystemTick                                   */
+/*                                                                            */
+/******************************************************************************/
+
+/*****************  Bit definition for SysTick_CTRL register  *****************/
+#define  SysTick_CTRL_ENABLE                 ((uint32_t)0x00000001)        /*!< Counter enable */
+#define  SysTick_CTRL_TICKINT                ((uint32_t)0x00000002)        /*!< Counting down to 0 pends the SysTick handler */
+#define  SysTick_CTRL_CLKSOURCE              ((uint32_t)0x00000004)        /*!< Clock source */
+#define  SysTick_CTRL_COUNTFLAG              ((uint32_t)0x00010000)        /*!< Count Flag */
+
+/*****************  Bit definition for SysTick_LOAD register  *****************/
+#define  SysTick_LOAD_RELOAD                 ((uint32_t)0x00FFFFFF)        /*!< Value to load into the SysTick Current Value Register when the counter reaches 0 */
+
+/*****************  Bit definition for SysTick_VAL register  ******************/
+#define  SysTick_VAL_CURRENT                 ((uint32_t)0x00FFFFFF)        /*!< Current value at the time the register is accessed */
+
+/*****************  Bit definition for SysTick_CALIB register  ****************/
+#define  SysTick_CALIB_TENMS                 ((uint32_t)0x00FFFFFF)        /*!< Reload value to use for 10ms timing */
+#define  SysTick_CALIB_SKEW                  ((uint32_t)0x40000000)        /*!< Calibration value is not exactly 10 ms */
+#define  SysTick_CALIB_NOREF                 ((uint32_t)0x80000000)        /*!< The reference clock is not provided */
+
+/******************************************************************************/
+/*                                                                            */
+/*                  Nested Vectored Interrupt Controller                      */
+/*                                                                            */
+/******************************************************************************/
+
+/******************  Bit definition for NVIC_ISER register  *******************/
+#define  NVIC_ISER_SETENA                    ((uint32_t)0xFFFFFFFF)        /*!< Interrupt set enable bits */
+#define  NVIC_ISER_SETENA_0                  ((uint32_t)0x00000001)        /*!< bit 0 */
+#define  NVIC_ISER_SETENA_1                  ((uint32_t)0x00000002)        /*!< bit 1 */
+#define  NVIC_ISER_SETENA_2                  ((uint32_t)0x00000004)        /*!< bit 2 */
+#define  NVIC_ISER_SETENA_3                  ((uint32_t)0x00000008)        /*!< bit 3 */
+#define  NVIC_ISER_SETENA_4                  ((uint32_t)0x00000010)        /*!< bit 4 */
+#define  NVIC_ISER_SETENA_5                  ((uint32_t)0x00000020)        /*!< bit 5 */
+#define  NVIC_ISER_SETENA_6                  ((uint32_t)0x00000040)        /*!< bit 6 */
+#define  NVIC_ISER_SETENA_7                  ((uint32_t)0x00000080)        /*!< bit 7 */
+#define  NVIC_ISER_SETENA_8                  ((uint32_t)0x00000100)        /*!< bit 8 */
+#define  NVIC_ISER_SETENA_9                  ((uint32_t)0x00000200)        /*!< bit 9 */
+#define  NVIC_ISER_SETENA_10                 ((uint32_t)0x00000400)        /*!< bit 10 */
+#define  NVIC_ISER_SETENA_11                 ((uint32_t)0x00000800)        /*!< bit 11 */
+#define  NVIC_ISER_SETENA_12                 ((uint32_t)0x00001000)        /*!< bit 12 */
+#define  NVIC_ISER_SETENA_13                 ((uint32_t)0x00002000)        /*!< bit 13 */
+#define  NVIC_ISER_SETENA_14                 ((uint32_t)0x00004000)        /*!< bit 14 */
+#define  NVIC_ISER_SETENA_15                 ((uint32_t)0x00008000)        /*!< bit 15 */
+#define  NVIC_ISER_SETENA_16                 ((uint32_t)0x00010000)        /*!< bit 16 */
+#define  NVIC_ISER_SETENA_17                 ((uint32_t)0x00020000)        /*!< bit 17 */
+#define  NVIC_ISER_SETENA_18                 ((uint32_t)0x00040000)        /*!< bit 18 */
+#define  NVIC_ISER_SETENA_19                 ((uint32_t)0x00080000)        /*!< bit 19 */
+#define  NVIC_ISER_SETENA_20                 ((uint32_t)0x00100000)        /*!< bit 20 */
+#define  NVIC_ISER_SETENA_21                 ((uint32_t)0x00200000)        /*!< bit 21 */
+#define  NVIC_ISER_SETENA_22                 ((uint32_t)0x00400000)        /*!< bit 22 */
+#define  NVIC_ISER_SETENA_23                 ((uint32_t)0x00800000)        /*!< bit 23 */
+#define  NVIC_ISER_SETENA_24                 ((uint32_t)0x01000000)        /*!< bit 24 */
+#define  NVIC_ISER_SETENA_25                 ((uint32_t)0x02000000)        /*!< bit 25 */
+#define  NVIC_ISER_SETENA_26                 ((uint32_t)0x04000000)        /*!< bit 26 */
+#define  NVIC_ISER_SETENA_27                 ((uint32_t)0x08000000)        /*!< bit 27 */
+#define  NVIC_ISER_SETENA_28                 ((uint32_t)0x10000000)        /*!< bit 28 */
+#define  NVIC_ISER_SETENA_29                 ((uint32_t)0x20000000)        /*!< bit 29 */
+#define  NVIC_ISER_SETENA_30                 ((uint32_t)0x40000000)        /*!< bit 30 */
+#define  NVIC_ISER_SETENA_31                 ((uint32_t)0x80000000)        /*!< bit 31 */
+
+/******************  Bit definition for NVIC_ICER register  *******************/
+#define  NVIC_ICER_CLRENA                   ((uint32_t)0xFFFFFFFF)        /*!< Interrupt clear-enable bits */
+#define  NVIC_ICER_CLRENA_0                  ((uint32_t)0x00000001)        /*!< bit 0 */
+#define  NVIC_ICER_CLRENA_1                  ((uint32_t)0x00000002)        /*!< bit 1 */
+#define  NVIC_ICER_CLRENA_2                  ((uint32_t)0x00000004)        /*!< bit 2 */
+#define  NVIC_ICER_CLRENA_3                  ((uint32_t)0x00000008)        /*!< bit 3 */
+#define  NVIC_ICER_CLRENA_4                  ((uint32_t)0x00000010)        /*!< bit 4 */
+#define  NVIC_ICER_CLRENA_5                  ((uint32_t)0x00000020)        /*!< bit 5 */
+#define  NVIC_ICER_CLRENA_6                  ((uint32_t)0x00000040)        /*!< bit 6 */
+#define  NVIC_ICER_CLRENA_7                  ((uint32_t)0x00000080)        /*!< bit 7 */
+#define  NVIC_ICER_CLRENA_8                  ((uint32_t)0x00000100)        /*!< bit 8 */
+#define  NVIC_ICER_CLRENA_9                  ((uint32_t)0x00000200)        /*!< bit 9 */
+#define  NVIC_ICER_CLRENA_10                 ((uint32_t)0x00000400)        /*!< bit 10 */
+#define  NVIC_ICER_CLRENA_11                 ((uint32_t)0x00000800)        /*!< bit 11 */
+#define  NVIC_ICER_CLRENA_12                 ((uint32_t)0x00001000)        /*!< bit 12 */
+#define  NVIC_ICER_CLRENA_13                 ((uint32_t)0x00002000)        /*!< bit 13 */
+#define  NVIC_ICER_CLRENA_14                 ((uint32_t)0x00004000)        /*!< bit 14 */
+#define  NVIC_ICER_CLRENA_15                 ((uint32_t)0x00008000)        /*!< bit 15 */
+#define  NVIC_ICER_CLRENA_16                 ((uint32_t)0x00010000)        /*!< bit 16 */
+#define  NVIC_ICER_CLRENA_17                 ((uint32_t)0x00020000)        /*!< bit 17 */
+#define  NVIC_ICER_CLRENA_18                 ((uint32_t)0x00040000)        /*!< bit 18 */
+#define  NVIC_ICER_CLRENA_19                 ((uint32_t)0x00080000)        /*!< bit 19 */
+#define  NVIC_ICER_CLRENA_20                 ((uint32_t)0x00100000)        /*!< bit 20 */
+#define  NVIC_ICER_CLRENA_21                 ((uint32_t)0x00200000)        /*!< bit 21 */
+#define  NVIC_ICER_CLRENA_22                 ((uint32_t)0x00400000)        /*!< bit 22 */
+#define  NVIC_ICER_CLRENA_23                 ((uint32_t)0x00800000)        /*!< bit 23 */
+#define  NVIC_ICER_CLRENA_24                 ((uint32_t)0x01000000)        /*!< bit 24 */
+#define  NVIC_ICER_CLRENA_25                 ((uint32_t)0x02000000)        /*!< bit 25 */
+#define  NVIC_ICER_CLRENA_26                 ((uint32_t)0x04000000)        /*!< bit 26 */
+#define  NVIC_ICER_CLRENA_27                 ((uint32_t)0x08000000)        /*!< bit 27 */
+#define  NVIC_ICER_CLRENA_28                 ((uint32_t)0x10000000)        /*!< bit 28 */
+#define  NVIC_ICER_CLRENA_29                 ((uint32_t)0x20000000)        /*!< bit 29 */
+#define  NVIC_ICER_CLRENA_30                 ((uint32_t)0x40000000)        /*!< bit 30 */
+#define  NVIC_ICER_CLRENA_31                 ((uint32_t)0x80000000)        /*!< bit 31 */
+
+/******************  Bit definition for NVIC_ISPR register  *******************/
+#define  NVIC_ISPR_SETPEND                   ((uint32_t)0xFFFFFFFF)        /*!< Interrupt set-pending bits */
+#define  NVIC_ISPR_SETPEND_0                 ((uint32_t)0x00000001)        /*!< bit 0 */
+#define  NVIC_ISPR_SETPEND_1                 ((uint32_t)0x00000002)        /*!< bit 1 */
+#define  NVIC_ISPR_SETPEND_2                 ((uint32_t)0x00000004)        /*!< bit 2 */
+#define  NVIC_ISPR_SETPEND_3                 ((uint32_t)0x00000008)        /*!< bit 3 */
+#define  NVIC_ISPR_SETPEND_4                 ((uint32_t)0x00000010)        /*!< bit 4 */
+#define  NVIC_ISPR_SETPEND_5                 ((uint32_t)0x00000020)        /*!< bit 5 */
+#define  NVIC_ISPR_SETPEND_6                 ((uint32_t)0x00000040)        /*!< bit 6 */
+#define  NVIC_ISPR_SETPEND_7                 ((uint32_t)0x00000080)        /*!< bit 7 */
+#define  NVIC_ISPR_SETPEND_8                 ((uint32_t)0x00000100)        /*!< bit 8 */
+#define  NVIC_ISPR_SETPEND_9                 ((uint32_t)0x00000200)        /*!< bit 9 */
+#define  NVIC_ISPR_SETPEND_10                ((uint32_t)0x00000400)        /*!< bit 10 */
+#define  NVIC_ISPR_SETPEND_11                ((uint32_t)0x00000800)        /*!< bit 11 */
+#define  NVIC_ISPR_SETPEND_12                ((uint32_t)0x00001000)        /*!< bit 12 */
+#define  NVIC_ISPR_SETPEND_13                ((uint32_t)0x00002000)        /*!< bit 13 */
+#define  NVIC_ISPR_SETPEND_14                ((uint32_t)0x00004000)        /*!< bit 14 */
+#define  NVIC_ISPR_SETPEND_15                ((uint32_t)0x00008000)        /*!< bit 15 */
+#define  NVIC_ISPR_SETPEND_16                ((uint32_t)0x00010000)        /*!< bit 16 */
+#define  NVIC_ISPR_SETPEND_17                ((uint32_t)0x00020000)        /*!< bit 17 */
+#define  NVIC_ISPR_SETPEND_18                ((uint32_t)0x00040000)        /*!< bit 18 */
+#define  NVIC_ISPR_SETPEND_19                ((uint32_t)0x00080000)        /*!< bit 19 */
+#define  NVIC_ISPR_SETPEND_20                ((uint32_t)0x00100000)        /*!< bit 20 */
+#define  NVIC_ISPR_SETPEND_21                ((uint32_t)0x00200000)        /*!< bit 21 */
+#define  NVIC_ISPR_SETPEND_22                ((uint32_t)0x00400000)        /*!< bit 22 */
+#define  NVIC_ISPR_SETPEND_23                ((uint32_t)0x00800000)        /*!< bit 23 */
+#define  NVIC_ISPR_SETPEND_24                ((uint32_t)0x01000000)        /*!< bit 24 */
+#define  NVIC_ISPR_SETPEND_25                ((uint32_t)0x02000000)        /*!< bit 25 */
+#define  NVIC_ISPR_SETPEND_26                ((uint32_t)0x04000000)        /*!< bit 26 */
+#define  NVIC_ISPR_SETPEND_27                ((uint32_t)0x08000000)        /*!< bit 27 */
+#define  NVIC_ISPR_SETPEND_28                ((uint32_t)0x10000000)        /*!< bit 28 */
+#define  NVIC_ISPR_SETPEND_29                ((uint32_t)0x20000000)        /*!< bit 29 */
+#define  NVIC_ISPR_SETPEND_30                ((uint32_t)0x40000000)        /*!< bit 30 */
+#define  NVIC_ISPR_SETPEND_31                ((uint32_t)0x80000000)        /*!< bit 31 */
+
+/******************  Bit definition for NVIC_ICPR register  *******************/
+#define  NVIC_ICPR_CLRPEND                   ((uint32_t)0xFFFFFFFF)        /*!< Interrupt clear-pending bits */
+#define  NVIC_ICPR_CLRPEND_0                 ((uint32_t)0x00000001)        /*!< bit 0 */
+#define  NVIC_ICPR_CLRPEND_1                 ((uint32_t)0x00000002)        /*!< bit 1 */
+#define  NVIC_ICPR_CLRPEND_2                 ((uint32_t)0x00000004)        /*!< bit 2 */
+#define  NVIC_ICPR_CLRPEND_3                 ((uint32_t)0x00000008)        /*!< bit 3 */
+#define  NVIC_ICPR_CLRPEND_4                 ((uint32_t)0x00000010)        /*!< bit 4 */
+#define  NVIC_ICPR_CLRPEND_5                 ((uint32_t)0x00000020)        /*!< bit 5 */
+#define  NVIC_ICPR_CLRPEND_6                 ((uint32_t)0x00000040)        /*!< bit 6 */
+#define  NVIC_ICPR_CLRPEND_7                 ((uint32_t)0x00000080)        /*!< bit 7 */
+#define  NVIC_ICPR_CLRPEND_8                 ((uint32_t)0x00000100)        /*!< bit 8 */
+#define  NVIC_ICPR_CLRPEND_9                 ((uint32_t)0x00000200)        /*!< bit 9 */
+#define  NVIC_ICPR_CLRPEND_10                ((uint32_t)0x00000400)        /*!< bit 10 */
+#define  NVIC_ICPR_CLRPEND_11                ((uint32_t)0x00000800)        /*!< bit 11 */
+#define  NVIC_ICPR_CLRPEND_12                ((uint32_t)0x00001000)        /*!< bit 12 */
+#define  NVIC_ICPR_CLRPEND_13                ((uint32_t)0x00002000)        /*!< bit 13 */
+#define  NVIC_ICPR_CLRPEND_14                ((uint32_t)0x00004000)        /*!< bit 14 */
+#define  NVIC_ICPR_CLRPEND_15                ((uint32_t)0x00008000)        /*!< bit 15 */
+#define  NVIC_ICPR_CLRPEND_16                ((uint32_t)0x00010000)        /*!< bit 16 */
+#define  NVIC_ICPR_CLRPEND_17                ((uint32_t)0x00020000)        /*!< bit 17 */
+#define  NVIC_ICPR_CLRPEND_18                ((uint32_t)0x00040000)        /*!< bit 18 */
+#define  NVIC_ICPR_CLRPEND_19                ((uint32_t)0x00080000)        /*!< bit 19 */
+#define  NVIC_ICPR_CLRPEND_20                ((uint32_t)0x00100000)        /*!< bit 20 */
+#define  NVIC_ICPR_CLRPEND_21                ((uint32_t)0x00200000)        /*!< bit 21 */
+#define  NVIC_ICPR_CLRPEND_22                ((uint32_t)0x00400000)        /*!< bit 22 */
+#define  NVIC_ICPR_CLRPEND_23                ((uint32_t)0x00800000)        /*!< bit 23 */
+#define  NVIC_ICPR_CLRPEND_24                ((uint32_t)0x01000000)        /*!< bit 24 */
+#define  NVIC_ICPR_CLRPEND_25                ((uint32_t)0x02000000)        /*!< bit 25 */
+#define  NVIC_ICPR_CLRPEND_26                ((uint32_t)0x04000000)        /*!< bit 26 */
+#define  NVIC_ICPR_CLRPEND_27                ((uint32_t)0x08000000)        /*!< bit 27 */
+#define  NVIC_ICPR_CLRPEND_28                ((uint32_t)0x10000000)        /*!< bit 28 */
+#define  NVIC_ICPR_CLRPEND_29                ((uint32_t)0x20000000)        /*!< bit 29 */
+#define  NVIC_ICPR_CLRPEND_30                ((uint32_t)0x40000000)        /*!< bit 30 */
+#define  NVIC_ICPR_CLRPEND_31                ((uint32_t)0x80000000)        /*!< bit 31 */
+
+/******************  Bit definition for NVIC_IABR register  *******************/
+#define  NVIC_IABR_ACTIVE                    ((uint32_t)0xFFFFFFFF)        /*!< Interrupt active flags */
+#define  NVIC_IABR_ACTIVE_0                  ((uint32_t)0x00000001)        /*!< bit 0 */
+#define  NVIC_IABR_ACTIVE_1                  ((uint32_t)0x00000002)        /*!< bit 1 */
+#define  NVIC_IABR_ACTIVE_2                  ((uint32_t)0x00000004)        /*!< bit 2 */
+#define  NVIC_IABR_ACTIVE_3                  ((uint32_t)0x00000008)        /*!< bit 3 */
+#define  NVIC_IABR_ACTIVE_4                  ((uint32_t)0x00000010)        /*!< bit 4 */
+#define  NVIC_IABR_ACTIVE_5                  ((uint32_t)0x00000020)        /*!< bit 5 */
+#define  NVIC_IABR_ACTIVE_6                  ((uint32_t)0x00000040)        /*!< bit 6 */
+#define  NVIC_IABR_ACTIVE_7                  ((uint32_t)0x00000080)        /*!< bit 7 */
+#define  NVIC_IABR_ACTIVE_8                  ((uint32_t)0x00000100)        /*!< bit 8 */
+#define  NVIC_IABR_ACTIVE_9                  ((uint32_t)0x00000200)        /*!< bit 9 */
+#define  NVIC_IABR_ACTIVE_10                 ((uint32_t)0x00000400)        /*!< bit 10 */
+#define  NVIC_IABR_ACTIVE_11                 ((uint32_t)0x00000800)        /*!< bit 11 */
+#define  NVIC_IABR_ACTIVE_12                 ((uint32_t)0x00001000)        /*!< bit 12 */
+#define  NVIC_IABR_ACTIVE_13                 ((uint32_t)0x00002000)        /*!< bit 13 */
+#define  NVIC_IABR_ACTIVE_14                 ((uint32_t)0x00004000)        /*!< bit 14 */
+#define  NVIC_IABR_ACTIVE_15                 ((uint32_t)0x00008000)        /*!< bit 15 */
+#define  NVIC_IABR_ACTIVE_16                 ((uint32_t)0x00010000)        /*!< bit 16 */
+#define  NVIC_IABR_ACTIVE_17                 ((uint32_t)0x00020000)        /*!< bit 17 */
+#define  NVIC_IABR_ACTIVE_18                 ((uint32_t)0x00040000)        /*!< bit 18 */
+#define  NVIC_IABR_ACTIVE_19                 ((uint32_t)0x00080000)        /*!< bit 19 */
+#define  NVIC_IABR_ACTIVE_20                 ((uint32_t)0x00100000)        /*!< bit 20 */
+#define  NVIC_IABR_ACTIVE_21                 ((uint32_t)0x00200000)        /*!< bit 21 */
+#define  NVIC_IABR_ACTIVE_22                 ((uint32_t)0x00400000)        /*!< bit 22 */
+#define  NVIC_IABR_ACTIVE_23                 ((uint32_t)0x00800000)        /*!< bit 23 */
+#define  NVIC_IABR_ACTIVE_24                 ((uint32_t)0x01000000)        /*!< bit 24 */
+#define  NVIC_IABR_ACTIVE_25                 ((uint32_t)0x02000000)        /*!< bit 25 */
+#define  NVIC_IABR_ACTIVE_26                 ((uint32_t)0x04000000)        /*!< bit 26 */
+#define  NVIC_IABR_ACTIVE_27                 ((uint32_t)0x08000000)        /*!< bit 27 */
+#define  NVIC_IABR_ACTIVE_28                 ((uint32_t)0x10000000)        /*!< bit 28 */
+#define  NVIC_IABR_ACTIVE_29                 ((uint32_t)0x20000000)        /*!< bit 29 */
+#define  NVIC_IABR_ACTIVE_30                 ((uint32_t)0x40000000)        /*!< bit 30 */
+#define  NVIC_IABR_ACTIVE_31                 ((uint32_t)0x80000000)        /*!< bit 31 */
+
+/******************  Bit definition for NVIC_PRI0 register  *******************/
+#define  NVIC_IPR0_PRI_0                     ((uint32_t)0x000000FF)        /*!< Priority of interrupt 0 */
+#define  NVIC_IPR0_PRI_1                     ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 1 */
+#define  NVIC_IPR0_PRI_2                     ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 2 */
+#define  NVIC_IPR0_PRI_3                     ((uint32_t)0xFF000000)        /*!< Priority of interrupt 3 */
+
+/******************  Bit definition for NVIC_PRI1 register  *******************/
+#define  NVIC_IPR1_PRI_4                     ((uint32_t)0x000000FF)        /*!< Priority of interrupt 4 */
+#define  NVIC_IPR1_PRI_5                     ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 5 */
+#define  NVIC_IPR1_PRI_6                     ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 6 */
+#define  NVIC_IPR1_PRI_7                     ((uint32_t)0xFF000000)        /*!< Priority of interrupt 7 */
+
+/******************  Bit definition for NVIC_PRI2 register  *******************/
+#define  NVIC_IPR2_PRI_8                     ((uint32_t)0x000000FF)        /*!< Priority of interrupt 8 */
+#define  NVIC_IPR2_PRI_9                     ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 9 */
+#define  NVIC_IPR2_PRI_10                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 10 */
+#define  NVIC_IPR2_PRI_11                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 11 */
+
+/******************  Bit definition for NVIC_PRI3 register  *******************/
+#define  NVIC_IPR3_PRI_12                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 12 */
+#define  NVIC_IPR3_PRI_13                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 13 */
+#define  NVIC_IPR3_PRI_14                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 14 */
+#define  NVIC_IPR3_PRI_15                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 15 */
+
+/******************  Bit definition for NVIC_PRI4 register  *******************/
+#define  NVIC_IPR4_PRI_16                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 16 */
+#define  NVIC_IPR4_PRI_17                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 17 */
+#define  NVIC_IPR4_PRI_18                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 18 */
+#define  NVIC_IPR4_PRI_19                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 19 */
+
+/******************  Bit definition for NVIC_PRI5 register  *******************/
+#define  NVIC_IPR5_PRI_20                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 20 */
+#define  NVIC_IPR5_PRI_21                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 21 */
+#define  NVIC_IPR5_PRI_22                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 22 */
+#define  NVIC_IPR5_PRI_23                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 23 */
+
+/******************  Bit definition for NVIC_PRI6 register  *******************/
+#define  NVIC_IPR6_PRI_24                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 24 */
+#define  NVIC_IPR6_PRI_25                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 25 */
+#define  NVIC_IPR6_PRI_26                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 26 */
+#define  NVIC_IPR6_PRI_27                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 27 */
+
+/******************  Bit definition for NVIC_PRI7 register  *******************/
+#define  NVIC_IPR7_PRI_28                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 28 */
+#define  NVIC_IPR7_PRI_29                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 29 */
+#define  NVIC_IPR7_PRI_30                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 30 */
+#define  NVIC_IPR7_PRI_31                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 31 */
+
+/******************  Bit definition for SCB_CPUID register  *******************/
+#define  SCB_CPUID_REVISION                  ((uint32_t)0x0000000F)        /*!< Implementation defined revision number */
+#define  SCB_CPUID_PARTNO                    ((uint32_t)0x0000FFF0)        /*!< Number of processor within family */
+#define  SCB_CPUID_Constant                  ((uint32_t)0x000F0000)        /*!< Reads as 0x0F */
+#define  SCB_CPUID_VARIANT                   ((uint32_t)0x00F00000)        /*!< Implementation defined variant number */
+#define  SCB_CPUID_IMPLEMENTER               ((uint32_t)0xFF000000)        /*!< Implementer code. ARM is 0x41 */
+
+/*******************  Bit definition for SCB_ICSR register  *******************/
+#define  SCB_ICSR_VECTACTIVE                 ((uint32_t)0x000001FF)        /*!< Active ISR number field */
+#define  SCB_ICSR_RETTOBASE                  ((uint32_t)0x00000800)        /*!< All active exceptions minus the IPSR_current_exception yields the empty set */
+#define  SCB_ICSR_VECTPENDING                ((uint32_t)0x003FF000)        /*!< Pending ISR number field */
+#define  SCB_ICSR_ISRPENDING                 ((uint32_t)0x00400000)        /*!< Interrupt pending flag */
+#define  SCB_ICSR_ISRPREEMPT                 ((uint32_t)0x00800000)        /*!< It indicates that a pending interrupt becomes active in the next running cycle */
+#define  SCB_ICSR_PENDSTCLR                  ((uint32_t)0x02000000)        /*!< Clear pending SysTick bit */
+#define  SCB_ICSR_PENDSTSET                  ((uint32_t)0x04000000)        /*!< Set pending SysTick bit */
+#define  SCB_ICSR_PENDSVCLR                  ((uint32_t)0x08000000)        /*!< Clear pending pendSV bit */
+#define  SCB_ICSR_PENDSVSET                  ((uint32_t)0x10000000)        /*!< Set pending pendSV bit */
+#define  SCB_ICSR_NMIPENDSET                 ((uint32_t)0x80000000)        /*!< Set pending NMI bit */
+
+/*******************  Bit definition for SCB_VTOR register  *******************/
+#define  SCB_VTOR_TBLOFF                     ((uint32_t)0x1FFFFF80)        /*!< Vector table base offset field */
+#define  SCB_VTOR_TBLBASE                    ((uint32_t)0x20000000)        /*!< Table base in code(0) or RAM(1) */
+
+/*!<*****************  Bit definition for SCB_AIRCR register  *******************/
+#define  SCB_AIRCR_VECTRESET                 ((uint32_t)0x00000001)        /*!< System Reset bit */
+#define  SCB_AIRCR_VECTCLRACTIVE             ((uint32_t)0x00000002)        /*!< Clear active vector bit */
+#define  SCB_AIRCR_SYSRESETREQ               ((uint32_t)0x00000004)        /*!< Requests chip control logic to generate a reset */
+
+#define  SCB_AIRCR_PRIGROUP                  ((uint32_t)0x00000700)        /*!< PRIGROUP[2:0] bits (Priority group) */
+#define  SCB_AIRCR_PRIGROUP_0                ((uint32_t)0x00000100)        /*!< Bit 0 */
+#define  SCB_AIRCR_PRIGROUP_1                ((uint32_t)0x00000200)        /*!< Bit 1 */
+#define  SCB_AIRCR_PRIGROUP_2                ((uint32_t)0x00000400)        /*!< Bit 2  */
+
+/* prority group configuration */
+#define  SCB_AIRCR_PRIGROUP0                 ((uint32_t)0x00000000)        /*!< Priority group=0 (7 bits of pre-emption priority, 1 bit of subpriority) */
+#define  SCB_AIRCR_PRIGROUP1                 ((uint32_t)0x00000100)        /*!< Priority group=1 (6 bits of pre-emption priority, 2 bits of subpriority) */
+#define  SCB_AIRCR_PRIGROUP2                 ((uint32_t)0x00000200)        /*!< Priority group=2 (5 bits of pre-emption priority, 3 bits of subpriority) */
+#define  SCB_AIRCR_PRIGROUP3                 ((uint32_t)0x00000300)        /*!< Priority group=3 (4 bits of pre-emption priority, 4 bits of subpriority) */
+#define  SCB_AIRCR_PRIGROUP4                 ((uint32_t)0x00000400)        /*!< Priority group=4 (3 bits of pre-emption priority, 5 bits of subpriority) */
+#define  SCB_AIRCR_PRIGROUP5                 ((uint32_t)0x00000500)        /*!< Priority group=5 (2 bits of pre-emption priority, 6 bits of subpriority) */
+#define  SCB_AIRCR_PRIGROUP6                 ((uint32_t)0x00000600)        /*!< Priority group=6 (1 bit of pre-emption priority, 7 bits of subpriority) */
+#define  SCB_AIRCR_PRIGROUP7                 ((uint32_t)0x00000700)        /*!< Priority group=7 (no pre-emption priority, 8 bits of subpriority) */
+
+#define  SCB_AIRCR_ENDIANESS                 ((uint32_t)0x00008000)        /*!< Data endianness bit */
+#define  SCB_AIRCR_VECTKEY                   ((uint32_t)0xFFFF0000)        /*!< Register key (VECTKEY) - Reads as 0xFA05 (VECTKEYSTAT) */
+
+/*******************  Bit definition for SCB_SCR register  ********************/
+#define  SCB_SCR_SLEEPONEXIT                 ((uint8_t)0x02)               /*!< Sleep on exit bit */
+#define  SCB_SCR_SLEEPDEEP                   ((uint8_t)0x04)               /*!< Sleep deep bit */
+#define  SCB_SCR_SEVONPEND                   ((uint8_t)0x10)               /*!< Wake up from WFE */
+
+/********************  Bit definition for SCB_CCR register  *******************/
+#define  SCB_CCR_NONBASETHRDENA              ((uint16_t)0x0001)            /*!< Thread mode can be entered from any level in Handler mode by controlled return value */
+#define  SCB_CCR_USERSETMPEND                ((uint16_t)0x0002)            /*!< Enables user code to write the Software Trigger Interrupt register to trigger (pend) a Main exception */
+#define  SCB_CCR_UNALIGN_TRP                 ((uint16_t)0x0008)            /*!< Trap for unaligned access */
+#define  SCB_CCR_DIV_0_TRP                   ((uint16_t)0x0010)            /*!< Trap on Divide by 0 */
+#define  SCB_CCR_BFHFNMIGN                   ((uint16_t)0x0100)            /*!< Handlers running at priority -1 and -2 */
+#define  SCB_CCR_STKALIGN                    ((uint16_t)0x0200)            /*!< On exception entry, the SP used prior to the exception is adjusted to be 8-byte aligned */
+
+/*******************  Bit definition for SCB_SHPR register ********************/
+#define  SCB_SHPR_PRI_N                      ((uint32_t)0x000000FF)        /*!< Priority of system handler 4,8, and 12. Mem Manage, reserved and Debug Monitor */
+#define  SCB_SHPR_PRI_N1                     ((uint32_t)0x0000FF00)        /*!< Priority of system handler 5,9, and 13. Bus Fault, reserved and reserved */
+#define  SCB_SHPR_PRI_N2                     ((uint32_t)0x00FF0000)        /*!< Priority of system handler 6,10, and 14. Usage Fault, reserved and PendSV */
+#define  SCB_SHPR_PRI_N3                     ((uint32_t)0xFF000000)        /*!< Priority of system handler 7,11, and 15. Reserved, SVCall and SysTick */
+
+/******************  Bit definition for SCB_SHCSR register  *******************/
+#define  SCB_SHCSR_MEMFAULTACT               ((uint32_t)0x00000001)        /*!< MemManage is active */
+#define  SCB_SHCSR_BUSFAULTACT               ((uint32_t)0x00000002)        /*!< BusFault is active */
+#define  SCB_SHCSR_USGFAULTACT               ((uint32_t)0x00000008)        /*!< UsageFault is active */
+#define  SCB_SHCSR_SVCALLACT                 ((uint32_t)0x00000080)        /*!< SVCall is active */
+#define  SCB_SHCSR_MONITORACT                ((uint32_t)0x00000100)        /*!< Monitor is active */
+#define  SCB_SHCSR_PENDSVACT                 ((uint32_t)0x00000400)        /*!< PendSV is active */
+#define  SCB_SHCSR_SYSTICKACT                ((uint32_t)0x00000800)        /*!< SysTick is active */
+#define  SCB_SHCSR_USGFAULTPENDED            ((uint32_t)0x00001000)        /*!< Usage Fault is pended */
+#define  SCB_SHCSR_MEMFAULTPENDED            ((uint32_t)0x00002000)        /*!< MemManage is pended */
+#define  SCB_SHCSR_BUSFAULTPENDED            ((uint32_t)0x00004000)        /*!< Bus Fault is pended */
+#define  SCB_SHCSR_SVCALLPENDED              ((uint32_t)0x00008000)        /*!< SVCall is pended */
+#define  SCB_SHCSR_MEMFAULTENA               ((uint32_t)0x00010000)        /*!< MemManage enable */
+#define  SCB_SHCSR_BUSFAULTENA               ((uint32_t)0x00020000)        /*!< Bus Fault enable */
+#define  SCB_SHCSR_USGFAULTENA               ((uint32_t)0x00040000)        /*!< UsageFault enable */
+
+/*******************  Bit definition for SCB_CFSR register  *******************/
+/*!< MFSR */
+#define  SCB_CFSR_IACCVIOL                   ((uint32_t)0x00000001)        /*!< Instruction access violation */
+#define  SCB_CFSR_DACCVIOL                   ((uint32_t)0x00000002)        /*!< Data access violation */
+#define  SCB_CFSR_MUNSTKERR                  ((uint32_t)0x00000008)        /*!< Unstacking error */
+#define  SCB_CFSR_MSTKERR                    ((uint32_t)0x00000010)        /*!< Stacking error */
+#define  SCB_CFSR_MMARVALID                  ((uint32_t)0x00000080)        /*!< Memory Manage Address Register address valid flag */
+/*!< BFSR */
+#define  SCB_CFSR_IBUSERR                    ((uint32_t)0x00000100)        /*!< Instruction bus error flag */
+#define  SCB_CFSR_PRECISERR                  ((uint32_t)0x00000200)        /*!< Precise data bus error */
+#define  SCB_CFSR_IMPRECISERR                ((uint32_t)0x00000400)        /*!< Imprecise data bus error */
+#define  SCB_CFSR_UNSTKERR                   ((uint32_t)0x00000800)        /*!< Unstacking error */
+#define  SCB_CFSR_STKERR                     ((uint32_t)0x00001000)        /*!< Stacking error */
+#define  SCB_CFSR_BFARVALID                  ((uint32_t)0x00008000)        /*!< Bus Fault Address Register address valid flag */
+/*!< UFSR */
+#define  SCB_CFSR_UNDEFINSTR                 ((uint32_t)0x00010000)        /*!< The processor attempt to execute an undefined instruction */
+#define  SCB_CFSR_INVSTATE                   ((uint32_t)0x00020000)        /*!< Invalid combination of EPSR and instruction */
+#define  SCB_CFSR_INVPC                      ((uint32_t)0x00040000)        /*!< Attempt to load EXC_RETURN into pc illegally */
+#define  SCB_CFSR_NOCP                       ((uint32_t)0x00080000)        /*!< Attempt to use a coprocessor instruction */
+#define  SCB_CFSR_UNALIGNED                  ((uint32_t)0x01000000)        /*!< Fault occurs when there is an attempt to make an unaligned memory access */
+#define  SCB_CFSR_DIVBYZERO                  ((uint32_t)0x02000000)        /*!< Fault occurs when SDIV or DIV instruction is used with a divisor of 0 */
+
+/*******************  Bit definition for SCB_HFSR register  *******************/
+#define  SCB_HFSR_VECTTBL                    ((uint32_t)0x00000002)        /*!< Fault occurs because of vector table read on exception processing */
+#define  SCB_HFSR_FORCED                     ((uint32_t)0x40000000)        /*!< Hard Fault activated when a configurable Fault was received and cannot activate */
+#define  SCB_HFSR_DEBUGEVT                   ((uint32_t)0x80000000)        /*!< Fault related to debug */
+
+/*******************  Bit definition for SCB_DFSR register  *******************/
+#define  SCB_DFSR_HALTED                     ((uint8_t)0x01)               /*!< Halt request flag */
+#define  SCB_DFSR_BKPT                       ((uint8_t)0x02)               /*!< BKPT flag */
+#define  SCB_DFSR_DWTTRAP                    ((uint8_t)0x04)               /*!< Data Watchpoint and Trace (DWT) flag */
+#define  SCB_DFSR_VCATCH                     ((uint8_t)0x08)               /*!< Vector catch flag */
+#define  SCB_DFSR_EXTERNAL                   ((uint8_t)0x10)               /*!< External debug request flag */
+
+/*******************  Bit definition for SCB_MMFAR register  ******************/
+#define  SCB_MMFAR_ADDRESS                   ((uint32_t)0xFFFFFFFF)        /*!< Mem Manage fault address field */
+
+/*******************  Bit definition for SCB_BFAR register  *******************/
+#define  SCB_BFAR_ADDRESS                    ((uint32_t)0xFFFFFFFF)        /*!< Bus fault address field */
+
+/*******************  Bit definition for SCB_afsr register  *******************/
+#define  SCB_AFSR_IMPDEF                     ((uint32_t)0xFFFFFFFF)        /*!< Implementation defined */
+
+/******************************************************************************/
+/*                                                                            */
+/*                    External Interrupt/Event Controller                     */
+/*                                                                            */
+/******************************************************************************/
+
+/*******************  Bit definition for EXTI_IMR register  *******************/
+#define  EXTI_IMR_MR0                        ((uint32_t)0x00000001)        /*!< Interrupt Mask on line 0 */
+#define  EXTI_IMR_MR1                        ((uint32_t)0x00000002)        /*!< Interrupt Mask on line 1 */
+#define  EXTI_IMR_MR2                        ((uint32_t)0x00000004)        /*!< Interrupt Mask on line 2 */
+#define  EXTI_IMR_MR3                        ((uint32_t)0x00000008)        /*!< Interrupt Mask on line 3 */
+#define  EXTI_IMR_MR4                        ((uint32_t)0x00000010)        /*!< Interrupt Mask on line 4 */
+#define  EXTI_IMR_MR5                        ((uint32_t)0x00000020)        /*!< Interrupt Mask on line 5 */
+#define  EXTI_IMR_MR6                        ((uint32_t)0x00000040)        /*!< Interrupt Mask on line 6 */
+#define  EXTI_IMR_MR7                        ((uint32_t)0x00000080)        /*!< Interrupt Mask on line 7 */
+#define  EXTI_IMR_MR8                        ((uint32_t)0x00000100)        /*!< Interrupt Mask on line 8 */
+#define  EXTI_IMR_MR9                        ((uint32_t)0x00000200)        /*!< Interrupt Mask on line 9 */
+#define  EXTI_IMR_MR10                       ((uint32_t)0x00000400)        /*!< Interrupt Mask on line 10 */
+#define  EXTI_IMR_MR11                       ((uint32_t)0x00000800)        /*!< Interrupt Mask on line 11 */
+#define  EXTI_IMR_MR12                       ((uint32_t)0x00001000)        /*!< Interrupt Mask on line 12 */
+#define  EXTI_IMR_MR13                       ((uint32_t)0x00002000)        /*!< Interrupt Mask on line 13 */
+#define  EXTI_IMR_MR14                       ((uint32_t)0x00004000)        /*!< Interrupt Mask on line 14 */
+#define  EXTI_IMR_MR15                       ((uint32_t)0x00008000)        /*!< Interrupt Mask on line 15 */
+#define  EXTI_IMR_MR16                       ((uint32_t)0x00010000)        /*!< Interrupt Mask on line 16 */
+#define  EXTI_IMR_MR17                       ((uint32_t)0x00020000)        /*!< Interrupt Mask on line 17 */
+#define  EXTI_IMR_MR18                       ((uint32_t)0x00040000)        /*!< Interrupt Mask on line 18 */
+#define  EXTI_IMR_MR19                       ((uint32_t)0x00080000)        /*!< Interrupt Mask on line 19 */
+
+/*******************  Bit definition for EXTI_EMR register  *******************/
+#define  EXTI_EMR_MR0                        ((uint32_t)0x00000001)        /*!< Event Mask on line 0 */
+#define  EXTI_EMR_MR1                        ((uint32_t)0x00000002)        /*!< Event Mask on line 1 */
+#define  EXTI_EMR_MR2                        ((uint32_t)0x00000004)        /*!< Event Mask on line 2 */
+#define  EXTI_EMR_MR3                        ((uint32_t)0x00000008)        /*!< Event Mask on line 3 */
+#define  EXTI_EMR_MR4                        ((uint32_t)0x00000010)        /*!< Event Mask on line 4 */
+#define  EXTI_EMR_MR5                        ((uint32_t)0x00000020)        /*!< Event Mask on line 5 */
+#define  EXTI_EMR_MR6                        ((uint32_t)0x00000040)        /*!< Event Mask on line 6 */
+#define  EXTI_EMR_MR7                        ((uint32_t)0x00000080)        /*!< Event Mask on line 7 */
+#define  EXTI_EMR_MR8                        ((uint32_t)0x00000100)        /*!< Event Mask on line 8 */
+#define  EXTI_EMR_MR9                        ((uint32_t)0x00000200)        /*!< Event Mask on line 9 */
+#define  EXTI_EMR_MR10                       ((uint32_t)0x00000400)        /*!< Event Mask on line 10 */
+#define  EXTI_EMR_MR11                       ((uint32_t)0x00000800)        /*!< Event Mask on line 11 */
+#define  EXTI_EMR_MR12                       ((uint32_t)0x00001000)        /*!< Event Mask on line 12 */
+#define  EXTI_EMR_MR13                       ((uint32_t)0x00002000)        /*!< Event Mask on line 13 */
+#define  EXTI_EMR_MR14                       ((uint32_t)0x00004000)        /*!< Event Mask on line 14 */
+#define  EXTI_EMR_MR15                       ((uint32_t)0x00008000)        /*!< Event Mask on line 15 */
+#define  EXTI_EMR_MR16                       ((uint32_t)0x00010000)        /*!< Event Mask on line 16 */
+#define  EXTI_EMR_MR17                       ((uint32_t)0x00020000)        /*!< Event Mask on line 17 */
+#define  EXTI_EMR_MR18                       ((uint32_t)0x00040000)        /*!< Event Mask on line 18 */
+#define  EXTI_EMR_MR19                       ((uint32_t)0x00080000)        /*!< Event Mask on line 19 */
+
+/******************  Bit definition for EXTI_RTSR register  *******************/
+#define  EXTI_RTSR_TR0                       ((uint32_t)0x00000001)        /*!< Rising trigger event configuration bit of line 0 */
+#define  EXTI_RTSR_TR1                       ((uint32_t)0x00000002)        /*!< Rising trigger event configuration bit of line 1 */
+#define  EXTI_RTSR_TR2                       ((uint32_t)0x00000004)        /*!< Rising trigger event configuration bit of line 2 */
+#define  EXTI_RTSR_TR3                       ((uint32_t)0x00000008)        /*!< Rising trigger event configuration bit of line 3 */
+#define  EXTI_RTSR_TR4                       ((uint32_t)0x00000010)        /*!< Rising trigger event configuration bit of line 4 */
+#define  EXTI_RTSR_TR5                       ((uint32_t)0x00000020)        /*!< Rising trigger event configuration bit of line 5 */
+#define  EXTI_RTSR_TR6                       ((uint32_t)0x00000040)        /*!< Rising trigger event configuration bit of line 6 */
+#define  EXTI_RTSR_TR7                       ((uint32_t)0x00000080)        /*!< Rising trigger event configuration bit of line 7 */
+#define  EXTI_RTSR_TR8                       ((uint32_t)0x00000100)        /*!< Rising trigger event configuration bit of line 8 */
+#define  EXTI_RTSR_TR9                       ((uint32_t)0x00000200)        /*!< Rising trigger event configuration bit of line 9 */
+#define  EXTI_RTSR_TR10                      ((uint32_t)0x00000400)        /*!< Rising trigger event configuration bit of line 10 */
+#define  EXTI_RTSR_TR11                      ((uint32_t)0x00000800)        /*!< Rising trigger event configuration bit of line 11 */
+#define  EXTI_RTSR_TR12                      ((uint32_t)0x00001000)        /*!< Rising trigger event configuration bit of line 12 */
+#define  EXTI_RTSR_TR13                      ((uint32_t)0x00002000)        /*!< Rising trigger event configuration bit of line 13 */
+#define  EXTI_RTSR_TR14                      ((uint32_t)0x00004000)        /*!< Rising trigger event configuration bit of line 14 */
+#define  EXTI_RTSR_TR15                      ((uint32_t)0x00008000)        /*!< Rising trigger event configuration bit of line 15 */
+#define  EXTI_RTSR_TR16                      ((uint32_t)0x00010000)        /*!< Rising trigger event configuration bit of line 16 */
+#define  EXTI_RTSR_TR17                      ((uint32_t)0x00020000)        /*!< Rising trigger event configuration bit of line 17 */
+#define  EXTI_RTSR_TR18                      ((uint32_t)0x00040000)        /*!< Rising trigger event configuration bit of line 18 */
+#define  EXTI_RTSR_TR19                      ((uint32_t)0x00080000)        /*!< Rising trigger event configuration bit of line 19 */
+
+/******************  Bit definition for EXTI_FTSR register  *******************/
+#define  EXTI_FTSR_TR0                       ((uint32_t)0x00000001)        /*!< Falling trigger event configuration bit of line 0 */
+#define  EXTI_FTSR_TR1                       ((uint32_t)0x00000002)        /*!< Falling trigger event configuration bit of line 1 */
+#define  EXTI_FTSR_TR2                       ((uint32_t)0x00000004)        /*!< Falling trigger event configuration bit of line 2 */
+#define  EXTI_FTSR_TR3                       ((uint32_t)0x00000008)        /*!< Falling trigger event configuration bit of line 3 */
+#define  EXTI_FTSR_TR4                       ((uint32_t)0x00000010)        /*!< Falling trigger event configuration bit of line 4 */
+#define  EXTI_FTSR_TR5                       ((uint32_t)0x00000020)        /*!< Falling trigger event configuration bit of line 5 */
+#define  EXTI_FTSR_TR6                       ((uint32_t)0x00000040)        /*!< Falling trigger event configuration bit of line 6 */
+#define  EXTI_FTSR_TR7                       ((uint32_t)0x00000080)        /*!< Falling trigger event configuration bit of line 7 */
+#define  EXTI_FTSR_TR8                       ((uint32_t)0x00000100)        /*!< Falling trigger event configuration bit of line 8 */
+#define  EXTI_FTSR_TR9                       ((uint32_t)0x00000200)        /*!< Falling trigger event configuration bit of line 9 */
+#define  EXTI_FTSR_TR10                      ((uint32_t)0x00000400)        /*!< Falling trigger event configuration bit of line 10 */
+#define  EXTI_FTSR_TR11                      ((uint32_t)0x00000800)        /*!< Falling trigger event configuration bit of line 11 */
+#define  EXTI_FTSR_TR12                      ((uint32_t)0x00001000)        /*!< Falling trigger event configuration bit of line 12 */
+#define  EXTI_FTSR_TR13                      ((uint32_t)0x00002000)        /*!< Falling trigger event configuration bit of line 13 */
+#define  EXTI_FTSR_TR14                      ((uint32_t)0x00004000)        /*!< Falling trigger event configuration bit of line 14 */
+#define  EXTI_FTSR_TR15                      ((uint32_t)0x00008000)        /*!< Falling trigger event configuration bit of line 15 */
+#define  EXTI_FTSR_TR16                      ((uint32_t)0x00010000)        /*!< Falling trigger event configuration bit of line 16 */
+#define  EXTI_FTSR_TR17                      ((uint32_t)0x00020000)        /*!< Falling trigger event configuration bit of line 17 */
+#define  EXTI_FTSR_TR18                      ((uint32_t)0x00040000)        /*!< Falling trigger event configuration bit of line 18 */
+#define  EXTI_FTSR_TR19                      ((uint32_t)0x00080000)        /*!< Falling trigger event configuration bit of line 19 */
+
+/******************  Bit definition for EXTI_SWIER register  ******************/
+#define  EXTI_SWIER_SWIER0                   ((uint32_t)0x00000001)        /*!< Software Interrupt on line 0 */
+#define  EXTI_SWIER_SWIER1                   ((uint32_t)0x00000002)        /*!< Software Interrupt on line 1 */
+#define  EXTI_SWIER_SWIER2                   ((uint32_t)0x00000004)        /*!< Software Interrupt on line 2 */
+#define  EXTI_SWIER_SWIER3                   ((uint32_t)0x00000008)        /*!< Software Interrupt on line 3 */
+#define  EXTI_SWIER_SWIER4                   ((uint32_t)0x00000010)        /*!< Software Interrupt on line 4 */
+#define  EXTI_SWIER_SWIER5                   ((uint32_t)0x00000020)        /*!< Software Interrupt on line 5 */
+#define  EXTI_SWIER_SWIER6                   ((uint32_t)0x00000040)        /*!< Software Interrupt on line 6 */
+#define  EXTI_SWIER_SWIER7                   ((uint32_t)0x00000080)        /*!< Software Interrupt on line 7 */
+#define  EXTI_SWIER_SWIER8                   ((uint32_t)0x00000100)        /*!< Software Interrupt on line 8 */
+#define  EXTI_SWIER_SWIER9                   ((uint32_t)0x00000200)        /*!< Software Interrupt on line 9 */
+#define  EXTI_SWIER_SWIER10                  ((uint32_t)0x00000400)        /*!< Software Interrupt on line 10 */
+#define  EXTI_SWIER_SWIER11                  ((uint32_t)0x00000800)        /*!< Software Interrupt on line 11 */
+#define  EXTI_SWIER_SWIER12                  ((uint32_t)0x00001000)        /*!< Software Interrupt on line 12 */
+#define  EXTI_SWIER_SWIER13                  ((uint32_t)0x00002000)        /*!< Software Interrupt on line 13 */
+#define  EXTI_SWIER_SWIER14                  ((uint32_t)0x00004000)        /*!< Software Interrupt on line 14 */
+#define  EXTI_SWIER_SWIER15                  ((uint32_t)0x00008000)        /*!< Software Interrupt on line 15 */
+#define  EXTI_SWIER_SWIER16                  ((uint32_t)0x00010000)        /*!< Software Interrupt on line 16 */
+#define  EXTI_SWIER_SWIER17                  ((uint32_t)0x00020000)        /*!< Software Interrupt on line 17 */
+#define  EXTI_SWIER_SWIER18                  ((uint32_t)0x00040000)        /*!< Software Interrupt on line 18 */
+#define  EXTI_SWIER_SWIER19                  ((uint32_t)0x00080000)        /*!< Software Interrupt on line 19 */
+
+/*******************  Bit definition for EXTI_PR register  ********************/
+#define  EXTI_PR_PR0                         ((uint32_t)0x00000001)        /*!< Pending bit for line 0 */
+#define  EXTI_PR_PR1                         ((uint32_t)0x00000002)        /*!< Pending bit for line 1 */
+#define  EXTI_PR_PR2                         ((uint32_t)0x00000004)        /*!< Pending bit for line 2 */
+#define  EXTI_PR_PR3                         ((uint32_t)0x00000008)        /*!< Pending bit for line 3 */
+#define  EXTI_PR_PR4                         ((uint32_t)0x00000010)        /*!< Pending bit for line 4 */
+#define  EXTI_PR_PR5                         ((uint32_t)0x00000020)        /*!< Pending bit for line 5 */
+#define  EXTI_PR_PR6                         ((uint32_t)0x00000040)        /*!< Pending bit for line 6 */
+#define  EXTI_PR_PR7                         ((uint32_t)0x00000080)        /*!< Pending bit for line 7 */
+#define  EXTI_PR_PR8                         ((uint32_t)0x00000100)        /*!< Pending bit for line 8 */
+#define  EXTI_PR_PR9                         ((uint32_t)0x00000200)        /*!< Pending bit for line 9 */
+#define  EXTI_PR_PR10                        ((uint32_t)0x00000400)        /*!< Pending bit for line 10 */
+#define  EXTI_PR_PR11                        ((uint32_t)0x00000800)        /*!< Pending bit for line 11 */
+#define  EXTI_PR_PR12                        ((uint32_t)0x00001000)        /*!< Pending bit for line 12 */
+#define  EXTI_PR_PR13                        ((uint32_t)0x00002000)        /*!< Pending bit for line 13 */
+#define  EXTI_PR_PR14                        ((uint32_t)0x00004000)        /*!< Pending bit for line 14 */
+#define  EXTI_PR_PR15                        ((uint32_t)0x00008000)        /*!< Pending bit for line 15 */
+#define  EXTI_PR_PR16                        ((uint32_t)0x00010000)        /*!< Pending bit for line 16 */
+#define  EXTI_PR_PR17                        ((uint32_t)0x00020000)        /*!< Pending bit for line 17 */
+#define  EXTI_PR_PR18                        ((uint32_t)0x00040000)        /*!< Pending bit for line 18 */
+#define  EXTI_PR_PR19                        ((uint32_t)0x00080000)        /*!< Pending bit for line 19 */
+
+/******************************************************************************/
+/*                                                                            */
+/*                             DMA Controller                                 */
+/*                                                                            */
+/******************************************************************************/
+
+/*******************  Bit definition for DMA_ISR register  ********************/
+#define  DMA_ISR_GIF1                        ((uint32_t)0x00000001)        /*!< Channel 1 Global interrupt flag */
+#define  DMA_ISR_TCIF1                       ((uint32_t)0x00000002)        /*!< Channel 1 Transfer Complete flag */
+#define  DMA_ISR_HTIF1                       ((uint32_t)0x00000004)        /*!< Channel 1 Half Transfer flag */
+#define  DMA_ISR_TEIF1                       ((uint32_t)0x00000008)        /*!< Channel 1 Transfer Error flag */
+#define  DMA_ISR_GIF2                        ((uint32_t)0x00000010)        /*!< Channel 2 Global interrupt flag */
+#define  DMA_ISR_TCIF2                       ((uint32_t)0x00000020)        /*!< Channel 2 Transfer Complete flag */
+#define  DMA_ISR_HTIF2                       ((uint32_t)0x00000040)        /*!< Channel 2 Half Transfer flag */
+#define  DMA_ISR_TEIF2                       ((uint32_t)0x00000080)        /*!< Channel 2 Transfer Error flag */
+#define  DMA_ISR_GIF3                        ((uint32_t)0x00000100)        /*!< Channel 3 Global interrupt flag */
+#define  DMA_ISR_TCIF3                       ((uint32_t)0x00000200)        /*!< Channel 3 Transfer Complete flag */
+#define  DMA_ISR_HTIF3                       ((uint32_t)0x00000400)        /*!< Channel 3 Half Transfer flag */
+#define  DMA_ISR_TEIF3                       ((uint32_t)0x00000800)        /*!< Channel 3 Transfer Error flag */
+#define  DMA_ISR_GIF4                        ((uint32_t)0x00001000)        /*!< Channel 4 Global interrupt flag */
+#define  DMA_ISR_TCIF4                       ((uint32_t)0x00002000)        /*!< Channel 4 Transfer Complete flag */
+#define  DMA_ISR_HTIF4                       ((uint32_t)0x00004000)        /*!< Channel 4 Half Transfer flag */
+#define  DMA_ISR_TEIF4                       ((uint32_t)0x00008000)        /*!< Channel 4 Transfer Error flag */
+#define  DMA_ISR_GIF5                        ((uint32_t)0x00010000)        /*!< Channel 5 Global interrupt flag */
+#define  DMA_ISR_TCIF5                       ((uint32_t)0x00020000)        /*!< Channel 5 Transfer Complete flag */
+#define  DMA_ISR_HTIF5                       ((uint32_t)0x00040000)        /*!< Channel 5 Half Transfer flag */
+#define  DMA_ISR_TEIF5                       ((uint32_t)0x00080000)        /*!< Channel 5 Transfer Error flag */
+#define  DMA_ISR_GIF6                        ((uint32_t)0x00100000)        /*!< Channel 6 Global interrupt flag */
+#define  DMA_ISR_TCIF6                       ((uint32_t)0x00200000)        /*!< Channel 6 Transfer Complete flag */
+#define  DMA_ISR_HTIF6                       ((uint32_t)0x00400000)        /*!< Channel 6 Half Transfer flag */
+#define  DMA_ISR_TEIF6                       ((uint32_t)0x00800000)        /*!< Channel 6 Transfer Error flag */
+#define  DMA_ISR_GIF7                        ((uint32_t)0x01000000)        /*!< Channel 7 Global interrupt flag */
+#define  DMA_ISR_TCIF7                       ((uint32_t)0x02000000)        /*!< Channel 7 Transfer Complete flag */
+#define  DMA_ISR_HTIF7                       ((uint32_t)0x04000000)        /*!< Channel 7 Half Transfer flag */
+#define  DMA_ISR_TEIF7                       ((uint32_t)0x08000000)        /*!< Channel 7 Transfer Error flag */
+
+/*******************  Bit definition for DMA_IFCR register  *******************/
+#define  DMA_IFCR_CGIF1                      ((uint32_t)0x00000001)        /*!< Channel 1 Global interrupt clear */
+#define  DMA_IFCR_CTCIF1                     ((uint32_t)0x00000002)        /*!< Channel 1 Transfer Complete clear */
+#define  DMA_IFCR_CHTIF1                     ((uint32_t)0x00000004)        /*!< Channel 1 Half Transfer clear */
+#define  DMA_IFCR_CTEIF1                     ((uint32_t)0x00000008)        /*!< Channel 1 Transfer Error clear */
+#define  DMA_IFCR_CGIF2                      ((uint32_t)0x00000010)        /*!< Channel 2 Global interrupt clear */
+#define  DMA_IFCR_CTCIF2                     ((uint32_t)0x00000020)        /*!< Channel 2 Transfer Complete clear */
+#define  DMA_IFCR_CHTIF2                     ((uint32_t)0x00000040)        /*!< Channel 2 Half Transfer clear */
+#define  DMA_IFCR_CTEIF2                     ((uint32_t)0x00000080)        /*!< Channel 2 Transfer Error clear */
+#define  DMA_IFCR_CGIF3                      ((uint32_t)0x00000100)        /*!< Channel 3 Global interrupt clear */
+#define  DMA_IFCR_CTCIF3                     ((uint32_t)0x00000200)        /*!< Channel 3 Transfer Complete clear */
+#define  DMA_IFCR_CHTIF3                     ((uint32_t)0x00000400)        /*!< Channel 3 Half Transfer clear */
+#define  DMA_IFCR_CTEIF3                     ((uint32_t)0x00000800)        /*!< Channel 3 Transfer Error clear */
+#define  DMA_IFCR_CGIF4                      ((uint32_t)0x00001000)        /*!< Channel 4 Global interrupt clear */
+#define  DMA_IFCR_CTCIF4                     ((uint32_t)0x00002000)        /*!< Channel 4 Transfer Complete clear */
+#define  DMA_IFCR_CHTIF4                     ((uint32_t)0x00004000)        /*!< Channel 4 Half Transfer clear */
+#define  DMA_IFCR_CTEIF4                     ((uint32_t)0x00008000)        /*!< Channel 4 Transfer Error clear */
+#define  DMA_IFCR_CGIF5                      ((uint32_t)0x00010000)        /*!< Channel 5 Global interrupt clear */
+#define  DMA_IFCR_CTCIF5                     ((uint32_t)0x00020000)        /*!< Channel 5 Transfer Complete clear */
+#define  DMA_IFCR_CHTIF5                     ((uint32_t)0x00040000)        /*!< Channel 5 Half Transfer clear */
+#define  DMA_IFCR_CTEIF5                     ((uint32_t)0x00080000)        /*!< Channel 5 Transfer Error clear */
+#define  DMA_IFCR_CGIF6                      ((uint32_t)0x00100000)        /*!< Channel 6 Global interrupt clear */
+#define  DMA_IFCR_CTCIF6                     ((uint32_t)0x00200000)        /*!< Channel 6 Transfer Complete clear */
+#define  DMA_IFCR_CHTIF6                     ((uint32_t)0x00400000)        /*!< Channel 6 Half Transfer clear */
+#define  DMA_IFCR_CTEIF6                     ((uint32_t)0x00800000)        /*!< Channel 6 Transfer Error clear */
+#define  DMA_IFCR_CGIF7                      ((uint32_t)0x01000000)        /*!< Channel 7 Global interrupt clear */
+#define  DMA_IFCR_CTCIF7                     ((uint32_t)0x02000000)        /*!< Channel 7 Transfer Complete clear */
+#define  DMA_IFCR_CHTIF7                     ((uint32_t)0x04000000)        /*!< Channel 7 Half Transfer clear */
+#define  DMA_IFCR_CTEIF7                     ((uint32_t)0x08000000)        /*!< Channel 7 Transfer Error clear */
+
+/*******************  Bit definition for DMA_CCR1 register  *******************/
+#define  DMA_CCR1_EN                         ((uint16_t)0x0001)            /*!< Channel enable*/
+#define  DMA_CCR1_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
+#define  DMA_CCR1_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
+#define  DMA_CCR1_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
+#define  DMA_CCR1_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
+#define  DMA_CCR1_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
+#define  DMA_CCR1_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
+#define  DMA_CCR1_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
+
+#define  DMA_CCR1_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
+#define  DMA_CCR1_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
+#define  DMA_CCR1_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
+
+#define  DMA_CCR1_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
+#define  DMA_CCR1_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
+#define  DMA_CCR1_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
+
+#define  DMA_CCR1_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits(Channel Priority level) */
+#define  DMA_CCR1_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
+#define  DMA_CCR1_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
+
+#define  DMA_CCR1_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */
+
+/*******************  Bit definition for DMA_CCR2 register  *******************/
+#define  DMA_CCR2_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
+#define  DMA_CCR2_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
+#define  DMA_CCR2_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
+#define  DMA_CCR2_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
+#define  DMA_CCR2_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
+#define  DMA_CCR2_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
+#define  DMA_CCR2_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
+#define  DMA_CCR2_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
+
+#define  DMA_CCR2_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
+#define  DMA_CCR2_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
+#define  DMA_CCR2_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
+
+#define  DMA_CCR2_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
+#define  DMA_CCR2_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
+#define  DMA_CCR2_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
+
+#define  DMA_CCR2_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
+#define  DMA_CCR2_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
+#define  DMA_CCR2_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
+
+#define  DMA_CCR2_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */
+
+/*******************  Bit definition for DMA_CCR3 register  *******************/
+#define  DMA_CCR3_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
+#define  DMA_CCR3_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
+#define  DMA_CCR3_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
+#define  DMA_CCR3_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
+#define  DMA_CCR3_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
+#define  DMA_CCR3_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
+#define  DMA_CCR3_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
+#define  DMA_CCR3_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
+
+#define  DMA_CCR3_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
+#define  DMA_CCR3_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
+#define  DMA_CCR3_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
+
+#define  DMA_CCR3_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
+#define  DMA_CCR3_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
+#define  DMA_CCR3_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
+
+#define  DMA_CCR3_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
+#define  DMA_CCR3_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
+#define  DMA_CCR3_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
+
+#define  DMA_CCR3_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */
+
+/*!<******************  Bit definition for DMA_CCR4 register  *******************/
+#define  DMA_CCR4_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
+#define  DMA_CCR4_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
+#define  DMA_CCR4_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
+#define  DMA_CCR4_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
+#define  DMA_CCR4_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
+#define  DMA_CCR4_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
+#define  DMA_CCR4_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
+#define  DMA_CCR4_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
+
+#define  DMA_CCR4_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
+#define  DMA_CCR4_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
+#define  DMA_CCR4_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
+
+#define  DMA_CCR4_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
+#define  DMA_CCR4_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
+#define  DMA_CCR4_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
+
+#define  DMA_CCR4_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
+#define  DMA_CCR4_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
+#define  DMA_CCR4_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
+
+#define  DMA_CCR4_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */
+
+/******************  Bit definition for DMA_CCR5 register  *******************/
+#define  DMA_CCR5_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
+#define  DMA_CCR5_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
+#define  DMA_CCR5_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
+#define  DMA_CCR5_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
+#define  DMA_CCR5_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
+#define  DMA_CCR5_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
+#define  DMA_CCR5_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
+#define  DMA_CCR5_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
+
+#define  DMA_CCR5_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
+#define  DMA_CCR5_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
+#define  DMA_CCR5_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
+
+#define  DMA_CCR5_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
+#define  DMA_CCR5_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
+#define  DMA_CCR5_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
+
+#define  DMA_CCR5_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
+#define  DMA_CCR5_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
+#define  DMA_CCR5_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
+
+#define  DMA_CCR5_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode enable */
+
+/*******************  Bit definition for DMA_CCR6 register  *******************/
+#define  DMA_CCR6_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
+#define  DMA_CCR6_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
+#define  DMA_CCR6_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
+#define  DMA_CCR6_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
+#define  DMA_CCR6_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
+#define  DMA_CCR6_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
+#define  DMA_CCR6_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
+#define  DMA_CCR6_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
+
+#define  DMA_CCR6_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
+#define  DMA_CCR6_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
+#define  DMA_CCR6_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
+
+#define  DMA_CCR6_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
+#define  DMA_CCR6_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
+#define  DMA_CCR6_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
+
+#define  DMA_CCR6_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
+#define  DMA_CCR6_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
+#define  DMA_CCR6_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
+
+#define  DMA_CCR6_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */
+
+/*******************  Bit definition for DMA_CCR7 register  *******************/
+#define  DMA_CCR7_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
+#define  DMA_CCR7_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
+#define  DMA_CCR7_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
+#define  DMA_CCR7_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
+#define  DMA_CCR7_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
+#define  DMA_CCR7_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
+#define  DMA_CCR7_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
+#define  DMA_CCR7_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
+
+#define  DMA_CCR7_PSIZE            ,         ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
+#define  DMA_CCR7_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
+#define  DMA_CCR7_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
+
+#define  DMA_CCR7_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
+#define  DMA_CCR7_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
+#define  DMA_CCR7_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
+
+#define  DMA_CCR7_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
+#define  DMA_CCR7_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
+#define  DMA_CCR7_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
+
+#define  DMA_CCR7_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode enable */
+
+/******************  Bit definition for DMA_CNDTR1 register  ******************/
+#define  DMA_CNDTR1_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
+
+/******************  Bit definition for DMA_CNDTR2 register  ******************/
+#define  DMA_CNDTR2_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
+
+/******************  Bit definition for DMA_CNDTR3 register  ******************/
+#define  DMA_CNDTR3_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
+
+/******************  Bit definition for DMA_CNDTR4 register  ******************/
+#define  DMA_CNDTR4_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
+
+/******************  Bit definition for DMA_CNDTR5 register  ******************/
+#define  DMA_CNDTR5_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
+
+/******************  Bit definition for DMA_CNDTR6 register  ******************/
+#define  DMA_CNDTR6_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
+
+/******************  Bit definition for DMA_CNDTR7 register  ******************/
+#define  DMA_CNDTR7_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
+
+/******************  Bit definition for DMA_CPAR1 register  *******************/
+#define  DMA_CPAR1_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
+
+/******************  Bit definition for DMA_CPAR2 register  *******************/
+#define  DMA_CPAR2_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
+
+/******************  Bit definition for DMA_CPAR3 register  *******************/
+#define  DMA_CPAR3_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
+
+
+/******************  Bit definition for DMA_CPAR4 register  *******************/
+#define  DMA_CPAR4_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
+
+/******************  Bit definition for DMA_CPAR5 register  *******************/
+#define  DMA_CPAR5_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
+
+/******************  Bit definition for DMA_CPAR6 register  *******************/
+#define  DMA_CPAR6_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
+
+
+/******************  Bit definition for DMA_CPAR7 register  *******************/
+#define  DMA_CPAR7_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
+
+/******************  Bit definition for DMA_CMAR1 register  *******************/
+#define  DMA_CMAR1_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
+
+/******************  Bit definition for DMA_CMAR2 register  *******************/
+#define  DMA_CMAR2_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
+
+/******************  Bit definition for DMA_CMAR3 register  *******************/
+#define  DMA_CMAR3_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
+
+
+/******************  Bit definition for DMA_CMAR4 register  *******************/
+#define  DMA_CMAR4_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
+
+/******************  Bit definition for DMA_CMAR5 register  *******************/
+#define  DMA_CMAR5_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
+
+/******************  Bit definition for DMA_CMAR6 register  *******************/
+#define  DMA_CMAR6_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
+
+/******************  Bit definition for DMA_CMAR7 register  *******************/
+#define  DMA_CMAR7_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
+
+/******************************************************************************/
+/*                                                                            */
+/*                        Analog to Digital Converter                         */
+/*                                                                            */
+/******************************************************************************/
+
+/********************  Bit definition for ADC_SR register  ********************/
+#define  ADC_SR_AWD                          ((uint8_t)0x01)               /*!< Analog watchdog flag */
+#define  ADC_SR_EOC                          ((uint8_t)0x02)               /*!< End of conversion */
+#define  ADC_SR_JEOC                         ((uint8_t)0x04)               /*!< Injected channel end of conversion */
+#define  ADC_SR_JSTRT                        ((uint8_t)0x08)               /*!< Injected channel Start flag */
+#define  ADC_SR_STRT                         ((uint8_t)0x10)               /*!< Regular channel Start flag */
+
+/*******************  Bit definition for ADC_CR1 register  ********************/
+#define  ADC_CR1_AWDCH                       ((uint32_t)0x0000001F)        /*!< AWDCH[4:0] bits (Analog watchdog channel select bits) */
+#define  ADC_CR1_AWDCH_0                     ((uint32_t)0x00000001)        /*!< Bit 0 */
+#define  ADC_CR1_AWDCH_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */
+#define  ADC_CR1_AWDCH_2                     ((uint32_t)0x00000004)        /*!< Bit 2 */
+#define  ADC_CR1_AWDCH_3                     ((uint32_t)0x00000008)        /*!< Bit 3 */
+#define  ADC_CR1_AWDCH_4                     ((uint32_t)0x00000010)        /*!< Bit 4 */
+
+#define  ADC_CR1_EOCIE                       ((uint32_t)0x00000020)        /*!< Interrupt enable for EOC */
+#define  ADC_CR1_AWDIE                       ((uint32_t)0x00000040)        /*!< Analog Watchdog interrupt enable */
+#define  ADC_CR1_JEOCIE                      ((uint32_t)0x00000080)        /*!< Interrupt enable for injected channels */
+#define  ADC_CR1_SCAN                        ((uint32_t)0x00000100)        /*!< Scan mode */
+#define  ADC_CR1_AWDSGL                      ((uint32_t)0x00000200)        /*!< Enable the watchdog on a single channel in scan mode */
+#define  ADC_CR1_JAUTO                       ((uint32_t)0x00000400)        /*!< Automatic injected group conversion */
+#define  ADC_CR1_DISCEN                      ((uint32_t)0x00000800)        /*!< Discontinuous mode on regular channels */
+#define  ADC_CR1_JDISCEN                     ((uint32_t)0x00001000)        /*!< Discontinuous mode on injected channels */
+
+#define  ADC_CR1_DISCNUM                     ((uint32_t)0x0000E000)        /*!< DISCNUM[2:0] bits (Discontinuous mode channel count) */
+#define  ADC_CR1_DISCNUM_0                   ((uint32_t)0x00002000)        /*!< Bit 0 */
+#define  ADC_CR1_DISCNUM_1                   ((uint32_t)0x00004000)        /*!< Bit 1 */
+#define  ADC_CR1_DISCNUM_2                   ((uint32_t)0x00008000)        /*!< Bit 2 */
+
+#define  ADC_CR1_DUALMOD                     ((uint32_t)0x000F0000)        /*!< DUALMOD[3:0] bits (Dual mode selection) */
+#define  ADC_CR1_DUALMOD_0                   ((uint32_t)0x00010000)        /*!< Bit 0 */
+#define  ADC_CR1_DUALMOD_1                   ((uint32_t)0x00020000)        /*!< Bit 1 */
+#define  ADC_CR1_DUALMOD_2                   ((uint32_t)0x00040000)        /*!< Bit 2 */
+#define  ADC_CR1_DUALMOD_3                   ((uint32_t)0x00080000)        /*!< Bit 3 */
+
+#define  ADC_CR1_JAWDEN                      ((uint32_t)0x00400000)        /*!< Analog watchdog enable on injected channels */
+#define  ADC_CR1_AWDEN                       ((uint32_t)0x00800000)        /*!< Analog watchdog enable on regular channels */
+
+
+/*******************  Bit definition for ADC_CR2 register  ********************/
+#define  ADC_CR2_ADON                        ((uint32_t)0x00000001)        /*!< A/D Converter ON / OFF */
+#define  ADC_CR2_CONT                        ((uint32_t)0x00000002)        /*!< Continuous Conversion */
+#define  ADC_CR2_CAL                         ((uint32_t)0x00000004)        /*!< A/D Calibration */
+#define  ADC_CR2_RSTCAL                      ((uint32_t)0x00000008)        /*!< Reset Calibration */
+#define  ADC_CR2_DMA                         ((uint32_t)0x00000100)        /*!< Direct Memory access mode */
+#define  ADC_CR2_ALIGN                       ((uint32_t)0x00000800)        /*!< Data Alignment */
+
+#define  ADC_CR2_JEXTSEL                     ((uint32_t)0x00007000)        /*!< JEXTSEL[2:0] bits (External event select for injected group) */
+#define  ADC_CR2_JEXTSEL_0                   ((uint32_t)0x00001000)        /*!< Bit 0 */
+#define  ADC_CR2_JEXTSEL_1                   ((uint32_t)0x00002000)        /*!< Bit 1 */
+#define  ADC_CR2_JEXTSEL_2                   ((uint32_t)0x00004000)        /*!< Bit 2 */
+
+#define  ADC_CR2_JEXTTRIG                    ((uint32_t)0x00008000)        /*!< External Trigger Conversion mode for injected channels */
+
+#define  ADC_CR2_EXTSEL                      ((uint32_t)0x000E0000)        /*!< EXTSEL[2:0] bits (External Event Select for regular group) */
+#define  ADC_CR2_EXTSEL_0                    ((uint32_t)0x00020000)        /*!< Bit 0 */
+#define  ADC_CR2_EXTSEL_1                    ((uint32_t)0x00040000)        /*!< Bit 1 */
+#define  ADC_CR2_EXTSEL_2                    ((uint32_t)0x00080000)        /*!< Bit 2 */
+
+#define  ADC_CR2_EXTTRIG                     ((uint32_t)0x00100000)        /*!< External Trigger Conversion mode for regular channels */
+#define  ADC_CR2_JSWSTART                    ((uint32_t)0x00200000)        /*!< Start Conversion of injected channels */
+#define  ADC_CR2_SWSTART                     ((uint32_t)0x00400000)        /*!< Start Conversion of regular channels */
+#define  ADC_CR2_TSVREFE                     ((uint32_t)0x00800000)        /*!< Temperature Sensor and VREFINT Enable */
+
+/******************  Bit definition for ADC_SMPR1 register  *******************/
+#define  ADC_SMPR1_SMP10                     ((uint32_t)0x00000007)        /*!< SMP10[2:0] bits (Channel 10 Sample time selection) */
+#define  ADC_SMPR1_SMP10_0                   ((uint32_t)0x00000001)        /*!< Bit 0 */
+#define  ADC_SMPR1_SMP10_1                   ((uint32_t)0x00000002)        /*!< Bit 1 */
+#define  ADC_SMPR1_SMP10_2                   ((uint32_t)0x00000004)        /*!< Bit 2 */
+
+#define  ADC_SMPR1_SMP11                     ((uint32_t)0x00000038)        /*!< SMP11[2:0] bits (Channel 11 Sample time selection) */
+#define  ADC_SMPR1_SMP11_0                   ((uint32_t)0x00000008)        /*!< Bit 0 */
+#define  ADC_SMPR1_SMP11_1                   ((uint32_t)0x00000010)        /*!< Bit 1 */
+#define  ADC_SMPR1_SMP11_2                   ((uint32_t)0x00000020)        /*!< Bit 2 */
+
+#define  ADC_SMPR1_SMP12                     ((uint32_t)0x000001C0)        /*!< SMP12[2:0] bits (Channel 12 Sample time selection) */
+#define  ADC_SMPR1_SMP12_0                   ((uint32_t)0x00000040)        /*!< Bit 0 */
+#define  ADC_SMPR1_SMP12_1                   ((uint32_t)0x00000080)        /*!< Bit 1 */
+#define  ADC_SMPR1_SMP12_2                   ((uint32_t)0x00000100)        /*!< Bit 2 */
+
+#define  ADC_SMPR1_SMP13                     ((uint32_t)0x00000E00)        /*!< SMP13[2:0] bits (Channel 13 Sample time selection) */
+#define  ADC_SMPR1_SMP13_0                   ((uint32_t)0x00000200)        /*!< Bit 0 */
+#define  ADC_SMPR1_SMP13_1                   ((uint32_t)0x00000400)        /*!< Bit 1 */
+#define  ADC_SMPR1_SMP13_2                   ((uint32_t)0x00000800)        /*!< Bit 2 */
+
+#define  ADC_SMPR1_SMP14                     ((uint32_t)0x00007000)        /*!< SMP14[2:0] bits (Channel 14 Sample time selection) */
+#define  ADC_SMPR1_SMP14_0                   ((uint32_t)0x00001000)        /*!< Bit 0 */
+#define  ADC_SMPR1_SMP14_1                   ((uint32_t)0x00002000)        /*!< Bit 1 */
+#define  ADC_SMPR1_SMP14_2                   ((uint32_t)0x00004000)        /*!< Bit 2 */
+
+#define  ADC_SMPR1_SMP15                     ((uint32_t)0x00038000)        /*!< SMP15[2:0] bits (Channel 15 Sample time selection) */
+#define  ADC_SMPR1_SMP15_0                   ((uint32_t)0x00008000)        /*!< Bit 0 */
+#define  ADC_SMPR1_SMP15_1                   ((uint32_t)0x00010000)        /*!< Bit 1 */
+#define  ADC_SMPR1_SMP15_2                   ((uint32_t)0x00020000)        /*!< Bit 2 */
+
+#define  ADC_SMPR1_SMP16                     ((uint32_t)0x001C0000)        /*!< SMP16[2:0] bits (Channel 16 Sample time selection) */
+#define  ADC_SMPR1_SMP16_0                   ((uint32_t)0x00040000)        /*!< Bit 0 */
+#define  ADC_SMPR1_SMP16_1                   ((uint32_t)0x00080000)        /*!< Bit 1 */
+#define  ADC_SMPR1_SMP16_2                   ((uint32_t)0x00100000)        /*!< Bit 2 */
+
+#define  ADC_SMPR1_SMP17                     ((uint32_t)0x00E00000)        /*!< SMP17[2:0] bits (Channel 17 Sample time selection) */
+#define  ADC_SMPR1_SMP17_0                   ((uint32_t)0x00200000)        /*!< Bit 0 */
+#define  ADC_SMPR1_SMP17_1                   ((uint32_t)0x00400000)        /*!< Bit 1 */
+#define  ADC_SMPR1_SMP17_2                   ((uint32_t)0x00800000)        /*!< Bit 2 */
+
+/******************  Bit definition for ADC_SMPR2 register  *******************/
+#define  ADC_SMPR2_SMP0                      ((uint32_t)0x00000007)        /*!< SMP0[2:0] bits (Channel 0 Sample time selection) */
+#define  ADC_SMPR2_SMP0_0                    ((uint32_t)0x00000001)        /*!< Bit 0 */
+#define  ADC_SMPR2_SMP0_1                    ((uint32_t)0x00000002)        /*!< Bit 1 */
+#define  ADC_SMPR2_SMP0_2                    ((uint32_t)0x00000004)        /*!< Bit 2 */
+
+#define  ADC_SMPR2_SMP1                      ((uint32_t)0x00000038)        /*!< SMP1[2:0] bits (Channel 1 Sample time selection) */
+#define  ADC_SMPR2_SMP1_0                    ((uint32_t)0x00000008)        /*!< Bit 0 */
+#define  ADC_SMPR2_SMP1_1                    ((uint32_t)0x00000010)        /*!< Bit 1 */
+#define  ADC_SMPR2_SMP1_2                    ((uint32_t)0x00000020)        /*!< Bit 2 */
+
+#define  ADC_SMPR2_SMP2                      ((uint32_t)0x000001C0)        /*!< SMP2[2:0] bits (Channel 2 Sample time selection) */
+#define  ADC_SMPR2_SMP2_0                    ((uint32_t)0x00000040)        /*!< Bit 0 */
+#define  ADC_SMPR2_SMP2_1                    ((uint32_t)0x00000080)        /*!< Bit 1 */
+#define  ADC_SMPR2_SMP2_2                    ((uint32_t)0x00000100)        /*!< Bit 2 */
+
+#define  ADC_SMPR2_SMP3                      ((uint32_t)0x00000E00)        /*!< SMP3[2:0] bits (Channel 3 Sample time selection) */
+#define  ADC_SMPR2_SMP3_0                    ((uint32_t)0x00000200)        /*!< Bit 0 */
+#define  ADC_SMPR2_SMP3_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */
+#define  ADC_SMPR2_SMP3_2                    ((uint32_t)0x00000800)        /*!< Bit 2 */
+
+#define  ADC_SMPR2_SMP4                      ((uint32_t)0x00007000)        /*!< SMP4[2:0] bits (Channel 4 Sample time selection) */
+#define  ADC_SMPR2_SMP4_0                    ((uint32_t)0x00001000)        /*!< Bit 0 */
+#define  ADC_SMPR2_SMP4_1                    ((uint32_t)0x00002000)        /*!< Bit 1 */
+#define  ADC_SMPR2_SMP4_2                    ((uint32_t)0x00004000)        /*!< Bit 2 */
+
+#define  ADC_SMPR2_SMP5                      ((uint32_t)0x00038000)        /*!< SMP5[2:0] bits (Channel 5 Sample time selection) */
+#define  ADC_SMPR2_SMP5_0                    ((uint32_t)0x00008000)        /*!< Bit 0 */
+#define  ADC_SMPR2_SMP5_1                    ((uint32_t)0x00010000)        /*!< Bit 1 */
+#define  ADC_SMPR2_SMP5_2                    ((uint32_t)0x00020000)        /*!< Bit 2 */
+
+#define  ADC_SMPR2_SMP6                      ((uint32_t)0x001C0000)        /*!< SMP6[2:0] bits (Channel 6 Sample time selection) */
+#define  ADC_SMPR2_SMP6_0                    ((uint32_t)0x00040000)        /*!< Bit 0 */
+#define  ADC_SMPR2_SMP6_1                    ((uint32_t)0x00080000)        /*!< Bit 1 */
+#define  ADC_SMPR2_SMP6_2                    ((uint32_t)0x00100000)        /*!< Bit 2 */
+
+#define  ADC_SMPR2_SMP7                      ((uint32_t)0x00E00000)        /*!< SMP7[2:0] bits (Channel 7 Sample time selection) */
+#define  ADC_SMPR2_SMP7_0                    ((uint32_t)0x00200000)        /*!< Bit 0 */
+#define  ADC_SMPR2_SMP7_1                    ((uint32_t)0x00400000)        /*!< Bit 1 */
+#define  ADC_SMPR2_SMP7_2                    ((uint32_t)0x00800000)        /*!< Bit 2 */
+
+#define  ADC_SMPR2_SMP8                      ((uint32_t)0x07000000)        /*!< SMP8[2:0] bits (Channel 8 Sample time selection) */
+#define  ADC_SMPR2_SMP8_0                    ((uint32_t)0x01000000)        /*!< Bit 0 */
+#define  ADC_SMPR2_SMP8_1                    ((uint32_t)0x02000000)        /*!< Bit 1 */
+#define  ADC_SMPR2_SMP8_2                    ((uint32_t)0x04000000)        /*!< Bit 2 */
+
+#define  ADC_SMPR2_SMP9                      ((uint32_t)0x38000000)        /*!< SMP9[2:0] bits (Channel 9 Sample time selection) */
+#define  ADC_SMPR2_SMP9_0                    ((uint32_t)0x08000000)        /*!< Bit 0 */
+#define  ADC_SMPR2_SMP9_1                    ((uint32_t)0x10000000)        /*!< Bit 1 */
+#define  ADC_SMPR2_SMP9_2                    ((uint32_t)0x20000000)        /*!< Bit 2 */
+
+/******************  Bit definition for ADC_JOFR1 register  *******************/
+#define  ADC_JOFR1_JOFFSET1                  ((uint16_t)0x0FFF)            /*!< Data offset for injected channel 1 */
+
+/******************  Bit definition for ADC_JOFR2 register  *******************/
+#define  ADC_JOFR2_JOFFSET2                  ((uint16_t)0x0FFF)            /*!< Data offset for injected channel 2 */
+
+/******************  Bit definition for ADC_JOFR3 register  *******************/
+#define  ADC_JOFR3_JOFFSET3                  ((uint16_t)0x0FFF)            /*!< Data offset for injected channel 3 */
+
+/******************  Bit definition for ADC_JOFR4 register  *******************/
+#define  ADC_JOFR4_JOFFSET4                  ((uint16_t)0x0FFF)            /*!< Data offset for injected channel 4 */
+
+/*******************  Bit definition for ADC_HTR register  ********************/
+#define  ADC_HTR_HT                          ((uint16_t)0x0FFF)            /*!< Analog watchdog high threshold */
+
+/*******************  Bit definition for ADC_LTR register  ********************/
+#define  ADC_LTR_LT                          ((uint16_t)0x0FFF)            /*!< Analog watchdog low threshold */
+
+/*******************  Bit definition for ADC_SQR1 register  *******************/
+#define  ADC_SQR1_SQ13                       ((uint32_t)0x0000001F)        /*!< SQ13[4:0] bits (13th conversion in regular sequence) */
+#define  ADC_SQR1_SQ13_0                     ((uint32_t)0x00000001)        /*!< Bit 0 */
+#define  ADC_SQR1_SQ13_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */
+#define  ADC_SQR1_SQ13_2                     ((uint32_t)0x00000004)        /*!< Bit 2 */
+#define  ADC_SQR1_SQ13_3                     ((uint32_t)0x00000008)        /*!< Bit 3 */
+#define  ADC_SQR1_SQ13_4                     ((uint32_t)0x00000010)        /*!< Bit 4 */
+
+#define  ADC_SQR1_SQ14                       ((uint32_t)0x000003E0)        /*!< SQ14[4:0] bits (14th conversion in regular sequence) */
+#define  ADC_SQR1_SQ14_0                     ((uint32_t)0x00000020)        /*!< Bit 0 */
+#define  ADC_SQR1_SQ14_1                     ((uint32_t)0x00000040)        /*!< Bit 1 */
+#define  ADC_SQR1_SQ14_2                     ((uint32_t)0x00000080)        /*!< Bit 2 */
+#define  ADC_SQR1_SQ14_3                     ((uint32_t)0x00000100)        /*!< Bit 3 */
+#define  ADC_SQR1_SQ14_4                     ((uint32_t)0x00000200)        /*!< Bit 4 */
+
+#define  ADC_SQR1_SQ15                       ((uint32_t)0x00007C00)        /*!< SQ15[4:0] bits (15th conversion in regular sequence) */
+#define  ADC_SQR1_SQ15_0                     ((uint32_t)0x00000400)        /*!< Bit 0 */
+#define  ADC_SQR1_SQ15_1                     ((uint32_t)0x00000800)        /*!< Bit 1 */
+#define  ADC_SQR1_SQ15_2                     ((uint32_t)0x00001000)        /*!< Bit 2 */
+#define  ADC_SQR1_SQ15_3                     ((uint32_t)0x00002000)        /*!< Bit 3 */
+#define  ADC_SQR1_SQ15_4                     ((uint32_t)0x00004000)        /*!< Bit 4 */
+
+#define  ADC_SQR1_SQ16                       ((uint32_t)0x000F8000)        /*!< SQ16[4:0] bits (16th conversion in regular sequence) */
+#define  ADC_SQR1_SQ16_0                     ((uint32_t)0x00008000)        /*!< Bit 0 */
+#define  ADC_SQR1_SQ16_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */
+#define  ADC_SQR1_SQ16_2                     ((uint32_t)0x00020000)        /*!< Bit 2 */
+#define  ADC_SQR1_SQ16_3                     ((uint32_t)0x00040000)        /*!< Bit 3 */
+#define  ADC_SQR1_SQ16_4                     ((uint32_t)0x00080000)        /*!< Bit 4 */
+
+#define  ADC_SQR1_L                          ((uint32_t)0x00F00000)        /*!< L[3:0] bits (Regular channel sequence length) */
+#define  ADC_SQR1_L_0                        ((uint32_t)0x00100000)        /*!< Bit 0 */
+#define  ADC_SQR1_L_1                        ((uint32_t)0x00200000)        /*!< Bit 1 */
+#define  ADC_SQR1_L_2                        ((uint32_t)0x00400000)        /*!< Bit 2 */
+#define  ADC_SQR1_L_3                        ((uint32_t)0x00800000)        /*!< Bit 3 */
+
+/*******************  Bit definition for ADC_SQR2 register  *******************/
+#define  ADC_SQR2_SQ7                        ((uint32_t)0x0000001F)        /*!< SQ7[4:0] bits (7th conversion in regular sequence) */
+#define  ADC_SQR2_SQ7_0                      ((uint32_t)0x00000001)        /*!< Bit 0 */
+#define  ADC_SQR2_SQ7_1                      ((uint32_t)0x00000002)        /*!< Bit 1 */
+#define  ADC_SQR2_SQ7_2                      ((uint32_t)0x00000004)        /*!< Bit 2 */
+#define  ADC_SQR2_SQ7_3                      ((uint32_t)0x00000008)        /*!< Bit 3 */
+#define  ADC_SQR2_SQ7_4                      ((uint32_t)0x00000010)        /*!< Bit 4 */
+
+#define  ADC_SQR2_SQ8                        ((uint32_t)0x000003E0)        /*!< SQ8[4:0] bits (8th conversion in regular sequence) */
+#define  ADC_SQR2_SQ8_0                      ((uint32_t)0x00000020)        /*!< Bit 0 */
+#define  ADC_SQR2_SQ8_1                      ((uint32_t)0x00000040)        /*!< Bit 1 */
+#define  ADC_SQR2_SQ8_2                      ((uint32_t)0x00000080)        /*!< Bit 2 */
+#define  ADC_SQR2_SQ8_3                      ((uint32_t)0x00000100)        /*!< Bit 3 */
+#define  ADC_SQR2_SQ8_4                      ((uint32_t)0x00000200)        /*!< Bit 4 */
+
+#define  ADC_SQR2_SQ9                        ((uint32_t)0x00007C00)        /*!< SQ9[4:0] bits (9th conversion in regular sequence) */
+#define  ADC_SQR2_SQ9_0                      ((uint32_t)0x00000400)        /*!< Bit 0 */
+#define  ADC_SQR2_SQ9_1                      ((uint32_t)0x00000800)        /*!< Bit 1 */
+#define  ADC_SQR2_SQ9_2                      ((uint32_t)0x00001000)        /*!< Bit 2 */
+#define  ADC_SQR2_SQ9_3                      ((uint32_t)0x00002000)        /*!< Bit 3 */
+#define  ADC_SQR2_SQ9_4                      ((uint32_t)0x00004000)        /*!< Bit 4 */
+
+#define  ADC_SQR2_SQ10                       ((uint32_t)0x000F8000)        /*!< SQ10[4:0] bits (10th conversion in regular sequence) */
+#define  ADC_SQR2_SQ10_0                     ((uint32_t)0x00008000)        /*!< Bit 0 */
+#define  ADC_SQR2_SQ10_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */
+#define  ADC_SQR2_SQ10_2                     ((uint32_t)0x00020000)        /*!< Bit 2 */
+#define  ADC_SQR2_SQ10_3                     ((uint32_t)0x00040000)        /*!< Bit 3 */
+#define  ADC_SQR2_SQ10_4                     ((uint32_t)0x00080000)        /*!< Bit 4 */
+
+#define  ADC_SQR2_SQ11                       ((uint32_t)0x01F00000)        /*!< SQ11[4:0] bits (11th conversion in regular sequence) */
+#define  ADC_SQR2_SQ11_0                     ((uint32_t)0x00100000)        /*!< Bit 0 */
+#define  ADC_SQR2_SQ11_1                     ((uint32_t)0x00200000)        /*!< Bit 1 */
+#define  ADC_SQR2_SQ11_2                     ((uint32_t)0x00400000)        /*!< Bit 2 */
+#define  ADC_SQR2_SQ11_3                     ((uint32_t)0x00800000)        /*!< Bit 3 */
+#define  ADC_SQR2_SQ11_4                     ((uint32_t)0x01000000)        /*!< Bit 4 */
+
+#define  ADC_SQR2_SQ12                       ((uint32_t)0x3E000000)        /*!< SQ12[4:0] bits (12th conversion in regular sequence) */
+#define  ADC_SQR2_SQ12_0                     ((uint32_t)0x02000000)        /*!< Bit 0 */
+#define  ADC_SQR2_SQ12_1                     ((uint32_t)0x04000000)        /*!< Bit 1 */
+#define  ADC_SQR2_SQ12_2                     ((uint32_t)0x08000000)        /*!< Bit 2 */
+#define  ADC_SQR2_SQ12_3                     ((uint32_t)0x10000000)        /*!< Bit 3 */
+#define  ADC_SQR2_SQ12_4                     ((uint32_t)0x20000000)        /*!< Bit 4 */
+
+/*******************  Bit definition for ADC_SQR3 register  *******************/
+#define  ADC_SQR3_SQ1                        ((uint32_t)0x0000001F)        /*!< SQ1[4:0] bits (1st conversion in regular sequence) */
+#define  ADC_SQR3_SQ1_0                      ((uint32_t)0x00000001)        /*!< Bit 0 */
+#define  ADC_SQR3_SQ1_1                      ((uint32_t)0x00000002)        /*!< Bit 1 */
+#define  ADC_SQR3_SQ1_2                      ((uint32_t)0x00000004)        /*!< Bit 2 */
+#define  ADC_SQR3_SQ1_3                      ((uint32_t)0x00000008)        /*!< Bit 3 */
+#define  ADC_SQR3_SQ1_4                      ((uint32_t)0x00000010)        /*!< Bit 4 */
+
+#define  ADC_SQR3_SQ2                        ((uint32_t)0x000003E0)        /*!< SQ2[4:0] bits (2nd conversion in regular sequence) */
+#define  ADC_SQR3_SQ2_0                      ((uint32_t)0x00000020)        /*!< Bit 0 */
+#define  ADC_SQR3_SQ2_1                      ((uint32_t)0x00000040)        /*!< Bit 1 */
+#define  ADC_SQR3_SQ2_2                      ((uint32_t)0x00000080)        /*!< Bit 2 */
+#define  ADC_SQR3_SQ2_3                      ((uint32_t)0x00000100)        /*!< Bit 3 */
+#define  ADC_SQR3_SQ2_4                      ((uint32_t)0x00000200)        /*!< Bit 4 */
+
+#define  ADC_SQR3_SQ3                        ((uint32_t)0x00007C00)        /*!< SQ3[4:0] bits (3rd conversion in regular sequence) */
+#define  ADC_SQR3_SQ3_0                      ((uint32_t)0x00000400)        /*!< Bit 0 */
+#define  ADC_SQR3_SQ3_1                      ((uint32_t)0x00000800)        /*!< Bit 1 */
+#define  ADC_SQR3_SQ3_2                      ((uint32_t)0x00001000)        /*!< Bit 2 */
+#define  ADC_SQR3_SQ3_3                      ((uint32_t)0x00002000)        /*!< Bit 3 */
+#define  ADC_SQR3_SQ3_4                      ((uint32_t)0x00004000)        /*!< Bit 4 */
+
+#define  ADC_SQR3_SQ4                        ((uint32_t)0x000F8000)        /*!< SQ4[4:0] bits (4th conversion in regular sequence) */
+#define  ADC_SQR3_SQ4_0                      ((uint32_t)0x00008000)        /*!< Bit 0 */
+#define  ADC_SQR3_SQ4_1                      ((uint32_t)0x00010000)        /*!< Bit 1 */
+#define  ADC_SQR3_SQ4_2                      ((uint32_t)0x00020000)        /*!< Bit 2 */
+#define  ADC_SQR3_SQ4_3                      ((uint32_t)0x00040000)        /*!< Bit 3 */
+#define  ADC_SQR3_SQ4_4                      ((uint32_t)0x00080000)        /*!< Bit 4 */
+
+#define  ADC_SQR3_SQ5                        ((uint32_t)0x01F00000)        /*!< SQ5[4:0] bits (5th conversion in regular sequence) */
+#define  ADC_SQR3_SQ5_0                      ((uint32_t)0x00100000)        /*!< Bit 0 */
+#define  ADC_SQR3_SQ5_1                      ((uint32_t)0x00200000)        /*!< Bit 1 */
+#define  ADC_SQR3_SQ5_2                      ((uint32_t)0x00400000)        /*!< Bit 2 */
+#define  ADC_SQR3_SQ5_3                      ((uint32_t)0x00800000)        /*!< Bit 3 */
+#define  ADC_SQR3_SQ5_4                      ((uint32_t)0x01000000)        /*!< Bit 4 */
+
+#define  ADC_SQR3_SQ6                        ((uint32_t)0x3E000000)        /*!< SQ6[4:0] bits (6th conversion in regular sequence) */
+#define  ADC_SQR3_SQ6_0                      ((uint32_t)0x02000000)        /*!< Bit 0 */
+#define  ADC_SQR3_SQ6_1                      ((uint32_t)0x04000000)        /*!< Bit 1 */
+#define  ADC_SQR3_SQ6_2                      ((uint32_t)0x08000000)        /*!< Bit 2 */
+#define  ADC_SQR3_SQ6_3                      ((uint32_t)0x10000000)        /*!< Bit 3 */
+#define  ADC_SQR3_SQ6_4                      ((uint32_t)0x20000000)        /*!< Bit 4 */
+
+/*******************  Bit definition for ADC_JSQR register  *******************/
+#define  ADC_JSQR_JSQ1                       ((uint32_t)0x0000001F)        /*!< JSQ1[4:0] bits (1st conversion in injected sequence) */
+#define  ADC_JSQR_JSQ1_0                     ((uint32_t)0x00000001)        /*!< Bit 0 */
+#define  ADC_JSQR_JSQ1_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */
+#define  ADC_JSQR_JSQ1_2                     ((uint32_t)0x00000004)        /*!< Bit 2 */
+#define  ADC_JSQR_JSQ1_3                     ((uint32_t)0x00000008)        /*!< Bit 3 */
+#define  ADC_JSQR_JSQ1_4                     ((uint32_t)0x00000010)        /*!< Bit 4 */
+
+#define  ADC_JSQR_JSQ2                       ((uint32_t)0x000003E0)        /*!< JSQ2[4:0] bits (2nd conversion in injected sequence) */
+#define  ADC_JSQR_JSQ2_0                     ((uint32_t)0x00000020)        /*!< Bit 0 */
+#define  ADC_JSQR_JSQ2_1                     ((uint32_t)0x00000040)        /*!< Bit 1 */
+#define  ADC_JSQR_JSQ2_2                     ((uint32_t)0x00000080)        /*!< Bit 2 */
+#define  ADC_JSQR_JSQ2_3                     ((uint32_t)0x00000100)        /*!< Bit 3 */
+#define  ADC_JSQR_JSQ2_4                     ((uint32_t)0x00000200)        /*!< Bit 4 */
+
+#define  ADC_JSQR_JSQ3                       ((uint32_t)0x00007C00)        /*!< JSQ3[4:0] bits (3rd conversion in injected sequence) */
+#define  ADC_JSQR_JSQ3_0                     ((uint32_t)0x00000400)        /*!< Bit 0 */
+#define  ADC_JSQR_JSQ3_1                     ((uint32_t)0x00000800)        /*!< Bit 1 */
+#define  ADC_JSQR_JSQ3_2                     ((uint32_t)0x00001000)        /*!< Bit 2 */
+#define  ADC_JSQR_JSQ3_3                     ((uint32_t)0x00002000)        /*!< Bit 3 */
+#define  ADC_JSQR_JSQ3_4                     ((uint32_t)0x00004000)        /*!< Bit 4 */
+
+#define  ADC_JSQR_JSQ4                       ((uint32_t)0x000F8000)        /*!< JSQ4[4:0] bits (4th conversion in injected sequence) */
+#define  ADC_JSQR_JSQ4_0                     ((uint32_t)0x00008000)        /*!< Bit 0 */
+#define  ADC_JSQR_JSQ4_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */
+#define  ADC_JSQR_JSQ4_2                     ((uint32_t)0x00020000)        /*!< Bit 2 */
+#define  ADC_JSQR_JSQ4_3                     ((uint32_t)0x00040000)        /*!< Bit 3 */
+#define  ADC_JSQR_JSQ4_4                     ((uint32_t)0x00080000)        /*!< Bit 4 */
+
+#define  ADC_JSQR_JL                         ((uint32_t)0x00300000)        /*!< JL[1:0] bits (Injected Sequence length) */
+#define  ADC_JSQR_JL_0                       ((uint32_t)0x00100000)        /*!< Bit 0 */
+#define  ADC_JSQR_JL_1                       ((uint32_t)0x00200000)        /*!< Bit 1 */
+
+/*******************  Bit definition for ADC_JDR1 register  *******************/
+#define  ADC_JDR1_JDATA                      ((uint16_t)0xFFFF)            /*!< Injected data */
+
+/*******************  Bit definition for ADC_JDR2 register  *******************/
+#define  ADC_JDR2_JDATA                      ((uint16_t)0xFFFF)            /*!< Injected data */
+
+/*******************  Bit definition for ADC_JDR3 register  *******************/
+#define  ADC_JDR3_JDATA                      ((uint16_t)0xFFFF)            /*!< Injected data */
+
+/*******************  Bit definition for ADC_JDR4 register  *******************/
+#define  ADC_JDR4_JDATA                      ((uint16_t)0xFFFF)            /*!< Injected data */
+
+/********************  Bit definition for ADC_DR register  ********************/
+#define  ADC_DR_DATA                         ((uint32_t)0x0000FFFF)        /*!< Regular data */
+#define  ADC_DR_ADC2DATA                     ((uint32_t)0xFFFF0000)        /*!< ADC2 data */
+
+/******************************************************************************/
+/*                                                                            */
+/*                      Digital to Analog Converter                           */
+/*                                                                            */
+/******************************************************************************/
+
+/********************  Bit definition for DAC_CR register  ********************/
+#define  DAC_CR_EN1                          ((uint32_t)0x00000001)        /*!< DAC channel1 enable */
+#define  DAC_CR_BOFF1                        ((uint32_t)0x00000002)        /*!< DAC channel1 output buffer disable */
+#define  DAC_CR_TEN1                         ((uint32_t)0x00000004)        /*!< DAC channel1 Trigger enable */
+
+#define  DAC_CR_TSEL1                        ((uint32_t)0x00000038)        /*!< TSEL1[2:0] (DAC channel1 Trigger selection) */
+#define  DAC_CR_TSEL1_0                      ((uint32_t)0x00000008)        /*!< Bit 0 */
+#define  DAC_CR_TSEL1_1                      ((uint32_t)0x00000010)        /*!< Bit 1 */
+#define  DAC_CR_TSEL1_2                      ((uint32_t)0x00000020)        /*!< Bit 2 */
+
+#define  DAC_CR_WAVE1                        ((uint32_t)0x000000C0)        /*!< WAVE1[1:0] (DAC channel1 noise/triangle wave generation enable) */
+#define  DAC_CR_WAVE1_0                      ((uint32_t)0x00000040)        /*!< Bit 0 */
+#define  DAC_CR_WAVE1_1                      ((uint32_t)0x00000080)        /*!< Bit 1 */
+
+#define  DAC_CR_MAMP1                        ((uint32_t)0x00000F00)        /*!< MAMP1[3:0] (DAC channel1 Mask/Amplitude selector) */
+#define  DAC_CR_MAMP1_0                      ((uint32_t)0x00000100)        /*!< Bit 0 */
+#define  DAC_CR_MAMP1_1                      ((uint32_t)0x00000200)        /*!< Bit 1 */
+#define  DAC_CR_MAMP1_2                      ((uint32_t)0x00000400)        /*!< Bit 2 */
+#define  DAC_CR_MAMP1_3                      ((uint32_t)0x00000800)        /*!< Bit 3 */
+
+#define  DAC_CR_DMAEN1                       ((uint32_t)0x00001000)        /*!< DAC channel1 DMA enable */
+#define  DAC_CR_EN2                          ((uint32_t)0x00010000)        /*!< DAC channel2 enable */
+#define  DAC_CR_BOFF2                        ((uint32_t)0x00020000)        /*!< DAC channel2 output buffer disable */
+#define  DAC_CR_TEN2                         ((uint32_t)0x00040000)        /*!< DAC channel2 Trigger enable */
+
+#define  DAC_CR_TSEL2                        ((uint32_t)0x00380000)        /*!< TSEL2[2:0] (DAC channel2 Trigger selection) */
+#define  DAC_CR_TSEL2_0                      ((uint32_t)0x00080000)        /*!< Bit 0 */
+#define  DAC_CR_TSEL2_1                      ((uint32_t)0x00100000)        /*!< Bit 1 */
+#define  DAC_CR_TSEL2_2                      ((uint32_t)0x00200000)        /*!< Bit 2 */
+
+#define  DAC_CR_WAVE2                        ((uint32_t)0x00C00000)        /*!< WAVE2[1:0] (DAC channel2 noise/triangle wave generation enable) */
+#define  DAC_CR_WAVE2_0                      ((uint32_t)0x00400000)        /*!< Bit 0 */
+#define  DAC_CR_WAVE2_1                      ((uint32_t)0x00800000)        /*!< Bit 1 */
+
+#define  DAC_CR_MAMP2                        ((uint32_t)0x0F000000)        /*!< MAMP2[3:0] (DAC channel2 Mask/Amplitude selector) */
+#define  DAC_CR_MAMP2_0                      ((uint32_t)0x01000000)        /*!< Bit 0 */
+#define  DAC_CR_MAMP2_1                      ((uint32_t)0x02000000)        /*!< Bit 1 */
+#define  DAC_CR_MAMP2_2                      ((uint32_t)0x04000000)        /*!< Bit 2 */
+#define  DAC_CR_MAMP2_3                      ((uint32_t)0x08000000)        /*!< Bit 3 */
+
+#define  DAC_CR_DMAEN2                       ((uint32_t)0x10000000)        /*!< DAC channel2 DMA enabled */
+
+/*****************  Bit definition for DAC_SWTRIGR register  ******************/
+#define  DAC_SWTRIGR_SWTRIG1                 ((uint8_t)0x01)               /*!< DAC channel1 software trigger */
+#define  DAC_SWTRIGR_SWTRIG2                 ((uint8_t)0x02)               /*!< DAC channel2 software trigger */
+
+/*****************  Bit definition for DAC_DHR12R1 register  ******************/
+#define  DAC_DHR12R1_DACC1DHR                ((uint16_t)0x0FFF)            /*!< DAC channel1 12-bit Right aligned data */
+
+/*****************  Bit definition for DAC_DHR12L1 register  ******************/
+#define  DAC_DHR12L1_DACC1DHR                ((uint16_t)0xFFF0)            /*!< DAC channel1 12-bit Left aligned data */
+
+/******************  Bit definition for DAC_DHR8R1 register  ******************/
+#define  DAC_DHR8R1_DACC1DHR                 ((uint8_t)0xFF)               /*!< DAC channel1 8-bit Right aligned data */
+
+/*****************  Bit definition for DAC_DHR12R2 register  ******************/
+#define  DAC_DHR12R2_DACC2DHR                ((uint16_t)0x0FFF)            /*!< DAC channel2 12-bit Right aligned data */
+
+/*****************  Bit definition for DAC_DHR12L2 register  ******************/
+#define  DAC_DHR12L2_DACC2DHR                ((uint16_t)0xFFF0)            /*!< DAC channel2 12-bit Left aligned data */
+
+/******************  Bit definition for DAC_DHR8R2 register  ******************/
+#define  DAC_DHR8R2_DACC2DHR                 ((uint8_t)0xFF)               /*!< DAC channel2 8-bit Right aligned data */
+
+/*****************  Bit definition for DAC_DHR12RD register  ******************/
+#define  DAC_DHR12RD_DACC1DHR                ((uint32_t)0x00000FFF)        /*!< DAC channel1 12-bit Right aligned data */
+#define  DAC_DHR12RD_DACC2DHR                ((uint32_t)0x0FFF0000)        /*!< DAC channel2 12-bit Right aligned data */
+
+/*****************  Bit definition for DAC_DHR12LD register  ******************/
+#define  DAC_DHR12LD_DACC1DHR                ((uint32_t)0x0000FFF0)        /*!< DAC channel1 12-bit Left aligned data */
+#define  DAC_DHR12LD_DACC2DHR                ((uint32_t)0xFFF00000)        /*!< DAC channel2 12-bit Left aligned data */
+
+/******************  Bit definition for DAC_DHR8RD register  ******************/
+#define  DAC_DHR8RD_DACC1DHR                 ((uint16_t)0x00FF)            /*!< DAC channel1 8-bit Right aligned data */
+#define  DAC_DHR8RD_DACC2DHR                 ((uint16_t)0xFF00)            /*!< DAC channel2 8-bit Right aligned data */
+
+/*******************  Bit definition for DAC_DOR1 register  *******************/
+#define  DAC_DOR1_DACC1DOR                   ((uint16_t)0x0FFF)            /*!< DAC channel1 data output */
+
+/*******************  Bit definition for DAC_DOR2 register  *******************/
+#define  DAC_DOR2_DACC2DOR                   ((uint16_t)0x0FFF)            /*!< DAC channel2 data output */
+
+/********************  Bit definition for DAC_SR register  ********************/
+#define  DAC_SR_DMAUDR1                      ((uint32_t)0x00002000)        /*!< DAC channel1 DMA underrun flag */
+#define  DAC_SR_DMAUDR2                      ((uint32_t)0x20000000)        /*!< DAC channel2 DMA underrun flag */
+
+/******************************************************************************/
+/*                                                                            */
+/*                                    CEC                                     */
+/*                                                                            */
+/******************************************************************************/
+/********************  Bit definition for CEC_CFGR register  ******************/
+#define  CEC_CFGR_PE              ((uint16_t)0x0001)     /*!<  Peripheral Enable */
+#define  CEC_CFGR_IE              ((uint16_t)0x0002)     /*!<  Interrupt Enable */
+#define  CEC_CFGR_BTEM            ((uint16_t)0x0004)     /*!<  Bit Timing Error Mode */
+#define  CEC_CFGR_BPEM            ((uint16_t)0x0008)     /*!<  Bit Period Error Mode */
+
+/********************  Bit definition for CEC_OAR register  ******************/
+#define  CEC_OAR_OA               ((uint16_t)0x000F)     /*!<  OA[3:0]: Own Address */
+#define  CEC_OAR_OA_0             ((uint16_t)0x0001)     /*!<  Bit 0 */
+#define  CEC_OAR_OA_1             ((uint16_t)0x0002)     /*!<  Bit 1 */
+#define  CEC_OAR_OA_2             ((uint16_t)0x0004)     /*!<  Bit 2 */
+#define  CEC_OAR_OA_3             ((uint16_t)0x0008)     /*!<  Bit 3 */
+
+/********************  Bit definition for CEC_PRES register  ******************/
+#define  CEC_PRES_PRES            ((uint16_t)0x3FFF)   /*!<  Prescaler Counter Value */
+
+/********************  Bit definition for CEC_ESR register  ******************/
+#define  CEC_ESR_BTE              ((uint16_t)0x0001)     /*!<  Bit Timing Error */
+#define  CEC_ESR_BPE              ((uint16_t)0x0002)     /*!<  Bit Period Error */
+#define  CEC_ESR_RBTFE            ((uint16_t)0x0004)     /*!<  Rx Block Transfer Finished Error */
+#define  CEC_ESR_SBE              ((uint16_t)0x0008)     /*!<  Start Bit Error */
+#define  CEC_ESR_ACKE             ((uint16_t)0x0010)     /*!<  Block Acknowledge Error */
+#define  CEC_ESR_LINE             ((uint16_t)0x0020)     /*!<  Line Error */
+#define  CEC_ESR_TBTFE            ((uint16_t)0x0040)     /*!<  Tx Block Transfer Finished Error */
+
+/********************  Bit definition for CEC_CSR register  ******************/
+#define  CEC_CSR_TSOM             ((uint16_t)0x0001)     /*!<  Tx Start Of Message */
+#define  CEC_CSR_TEOM             ((uint16_t)0x0002)     /*!<  Tx End Of Message */
+#define  CEC_CSR_TERR             ((uint16_t)0x0004)     /*!<  Tx Error */
+#define  CEC_CSR_TBTRF            ((uint16_t)0x0008)     /*!<  Tx Byte Transfer Request or Block Transfer Finished */
+#define  CEC_CSR_RSOM             ((uint16_t)0x0010)     /*!<  Rx Start Of Message */
+#define  CEC_CSR_REOM             ((uint16_t)0x0020)     /*!<  Rx End Of Message */
+#define  CEC_CSR_RERR             ((uint16_t)0x0040)     /*!<  Rx Error */
+#define  CEC_CSR_RBTF             ((uint16_t)0x0080)     /*!<  Rx Block Transfer Finished */
+
+/********************  Bit definition for CEC_TXD register  ******************/
+#define  CEC_TXD_TXD              ((uint16_t)0x00FF)     /*!<  Tx Data register */
+
+/********************  Bit definition for CEC_RXD register  ******************/
+#define  CEC_RXD_RXD              ((uint16_t)0x00FF)     /*!<  Rx Data register */
+
+/******************************************************************************/
+/*                                                                            */
+/*                                    TIM                                     */
+/*                                                                            */
+/******************************************************************************/
+
+/*******************  Bit definition for TIM_CR1 register  ********************/
+#define  TIM_CR1_CEN                         ((uint16_t)0x0001)            /*!< Counter enable */
+#define  TIM_CR1_UDIS                        ((uint16_t)0x0002)            /*!< Update disable */
+#define  TIM_CR1_URS                         ((uint16_t)0x0004)            /*!< Update request source */
+#define  TIM_CR1_OPM                         ((uint16_t)0x0008)            /*!< One pulse mode */
+#define  TIM_CR1_DIR                         ((uint16_t)0x0010)            /*!< Direction */
+
+#define  TIM_CR1_CMS                         ((uint16_t)0x0060)            /*!< CMS[1:0] bits (Center-aligned mode selection) */
+#define  TIM_CR1_CMS_0                       ((uint16_t)0x0020)            /*!< Bit 0 */
+#define  TIM_CR1_CMS_1                       ((uint16_t)0x0040)            /*!< Bit 1 */
+
+#define  TIM_CR1_ARPE                        ((uint16_t)0x0080)            /*!< Auto-reload preload enable */
+
+#define  TIM_CR1_CKD                         ((uint16_t)0x0300)            /*!< CKD[1:0] bits (clock division) */
+#define  TIM_CR1_CKD_0                       ((uint16_t)0x0100)            /*!< Bit 0 */
+#define  TIM_CR1_CKD_1                       ((uint16_t)0x0200)            /*!< Bit 1 */
+
+/*******************  Bit definition for TIM_CR2 register  ********************/
+#define  TIM_CR2_CCPC                        ((uint16_t)0x0001)            /*!< Capture/Compare Preloaded Control */
+#define  TIM_CR2_CCUS                        ((uint16_t)0x0004)            /*!< Capture/Compare Control Update Selection */
+#define  TIM_CR2_CCDS                        ((uint16_t)0x0008)            /*!< Capture/Compare DMA Selection */
+
+#define  TIM_CR2_MMS                         ((uint16_t)0x0070)            /*!< MMS[2:0] bits (Master Mode Selection) */
+#define  TIM_CR2_MMS_0                       ((uint16_t)0x0010)            /*!< Bit 0 */
+#define  TIM_CR2_MMS_1                       ((uint16_t)0x0020)            /*!< Bit 1 */
+#define  TIM_CR2_MMS_2                       ((uint16_t)0x0040)            /*!< Bit 2 */
+
+#define  TIM_CR2_TI1S                        ((uint16_t)0x0080)            /*!< TI1 Selection */
+#define  TIM_CR2_OIS1                        ((uint16_t)0x0100)            /*!< Output Idle state 1 (OC1 output) */
+#define  TIM_CR2_OIS1N                       ((uint16_t)0x0200)            /*!< Output Idle state 1 (OC1N output) */
+#define  TIM_CR2_OIS2                        ((uint16_t)0x0400)            /*!< Output Idle state 2 (OC2 output) */
+#define  TIM_CR2_OIS2N                       ((uint16_t)0x0800)            /*!< Output Idle state 2 (OC2N output) */
+#define  TIM_CR2_OIS3                        ((uint16_t)0x1000)            /*!< Output Idle state 3 (OC3 output) */
+#define  TIM_CR2_OIS3N                       ((uint16_t)0x2000)            /*!< Output Idle state 3 (OC3N output) */
+#define  TIM_CR2_OIS4                        ((uint16_t)0x4000)            /*!< Output Idle state 4 (OC4 output) */
+
+/*******************  Bit definition for TIM_SMCR register  *******************/
+#define  TIM_SMCR_SMS                        ((uint16_t)0x0007)            /*!< SMS[2:0] bits (Slave mode selection) */
+#define  TIM_SMCR_SMS_0                      ((uint16_t)0x0001)            /*!< Bit 0 */
+#define  TIM_SMCR_SMS_1                      ((uint16_t)0x0002)            /*!< Bit 1 */
+#define  TIM_SMCR_SMS_2                      ((uint16_t)0x0004)            /*!< Bit 2 */
+
+#define  TIM_SMCR_TS                         ((uint16_t)0x0070)            /*!< TS[2:0] bits (Trigger selection) */
+#define  TIM_SMCR_TS_0                       ((uint16_t)0x0010)            /*!< Bit 0 */
+#define  TIM_SMCR_TS_1                       ((uint16_t)0x0020)            /*!< Bit 1 */
+#define  TIM_SMCR_TS_2                       ((uint16_t)0x0040)            /*!< Bit 2 */
+
+#define  TIM_SMCR_MSM                        ((uint16_t)0x0080)            /*!< Master/slave mode */
+
+#define  TIM_SMCR_ETF                        ((uint16_t)0x0F00)            /*!< ETF[3:0] bits (External trigger filter) */
+#define  TIM_SMCR_ETF_0                      ((uint16_t)0x0100)            /*!< Bit 0 */
+#define  TIM_SMCR_ETF_1                      ((uint16_t)0x0200)            /*!< Bit 1 */
+#define  TIM_SMCR_ETF_2                      ((uint16_t)0x0400)            /*!< Bit 2 */
+#define  TIM_SMCR_ETF_3                      ((uint16_t)0x0800)            /*!< Bit 3 */
+
+#define  TIM_SMCR_ETPS                       ((uint16_t)0x3000)            /*!< ETPS[1:0] bits (External trigger prescaler) */
+#define  TIM_SMCR_ETPS_0                     ((uint16_t)0x1000)            /*!< Bit 0 */
+#define  TIM_SMCR_ETPS_1                     ((uint16_t)0x2000)            /*!< Bit 1 */
+
+#define  TIM_SMCR_ECE                        ((uint16_t)0x4000)            /*!< External clock enable */
+#define  TIM_SMCR_ETP                        ((uint16_t)0x8000)            /*!< External trigger polarity */
+
+/*******************  Bit definition for TIM_DIER register  *******************/
+#define  TIM_DIER_UIE                        ((uint16_t)0x0001)            /*!< Update interrupt enable */
+#define  TIM_DIER_CC1IE                      ((uint16_t)0x0002)            /*!< Capture/Compare 1 interrupt enable */
+#define  TIM_DIER_CC2IE                      ((uint16_t)0x0004)            /*!< Capture/Compare 2 interrupt enable */
+#define  TIM_DIER_CC3IE                      ((uint16_t)0x0008)            /*!< Capture/Compare 3 interrupt enable */
+#define  TIM_DIER_CC4IE                      ((uint16_t)0x0010)            /*!< Capture/Compare 4 interrupt enable */
+#define  TIM_DIER_COMIE                      ((uint16_t)0x0020)            /*!< COM interrupt enable */
+#define  TIM_DIER_TIE                        ((uint16_t)0x0040)            /*!< Trigger interrupt enable */
+#define  TIM_DIER_BIE                        ((uint16_t)0x0080)            /*!< Break interrupt enable */
+#define  TIM_DIER_UDE                        ((uint16_t)0x0100)            /*!< Update DMA request enable */
+#define  TIM_DIER_CC1DE                      ((uint16_t)0x0200)            /*!< Capture/Compare 1 DMA request enable */
+#define  TIM_DIER_CC2DE                      ((uint16_t)0x0400)            /*!< Capture/Compare 2 DMA request enable */
+#define  TIM_DIER_CC3DE                      ((uint16_t)0x0800)            /*!< Capture/Compare 3 DMA request enable */
+#define  TIM_DIER_CC4DE                      ((uint16_t)0x1000)            /*!< Capture/Compare 4 DMA request enable */
+#define  TIM_DIER_COMDE                      ((uint16_t)0x2000)            /*!< COM DMA request enable */
+#define  TIM_DIER_TDE                        ((uint16_t)0x4000)            /*!< Trigger DMA request enable */
+
+/********************  Bit definition for TIM_SR register  ********************/
+#define  TIM_SR_UIF                          ((uint16_t)0x0001)            /*!< Update interrupt Flag */
+#define  TIM_SR_CC1IF                        ((uint16_t)0x0002)            /*!< Capture/Compare 1 interrupt Flag */
+#define  TIM_SR_CC2IF                        ((uint16_t)0x0004)            /*!< Capture/Compare 2 interrupt Flag */
+#define  TIM_SR_CC3IF                        ((uint16_t)0x0008)            /*!< Capture/Compare 3 interrupt Flag */
+#define  TIM_SR_CC4IF                        ((uint16_t)0x0010)            /*!< Capture/Compare 4 interrupt Flag */
+#define  TIM_SR_COMIF                        ((uint16_t)0x0020)            /*!< COM interrupt Flag */
+#define  TIM_SR_TIF                          ((uint16_t)0x0040)            /*!< Trigger interrupt Flag */
+#define  TIM_SR_BIF                          ((uint16_t)0x0080)            /*!< Break interrupt Flag */
+#define  TIM_SR_CC1OF                        ((uint16_t)0x0200)            /*!< Capture/Compare 1 Overcapture Flag */
+#define  TIM_SR_CC2OF                        ((uint16_t)0x0400)            /*!< Capture/Compare 2 Overcapture Flag */
+#define  TIM_SR_CC3OF                        ((uint16_t)0x0800)            /*!< Capture/Compare 3 Overcapture Flag */
+#define  TIM_SR_CC4OF                        ((uint16_t)0x1000)            /*!< Capture/Compare 4 Overcapture Flag */
+
+/*******************  Bit definition for TIM_EGR register  ********************/
+#define  TIM_EGR_UG                          ((uint8_t)0x01)               /*!< Update Generation */
+#define  TIM_EGR_CC1G                        ((uint8_t)0x02)               /*!< Capture/Compare 1 Generation */
+#define  TIM_EGR_CC2G                        ((uint8_t)0x04)               /*!< Capture/Compare 2 Generation */
+#define  TIM_EGR_CC3G                        ((uint8_t)0x08)               /*!< Capture/Compare 3 Generation */
+#define  TIM_EGR_CC4G                        ((uint8_t)0x10)               /*!< Capture/Compare 4 Generation */
+#define  TIM_EGR_COMG                        ((uint8_t)0x20)               /*!< Capture/Compare Control Update Generation */
+#define  TIM_EGR_TG                          ((uint8_t)0x40)               /*!< Trigger Generation */
+#define  TIM_EGR_BG                          ((uint8_t)0x80)               /*!< Break Generation */
+
+/******************  Bit definition for TIM_CCMR1 register  *******************/
+#define  TIM_CCMR1_CC1S                      ((uint16_t)0x0003)            /*!< CC1S[1:0] bits (Capture/Compare 1 Selection) */
+#define  TIM_CCMR1_CC1S_0                    ((uint16_t)0x0001)            /*!< Bit 0 */
+#define  TIM_CCMR1_CC1S_1                    ((uint16_t)0x0002)            /*!< Bit 1 */
+
+#define  TIM_CCMR1_OC1FE                     ((uint16_t)0x0004)            /*!< Output Compare 1 Fast enable */
+#define  TIM_CCMR1_OC1PE                     ((uint16_t)0x0008)            /*!< Output Compare 1 Preload enable */
+
+#define  TIM_CCMR1_OC1M                      ((uint16_t)0x0070)            /*!< OC1M[2:0] bits (Output Compare 1 Mode) */
+#define  TIM_CCMR1_OC1M_0                    ((uint16_t)0x0010)            /*!< Bit 0 */
+#define  TIM_CCMR1_OC1M_1                    ((uint16_t)0x0020)            /*!< Bit 1 */
+#define  TIM_CCMR1_OC1M_2                    ((uint16_t)0x0040)            /*!< Bit 2 */
+
+#define  TIM_CCMR1_OC1CE                     ((uint16_t)0x0080)            /*!< Output Compare 1Clear Enable */
+
+#define  TIM_CCMR1_CC2S                      ((uint16_t)0x0300)            /*!< CC2S[1:0] bits (Capture/Compare 2 Selection) */
+#define  TIM_CCMR1_CC2S_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
+#define  TIM_CCMR1_CC2S_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
+
+#define  TIM_CCMR1_OC2FE                     ((uint16_t)0x0400)            /*!< Output Compare 2 Fast enable */
+#define  TIM_CCMR1_OC2PE                     ((uint16_t)0x0800)            /*!< Output Compare 2 Preload enable */
+
+#define  TIM_CCMR1_OC2M                      ((uint16_t)0x7000)            /*!< OC2M[2:0] bits (Output Compare 2 Mode) */
+#define  TIM_CCMR1_OC2M_0                    ((uint16_t)0x1000)            /*!< Bit 0 */
+#define  TIM_CCMR1_OC2M_1                    ((uint16_t)0x2000)            /*!< Bit 1 */
+#define  TIM_CCMR1_OC2M_2                    ((uint16_t)0x4000)            /*!< Bit 2 */
+
+#define  TIM_CCMR1_OC2CE                     ((uint16_t)0x8000)            /*!< Output Compare 2 Clear Enable */
+
+/*----------------------------------------------------------------------------*/
+
+#define  TIM_CCMR1_IC1PSC                    ((uint16_t)0x000C)            /*!< IC1PSC[1:0] bits (Input Capture 1 Prescaler) */
+#define  TIM_CCMR1_IC1PSC_0                  ((uint16_t)0x0004)            /*!< Bit 0 */
+#define  TIM_CCMR1_IC1PSC_1                  ((uint16_t)0x0008)            /*!< Bit 1 */
+
+#define  TIM_CCMR1_IC1F                      ((uint16_t)0x00F0)            /*!< IC1F[3:0] bits (Input Capture 1 Filter) */
+#define  TIM_CCMR1_IC1F_0                    ((uint16_t)0x0010)            /*!< Bit 0 */
+#define  TIM_CCMR1_IC1F_1                    ((uint16_t)0x0020)            /*!< Bit 1 */
+#define  TIM_CCMR1_IC1F_2                    ((uint16_t)0x0040)            /*!< Bit 2 */
+#define  TIM_CCMR1_IC1F_3                    ((uint16_t)0x0080)            /*!< Bit 3 */
+
+#define  TIM_CCMR1_IC2PSC                    ((uint16_t)0x0C00)            /*!< IC2PSC[1:0] bits (Input Capture 2 Prescaler) */
+#define  TIM_CCMR1_IC2PSC_0                  ((uint16_t)0x0400)            /*!< Bit 0 */
+#define  TIM_CCMR1_IC2PSC_1                  ((uint16_t)0x0800)            /*!< Bit 1 */
+
+#define  TIM_CCMR1_IC2F                      ((uint16_t)0xF000)            /*!< IC2F[3:0] bits (Input Capture 2 Filter) */
+#define  TIM_CCMR1_IC2F_0                    ((uint16_t)0x1000)            /*!< Bit 0 */
+#define  TIM_CCMR1_IC2F_1                    ((uint16_t)0x2000)            /*!< Bit 1 */
+#define  TIM_CCMR1_IC2F_2                    ((uint16_t)0x4000)            /*!< Bit 2 */
+#define  TIM_CCMR1_IC2F_3                    ((uint16_t)0x8000)            /*!< Bit 3 */
+
+/******************  Bit definition for TIM_CCMR2 register  *******************/
+#define  TIM_CCMR2_CC3S                      ((uint16_t)0x0003)            /*!< CC3S[1:0] bits (Capture/Compare 3 Selection) */
+#define  TIM_CCMR2_CC3S_0                    ((uint16_t)0x0001)            /*!< Bit 0 */
+#define  TIM_CCMR2_CC3S_1                    ((uint16_t)0x0002)            /*!< Bit 1 */
+
+#define  TIM_CCMR2_OC3FE                     ((uint16_t)0x0004)            /*!< Output Compare 3 Fast enable */
+#define  TIM_CCMR2_OC3PE                     ((uint16_t)0x0008)            /*!< Output Compare 3 Preload enable */
+
+#define  TIM_CCMR2_OC3M                      ((uint16_t)0x0070)            /*!< OC3M[2:0] bits (Output Compare 3 Mode) */
+#define  TIM_CCMR2_OC3M_0                    ((uint16_t)0x0010)            /*!< Bit 0 */
+#define  TIM_CCMR2_OC3M_1                    ((uint16_t)0x0020)            /*!< Bit 1 */
+#define  TIM_CCMR2_OC3M_2                    ((uint16_t)0x0040)            /*!< Bit 2 */
+
+#define  TIM_CCMR2_OC3CE                     ((uint16_t)0x0080)            /*!< Output Compare 3 Clear Enable */
+
+#define  TIM_CCMR2_CC4S                      ((uint16_t)0x0300)            /*!< CC4S[1:0] bits (Capture/Compare 4 Selection) */
+#define  TIM_CCMR2_CC4S_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
+#define  TIM_CCMR2_CC4S_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
+
+#define  TIM_CCMR2_OC4FE                     ((uint16_t)0x0400)            /*!< Output Compare 4 Fast enable */
+#define  TIM_CCMR2_OC4PE                     ((uint16_t)0x0800)            /*!< Output Compare 4 Preload enable */
+
+#define  TIM_CCMR2_OC4M                      ((uint16_t)0x7000)            /*!< OC4M[2:0] bits (Output Compare 4 Mode) */
+#define  TIM_CCMR2_OC4M_0                    ((uint16_t)0x1000)            /*!< Bit 0 */
+#define  TIM_CCMR2_OC4M_1                    ((uint16_t)0x2000)            /*!< Bit 1 */
+#define  TIM_CCMR2_OC4M_2                    ((uint16_t)0x4000)            /*!< Bit 2 */
+
+#define  TIM_CCMR2_OC4CE                     ((uint16_t)0x8000)            /*!< Output Compare 4 Clear Enable */
+
+/*----------------------------------------------------------------------------*/
+
+#define  TIM_CCMR2_IC3PSC                    ((uint16_t)0x000C)            /*!< IC3PSC[1:0] bits (Input Capture 3 Prescaler) */
+#define  TIM_CCMR2_IC3PSC_0                  ((uint16_t)0x0004)            /*!< Bit 0 */
+#define  TIM_CCMR2_IC3PSC_1                  ((uint16_t)0x0008)            /*!< Bit 1 */
+
+#define  TIM_CCMR2_IC3F                      ((uint16_t)0x00F0)            /*!< IC3F[3:0] bits (Input Capture 3 Filter) */
+#define  TIM_CCMR2_IC3F_0                    ((uint16_t)0x0010)            /*!< Bit 0 */
+#define  TIM_CCMR2_IC3F_1                    ((uint16_t)0x0020)            /*!< Bit 1 */
+#define  TIM_CCMR2_IC3F_2                    ((uint16_t)0x0040)            /*!< Bit 2 */
+#define  TIM_CCMR2_IC3F_3                    ((uint16_t)0x0080)            /*!< Bit 3 */
+
+#define  TIM_CCMR2_IC4PSC                    ((uint16_t)0x0C00)            /*!< IC4PSC[1:0] bits (Input Capture 4 Prescaler) */
+#define  TIM_CCMR2_IC4PSC_0                  ((uint16_t)0x0400)            /*!< Bit 0 */
+#define  TIM_CCMR2_IC4PSC_1                  ((uint16_t)0x0800)            /*!< Bit 1 */
+
+#define  TIM_CCMR2_IC4F                      ((uint16_t)0xF000)            /*!< IC4F[3:0] bits (Input Capture 4 Filter) */
+#define  TIM_CCMR2_IC4F_0                    ((uint16_t)0x1000)            /*!< Bit 0 */
+#define  TIM_CCMR2_IC4F_1                    ((uint16_t)0x2000)            /*!< Bit 1 */
+#define  TIM_CCMR2_IC4F_2                    ((uint16_t)0x4000)            /*!< Bit 2 */
+#define  TIM_CCMR2_IC4F_3                    ((uint16_t)0x8000)            /*!< Bit 3 */
+
+/*******************  Bit definition for TIM_CCER register  *******************/
+#define  TIM_CCER_CC1E                       ((uint16_t)0x0001)            /*!< Capture/Compare 1 output enable */
+#define  TIM_CCER_CC1P                       ((uint16_t)0x0002)            /*!< Capture/Compare 1 output Polarity */
+#define  TIM_CCER_CC1NE                      ((uint16_t)0x0004)            /*!< Capture/Compare 1 Complementary output enable */
+#define  TIM_CCER_CC1NP                      ((uint16_t)0x0008)            /*!< Capture/Compare 1 Complementary output Polarity */
+#define  TIM_CCER_CC2E                       ((uint16_t)0x0010)            /*!< Capture/Compare 2 output enable */
+#define  TIM_CCER_CC2P                       ((uint16_t)0x0020)            /*!< Capture/Compare 2 output Polarity */
+#define  TIM_CCER_CC2NE                      ((uint16_t)0x0040)            /*!< Capture/Compare 2 Complementary output enable */
+#define  TIM_CCER_CC2NP                      ((uint16_t)0x0080)            /*!< Capture/Compare 2 Complementary output Polarity */
+#define  TIM_CCER_CC3E                       ((uint16_t)0x0100)            /*!< Capture/Compare 3 output enable */
+#define  TIM_CCER_CC3P                       ((uint16_t)0x0200)            /*!< Capture/Compare 3 output Polarity */
+#define  TIM_CCER_CC3NE                      ((uint16_t)0x0400)            /*!< Capture/Compare 3 Complementary output enable */
+#define  TIM_CCER_CC3NP                      ((uint16_t)0x0800)            /*!< Capture/Compare 3 Complementary output Polarity */
+#define  TIM_CCER_CC4E                       ((uint16_t)0x1000)            /*!< Capture/Compare 4 output enable */
+#define  TIM_CCER_CC4P                       ((uint16_t)0x2000)            /*!< Capture/Compare 4 output Polarity */
+#define  TIM_CCER_CC4NP                      ((uint16_t)0x8000)            /*!< Capture/Compare 4 Complementary output Polarity */
+
+/*******************  Bit definition for TIM_CNT register  ********************/
+#define  TIM_CNT_CNT                         ((uint16_t)0xFFFF)            /*!< Counter Value */
+
+/*******************  Bit definition for TIM_PSC register  ********************/
+#define  TIM_PSC_PSC                         ((uint16_t)0xFFFF)            /*!< Prescaler Value */
+
+/*******************  Bit definition for TIM_ARR register  ********************/
+#define  TIM_ARR_ARR                         ((uint16_t)0xFFFF)            /*!< actual auto-reload Value */
+
+/*******************  Bit definition for TIM_RCR register  ********************/
+#define  TIM_RCR_REP                         ((uint8_t)0xFF)               /*!< Repetition Counter Value */
+
+/*******************  Bit definition for TIM_CCR1 register  *******************/
+#define  TIM_CCR1_CCR1                       ((uint16_t)0xFFFF)            /*!< Capture/Compare 1 Value */
+
+/*******************  Bit definition for TIM_CCR2 register  *******************/
+#define  TIM_CCR2_CCR2                       ((uint16_t)0xFFFF)            /*!< Capture/Compare 2 Value */
+
+/*******************  Bit definition for TIM_CCR3 register  *******************/
+#define  TIM_CCR3_CCR3                       ((uint16_t)0xFFFF)            /*!< Capture/Compare 3 Value */
+
+/*******************  Bit definition for TIM_CCR4 register  *******************/
+#define  TIM_CCR4_CCR4                       ((uint16_t)0xFFFF)            /*!< Capture/Compare 4 Value */
+
+/*******************  Bit definition for TIM_BDTR register  *******************/
+#define  TIM_BDTR_DTG                        ((uint16_t)0x00FF)            /*!< DTG[0:7] bits (Dead-Time Generator set-up) */
+#define  TIM_BDTR_DTG_0                      ((uint16_t)0x0001)            /*!< Bit 0 */
+#define  TIM_BDTR_DTG_1                      ((uint16_t)0x0002)            /*!< Bit 1 */
+#define  TIM_BDTR_DTG_2                      ((uint16_t)0x0004)            /*!< Bit 2 */
+#define  TIM_BDTR_DTG_3                      ((uint16_t)0x0008)            /*!< Bit 3 */
+#define  TIM_BDTR_DTG_4                      ((uint16_t)0x0010)            /*!< Bit 4 */
+#define  TIM_BDTR_DTG_5                      ((uint16_t)0x0020)            /*!< Bit 5 */
+#define  TIM_BDTR_DTG_6                      ((uint16_t)0x0040)            /*!< Bit 6 */
+#define  TIM_BDTR_DTG_7                      ((uint16_t)0x0080)            /*!< Bit 7 */
+
+#define  TIM_BDTR_LOCK                       ((uint16_t)0x0300)            /*!< LOCK[1:0] bits (Lock Configuration) */
+#define  TIM_BDTR_LOCK_0                     ((uint16_t)0x0100)            /*!< Bit 0 */
+#define  TIM_BDTR_LOCK_1                     ((uint16_t)0x0200)            /*!< Bit 1 */
+
+#define  TIM_BDTR_OSSI                       ((uint16_t)0x0400)            /*!< Off-State Selection for Idle mode */
+#define  TIM_BDTR_OSSR                       ((uint16_t)0x0800)            /*!< Off-State Selection for Run mode */
+#define  TIM_BDTR_BKE                        ((uint16_t)0x1000)            /*!< Break enable */
+#define  TIM_BDTR_BKP                        ((uint16_t)0x2000)            /*!< Break Polarity */
+#define  TIM_BDTR_AOE                        ((uint16_t)0x4000)            /*!< Automatic Output enable */
+#define  TIM_BDTR_MOE                        ((uint16_t)0x8000)            /*!< Main Output enable */
+
+/*******************  Bit definition for TIM_DCR register  ********************/
+#define  TIM_DCR_DBA                         ((uint16_t)0x001F)            /*!< DBA[4:0] bits (DMA Base Address) */
+#define  TIM_DCR_DBA_0                       ((uint16_t)0x0001)            /*!< Bit 0 */
+#define  TIM_DCR_DBA_1                       ((uint16_t)0x0002)            /*!< Bit 1 */
+#define  TIM_DCR_DBA_2                       ((uint16_t)0x0004)            /*!< Bit 2 */
+#define  TIM_DCR_DBA_3                       ((uint16_t)0x0008)            /*!< Bit 3 */
+#define  TIM_DCR_DBA_4                       ((uint16_t)0x0010)            /*!< Bit 4 */
+
+#define  TIM_DCR_DBL                         ((uint16_t)0x1F00)            /*!< DBL[4:0] bits (DMA Burst Length) */
+#define  TIM_DCR_DBL_0                       ((uint16_t)0x0100)            /*!< Bit 0 */
+#define  TIM_DCR_DBL_1                       ((uint16_t)0x0200)            /*!< Bit 1 */
+#define  TIM_DCR_DBL_2                       ((uint16_t)0x0400)            /*!< Bit 2 */
+#define  TIM_DCR_DBL_3                       ((uint16_t)0x0800)            /*!< Bit 3 */
+#define  TIM_DCR_DBL_4                       ((uint16_t)0x1000)            /*!< Bit 4 */
+
+/*******************  Bit definition for TIM_DMAR register  *******************/
+#define  TIM_DMAR_DMAB                       ((uint16_t)0xFFFF)            /*!< DMA register for burst accesses */
+
+/******************************************************************************/
+/*                                                                            */
+/*                             Real-Time Clock                                */
+/*                                                                            */
+/******************************************************************************/
+
+/*******************  Bit definition for RTC_CRH register  ********************/
+#define  RTC_CRH_SECIE                       ((uint8_t)0x01)               /*!< Second Interrupt Enable */
+#define  RTC_CRH_ALRIE                       ((uint8_t)0x02)               /*!< Alarm Interrupt Enable */
+#define  RTC_CRH_OWIE                        ((uint8_t)0x04)               /*!< OverfloW Interrupt Enable */
+
+/*******************  Bit definition for RTC_CRL register  ********************/
+#define  RTC_CRL_SECF                        ((uint8_t)0x01)               /*!< Second Flag */
+#define  RTC_CRL_ALRF                        ((uint8_t)0x02)               /*!< Alarm Flag */
+#define  RTC_CRL_OWF                         ((uint8_t)0x04)               /*!< OverfloW Flag */
+#define  RTC_CRL_RSF                         ((uint8_t)0x08)               /*!< Registers Synchronized Flag */
+#define  RTC_CRL_CNF                         ((uint8_t)0x10)               /*!< Configuration Flag */
+#define  RTC_CRL_RTOFF                       ((uint8_t)0x20)               /*!< RTC operation OFF */
+
+/*******************  Bit definition for RTC_PRLH register  *******************/
+#define  RTC_PRLH_PRL                        ((uint16_t)0x000F)            /*!< RTC Prescaler Reload Value High */
+
+/*******************  Bit definition for RTC_PRLL register  *******************/
+#define  RTC_PRLL_PRL                        ((uint16_t)0xFFFF)            /*!< RTC Prescaler Reload Value Low */
+
+/*******************  Bit definition for RTC_DIVH register  *******************/
+#define  RTC_DIVH_RTC_DIV                    ((uint16_t)0x000F)            /*!< RTC Clock Divider High */
+
+/*******************  Bit definition for RTC_DIVL register  *******************/
+#define  RTC_DIVL_RTC_DIV                    ((uint16_t)0xFFFF)            /*!< RTC Clock Divider Low */
+
+/*******************  Bit definition for RTC_CNTH register  *******************/
+#define  RTC_CNTH_RTC_CNT                    ((uint16_t)0xFFFF)            /*!< RTC Counter High */
+
+/*******************  Bit definition for RTC_CNTL register  *******************/
+#define  RTC_CNTL_RTC_CNT                    ((uint16_t)0xFFFF)            /*!< RTC Counter Low */
+
+/*******************  Bit definition for RTC_ALRH register  *******************/
+#define  RTC_ALRH_RTC_ALR                    ((uint16_t)0xFFFF)            /*!< RTC Alarm High */
+
+/*******************  Bit definition for RTC_ALRL register  *******************/
+#define  RTC_ALRL_RTC_ALR                    ((uint16_t)0xFFFF)            /*!< RTC Alarm Low */
+
+/******************************************************************************/
+/*                                                                            */
+/*                           Independent WATCHDOG                             */
+/*                                                                            */
+/******************************************************************************/
+
+/*******************  Bit definition for IWDG_KR register  ********************/
+#define  IWDG_KR_KEY                         ((uint16_t)0xFFFF)            /*!< Key value (write only, read 0000h) */
+
+/*******************  Bit definition for IWDG_PR register  ********************/
+#define  IWDG_PR_PR                          ((uint8_t)0x07)               /*!< PR[2:0] (Prescaler divider) */
+#define  IWDG_PR_PR_0                        ((uint8_t)0x01)               /*!< Bit 0 */
+#define  IWDG_PR_PR_1                        ((uint8_t)0x02)               /*!< Bit 1 */
+#define  IWDG_PR_PR_2                        ((uint8_t)0x04)               /*!< Bit 2 */
+
+/*******************  Bit definition for IWDG_RLR register  *******************/
+#define  IWDG_RLR_RL                         ((uint16_t)0x0FFF)            /*!< Watchdog counter reload value */
+
+/*******************  Bit definition for IWDG_SR register  ********************/
+#define  IWDG_SR_PVU                         ((uint8_t)0x01)               /*!< Watchdog prescaler value update */
+#define  IWDG_SR_RVU                         ((uint8_t)0x02)               /*!< Watchdog counter reload value update */
+
+/******************************************************************************/
+/*                                                                            */
+/*                            Window WATCHDOG                                 */
+/*                                                                            */
+/******************************************************************************/
+
+/*******************  Bit definition for WWDG_CR register  ********************/
+#define  WWDG_CR_T                           ((uint8_t)0x7F)               /*!< T[6:0] bits (7-Bit counter (MSB to LSB)) */
+#define  WWDG_CR_T0                          ((uint8_t)0x01)               /*!< Bit 0 */
+#define  WWDG_CR_T1                          ((uint8_t)0x02)               /*!< Bit 1 */
+#define  WWDG_CR_T2                          ((uint8_t)0x04)               /*!< Bit 2 */
+#define  WWDG_CR_T3                          ((uint8_t)0x08)               /*!< Bit 3 */
+#define  WWDG_CR_T4                          ((uint8_t)0x10)               /*!< Bit 4 */
+#define  WWDG_CR_T5                          ((uint8_t)0x20)               /*!< Bit 5 */
+#define  WWDG_CR_T6                          ((uint8_t)0x40)               /*!< Bit 6 */
+
+#define  WWDG_CR_WDGA                        ((uint8_t)0x80)               /*!< Activation bit */
+
+/*******************  Bit definition for WWDG_CFR register  *******************/
+#define  WWDG_CFR_W                          ((uint16_t)0x007F)            /*!< W[6:0] bits (7-bit window value) */
+#define  WWDG_CFR_W0                         ((uint16_t)0x0001)            /*!< Bit 0 */
+#define  WWDG_CFR_W1                         ((uint16_t)0x0002)            /*!< Bit 1 */
+#define  WWDG_CFR_W2                         ((uint16_t)0x0004)            /*!< Bit 2 */
+#define  WWDG_CFR_W3                         ((uint16_t)0x0008)            /*!< Bit 3 */
+#define  WWDG_CFR_W4                         ((uint16_t)0x0010)            /*!< Bit 4 */
+#define  WWDG_CFR_W5                         ((uint16_t)0x0020)            /*!< Bit 5 */
+#define  WWDG_CFR_W6                         ((uint16_t)0x0040)            /*!< Bit 6 */
+
+#define  WWDG_CFR_WDGTB                      ((uint16_t)0x0180)            /*!< WDGTB[1:0] bits (Timer Base) */
+#define  WWDG_CFR_WDGTB0                     ((uint16_t)0x0080)            /*!< Bit 0 */
+#define  WWDG_CFR_WDGTB1                     ((uint16_t)0x0100)            /*!< Bit 1 */
+
+#define  WWDG_CFR_EWI                        ((uint16_t)0x0200)            /*!< Early Wakeup Interrupt */
+
+/*******************  Bit definition for WWDG_SR register  ********************/
+#define  WWDG_SR_EWIF                        ((uint8_t)0x01)               /*!< Early Wakeup Interrupt Flag */
+
+/******************************************************************************/
+/*                                                                            */
+/*                       Flexible Static Memory Controller                    */
+/*                                                                            */
+/******************************************************************************/
+
+/******************  Bit definition for FSMC_BCR1 register  *******************/
+#define  FSMC_BCR1_MBKEN                     ((uint32_t)0x00000001)        /*!< Memory bank enable bit */
+#define  FSMC_BCR1_MUXEN                     ((uint32_t)0x00000002)        /*!< Address/data multiplexing enable bit */
+
+#define  FSMC_BCR1_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */
+#define  FSMC_BCR1_MTYP_0                    ((uint32_t)0x00000004)        /*!< Bit 0 */
+#define  FSMC_BCR1_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */
+
+#define  FSMC_BCR1_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */
+#define  FSMC_BCR1_MWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
+#define  FSMC_BCR1_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
+
+#define  FSMC_BCR1_FACCEN                    ((uint32_t)0x00000040)        /*!< Flash access enable */
+#define  FSMC_BCR1_BURSTEN                   ((uint32_t)0x00000100)        /*!< Burst enable bit */
+#define  FSMC_BCR1_WAITPOL                   ((uint32_t)0x00000200)        /*!< Wait signal polarity bit */
+#define  FSMC_BCR1_WRAPMOD                   ((uint32_t)0x00000400)        /*!< Wrapped burst mode support */
+#define  FSMC_BCR1_WAITCFG                   ((uint32_t)0x00000800)        /*!< Wait timing configuration */
+#define  FSMC_BCR1_WREN                      ((uint32_t)0x00001000)        /*!< Write enable bit */
+#define  FSMC_BCR1_WAITEN                    ((uint32_t)0x00002000)        /*!< Wait enable bit */
+#define  FSMC_BCR1_EXTMOD                    ((uint32_t)0x00004000)        /*!< Extended mode enable */
+#define  FSMC_BCR1_ASYNCWAIT                 ((uint32_t)0x00008000)       /*!< Asynchronous wait */
+#define  FSMC_BCR1_CBURSTRW                  ((uint32_t)0x00080000)        /*!< Write burst enable */
+
+/******************  Bit definition for FSMC_BCR2 register  *******************/
+#define  FSMC_BCR2_MBKEN                     ((uint32_t)0x00000001)        /*!< Memory bank enable bit */
+#define  FSMC_BCR2_MUXEN                     ((uint32_t)0x00000002)        /*!< Address/data multiplexing enable bit */
+
+#define  FSMC_BCR2_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */
+#define  FSMC_BCR2_MTYP_0                    ((uint32_t)0x00000004)        /*!< Bit 0 */
+#define  FSMC_BCR2_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */
+
+#define  FSMC_BCR2_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */
+#define  FSMC_BCR2_MWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
+#define  FSMC_BCR2_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
+
+#define  FSMC_BCR2_FACCEN                    ((uint32_t)0x00000040)        /*!< Flash access enable */
+#define  FSMC_BCR2_BURSTEN                   ((uint32_t)0x00000100)        /*!< Burst enable bit */
+#define  FSMC_BCR2_WAITPOL                   ((uint32_t)0x00000200)        /*!< Wait signal polarity bit */
+#define  FSMC_BCR2_WRAPMOD                   ((uint32_t)0x00000400)        /*!< Wrapped burst mode support */
+#define  FSMC_BCR2_WAITCFG                   ((uint32_t)0x00000800)        /*!< Wait timing configuration */
+#define  FSMC_BCR2_WREN                      ((uint32_t)0x00001000)        /*!< Write enable bit */
+#define  FSMC_BCR2_WAITEN                    ((uint32_t)0x00002000)        /*!< Wait enable bit */
+#define  FSMC_BCR2_EXTMOD                    ((uint32_t)0x00004000)        /*!< Extended mode enable */
+#define  FSMC_BCR2_ASYNCWAIT                 ((uint32_t)0x00008000)       /*!< Asynchronous wait */
+#define  FSMC_BCR2_CBURSTRW                  ((uint32_t)0x00080000)        /*!< Write burst enable */
+
+/******************  Bit definition for FSMC_BCR3 register  *******************/
+#define  FSMC_BCR3_MBKEN                     ((uint32_t)0x00000001)        /*!< Memory bank enable bit */
+#define  FSMC_BCR3_MUXEN                     ((uint32_t)0x00000002)        /*!< Address/data multiplexing enable bit */
+
+#define  FSMC_BCR3_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */
+#define  FSMC_BCR3_MTYP_0                    ((uint32_t)0x00000004)        /*!< Bit 0 */
+#define  FSMC_BCR3_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */
+
+#define  FSMC_BCR3_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */
+#define  FSMC_BCR3_MWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
+#define  FSMC_BCR3_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
+
+#define  FSMC_BCR3_FACCEN                    ((uint32_t)0x00000040)        /*!< Flash access enable */
+#define  FSMC_BCR3_BURSTEN                   ((uint32_t)0x00000100)        /*!< Burst enable bit */
+#define  FSMC_BCR3_WAITPOL                   ((uint32_t)0x00000200)        /*!< Wait signal polarity bit. */
+#define  FSMC_BCR3_WRAPMOD                   ((uint32_t)0x00000400)        /*!< Wrapped burst mode support */
+#define  FSMC_BCR3_WAITCFG                   ((uint32_t)0x00000800)        /*!< Wait timing configuration */
+#define  FSMC_BCR3_WREN                      ((uint32_t)0x00001000)        /*!< Write enable bit */
+#define  FSMC_BCR3_WAITEN                    ((uint32_t)0x00002000)        /*!< Wait enable bit */
+#define  FSMC_BCR3_EXTMOD                    ((uint32_t)0x00004000)        /*!< Extended mode enable */
+#define  FSMC_BCR3_ASYNCWAIT                 ((uint32_t)0x00008000)       /*!< Asynchronous wait */
+#define  FSMC_BCR3_CBURSTRW                  ((uint32_t)0x00080000)        /*!< Write burst enable */
+
+/******************  Bit definition for FSMC_BCR4 register  *******************/
+#define  FSMC_BCR4_MBKEN                     ((uint32_t)0x00000001)        /*!< Memory bank enable bit */
+#define  FSMC_BCR4_MUXEN                     ((uint32_t)0x00000002)        /*!< Address/data multiplexing enable bit */
+
+#define  FSMC_BCR4_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */
+#define  FSMC_BCR4_MTYP_0                    ((uint32_t)0x00000004)        /*!< Bit 0 */
+#define  FSMC_BCR4_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */
+
+#define  FSMC_BCR4_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */
+#define  FSMC_BCR4_MWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
+#define  FSMC_BCR4_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
+
+#define  FSMC_BCR4_FACCEN                    ((uint32_t)0x00000040)        /*!< Flash access enable */
+#define  FSMC_BCR4_BURSTEN                   ((uint32_t)0x00000100)        /*!< Burst enable bit */
+#define  FSMC_BCR4_WAITPOL                   ((uint32_t)0x00000200)        /*!< Wait signal polarity bit */
+#define  FSMC_BCR4_WRAPMOD                   ((uint32_t)0x00000400)        /*!< Wrapped burst mode support */
+#define  FSMC_BCR4_WAITCFG                   ((uint32_t)0x00000800)        /*!< Wait timing configuration */
+#define  FSMC_BCR4_WREN                      ((uint32_t)0x00001000)        /*!< Write enable bit */
+#define  FSMC_BCR4_WAITEN                    ((uint32_t)0x00002000)        /*!< Wait enable bit */
+#define  FSMC_BCR4_EXTMOD                    ((uint32_t)0x00004000)        /*!< Extended mode enable */
+#define  FSMC_BCR4_ASYNCWAIT                 ((uint32_t)0x00008000)       /*!< Asynchronous wait */
+#define  FSMC_BCR4_CBURSTRW                  ((uint32_t)0x00080000)        /*!< Write burst enable */
+
+/******************  Bit definition for FSMC_BTR1 register  ******************/
+#define  FSMC_BTR1_ADDSET                    ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
+#define  FSMC_BTR1_ADDSET_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */
+#define  FSMC_BTR1_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
+#define  FSMC_BTR1_ADDSET_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */
+#define  FSMC_BTR1_ADDSET_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */
+
+#define  FSMC_BTR1_ADDHLD                    ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
+#define  FSMC_BTR1_ADDHLD_0                  ((uint32_t)0x00000010)        /*!< Bit 0 */
+#define  FSMC_BTR1_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */
+#define  FSMC_BTR1_ADDHLD_2                  ((uint32_t)0x00000040)        /*!< Bit 2 */
+#define  FSMC_BTR1_ADDHLD_3                  ((uint32_t)0x00000080)        /*!< Bit 3 */
+
+#define  FSMC_BTR1_DATAST                    ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
+#define  FSMC_BTR1_DATAST_0                  ((uint32_t)0x00000100)        /*!< Bit 0 */
+#define  FSMC_BTR1_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */
+#define  FSMC_BTR1_DATAST_2                  ((uint32_t)0x00000400)        /*!< Bit 2 */
+#define  FSMC_BTR1_DATAST_3                  ((uint32_t)0x00000800)        /*!< Bit 3 */
+
+#define  FSMC_BTR1_BUSTURN                   ((uint32_t)0x000F0000)        /*!< BUSTURN[3:0] bits (Bus turnaround phase duration) */
+#define  FSMC_BTR1_BUSTURN_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */
+#define  FSMC_BTR1_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
+#define  FSMC_BTR1_BUSTURN_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */
+#define  FSMC_BTR1_BUSTURN_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */
+
+#define  FSMC_BTR1_CLKDIV                    ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
+#define  FSMC_BTR1_CLKDIV_0                  ((uint32_t)0x00100000)        /*!< Bit 0 */
+#define  FSMC_BTR1_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */
+#define  FSMC_BTR1_CLKDIV_2                  ((uint32_t)0x00400000)        /*!< Bit 2 */
+#define  FSMC_BTR1_CLKDIV_3                  ((uint32_t)0x00800000)        /*!< Bit 3 */
+
+#define  FSMC_BTR1_DATLAT                    ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
+#define  FSMC_BTR1_DATLAT_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
+#define  FSMC_BTR1_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
+#define  FSMC_BTR1_DATLAT_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
+#define  FSMC_BTR1_DATLAT_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */
+
+#define  FSMC_BTR1_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
+#define  FSMC_BTR1_ACCMOD_0                  ((uint32_t)0x10000000)        /*!< Bit 0 */
+#define  FSMC_BTR1_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */
+
+/******************  Bit definition for FSMC_BTR2 register  *******************/
+#define  FSMC_BTR2_ADDSET                    ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
+#define  FSMC_BTR2_ADDSET_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */
+#define  FSMC_BTR2_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
+#define  FSMC_BTR2_ADDSET_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */
+#define  FSMC_BTR2_ADDSET_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */
+
+#define  FSMC_BTR2_ADDHLD                    ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
+#define  FSMC_BTR2_ADDHLD_0                  ((uint32_t)0x00000010)        /*!< Bit 0 */
+#define  FSMC_BTR2_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */
+#define  FSMC_BTR2_ADDHLD_2                  ((uint32_t)0x00000040)        /*!< Bit 2 */
+#define  FSMC_BTR2_ADDHLD_3                  ((uint32_t)0x00000080)        /*!< Bit 3 */
+
+#define  FSMC_BTR2_DATAST                    ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
+#define  FSMC_BTR2_DATAST_0                  ((uint32_t)0x00000100)        /*!< Bit 0 */
+#define  FSMC_BTR2_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */
+#define  FSMC_BTR2_DATAST_2                  ((uint32_t)0x00000400)        /*!< Bit 2 */
+#define  FSMC_BTR2_DATAST_3                  ((uint32_t)0x00000800)        /*!< Bit 3 */
+
+#define  FSMC_BTR2_BUSTURN                   ((uint32_t)0x000F0000)        /*!< BUSTURN[3:0] bits (Bus turnaround phase duration) */
+#define  FSMC_BTR2_BUSTURN_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */
+#define  FSMC_BTR2_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
+#define  FSMC_BTR2_BUSTURN_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */
+#define  FSMC_BTR2_BUSTURN_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */
+
+#define  FSMC_BTR2_CLKDIV                    ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
+#define  FSMC_BTR2_CLKDIV_0                  ((uint32_t)0x00100000)        /*!< Bit 0 */
+#define  FSMC_BTR2_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */
+#define  FSMC_BTR2_CLKDIV_2                  ((uint32_t)0x00400000)        /*!< Bit 2 */
+#define  FSMC_BTR2_CLKDIV_3                  ((uint32_t)0x00800000)        /*!< Bit 3 */
+
+#define  FSMC_BTR2_DATLAT                    ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
+#define  FSMC_BTR2_DATLAT_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
+#define  FSMC_BTR2_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
+#define  FSMC_BTR2_DATLAT_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
+#define  FSMC_BTR2_DATLAT_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */
+
+#define  FSMC_BTR2_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
+#define  FSMC_BTR2_ACCMOD_0                  ((uint32_t)0x10000000)        /*!< Bit 0 */
+#define  FSMC_BTR2_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */
+
+/*******************  Bit definition for FSMC_BTR3 register  *******************/
+#define  FSMC_BTR3_ADDSET                    ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
+#define  FSMC_BTR3_ADDSET_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */
+#define  FSMC_BTR3_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
+#define  FSMC_BTR3_ADDSET_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */
+#define  FSMC_BTR3_ADDSET_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */
+
+#define  FSMC_BTR3_ADDHLD                    ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
+#define  FSMC_BTR3_ADDHLD_0                  ((uint32_t)0x00000010)        /*!< Bit 0 */
+#define  FSMC_BTR3_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */
+#define  FSMC_BTR3_ADDHLD_2                  ((uint32_t)0x00000040)        /*!< Bit 2 */
+#define  FSMC_BTR3_ADDHLD_3                  ((uint32_t)0x00000080)        /*!< Bit 3 */
+
+#define  FSMC_BTR3_DATAST                    ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
+#define  FSMC_BTR3_DATAST_0                  ((uint32_t)0x00000100)        /*!< Bit 0 */
+#define  FSMC_BTR3_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */
+#define  FSMC_BTR3_DATAST_2                  ((uint32_t)0x00000400)        /*!< Bit 2 */
+#define  FSMC_BTR3_DATAST_3                  ((uint32_t)0x00000800)        /*!< Bit 3 */
+
+#define  FSMC_BTR3_BUSTURN                   ((uint32_t)0x000F0000)        /*!< BUSTURN[3:0] bits (Bus turnaround phase duration) */
+#define  FSMC_BTR3_BUSTURN_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */
+#define  FSMC_BTR3_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
+#define  FSMC_BTR3_BUSTURN_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */
+#define  FSMC_BTR3_BUSTURN_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */
+
+#define  FSMC_BTR3_CLKDIV                    ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
+#define  FSMC_BTR3_CLKDIV_0                  ((uint32_t)0x00100000)        /*!< Bit 0 */
+#define  FSMC_BTR3_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */
+#define  FSMC_BTR3_CLKDIV_2                  ((uint32_t)0x00400000)        /*!< Bit 2 */
+#define  FSMC_BTR3_CLKDIV_3                  ((uint32_t)0x00800000)        /*!< Bit 3 */
+
+#define  FSMC_BTR3_DATLAT                    ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
+#define  FSMC_BTR3_DATLAT_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
+#define  FSMC_BTR3_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
+#define  FSMC_BTR3_DATLAT_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
+#define  FSMC_BTR3_DATLAT_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */
+
+#define  FSMC_BTR3_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
+#define  FSMC_BTR3_ACCMOD_0                  ((uint32_t)0x10000000)        /*!< Bit 0 */
+#define  FSMC_BTR3_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */
+
+/******************  Bit definition for FSMC_BTR4 register  *******************/
+#define  FSMC_BTR4_ADDSET                    ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
+#define  FSMC_BTR4_ADDSET_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */
+#define  FSMC_BTR4_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
+#define  FSMC_BTR4_ADDSET_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */
+#define  FSMC_BTR4_ADDSET_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */
+
+#define  FSMC_BTR4_ADDHLD                    ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
+#define  FSMC_BTR4_ADDHLD_0                  ((uint32_t)0x00000010)        /*!< Bit 0 */
+#define  FSMC_BTR4_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */
+#define  FSMC_BTR4_ADDHLD_2                  ((uint32_t)0x00000040)        /*!< Bit 2 */
+#define  FSMC_BTR4_ADDHLD_3                  ((uint32_t)0x00000080)        /*!< Bit 3 */
+
+#define  FSMC_BTR4_DATAST                    ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
+#define  FSMC_BTR4_DATAST_0                  ((uint32_t)0x00000100)        /*!< Bit 0 */
+#define  FSMC_BTR4_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */
+#define  FSMC_BTR4_DATAST_2                  ((uint32_t)0x00000400)        /*!< Bit 2 */
+#define  FSMC_BTR4_DATAST_3                  ((uint32_t)0x00000800)        /*!< Bit 3 */
+
+#define  FSMC_BTR4_BUSTURN                   ((uint32_t)0x000F0000)        /*!< BUSTURN[3:0] bits (Bus turnaround phase duration) */
+#define  FSMC_BTR4_BUSTURN_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */
+#define  FSMC_BTR4_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
+#define  FSMC_BTR4_BUSTURN_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */
+#define  FSMC_BTR4_BUSTURN_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */
+
+#define  FSMC_BTR4_CLKDIV                    ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
+#define  FSMC_BTR4_CLKDIV_0                  ((uint32_t)0x00100000)        /*!< Bit 0 */
+#define  FSMC_BTR4_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */
+#define  FSMC_BTR4_CLKDIV_2                  ((uint32_t)0x00400000)        /*!< Bit 2 */
+#define  FSMC_BTR4_CLKDIV_3                  ((uint32_t)0x00800000)        /*!< Bit 3 */
+
+#define  FSMC_BTR4_DATLAT                    ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
+#define  FSMC_BTR4_DATLAT_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
+#define  FSMC_BTR4_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
+#define  FSMC_BTR4_DATLAT_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
+#define  FSMC_BTR4_DATLAT_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */
+
+#define  FSMC_BTR4_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
+#define  FSMC_BTR4_ACCMOD_0                  ((uint32_t)0x10000000)        /*!< Bit 0 */
+#define  FSMC_BTR4_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */
+
+/******************  Bit definition for FSMC_BWTR1 register  ******************/
+#define  FSMC_BWTR1_ADDSET                   ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
+#define  FSMC_BWTR1_ADDSET_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */
+#define  FSMC_BWTR1_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
+#define  FSMC_BWTR1_ADDSET_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */
+#define  FSMC_BWTR1_ADDSET_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */
+
+#define  FSMC_BWTR1_ADDHLD                   ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
+#define  FSMC_BWTR1_ADDHLD_0                 ((uint32_t)0x00000010)        /*!< Bit 0 */
+#define  FSMC_BWTR1_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */
+#define  FSMC_BWTR1_ADDHLD_2                 ((uint32_t)0x00000040)        /*!< Bit 2 */
+#define  FSMC_BWTR1_ADDHLD_3                 ((uint32_t)0x00000080)        /*!< Bit 3 */
+
+#define  FSMC_BWTR1_DATAST                   ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
+#define  FSMC_BWTR1_DATAST_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */
+#define  FSMC_BWTR1_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
+#define  FSMC_BWTR1_DATAST_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */
+#define  FSMC_BWTR1_DATAST_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */
+
+#define  FSMC_BWTR1_CLKDIV                   ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
+#define  FSMC_BWTR1_CLKDIV_0                 ((uint32_t)0x00100000)        /*!< Bit 0 */
+#define  FSMC_BWTR1_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1 */
+#define  FSMC_BWTR1_CLKDIV_2                 ((uint32_t)0x00400000)        /*!< Bit 2 */
+#define  FSMC_BWTR1_CLKDIV_3                 ((uint32_t)0x00800000)        /*!< Bit 3 */
+
+#define  FSMC_BWTR1_DATLAT                   ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
+#define  FSMC_BWTR1_DATLAT_0                 ((uint32_t)0x01000000)        /*!< Bit 0 */
+#define  FSMC_BWTR1_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */
+#define  FSMC_BWTR1_DATLAT_2                 ((uint32_t)0x04000000)        /*!< Bit 2 */
+#define  FSMC_BWTR1_DATLAT_3                 ((uint32_t)0x08000000)        /*!< Bit 3 */
+
+#define  FSMC_BWTR1_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
+#define  FSMC_BWTR1_ACCMOD_0                 ((uint32_t)0x10000000)        /*!< Bit 0 */
+#define  FSMC_BWTR1_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */
+
+/******************  Bit definition for FSMC_BWTR2 register  ******************/
+#define  FSMC_BWTR2_ADDSET                   ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
+#define  FSMC_BWTR2_ADDSET_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */
+#define  FSMC_BWTR2_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
+#define  FSMC_BWTR2_ADDSET_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */
+#define  FSMC_BWTR2_ADDSET_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */
+
+#define  FSMC_BWTR2_ADDHLD                   ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
+#define  FSMC_BWTR2_ADDHLD_0                 ((uint32_t)0x00000010)        /*!< Bit 0 */
+#define  FSMC_BWTR2_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */
+#define  FSMC_BWTR2_ADDHLD_2                 ((uint32_t)0x00000040)        /*!< Bit 2 */
+#define  FSMC_BWTR2_ADDHLD_3                 ((uint32_t)0x00000080)        /*!< Bit 3 */
+
+#define  FSMC_BWTR2_DATAST                   ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
+#define  FSMC_BWTR2_DATAST_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */
+#define  FSMC_BWTR2_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
+#define  FSMC_BWTR2_DATAST_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */
+#define  FSMC_BWTR2_DATAST_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */
+
+#define  FSMC_BWTR2_CLKDIV                   ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
+#define  FSMC_BWTR2_CLKDIV_0                 ((uint32_t)0x00100000)        /*!< Bit 0 */
+#define  FSMC_BWTR2_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1*/
+#define  FSMC_BWTR2_CLKDIV_2                 ((uint32_t)0x00400000)        /*!< Bit 2 */
+#define  FSMC_BWTR2_CLKDIV_3                 ((uint32_t)0x00800000)        /*!< Bit 3 */
+
+#define  FSMC_BWTR2_DATLAT                   ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
+#define  FSMC_BWTR2_DATLAT_0                 ((uint32_t)0x01000000)        /*!< Bit 0 */
+#define  FSMC_BWTR2_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */
+#define  FSMC_BWTR2_DATLAT_2                 ((uint32_t)0x04000000)        /*!< Bit 2 */
+#define  FSMC_BWTR2_DATLAT_3                 ((uint32_t)0x08000000)        /*!< Bit 3 */
+
+#define  FSMC_BWTR2_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
+#define  FSMC_BWTR2_ACCMOD_0                 ((uint32_t)0x10000000)        /*!< Bit 0 */
+#define  FSMC_BWTR2_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */
+
+/******************  Bit definition for FSMC_BWTR3 register  ******************/
+#define  FSMC_BWTR3_ADDSET                   ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
+#define  FSMC_BWTR3_ADDSET_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */
+#define  FSMC_BWTR3_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
+#define  FSMC_BWTR3_ADDSET_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */
+#define  FSMC_BWTR3_ADDSET_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */
+
+#define  FSMC_BWTR3_ADDHLD                   ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
+#define  FSMC_BWTR3_ADDHLD_0                 ((uint32_t)0x00000010)        /*!< Bit 0 */
+#define  FSMC_BWTR3_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */
+#define  FSMC_BWTR3_ADDHLD_2                 ((uint32_t)0x00000040)        /*!< Bit 2 */
+#define  FSMC_BWTR3_ADDHLD_3                 ((uint32_t)0x00000080)        /*!< Bit 3 */
+
+#define  FSMC_BWTR3_DATAST                   ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
+#define  FSMC_BWTR3_DATAST_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */
+#define  FSMC_BWTR3_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
+#define  FSMC_BWTR3_DATAST_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */
+#define  FSMC_BWTR3_DATAST_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */
+
+#define  FSMC_BWTR3_CLKDIV                   ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
+#define  FSMC_BWTR3_CLKDIV_0                 ((uint32_t)0x00100000)        /*!< Bit 0 */
+#define  FSMC_BWTR3_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1 */
+#define  FSMC_BWTR3_CLKDIV_2                 ((uint32_t)0x00400000)        /*!< Bit 2 */
+#define  FSMC_BWTR3_CLKDIV_3                 ((uint32_t)0x00800000)        /*!< Bit 3 */
+
+#define  FSMC_BWTR3_DATLAT                   ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
+#define  FSMC_BWTR3_DATLAT_0                 ((uint32_t)0x01000000)        /*!< Bit 0 */
+#define  FSMC_BWTR3_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */
+#define  FSMC_BWTR3_DATLAT_2                 ((uint32_t)0x04000000)        /*!< Bit 2 */
+#define  FSMC_BWTR3_DATLAT_3                 ((uint32_t)0x08000000)        /*!< Bit 3 */
+
+#define  FSMC_BWTR3_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
+#define  FSMC_BWTR3_ACCMOD_0                 ((uint32_t)0x10000000)        /*!< Bit 0 */
+#define  FSMC_BWTR3_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */
+
+/******************  Bit definition for FSMC_BWTR4 register  ******************/
+#define  FSMC_BWTR4_ADDSET                   ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
+#define  FSMC_BWTR4_ADDSET_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */
+#define  FSMC_BWTR4_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
+#define  FSMC_BWTR4_ADDSET_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */
+#define  FSMC_BWTR4_ADDSET_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */
+
+#define  FSMC_BWTR4_ADDHLD                   ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
+#define  FSMC_BWTR4_ADDHLD_0                 ((uint32_t)0x00000010)        /*!< Bit 0 */
+#define  FSMC_BWTR4_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */
+#define  FSMC_BWTR4_ADDHLD_2                 ((uint32_t)0x00000040)        /*!< Bit 2 */
+#define  FSMC_BWTR4_ADDHLD_3                 ((uint32_t)0x00000080)        /*!< Bit 3 */
+
+#define  FSMC_BWTR4_DATAST                   ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
+#define  FSMC_BWTR4_DATAST_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */
+#define  FSMC_BWTR4_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
+#define  FSMC_BWTR4_DATAST_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */
+#define  FSMC_BWTR4_DATAST_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */
+
+#define  FSMC_BWTR4_CLKDIV                   ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
+#define  FSMC_BWTR4_CLKDIV_0                 ((uint32_t)0x00100000)        /*!< Bit 0 */
+#define  FSMC_BWTR4_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1 */
+#define  FSMC_BWTR4_CLKDIV_2                 ((uint32_t)0x00400000)        /*!< Bit 2 */
+#define  FSMC_BWTR4_CLKDIV_3                 ((uint32_t)0x00800000)        /*!< Bit 3 */
+
+#define  FSMC_BWTR4_DATLAT                   ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
+#define  FSMC_BWTR4_DATLAT_0                 ((uint32_t)0x01000000)        /*!< Bit 0 */
+#define  FSMC_BWTR4_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */
+#define  FSMC_BWTR4_DATLAT_2                 ((uint32_t)0x04000000)        /*!< Bit 2 */
+#define  FSMC_BWTR4_DATLAT_3                 ((uint32_t)0x08000000)        /*!< Bit 3 */
+
+#define  FSMC_BWTR4_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
+#define  FSMC_BWTR4_ACCMOD_0                 ((uint32_t)0x10000000)        /*!< Bit 0 */
+#define  FSMC_BWTR4_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */
+
+/******************  Bit definition for FSMC_PCR2 register  *******************/
+#define  FSMC_PCR2_PWAITEN                   ((uint32_t)0x00000002)        /*!< Wait feature enable bit */
+#define  FSMC_PCR2_PBKEN                     ((uint32_t)0x00000004)        /*!< PC Card/NAND Flash memory bank enable bit */
+#define  FSMC_PCR2_PTYP                      ((uint32_t)0x00000008)        /*!< Memory type */
+
+#define  FSMC_PCR2_PWID                      ((uint32_t)0x00000030)        /*!< PWID[1:0] bits (NAND Flash databus width) */
+#define  FSMC_PCR2_PWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
+#define  FSMC_PCR2_PWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
+
+#define  FSMC_PCR2_ECCEN                     ((uint32_t)0x00000040)        /*!< ECC computation logic enable bit */
+
+#define  FSMC_PCR2_TCLR                      ((uint32_t)0x00001E00)        /*!< TCLR[3:0] bits (CLE to RE delay) */
+#define  FSMC_PCR2_TCLR_0                    ((uint32_t)0x00000200)        /*!< Bit 0 */
+#define  FSMC_PCR2_TCLR_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */
+#define  FSMC_PCR2_TCLR_2                    ((uint32_t)0x00000800)        /*!< Bit 2 */
+#define  FSMC_PCR2_TCLR_3                    ((uint32_t)0x00001000)        /*!< Bit 3 */
+
+#define  FSMC_PCR2_TAR                       ((uint32_t)0x0001E000)        /*!< TAR[3:0] bits (ALE to RE delay) */
+#define  FSMC_PCR2_TAR_0                     ((uint32_t)0x00002000)        /*!< Bit 0 */
+#define  FSMC_PCR2_TAR_1                     ((uint32_t)0x00004000)        /*!< Bit 1 */
+#define  FSMC_PCR2_TAR_2                     ((uint32_t)0x00008000)        /*!< Bit 2 */
+#define  FSMC_PCR2_TAR_3                     ((uint32_t)0x00010000)        /*!< Bit 3 */
+
+#define  FSMC_PCR2_ECCPS                     ((uint32_t)0x000E0000)        /*!< ECCPS[1:0] bits (ECC page size) */
+#define  FSMC_PCR2_ECCPS_0                   ((uint32_t)0x00020000)        /*!< Bit 0 */
+#define  FSMC_PCR2_ECCPS_1                   ((uint32_t)0x00040000)        /*!< Bit 1 */
+#define  FSMC_PCR2_ECCPS_2                   ((uint32_t)0x00080000)        /*!< Bit 2 */
+
+/******************  Bit definition for FSMC_PCR3 register  *******************/
+#define  FSMC_PCR3_PWAITEN                   ((uint32_t)0x00000002)        /*!< Wait feature enable bit */
+#define  FSMC_PCR3_PBKEN                     ((uint32_t)0x00000004)        /*!< PC Card/NAND Flash memory bank enable bit */
+#define  FSMC_PCR3_PTYP                      ((uint32_t)0x00000008)        /*!< Memory type */
+
+#define  FSMC_PCR3_PWID                      ((uint32_t)0x00000030)        /*!< PWID[1:0] bits (NAND Flash databus width) */
+#define  FSMC_PCR3_PWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
+#define  FSMC_PCR3_PWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
+
+#define  FSMC_PCR3_ECCEN                     ((uint32_t)0x00000040)        /*!< ECC computation logic enable bit */
+
+#define  FSMC_PCR3_TCLR                      ((uint32_t)0x00001E00)        /*!< TCLR[3:0] bits (CLE to RE delay) */
+#define  FSMC_PCR3_TCLR_0                    ((uint32_t)0x00000200)        /*!< Bit 0 */
+#define  FSMC_PCR3_TCLR_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */
+#define  FSMC_PCR3_TCLR_2                    ((uint32_t)0x00000800)        /*!< Bit 2 */
+#define  FSMC_PCR3_TCLR_3                    ((uint32_t)0x00001000)        /*!< Bit 3 */
+
+#define  FSMC_PCR3_TAR                       ((uint32_t)0x0001E000)        /*!< TAR[3:0] bits (ALE to RE delay) */
+#define  FSMC_PCR3_TAR_0                     ((uint32_t)0x00002000)        /*!< Bit 0 */
+#define  FSMC_PCR3_TAR_1                     ((uint32_t)0x00004000)        /*!< Bit 1 */
+#define  FSMC_PCR3_TAR_2                     ((uint32_t)0x00008000)        /*!< Bit 2 */
+#define  FSMC_PCR3_TAR_3                     ((uint32_t)0x00010000)        /*!< Bit 3 */
+
+#define  FSMC_PCR3_ECCPS                     ((uint32_t)0x000E0000)        /*!< ECCPS[2:0] bits (ECC page size) */
+#define  FSMC_PCR3_ECCPS_0                   ((uint32_t)0x00020000)        /*!< Bit 0 */
+#define  FSMC_PCR3_ECCPS_1                   ((uint32_t)0x00040000)        /*!< Bit 1 */
+#define  FSMC_PCR3_ECCPS_2                   ((uint32_t)0x00080000)        /*!< Bit 2 */
+
+/******************  Bit definition for FSMC_PCR4 register  *******************/
+#define  FSMC_PCR4_PWAITEN                   ((uint32_t)0x00000002)        /*!< Wait feature enable bit */
+#define  FSMC_PCR4_PBKEN                     ((uint32_t)0x00000004)        /*!< PC Card/NAND Flash memory bank enable bit */
+#define  FSMC_PCR4_PTYP                      ((uint32_t)0x00000008)        /*!< Memory type */
+
+#define  FSMC_PCR4_PWID                      ((uint32_t)0x00000030)        /*!< PWID[1:0] bits (NAND Flash databus width) */
+#define  FSMC_PCR4_PWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
+#define  FSMC_PCR4_PWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
+
+#define  FSMC_PCR4_ECCEN                     ((uint32_t)0x00000040)        /*!< ECC computation logic enable bit */
+
+#define  FSMC_PCR4_TCLR                      ((uint32_t)0x00001E00)        /*!< TCLR[3:0] bits (CLE to RE delay) */
+#define  FSMC_PCR4_TCLR_0                    ((uint32_t)0x00000200)        /*!< Bit 0 */
+#define  FSMC_PCR4_TCLR_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */
+#define  FSMC_PCR4_TCLR_2                    ((uint32_t)0x00000800)        /*!< Bit 2 */
+#define  FSMC_PCR4_TCLR_3                    ((uint32_t)0x00001000)        /*!< Bit 3 */
+
+#define  FSMC_PCR4_TAR                       ((uint32_t)0x0001E000)        /*!< TAR[3:0] bits (ALE to RE delay) */
+#define  FSMC_PCR4_TAR_0                     ((uint32_t)0x00002000)        /*!< Bit 0 */
+#define  FSMC_PCR4_TAR_1                     ((uint32_t)0x00004000)        /*!< Bit 1 */
+#define  FSMC_PCR4_TAR_2                     ((uint32_t)0x00008000)        /*!< Bit 2 */
+#define  FSMC_PCR4_TAR_3                     ((uint32_t)0x00010000)        /*!< Bit 3 */
+
+#define  FSMC_PCR4_ECCPS                     ((uint32_t)0x000E0000)        /*!< ECCPS[2:0] bits (ECC page size) */
+#define  FSMC_PCR4_ECCPS_0                   ((uint32_t)0x00020000)        /*!< Bit 0 */
+#define  FSMC_PCR4_ECCPS_1                   ((uint32_t)0x00040000)        /*!< Bit 1 */
+#define  FSMC_PCR4_ECCPS_2                   ((uint32_t)0x00080000)        /*!< Bit 2 */
+
+/*******************  Bit definition for FSMC_SR2 register  *******************/
+#define  FSMC_SR2_IRS                        ((uint8_t)0x01)               /*!< Interrupt Rising Edge status */
+#define  FSMC_SR2_ILS                        ((uint8_t)0x02)               /*!< Interrupt Level status */
+#define  FSMC_SR2_IFS                        ((uint8_t)0x04)               /*!< Interrupt Falling Edge status */
+#define  FSMC_SR2_IREN                       ((uint8_t)0x08)               /*!< Interrupt Rising Edge detection Enable bit */
+#define  FSMC_SR2_ILEN                       ((uint8_t)0x10)               /*!< Interrupt Level detection Enable bit */
+#define  FSMC_SR2_IFEN                       ((uint8_t)0x20)               /*!< Interrupt Falling Edge detection Enable bit */
+#define  FSMC_SR2_FEMPT                      ((uint8_t)0x40)               /*!< FIFO empty */
+
+/*******************  Bit definition for FSMC_SR3 register  *******************/
+#define  FSMC_SR3_IRS                        ((uint8_t)0x01)               /*!< Interrupt Rising Edge status */
+#define  FSMC_SR3_ILS                        ((uint8_t)0x02)               /*!< Interrupt Level status */
+#define  FSMC_SR3_IFS                        ((uint8_t)0x04)               /*!< Interrupt Falling Edge status */
+#define  FSMC_SR3_IREN                       ((uint8_t)0x08)               /*!< Interrupt Rising Edge detection Enable bit */
+#define  FSMC_SR3_ILEN                       ((uint8_t)0x10)               /*!< Interrupt Level detection Enable bit */
+#define  FSMC_SR3_IFEN                       ((uint8_t)0x20)               /*!< Interrupt Falling Edge detection Enable bit */
+#define  FSMC_SR3_FEMPT                      ((uint8_t)0x40)               /*!< FIFO empty */
+
+/*******************  Bit definition for FSMC_SR4 register  *******************/
+#define  FSMC_SR4_IRS                        ((uint8_t)0x01)               /*!< Interrupt Rising Edge status */
+#define  FSMC_SR4_ILS                        ((uint8_t)0x02)               /*!< Interrupt Level status */
+#define  FSMC_SR4_IFS                        ((uint8_t)0x04)               /*!< Interrupt Falling Edge status */
+#define  FSMC_SR4_IREN                       ((uint8_t)0x08)               /*!< Interrupt Rising Edge detection Enable bit */
+#define  FSMC_SR4_ILEN                       ((uint8_t)0x10)               /*!< Interrupt Level detection Enable bit */
+#define  FSMC_SR4_IFEN                       ((uint8_t)0x20)               /*!< Interrupt Falling Edge detection Enable bit */
+#define  FSMC_SR4_FEMPT                      ((uint8_t)0x40)               /*!< FIFO empty */
+
+/******************  Bit definition for FSMC_PMEM2 register  ******************/
+#define  FSMC_PMEM2_MEMSET2                  ((uint32_t)0x000000FF)        /*!< MEMSET2[7:0] bits (Common memory 2 setup time) */
+#define  FSMC_PMEM2_MEMSET2_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
+#define  FSMC_PMEM2_MEMSET2_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
+#define  FSMC_PMEM2_MEMSET2_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
+#define  FSMC_PMEM2_MEMSET2_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
+#define  FSMC_PMEM2_MEMSET2_4                ((uint32_t)0x00000010)        /*!< Bit 4 */
+#define  FSMC_PMEM2_MEMSET2_5                ((uint32_t)0x00000020)        /*!< Bit 5 */
+#define  FSMC_PMEM2_MEMSET2_6                ((uint32_t)0x00000040)        /*!< Bit 6 */
+#define  FSMC_PMEM2_MEMSET2_7                ((uint32_t)0x00000080)        /*!< Bit 7 */
+
+#define  FSMC_PMEM2_MEMWAIT2                 ((uint32_t)0x0000FF00)        /*!< MEMWAIT2[7:0] bits (Common memory 2 wait time) */
+#define  FSMC_PMEM2_MEMWAIT2_0               ((uint32_t)0x00000100)        /*!< Bit 0 */
+#define  FSMC_PMEM2_MEMWAIT2_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
+#define  FSMC_PMEM2_MEMWAIT2_2               ((uint32_t)0x00000400)        /*!< Bit 2 */
+#define  FSMC_PMEM2_MEMWAIT2_3               ((uint32_t)0x00000800)        /*!< Bit 3 */
+#define  FSMC_PMEM2_MEMWAIT2_4               ((uint32_t)0x00001000)        /*!< Bit 4 */
+#define  FSMC_PMEM2_MEMWAIT2_5               ((uint32_t)0x00002000)        /*!< Bit 5 */
+#define  FSMC_PMEM2_MEMWAIT2_6               ((uint32_t)0x00004000)        /*!< Bit 6 */
+#define  FSMC_PMEM2_MEMWAIT2_7               ((uint32_t)0x00008000)        /*!< Bit 7 */
+
+#define  FSMC_PMEM2_MEMHOLD2                 ((uint32_t)0x00FF0000)        /*!< MEMHOLD2[7:0] bits (Common memory 2 hold time) */
+#define  FSMC_PMEM2_MEMHOLD2_0               ((uint32_t)0x00010000)        /*!< Bit 0 */
+#define  FSMC_PMEM2_MEMHOLD2_1               ((uint32_t)0x00020000)        /*!< Bit 1 */
+#define  FSMC_PMEM2_MEMHOLD2_2               ((uint32_t)0x00040000)        /*!< Bit 2 */
+#define  FSMC_PMEM2_MEMHOLD2_3               ((uint32_t)0x00080000)        /*!< Bit 3 */
+#define  FSMC_PMEM2_MEMHOLD2_4               ((uint32_t)0x00100000)        /*!< Bit 4 */
+#define  FSMC_PMEM2_MEMHOLD2_5               ((uint32_t)0x00200000)        /*!< Bit 5 */
+#define  FSMC_PMEM2_MEMHOLD2_6               ((uint32_t)0x00400000)        /*!< Bit 6 */
+#define  FSMC_PMEM2_MEMHOLD2_7               ((uint32_t)0x00800000)        /*!< Bit 7 */
+
+#define  FSMC_PMEM2_MEMHIZ2                  ((uint32_t)0xFF000000)        /*!< MEMHIZ2[7:0] bits (Common memory 2 databus HiZ time) */
+#define  FSMC_PMEM2_MEMHIZ2_0                ((uint32_t)0x01000000)        /*!< Bit 0 */
+#define  FSMC_PMEM2_MEMHIZ2_1                ((uint32_t)0x02000000)        /*!< Bit 1 */
+#define  FSMC_PMEM2_MEMHIZ2_2                ((uint32_t)0x04000000)        /*!< Bit 2 */
+#define  FSMC_PMEM2_MEMHIZ2_3                ((uint32_t)0x08000000)        /*!< Bit 3 */
+#define  FSMC_PMEM2_MEMHIZ2_4                ((uint32_t)0x10000000)        /*!< Bit 4 */
+#define  FSMC_PMEM2_MEMHIZ2_5                ((uint32_t)0x20000000)        /*!< Bit 5 */
+#define  FSMC_PMEM2_MEMHIZ2_6                ((uint32_t)0x40000000)        /*!< Bit 6 */
+#define  FSMC_PMEM2_MEMHIZ2_7                ((uint32_t)0x80000000)        /*!< Bit 7 */
+
+/******************  Bit definition for FSMC_PMEM3 register  ******************/
+#define  FSMC_PMEM3_MEMSET3                  ((uint32_t)0x000000FF)        /*!< MEMSET3[7:0] bits (Common memory 3 setup time) */
+#define  FSMC_PMEM3_MEMSET3_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
+#define  FSMC_PMEM3_MEMSET3_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
+#define  FSMC_PMEM3_MEMSET3_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
+#define  FSMC_PMEM3_MEMSET3_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
+#define  FSMC_PMEM3_MEMSET3_4                ((uint32_t)0x00000010)        /*!< Bit 4 */
+#define  FSMC_PMEM3_MEMSET3_5                ((uint32_t)0x00000020)        /*!< Bit 5 */
+#define  FSMC_PMEM3_MEMSET3_6                ((uint32_t)0x00000040)        /*!< Bit 6 */
+#define  FSMC_PMEM3_MEMSET3_7                ((uint32_t)0x00000080)        /*!< Bit 7 */
+
+#define  FSMC_PMEM3_MEMWAIT3                 ((uint32_t)0x0000FF00)        /*!< MEMWAIT3[7:0] bits (Common memory 3 wait time) */
+#define  FSMC_PMEM3_MEMWAIT3_0               ((uint32_t)0x00000100)        /*!< Bit 0 */
+#define  FSMC_PMEM3_MEMWAIT3_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
+#define  FSMC_PMEM3_MEMWAIT3_2               ((uint32_t)0x00000400)        /*!< Bit 2 */
+#define  FSMC_PMEM3_MEMWAIT3_3               ((uint32_t)0x00000800)        /*!< Bit 3 */
+#define  FSMC_PMEM3_MEMWAIT3_4               ((uint32_t)0x00001000)        /*!< Bit 4 */
+#define  FSMC_PMEM3_MEMWAIT3_5               ((uint32_t)0x00002000)        /*!< Bit 5 */
+#define  FSMC_PMEM3_MEMWAIT3_6               ((uint32_t)0x00004000)        /*!< Bit 6 */
+#define  FSMC_PMEM3_MEMWAIT3_7               ((uint32_t)0x00008000)        /*!< Bit 7 */
+
+#define  FSMC_PMEM3_MEMHOLD3                 ((uint32_t)0x00FF0000)        /*!< MEMHOLD3[7:0] bits (Common memory 3 hold time) */
+#define  FSMC_PMEM3_MEMHOLD3_0               ((uint32_t)0x00010000)        /*!< Bit 0 */
+#define  FSMC_PMEM3_MEMHOLD3_1               ((uint32_t)0x00020000)        /*!< Bit 1 */
+#define  FSMC_PMEM3_MEMHOLD3_2               ((uint32_t)0x00040000)        /*!< Bit 2 */
+#define  FSMC_PMEM3_MEMHOLD3_3               ((uint32_t)0x00080000)        /*!< Bit 3 */
+#define  FSMC_PMEM3_MEMHOLD3_4               ((uint32_t)0x00100000)        /*!< Bit 4 */
+#define  FSMC_PMEM3_MEMHOLD3_5               ((uint32_t)0x00200000)        /*!< Bit 5 */
+#define  FSMC_PMEM3_MEMHOLD3_6               ((uint32_t)0x00400000)        /*!< Bit 6 */
+#define  FSMC_PMEM3_MEMHOLD3_7               ((uint32_t)0x00800000)        /*!< Bit 7 */
+
+#define  FSMC_PMEM3_MEMHIZ3                  ((uint32_t)0xFF000000)        /*!< MEMHIZ3[7:0] bits (Common memory 3 databus HiZ time) */
+#define  FSMC_PMEM3_MEMHIZ3_0                ((uint32_t)0x01000000)        /*!< Bit 0 */
+#define  FSMC_PMEM3_MEMHIZ3_1                ((uint32_t)0x02000000)        /*!< Bit 1 */
+#define  FSMC_PMEM3_MEMHIZ3_2                ((uint32_t)0x04000000)        /*!< Bit 2 */
+#define  FSMC_PMEM3_MEMHIZ3_3                ((uint32_t)0x08000000)        /*!< Bit 3 */
+#define  FSMC_PMEM3_MEMHIZ3_4                ((uint32_t)0x10000000)        /*!< Bit 4 */
+#define  FSMC_PMEM3_MEMHIZ3_5                ((uint32_t)0x20000000)        /*!< Bit 5 */
+#define  FSMC_PMEM3_MEMHIZ3_6                ((uint32_t)0x40000000)        /*!< Bit 6 */
+#define  FSMC_PMEM3_MEMHIZ3_7                ((uint32_t)0x80000000)        /*!< Bit 7 */
+
+/******************  Bit definition for FSMC_PMEM4 register  ******************/
+#define  FSMC_PMEM4_MEMSET4                  ((uint32_t)0x000000FF)        /*!< MEMSET4[7:0] bits (Common memory 4 setup time) */
+#define  FSMC_PMEM4_MEMSET4_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
+#define  FSMC_PMEM4_MEMSET4_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
+#define  FSMC_PMEM4_MEMSET4_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
+#define  FSMC_PMEM4_MEMSET4_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
+#define  FSMC_PMEM4_MEMSET4_4                ((uint32_t)0x00000010)        /*!< Bit 4 */
+#define  FSMC_PMEM4_MEMSET4_5                ((uint32_t)0x00000020)        /*!< Bit 5 */
+#define  FSMC_PMEM4_MEMSET4_6                ((uint32_t)0x00000040)        /*!< Bit 6 */
+#define  FSMC_PMEM4_MEMSET4_7                ((uint32_t)0x00000080)        /*!< Bit 7 */
+
+#define  FSMC_PMEM4_MEMWAIT4                 ((uint32_t)0x0000FF00)        /*!< MEMWAIT4[7:0] bits (Common memory 4 wait time) */
+#define  FSMC_PMEM4_MEMWAIT4_0               ((uint32_t)0x00000100)        /*!< Bit 0 */
+#define  FSMC_PMEM4_MEMWAIT4_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
+#define  FSMC_PMEM4_MEMWAIT4_2               ((uint32_t)0x00000400)        /*!< Bit 2 */
+#define  FSMC_PMEM4_MEMWAIT4_3               ((uint32_t)0x00000800)        /*!< Bit 3 */
+#define  FSMC_PMEM4_MEMWAIT4_4               ((uint32_t)0x00001000)        /*!< Bit 4 */
+#define  FSMC_PMEM4_MEMWAIT4_5               ((uint32_t)0x00002000)        /*!< Bit 5 */
+#define  FSMC_PMEM4_MEMWAIT4_6               ((uint32_t)0x00004000)        /*!< Bit 6 */
+#define  FSMC_PMEM4_MEMWAIT4_7               ((uint32_t)0x00008000)        /*!< Bit 7 */
+
+#define  FSMC_PMEM4_MEMHOLD4                 ((uint32_t)0x00FF0000)        /*!< MEMHOLD4[7:0] bits (Common memory 4 hold time) */
+#define  FSMC_PMEM4_MEMHOLD4_0               ((uint32_t)0x00010000)        /*!< Bit 0 */
+#define  FSMC_PMEM4_MEMHOLD4_1               ((uint32_t)0x00020000)        /*!< Bit 1 */
+#define  FSMC_PMEM4_MEMHOLD4_2               ((uint32_t)0x00040000)        /*!< Bit 2 */
+#define  FSMC_PMEM4_MEMHOLD4_3               ((uint32_t)0x00080000)        /*!< Bit 3 */
+#define  FSMC_PMEM4_MEMHOLD4_4               ((uint32_t)0x00100000)        /*!< Bit 4 */
+#define  FSMC_PMEM4_MEMHOLD4_5               ((uint32_t)0x00200000)        /*!< Bit 5 */
+#define  FSMC_PMEM4_MEMHOLD4_6               ((uint32_t)0x00400000)        /*!< Bit 6 */
+#define  FSMC_PMEM4_MEMHOLD4_7               ((uint32_t)0x00800000)        /*!< Bit 7 */
+
+#define  FSMC_PMEM4_MEMHIZ4                  ((uint32_t)0xFF000000)        /*!< MEMHIZ4[7:0] bits (Common memory 4 databus HiZ time) */
+#define  FSMC_PMEM4_MEMHIZ4_0                ((uint32_t)0x01000000)        /*!< Bit 0 */
+#define  FSMC_PMEM4_MEMHIZ4_1                ((uint32_t)0x02000000)        /*!< Bit 1 */
+#define  FSMC_PMEM4_MEMHIZ4_2                ((uint32_t)0x04000000)        /*!< Bit 2 */
+#define  FSMC_PMEM4_MEMHIZ4_3                ((uint32_t)0x08000000)        /*!< Bit 3 */
+#define  FSMC_PMEM4_MEMHIZ4_4                ((uint32_t)0x10000000)        /*!< Bit 4 */
+#define  FSMC_PMEM4_MEMHIZ4_5                ((uint32_t)0x20000000)        /*!< Bit 5 */
+#define  FSMC_PMEM4_MEMHIZ4_6                ((uint32_t)0x40000000)        /*!< Bit 6 */
+#define  FSMC_PMEM4_MEMHIZ4_7                ((uint32_t)0x80000000)        /*!< Bit 7 */
+
+/******************  Bit definition for FSMC_PATT2 register  ******************/
+#define  FSMC_PATT2_ATTSET2                  ((uint32_t)0x000000FF)        /*!< ATTSET2[7:0] bits (Attribute memory 2 setup time) */
+#define  FSMC_PATT2_ATTSET2_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
+#define  FSMC_PATT2_ATTSET2_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
+#define  FSMC_PATT2_ATTSET2_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
+#define  FSMC_PATT2_ATTSET2_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
+#define  FSMC_PATT2_ATTSET2_4                ((uint32_t)0x00000010)        /*!< Bit 4 */
+#define  FSMC_PATT2_ATTSET2_5                ((uint32_t)0x00000020)        /*!< Bit 5 */
+#define  FSMC_PATT2_ATTSET2_6                ((uint32_t)0x00000040)        /*!< Bit 6 */
+#define  FSMC_PATT2_ATTSET2_7                ((uint32_t)0x00000080)        /*!< Bit 7 */
+
+#define  FSMC_PATT2_ATTWAIT2                 ((uint32_t)0x0000FF00)        /*!< ATTWAIT2[7:0] bits (Attribute memory 2 wait time) */
+#define  FSMC_PATT2_ATTWAIT2_0               ((uint32_t)0x00000100)        /*!< Bit 0 */
+#define  FSMC_PATT2_ATTWAIT2_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
+#define  FSMC_PATT2_ATTWAIT2_2               ((uint32_t)0x00000400)        /*!< Bit 2 */
+#define  FSMC_PATT2_ATTWAIT2_3               ((uint32_t)0x00000800)        /*!< Bit 3 */
+#define  FSMC_PATT2_ATTWAIT2_4               ((uint32_t)0x00001000)        /*!< Bit 4 */
+#define  FSMC_PATT2_ATTWAIT2_5               ((uint32_t)0x00002000)        /*!< Bit 5 */
+#define  FSMC_PATT2_ATTWAIT2_6               ((uint32_t)0x00004000)        /*!< Bit 6 */
+#define  FSMC_PATT2_ATTWAIT2_7               ((uint32_t)0x00008000)        /*!< Bit 7 */
+
+#define  FSMC_PATT2_ATTHOLD2                 ((uint32_t)0x00FF0000)        /*!< ATTHOLD2[7:0] bits (Attribute memory 2 hold time) */
+#define  FSMC_PATT2_ATTHOLD2_0               ((uint32_t)0x00010000)        /*!< Bit 0 */
+#define  FSMC_PATT2_ATTHOLD2_1               ((uint32_t)0x00020000)        /*!< Bit 1 */
+#define  FSMC_PATT2_ATTHOLD2_2               ((uint32_t)0x00040000)        /*!< Bit 2 */
+#define  FSMC_PATT2_ATTHOLD2_3               ((uint32_t)0x00080000)        /*!< Bit 3 */
+#define  FSMC_PATT2_ATTHOLD2_4               ((uint32_t)0x00100000)        /*!< Bit 4 */
+#define  FSMC_PATT2_ATTHOLD2_5               ((uint32_t)0x00200000)        /*!< Bit 5 */
+#define  FSMC_PATT2_ATTHOLD2_6               ((uint32_t)0x00400000)        /*!< Bit 6 */
+#define  FSMC_PATT2_ATTHOLD2_7               ((uint32_t)0x00800000)        /*!< Bit 7 */
+
+#define  FSMC_PATT2_ATTHIZ2                  ((uint32_t)0xFF000000)        /*!< ATTHIZ2[7:0] bits (Attribute memory 2 databus HiZ time) */
+#define  FSMC_PATT2_ATTHIZ2_0                ((uint32_t)0x01000000)        /*!< Bit 0 */
+#define  FSMC_PATT2_ATTHIZ2_1                ((uint32_t)0x02000000)        /*!< Bit 1 */
+#define  FSMC_PATT2_ATTHIZ2_2                ((uint32_t)0x04000000)        /*!< Bit 2 */
+#define  FSMC_PATT2_ATTHIZ2_3                ((uint32_t)0x08000000)        /*!< Bit 3 */
+#define  FSMC_PATT2_ATTHIZ2_4                ((uint32_t)0x10000000)        /*!< Bit 4 */
+#define  FSMC_PATT2_ATTHIZ2_5                ((uint32_t)0x20000000)        /*!< Bit 5 */
+#define  FSMC_PATT2_ATTHIZ2_6                ((uint32_t)0x40000000)        /*!< Bit 6 */
+#define  FSMC_PATT2_ATTHIZ2_7                ((uint32_t)0x80000000)        /*!< Bit 7 */
+
+/******************  Bit definition for FSMC_PATT3 register  ******************/
+#define  FSMC_PATT3_ATTSET3                  ((uint32_t)0x000000FF)        /*!< ATTSET3[7:0] bits (Attribute memory 3 setup time) */
+#define  FSMC_PATT3_ATTSET3_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
+#define  FSMC_PATT3_ATTSET3_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
+#define  FSMC_PATT3_ATTSET3_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
+#define  FSMC_PATT3_ATTSET3_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
+#define  FSMC_PATT3_ATTSET3_4                ((uint32_t)0x00000010)        /*!< Bit 4 */
+#define  FSMC_PATT3_ATTSET3_5                ((uint32_t)0x00000020)        /*!< Bit 5 */
+#define  FSMC_PATT3_ATTSET3_6                ((uint32_t)0x00000040)        /*!< Bit 6 */
+#define  FSMC_PATT3_ATTSET3_7                ((uint32_t)0x00000080)        /*!< Bit 7 */
+
+#define  FSMC_PATT3_ATTWAIT3                 ((uint32_t)0x0000FF00)        /*!< ATTWAIT3[7:0] bits (Attribute memory 3 wait time) */
+#define  FSMC_PATT3_ATTWAIT3_0               ((uint32_t)0x00000100)        /*!< Bit 0 */
+#define  FSMC_PATT3_ATTWAIT3_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
+#define  FSMC_PATT3_ATTWAIT3_2               ((uint32_t)0x00000400)        /*!< Bit 2 */
+#define  FSMC_PATT3_ATTWAIT3_3               ((uint32_t)0x00000800)        /*!< Bit 3 */
+#define  FSMC_PATT3_ATTWAIT3_4               ((uint32_t)0x00001000)        /*!< Bit 4 */
+#define  FSMC_PATT3_ATTWAIT3_5               ((uint32_t)0x00002000)        /*!< Bit 5 */
+#define  FSMC_PATT3_ATTWAIT3_6               ((uint32_t)0x00004000)        /*!< Bit 6 */
+#define  FSMC_PATT3_ATTWAIT3_7               ((uint32_t)0x00008000)        /*!< Bit 7 */
+
+#define  FSMC_PATT3_ATTHOLD3                 ((uint32_t)0x00FF0000)        /*!< ATTHOLD3[7:0] bits (Attribute memory 3 hold time) */
+#define  FSMC_PATT3_ATTHOLD3_0               ((uint32_t)0x00010000)        /*!< Bit 0 */
+#define  FSMC_PATT3_ATTHOLD3_1               ((uint32_t)0x00020000)        /*!< Bit 1 */
+#define  FSMC_PATT3_ATTHOLD3_2               ((uint32_t)0x00040000)        /*!< Bit 2 */
+#define  FSMC_PATT3_ATTHOLD3_3               ((uint32_t)0x00080000)        /*!< Bit 3 */
+#define  FSMC_PATT3_ATTHOLD3_4               ((uint32_t)0x00100000)        /*!< Bit 4 */
+#define  FSMC_PATT3_ATTHOLD3_5               ((uint32_t)0x00200000)        /*!< Bit 5 */
+#define  FSMC_PATT3_ATTHOLD3_6               ((uint32_t)0x00400000)        /*!< Bit 6 */
+#define  FSMC_PATT3_ATTHOLD3_7               ((uint32_t)0x00800000)        /*!< Bit 7 */
+
+#define  FSMC_PATT3_ATTHIZ3                  ((uint32_t)0xFF000000)        /*!< ATTHIZ3[7:0] bits (Attribute memory 3 databus HiZ time) */
+#define  FSMC_PATT3_ATTHIZ3_0                ((uint32_t)0x01000000)        /*!< Bit 0 */
+#define  FSMC_PATT3_ATTHIZ3_1                ((uint32_t)0x02000000)        /*!< Bit 1 */
+#define  FSMC_PATT3_ATTHIZ3_2                ((uint32_t)0x04000000)        /*!< Bit 2 */
+#define  FSMC_PATT3_ATTHIZ3_3                ((uint32_t)0x08000000)        /*!< Bit 3 */
+#define  FSMC_PATT3_ATTHIZ3_4                ((uint32_t)0x10000000)        /*!< Bit 4 */
+#define  FSMC_PATT3_ATTHIZ3_5                ((uint32_t)0x20000000)        /*!< Bit 5 */
+#define  FSMC_PATT3_ATTHIZ3_6                ((uint32_t)0x40000000)        /*!< Bit 6 */
+#define  FSMC_PATT3_ATTHIZ3_7                ((uint32_t)0x80000000)        /*!< Bit 7 */
+
+/******************  Bit definition for FSMC_PATT4 register  ******************/
+#define  FSMC_PATT4_ATTSET4                  ((uint32_t)0x000000FF)        /*!< ATTSET4[7:0] bits (Attribute memory 4 setup time) */
+#define  FSMC_PATT4_ATTSET4_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
+#define  FSMC_PATT4_ATTSET4_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
+#define  FSMC_PATT4_ATTSET4_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
+#define  FSMC_PATT4_ATTSET4_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
+#define  FSMC_PATT4_ATTSET4_4                ((uint32_t)0x00000010)        /*!< Bit 4 */
+#define  FSMC_PATT4_ATTSET4_5                ((uint32_t)0x00000020)        /*!< Bit 5 */
+#define  FSMC_PATT4_ATTSET4_6                ((uint32_t)0x00000040)        /*!< Bit 6 */
+#define  FSMC_PATT4_ATTSET4_7                ((uint32_t)0x00000080)        /*!< Bit 7 */
+
+#define  FSMC_PATT4_ATTWAIT4                 ((uint32_t)0x0000FF00)        /*!< ATTWAIT4[7:0] bits (Attribute memory 4 wait time) */
+#define  FSMC_PATT4_ATTWAIT4_0               ((uint32_t)0x00000100)        /*!< Bit 0 */
+#define  FSMC_PATT4_ATTWAIT4_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
+#define  FSMC_PATT4_ATTWAIT4_2               ((uint32_t)0x00000400)        /*!< Bit 2 */
+#define  FSMC_PATT4_ATTWAIT4_3               ((uint32_t)0x00000800)        /*!< Bit 3 */
+#define  FSMC_PATT4_ATTWAIT4_4               ((uint32_t)0x00001000)        /*!< Bit 4 */
+#define  FSMC_PATT4_ATTWAIT4_5               ((uint32_t)0x00002000)        /*!< Bit 5 */
+#define  FSMC_PATT4_ATTWAIT4_6               ((uint32_t)0x00004000)        /*!< Bit 6 */
+#define  FSMC_PATT4_ATTWAIT4_7               ((uint32_t)0x00008000)        /*!< Bit 7 */
+
+#define  FSMC_PATT4_ATTHOLD4                 ((uint32_t)0x00FF0000)        /*!< ATTHOLD4[7:0] bits (Attribute memory 4 hold time) */
+#define  FSMC_PATT4_ATTHOLD4_0               ((uint32_t)0x00010000)        /*!< Bit 0 */
+#define  FSMC_PATT4_ATTHOLD4_1               ((uint32_t)0x00020000)        /*!< Bit 1 */
+#define  FSMC_PATT4_ATTHOLD4_2               ((uint32_t)0x00040000)        /*!< Bit 2 */
+#define  FSMC_PATT4_ATTHOLD4_3               ((uint32_t)0x00080000)        /*!< Bit 3 */
+#define  FSMC_PATT4_ATTHOLD4_4               ((uint32_t)0x00100000)        /*!< Bit 4 */
+#define  FSMC_PATT4_ATTHOLD4_5               ((uint32_t)0x00200000)        /*!< Bit 5 */
+#define  FSMC_PATT4_ATTHOLD4_6               ((uint32_t)0x00400000)        /*!< Bit 6 */
+#define  FSMC_PATT4_ATTHOLD4_7               ((uint32_t)0x00800000)        /*!< Bit 7 */
+
+#define  FSMC_PATT4_ATTHIZ4                  ((uint32_t)0xFF000000)        /*!< ATTHIZ4[7:0] bits (Attribute memory 4 databus HiZ time) */
+#define  FSMC_PATT4_ATTHIZ4_0                ((uint32_t)0x01000000)        /*!< Bit 0 */
+#define  FSMC_PATT4_ATTHIZ4_1                ((uint32_t)0x02000000)        /*!< Bit 1 */
+#define  FSMC_PATT4_ATTHIZ4_2                ((uint32_t)0x04000000)        /*!< Bit 2 */
+#define  FSMC_PATT4_ATTHIZ4_3                ((uint32_t)0x08000000)        /*!< Bit 3 */
+#define  FSMC_PATT4_ATTHIZ4_4                ((uint32_t)0x10000000)        /*!< Bit 4 */
+#define  FSMC_PATT4_ATTHIZ4_5                ((uint32_t)0x20000000)        /*!< Bit 5 */
+#define  FSMC_PATT4_ATTHIZ4_6                ((uint32_t)0x40000000)        /*!< Bit 6 */
+#define  FSMC_PATT4_ATTHIZ4_7                ((uint32_t)0x80000000)        /*!< Bit 7 */
+
+/******************  Bit definition for FSMC_PIO4 register  *******************/
+#define  FSMC_PIO4_IOSET4                    ((uint32_t)0x000000FF)        /*!< IOSET4[7:0] bits (I/O 4 setup time) */
+#define  FSMC_PIO4_IOSET4_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */
+#define  FSMC_PIO4_IOSET4_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
+#define  FSMC_PIO4_IOSET4_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */
+#define  FSMC_PIO4_IOSET4_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */
+#define  FSMC_PIO4_IOSET4_4                  ((uint32_t)0x00000010)        /*!< Bit 4 */
+#define  FSMC_PIO4_IOSET4_5                  ((uint32_t)0x00000020)        /*!< Bit 5 */
+#define  FSMC_PIO4_IOSET4_6                  ((uint32_t)0x00000040)        /*!< Bit 6 */
+#define  FSMC_PIO4_IOSET4_7                  ((uint32_t)0x00000080)        /*!< Bit 7 */
+
+#define  FSMC_PIO4_IOWAIT4                   ((uint32_t)0x0000FF00)        /*!< IOWAIT4[7:0] bits (I/O 4 wait time) */
+#define  FSMC_PIO4_IOWAIT4_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */
+#define  FSMC_PIO4_IOWAIT4_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
+#define  FSMC_PIO4_IOWAIT4_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */
+#define  FSMC_PIO4_IOWAIT4_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */
+#define  FSMC_PIO4_IOWAIT4_4                 ((uint32_t)0x00001000)        /*!< Bit 4 */
+#define  FSMC_PIO4_IOWAIT4_5                 ((uint32_t)0x00002000)        /*!< Bit 5 */
+#define  FSMC_PIO4_IOWAIT4_6                 ((uint32_t)0x00004000)        /*!< Bit 6 */
+#define  FSMC_PIO4_IOWAIT4_7                 ((uint32_t)0x00008000)        /*!< Bit 7 */
+
+#define  FSMC_PIO4_IOHOLD4                   ((uint32_t)0x00FF0000)        /*!< IOHOLD4[7:0] bits (I/O 4 hold time) */
+#define  FSMC_PIO4_IOHOLD4_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */
+#define  FSMC_PIO4_IOHOLD4_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
+#define  FSMC_PIO4_IOHOLD4_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */
+#define  FSMC_PIO4_IOHOLD4_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */
+#define  FSMC_PIO4_IOHOLD4_4                 ((uint32_t)0x00100000)        /*!< Bit 4 */
+#define  FSMC_PIO4_IOHOLD4_5                 ((uint32_t)0x00200000)        /*!< Bit 5 */
+#define  FSMC_PIO4_IOHOLD4_6                 ((uint32_t)0x00400000)        /*!< Bit 6 */
+#define  FSMC_PIO4_IOHOLD4_7                 ((uint32_t)0x00800000)        /*!< Bit 7 */
+
+#define  FSMC_PIO4_IOHIZ4                    ((uint32_t)0xFF000000)        /*!< IOHIZ4[7:0] bits (I/O 4 databus HiZ time) */
+#define  FSMC_PIO4_IOHIZ4_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
+#define  FSMC_PIO4_IOHIZ4_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
+#define  FSMC_PIO4_IOHIZ4_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
+#define  FSMC_PIO4_IOHIZ4_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */
+#define  FSMC_PIO4_IOHIZ4_4                  ((uint32_t)0x10000000)        /*!< Bit 4 */
+#define  FSMC_PIO4_IOHIZ4_5                  ((uint32_t)0x20000000)        /*!< Bit 5 */
+#define  FSMC_PIO4_IOHIZ4_6                  ((uint32_t)0x40000000)        /*!< Bit 6 */
+#define  FSMC_PIO4_IOHIZ4_7                  ((uint32_t)0x80000000)        /*!< Bit 7 */
+
+/******************  Bit definition for FSMC_ECCR2 register  ******************/
+#define  FSMC_ECCR2_ECC2                     ((uint32_t)0xFFFFFFFF)        /*!< ECC result */
+
+/******************  Bit definition for FSMC_ECCR3 register  ******************/
+#define  FSMC_ECCR3_ECC3                     ((uint32_t)0xFFFFFFFF)        /*!< ECC result */
+
+/******************************************************************************/
+/*                                                                            */
+/*                          SD host Interface                                 */
+/*                                                                            */
+/******************************************************************************/
+
+/******************  Bit definition for SDIO_POWER register  ******************/
+#define  SDIO_POWER_PWRCTRL                  ((uint8_t)0x03)               /*!< PWRCTRL[1:0] bits (Power supply control bits) */
+#define  SDIO_POWER_PWRCTRL_0                ((uint8_t)0x01)               /*!< Bit 0 */
+#define  SDIO_POWER_PWRCTRL_1                ((uint8_t)0x02)               /*!< Bit 1 */
+
+/******************  Bit definition for SDIO_CLKCR register  ******************/
+#define  SDIO_CLKCR_CLKDIV                   ((uint16_t)0x00FF)            /*!< Clock divide factor */
+#define  SDIO_CLKCR_CLKEN                    ((uint16_t)0x0100)            /*!< Clock enable bit */
+#define  SDIO_CLKCR_PWRSAV                   ((uint16_t)0x0200)            /*!< Power saving configuration bit */
+#define  SDIO_CLKCR_BYPASS                   ((uint16_t)0x0400)            /*!< Clock divider bypass enable bit */
+
+#define  SDIO_CLKCR_WIDBUS                   ((uint16_t)0x1800)            /*!< WIDBUS[1:0] bits (Wide bus mode enable bit) */
+#define  SDIO_CLKCR_WIDBUS_0                 ((uint16_t)0x0800)            /*!< Bit 0 */
+#define  SDIO_CLKCR_WIDBUS_1                 ((uint16_t)0x1000)            /*!< Bit 1 */
+
+#define  SDIO_CLKCR_NEGEDGE                  ((uint16_t)0x2000)            /*!< SDIO_CK dephasing selection bit */
+#define  SDIO_CLKCR_HWFC_EN                  ((uint16_t)0x4000)            /*!< HW Flow Control enable */
+
+/*******************  Bit definition for SDIO_ARG register  *******************/
+#define  SDIO_ARG_CMDARG                     ((uint32_t)0xFFFFFFFF)            /*!< Command argument */
+
+/*******************  Bit definition for SDIO_CMD register  *******************/
+#define  SDIO_CMD_CMDINDEX                   ((uint16_t)0x003F)            /*!< Command Index */
+
+#define  SDIO_CMD_WAITRESP                   ((uint16_t)0x00C0)            /*!< WAITRESP[1:0] bits (Wait for response bits) */
+#define  SDIO_CMD_WAITRESP_0                 ((uint16_t)0x0040)            /*!<  Bit 0 */
+#define  SDIO_CMD_WAITRESP_1                 ((uint16_t)0x0080)            /*!<  Bit 1 */
+
+#define  SDIO_CMD_WAITINT                    ((uint16_t)0x0100)            /*!< CPSM Waits for Interrupt Request */
+#define  SDIO_CMD_WAITPEND                   ((uint16_t)0x0200)            /*!< CPSM Waits for ends of data transfer (CmdPend internal signal) */
+#define  SDIO_CMD_CPSMEN                     ((uint16_t)0x0400)            /*!< Command path state machine (CPSM) Enable bit */
+#define  SDIO_CMD_SDIOSUSPEND                ((uint16_t)0x0800)            /*!< SD I/O suspend command */
+#define  SDIO_CMD_ENCMDCOMPL                 ((uint16_t)0x1000)            /*!< Enable CMD completion */
+#define  SDIO_CMD_NIEN                       ((uint16_t)0x2000)            /*!< Not Interrupt Enable */
+#define  SDIO_CMD_CEATACMD                   ((uint16_t)0x4000)            /*!< CE-ATA command */
+
+/*****************  Bit definition for SDIO_RESPCMD register  *****************/
+#define  SDIO_RESPCMD_RESPCMD                ((uint8_t)0x3F)               /*!< Response command index */
+
+/******************  Bit definition for SDIO_RESP0 register  ******************/
+#define  SDIO_RESP0_CARDSTATUS0              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */
+
+/******************  Bit definition for SDIO_RESP1 register  ******************/
+#define  SDIO_RESP1_CARDSTATUS1              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */
+
+/******************  Bit definition for SDIO_RESP2 register  ******************/
+#define  SDIO_RESP2_CARDSTATUS2              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */
+
+/******************  Bit definition for SDIO_RESP3 register  ******************/
+#define  SDIO_RESP3_CARDSTATUS3              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */
+
+/******************  Bit definition for SDIO_RESP4 register  ******************/
+#define  SDIO_RESP4_CARDSTATUS4              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */
+
+/******************  Bit definition for SDIO_DTIMER register  *****************/
+#define  SDIO_DTIMER_DATATIME                ((uint32_t)0xFFFFFFFF)        /*!< Data timeout period. */
+
+/******************  Bit definition for SDIO_DLEN register  *******************/
+#define  SDIO_DLEN_DATALENGTH                ((uint32_t)0x01FFFFFF)        /*!< Data length value */
+
+/******************  Bit definition for SDIO_DCTRL register  ******************/
+#define  SDIO_DCTRL_DTEN                     ((uint16_t)0x0001)            /*!< Data transfer enabled bit */
+#define  SDIO_DCTRL_DTDIR                    ((uint16_t)0x0002)            /*!< Data transfer direction selection */
+#define  SDIO_DCTRL_DTMODE                   ((uint16_t)0x0004)            /*!< Data transfer mode selection */
+#define  SDIO_DCTRL_DMAEN                    ((uint16_t)0x0008)            /*!< DMA enabled bit */
+
+#define  SDIO_DCTRL_DBLOCKSIZE               ((uint16_t)0x00F0)            /*!< DBLOCKSIZE[3:0] bits (Data block size) */
+#define  SDIO_DCTRL_DBLOCKSIZE_0             ((uint16_t)0x0010)            /*!< Bit 0 */
+#define  SDIO_DCTRL_DBLOCKSIZE_1             ((uint16_t)0x0020)            /*!< Bit 1 */
+#define  SDIO_DCTRL_DBLOCKSIZE_2             ((uint16_t)0x0040)            /*!< Bit 2 */
+#define  SDIO_DCTRL_DBLOCKSIZE_3             ((uint16_t)0x0080)            /*!< Bit 3 */
+
+#define  SDIO_DCTRL_RWSTART                  ((uint16_t)0x0100)            /*!< Read wait start */
+#define  SDIO_DCTRL_RWSTOP                   ((uint16_t)0x0200)            /*!< Read wait stop */
+#define  SDIO_DCTRL_RWMOD                    ((uint16_t)0x0400)            /*!< Read wait mode */
+#define  SDIO_DCTRL_SDIOEN                   ((uint16_t)0x0800)            /*!< SD I/O enable functions */
+
+/******************  Bit definition for SDIO_DCOUNT register  *****************/
+#define  SDIO_DCOUNT_DATACOUNT               ((uint32_t)0x01FFFFFF)        /*!< Data count value */
+
+/******************  Bit definition for SDIO_STA register  ********************/
+#define  SDIO_STA_CCRCFAIL                   ((uint32_t)0x00000001)        /*!< Command response received (CRC check failed) */
+#define  SDIO_STA_DCRCFAIL                   ((uint32_t)0x00000002)        /*!< Data block sent/received (CRC check failed) */
+#define  SDIO_STA_CTIMEOUT                   ((uint32_t)0x00000004)        /*!< Command response timeout */
+#define  SDIO_STA_DTIMEOUT                   ((uint32_t)0x00000008)        /*!< Data timeout */
+#define  SDIO_STA_TXUNDERR                   ((uint32_t)0x00000010)        /*!< Transmit FIFO underrun error */
+#define  SDIO_STA_RXOVERR                    ((uint32_t)0x00000020)        /*!< Received FIFO overrun error */
+#define  SDIO_STA_CMDREND                    ((uint32_t)0x00000040)        /*!< Command response received (CRC check passed) */
+#define  SDIO_STA_CMDSENT                    ((uint32_t)0x00000080)        /*!< Command sent (no response required) */
+#define  SDIO_STA_DATAEND                    ((uint32_t)0x00000100)        /*!< Data end (data counter, SDIDCOUNT, is zero) */
+#define  SDIO_STA_STBITERR                   ((uint32_t)0x00000200)        /*!< Start bit not detected on all data signals in wide bus mode */
+#define  SDIO_STA_DBCKEND                    ((uint32_t)0x00000400)        /*!< Data block sent/received (CRC check passed) */
+#define  SDIO_STA_CMDACT                     ((uint32_t)0x00000800)        /*!< Command transfer in progress */
+#define  SDIO_STA_TXACT                      ((uint32_t)0x00001000)        /*!< Data transmit in progress */
+#define  SDIO_STA_RXACT                      ((uint32_t)0x00002000)        /*!< Data receive in progress */
+#define  SDIO_STA_TXFIFOHE                   ((uint32_t)0x00004000)        /*!< Transmit FIFO Half Empty: at least 8 words can be written into the FIFO */
+#define  SDIO_STA_RXFIFOHF                   ((uint32_t)0x00008000)        /*!< Receive FIFO Half Full: there are at least 8 words in the FIFO */
+#define  SDIO_STA_TXFIFOF                    ((uint32_t)0x00010000)        /*!< Transmit FIFO full */
+#define  SDIO_STA_RXFIFOF                    ((uint32_t)0x00020000)        /*!< Receive FIFO full */
+#define  SDIO_STA_TXFIFOE                    ((uint32_t)0x00040000)        /*!< Transmit FIFO empty */
+#define  SDIO_STA_RXFIFOE                    ((uint32_t)0x00080000)        /*!< Receive FIFO empty */
+#define  SDIO_STA_TXDAVL                     ((uint32_t)0x00100000)        /*!< Data available in transmit FIFO */
+#define  SDIO_STA_RXDAVL                     ((uint32_t)0x00200000)        /*!< Data available in receive FIFO */
+#define  SDIO_STA_SDIOIT                     ((uint32_t)0x00400000)        /*!< SDIO interrupt received */
+#define  SDIO_STA_CEATAEND                   ((uint32_t)0x00800000)        /*!< CE-ATA command completion signal received for CMD61 */
+
+/*******************  Bit definition for SDIO_ICR register  *******************/
+#define  SDIO_ICR_CCRCFAILC                  ((uint32_t)0x00000001)        /*!< CCRCFAIL flag clear bit */
+#define  SDIO_ICR_DCRCFAILC                  ((uint32_t)0x00000002)        /*!< DCRCFAIL flag clear bit */
+#define  SDIO_ICR_CTIMEOUTC                  ((uint32_t)0x00000004)        /*!< CTIMEOUT flag clear bit */
+#define  SDIO_ICR_DTIMEOUTC                  ((uint32_t)0x00000008)        /*!< DTIMEOUT flag clear bit */
+#define  SDIO_ICR_TXUNDERRC                  ((uint32_t)0x00000010)        /*!< TXUNDERR flag clear bit */
+#define  SDIO_ICR_RXOVERRC                   ((uint32_t)0x00000020)        /*!< RXOVERR flag clear bit */
+#define  SDIO_ICR_CMDRENDC                   ((uint32_t)0x00000040)        /*!< CMDREND flag clear bit */
+#define  SDIO_ICR_CMDSENTC                   ((uint32_t)0x00000080)        /*!< CMDSENT flag clear bit */
+#define  SDIO_ICR_DATAENDC                   ((uint32_t)0x00000100)        /*!< DATAEND flag clear bit */
+#define  SDIO_ICR_STBITERRC                  ((uint32_t)0x00000200)        /*!< STBITERR flag clear bit */
+#define  SDIO_ICR_DBCKENDC                   ((uint32_t)0x00000400)        /*!< DBCKEND flag clear bit */
+#define  SDIO_ICR_SDIOITC                    ((uint32_t)0x00400000)        /*!< SDIOIT flag clear bit */
+#define  SDIO_ICR_CEATAENDC                  ((uint32_t)0x00800000)        /*!< CEATAEND flag clear bit */
+
+/******************  Bit definition for SDIO_MASK register  *******************/
+#define  SDIO_MASK_CCRCFAILIE                ((uint32_t)0x00000001)        /*!< Command CRC Fail Interrupt Enable */
+#define  SDIO_MASK_DCRCFAILIE                ((uint32_t)0x00000002)        /*!< Data CRC Fail Interrupt Enable */
+#define  SDIO_MASK_CTIMEOUTIE                ((uint32_t)0x00000004)        /*!< Command TimeOut Interrupt Enable */
+#define  SDIO_MASK_DTIMEOUTIE                ((uint32_t)0x00000008)        /*!< Data TimeOut Interrupt Enable */
+#define  SDIO_MASK_TXUNDERRIE                ((uint32_t)0x00000010)        /*!< Tx FIFO UnderRun Error Interrupt Enable */
+#define  SDIO_MASK_RXOVERRIE                 ((uint32_t)0x00000020)        /*!< Rx FIFO OverRun Error Interrupt Enable */
+#define  SDIO_MASK_CMDRENDIE                 ((uint32_t)0x00000040)        /*!< Command Response Received Interrupt Enable */
+#define  SDIO_MASK_CMDSENTIE                 ((uint32_t)0x00000080)        /*!< Command Sent Interrupt Enable */
+#define  SDIO_MASK_DATAENDIE                 ((uint32_t)0x00000100)        /*!< Data End Interrupt Enable */
+#define  SDIO_MASK_STBITERRIE                ((uint32_t)0x00000200)        /*!< Start Bit Error Interrupt Enable */
+#define  SDIO_MASK_DBCKENDIE                 ((uint32_t)0x00000400)        /*!< Data Block End Interrupt Enable */
+#define  SDIO_MASK_CMDACTIE                  ((uint32_t)0x00000800)        /*!< Command Acting Interrupt Enable */
+#define  SDIO_MASK_TXACTIE                   ((uint32_t)0x00001000)        /*!< Data Transmit Acting Interrupt Enable */
+#define  SDIO_MASK_RXACTIE                   ((uint32_t)0x00002000)        /*!< Data receive acting interrupt enabled */
+#define  SDIO_MASK_TXFIFOHEIE                ((uint32_t)0x00004000)        /*!< Tx FIFO Half Empty interrupt Enable */
+#define  SDIO_MASK_RXFIFOHFIE                ((uint32_t)0x00008000)        /*!< Rx FIFO Half Full interrupt Enable */
+#define  SDIO_MASK_TXFIFOFIE                 ((uint32_t)0x00010000)        /*!< Tx FIFO Full interrupt Enable */
+#define  SDIO_MASK_RXFIFOFIE                 ((uint32_t)0x00020000)        /*!< Rx FIFO Full interrupt Enable */
+#define  SDIO_MASK_TXFIFOEIE                 ((uint32_t)0x00040000)        /*!< Tx FIFO Empty interrupt Enable */
+#define  SDIO_MASK_RXFIFOEIE                 ((uint32_t)0x00080000)        /*!< Rx FIFO Empty interrupt Enable */
+#define  SDIO_MASK_TXDAVLIE                  ((uint32_t)0x00100000)        /*!< Data available in Tx FIFO interrupt Enable */
+#define  SDIO_MASK_RXDAVLIE                  ((uint32_t)0x00200000)        /*!< Data available in Rx FIFO interrupt Enable */
+#define  SDIO_MASK_SDIOITIE                  ((uint32_t)0x00400000)        /*!< SDIO Mode Interrupt Received interrupt Enable */
+#define  SDIO_MASK_CEATAENDIE                ((uint32_t)0x00800000)        /*!< CE-ATA command completion signal received Interrupt Enable */
+
+/*****************  Bit definition for SDIO_FIFOCNT register  *****************/
+#define  SDIO_FIFOCNT_FIFOCOUNT              ((uint32_t)0x00FFFFFF)        /*!< Remaining number of words to be written to or read from the FIFO */
+
+/******************  Bit definition for SDIO_FIFO register  *******************/
+#define  SDIO_FIFO_FIFODATA                  ((uint32_t)0xFFFFFFFF)        /*!< Receive and transmit FIFO data */
+
+/******************************************************************************/
+/*                                                                            */
+/*                                   USB Device FS                            */
+/*                                                                            */
+/******************************************************************************/
+
+/*!< Endpoint-specific registers */
+/*******************  Bit definition for USB_EP0R register  *******************/
+#define  USB_EP0R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
+
+#define  USB_EP0R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
+#define  USB_EP0R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
+#define  USB_EP0R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
+
+#define  USB_EP0R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
+#define  USB_EP0R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
+#define  USB_EP0R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
+
+#define  USB_EP0R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
+#define  USB_EP0R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
+#define  USB_EP0R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
+
+#define  USB_EP0R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
+
+#define  USB_EP0R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
+#define  USB_EP0R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
+#define  USB_EP0R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
+
+#define  USB_EP0R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
+#define  USB_EP0R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
+
+/*******************  Bit definition for USB_EP1R register  *******************/
+#define  USB_EP1R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
+
+#define  USB_EP1R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
+#define  USB_EP1R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
+#define  USB_EP1R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
+
+#define  USB_EP1R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
+#define  USB_EP1R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
+#define  USB_EP1R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
+
+#define  USB_EP1R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
+#define  USB_EP1R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
+#define  USB_EP1R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
+
+#define  USB_EP1R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
+
+#define  USB_EP1R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
+#define  USB_EP1R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
+#define  USB_EP1R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
+
+#define  USB_EP1R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
+#define  USB_EP1R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
+
+/*******************  Bit definition for USB_EP2R register  *******************/
+#define  USB_EP2R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
+
+#define  USB_EP2R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
+#define  USB_EP2R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
+#define  USB_EP2R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
+
+#define  USB_EP2R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
+#define  USB_EP2R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
+#define  USB_EP2R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
+
+#define  USB_EP2R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
+#define  USB_EP2R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
+#define  USB_EP2R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
+
+#define  USB_EP2R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
+
+#define  USB_EP2R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
+#define  USB_EP2R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
+#define  USB_EP2R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
+
+#define  USB_EP2R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
+#define  USB_EP2R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
+
+/*******************  Bit definition for USB_EP3R register  *******************/
+#define  USB_EP3R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
+
+#define  USB_EP3R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
+#define  USB_EP3R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
+#define  USB_EP3R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
+
+#define  USB_EP3R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
+#define  USB_EP3R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
+#define  USB_EP3R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
+
+#define  USB_EP3R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
+#define  USB_EP3R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
+#define  USB_EP3R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
+
+#define  USB_EP3R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
+
+#define  USB_EP3R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
+#define  USB_EP3R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
+#define  USB_EP3R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
+
+#define  USB_EP3R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
+#define  USB_EP3R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
+
+/*******************  Bit definition for USB_EP4R register  *******************/
+#define  USB_EP4R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
+
+#define  USB_EP4R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
+#define  USB_EP4R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
+#define  USB_EP4R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
+
+#define  USB_EP4R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
+#define  USB_EP4R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
+#define  USB_EP4R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
+
+#define  USB_EP4R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
+#define  USB_EP4R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
+#define  USB_EP4R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
+
+#define  USB_EP4R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
+
+#define  USB_EP4R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
+#define  USB_EP4R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
+#define  USB_EP4R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
+
+#define  USB_EP4R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
+#define  USB_EP4R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
+
+/*******************  Bit definition for USB_EP5R register  *******************/
+#define  USB_EP5R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
+
+#define  USB_EP5R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
+#define  USB_EP5R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
+#define  USB_EP5R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
+
+#define  USB_EP5R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
+#define  USB_EP5R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
+#define  USB_EP5R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
+
+#define  USB_EP5R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
+#define  USB_EP5R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
+#define  USB_EP5R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
+
+#define  USB_EP5R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
+
+#define  USB_EP5R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
+#define  USB_EP5R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
+#define  USB_EP5R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
+
+#define  USB_EP5R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
+#define  USB_EP5R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
+
+/*******************  Bit definition for USB_EP6R register  *******************/
+#define  USB_EP6R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
+
+#define  USB_EP6R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
+#define  USB_EP6R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
+#define  USB_EP6R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
+
+#define  USB_EP6R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
+#define  USB_EP6R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
+#define  USB_EP6R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
+
+#define  USB_EP6R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
+#define  USB_EP6R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
+#define  USB_EP6R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
+
+#define  USB_EP6R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
+
+#define  USB_EP6R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
+#define  USB_EP6R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
+#define  USB_EP6R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
+
+#define  USB_EP6R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
+#define  USB_EP6R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
+
+/*******************  Bit definition for USB_EP7R register  *******************/
+#define  USB_EP7R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
+
+#define  USB_EP7R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
+#define  USB_EP7R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
+#define  USB_EP7R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
+
+#define  USB_EP7R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
+#define  USB_EP7R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
+#define  USB_EP7R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
+
+#define  USB_EP7R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
+#define  USB_EP7R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
+#define  USB_EP7R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
+
+#define  USB_EP7R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
+
+#define  USB_EP7R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
+#define  USB_EP7R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
+#define  USB_EP7R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
+
+#define  USB_EP7R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
+#define  USB_EP7R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
+
+/*!< Common registers */
+/*******************  Bit definition for USB_CNTR register  *******************/
+#define  USB_CNTR_FRES                       ((uint16_t)0x0001)            /*!< Force USB Reset */
+#define  USB_CNTR_PDWN                       ((uint16_t)0x0002)            /*!< Power down */
+#define  USB_CNTR_LP_MODE                    ((uint16_t)0x0004)            /*!< Low-power mode */
+#define  USB_CNTR_FSUSP                      ((uint16_t)0x0008)            /*!< Force suspend */
+#define  USB_CNTR_RESUME                     ((uint16_t)0x0010)            /*!< Resume request */
+#define  USB_CNTR_ESOFM                      ((uint16_t)0x0100)            /*!< Expected Start Of Frame Interrupt Mask */
+#define  USB_CNTR_SOFM                       ((uint16_t)0x0200)            /*!< Start Of Frame Interrupt Mask */
+#define  USB_CNTR_RESETM                     ((uint16_t)0x0400)            /*!< RESET Interrupt Mask */
+#define  USB_CNTR_SUSPM                      ((uint16_t)0x0800)            /*!< Suspend mode Interrupt Mask */
+#define  USB_CNTR_WKUPM                      ((uint16_t)0x1000)            /*!< Wakeup Interrupt Mask */
+#define  USB_CNTR_ERRM                       ((uint16_t)0x2000)            /*!< Error Interrupt Mask */
+#define  USB_CNTR_PMAOVRM                    ((uint16_t)0x4000)            /*!< Packet Memory Area Over / Underrun Interrupt Mask */
+#define  USB_CNTR_CTRM                       ((uint16_t)0x8000)            /*!< Correct Transfer Interrupt Mask */
+
+/*******************  Bit definition for USB_ISTR register  *******************/
+#define  USB_ISTR_EP_ID                      ((uint16_t)0x000F)            /*!< Endpoint Identifier */
+#define  USB_ISTR_DIR                        ((uint16_t)0x0010)            /*!< Direction of transaction */
+#define  USB_ISTR_ESOF                       ((uint16_t)0x0100)            /*!< Expected Start Of Frame */
+#define  USB_ISTR_SOF                        ((uint16_t)0x0200)            /*!< Start Of Frame */
+#define  USB_ISTR_RESET                      ((uint16_t)0x0400)            /*!< USB RESET request */
+#define  USB_ISTR_SUSP                       ((uint16_t)0x0800)            /*!< Suspend mode request */
+#define  USB_ISTR_WKUP                       ((uint16_t)0x1000)            /*!< Wake up */
+#define  USB_ISTR_ERR                        ((uint16_t)0x2000)            /*!< Error */
+#define  USB_ISTR_PMAOVR                     ((uint16_t)0x4000)            /*!< Packet Memory Area Over / Underrun */
+#define  USB_ISTR_CTR                        ((uint16_t)0x8000)            /*!< Correct Transfer */
+
+/*******************  Bit definition for USB_FNR register  ********************/
+#define  USB_FNR_FN                          ((uint16_t)0x07FF)            /*!< Frame Number */
+#define  USB_FNR_LSOF                        ((uint16_t)0x1800)            /*!< Lost SOF */
+#define  USB_FNR_LCK                         ((uint16_t)0x2000)            /*!< Locked */
+#define  USB_FNR_RXDM                        ((uint16_t)0x4000)            /*!< Receive Data - Line Status */
+#define  USB_FNR_RXDP                        ((uint16_t)0x8000)            /*!< Receive Data + Line Status */
+
+/******************  Bit definition for USB_DADDR register  *******************/
+#define  USB_DADDR_ADD                       ((uint8_t)0x7F)               /*!< ADD[6:0] bits (Device Address) */
+#define  USB_DADDR_ADD0                      ((uint8_t)0x01)               /*!< Bit 0 */
+#define  USB_DADDR_ADD1                      ((uint8_t)0x02)               /*!< Bit 1 */
+#define  USB_DADDR_ADD2                      ((uint8_t)0x04)               /*!< Bit 2 */
+#define  USB_DADDR_ADD3                      ((uint8_t)0x08)               /*!< Bit 3 */
+#define  USB_DADDR_ADD4                      ((uint8_t)0x10)               /*!< Bit 4 */
+#define  USB_DADDR_ADD5                      ((uint8_t)0x20)               /*!< Bit 5 */
+#define  USB_DADDR_ADD6                      ((uint8_t)0x40)               /*!< Bit 6 */
+
+#define  USB_DADDR_EF                        ((uint8_t)0x80)               /*!< Enable Function */
+
+/******************  Bit definition for USB_BTABLE register  ******************/
+#define  USB_BTABLE_BTABLE                   ((uint16_t)0xFFF8)            /*!< Buffer Table */
+
+/*!< Buffer descriptor table */
+/*****************  Bit definition for USB_ADDR0_TX register  *****************/
+#define  USB_ADDR0_TX_ADDR0_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 0 */
+
+/*****************  Bit definition for USB_ADDR1_TX register  *****************/
+#define  USB_ADDR1_TX_ADDR1_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 1 */
+
+/*****************  Bit definition for USB_ADDR2_TX register  *****************/
+#define  USB_ADDR2_TX_ADDR2_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 2 */
+
+/*****************  Bit definition for USB_ADDR3_TX register  *****************/
+#define  USB_ADDR3_TX_ADDR3_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 3 */
+
+/*****************  Bit definition for USB_ADDR4_TX register  *****************/
+#define  USB_ADDR4_TX_ADDR4_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 4 */
+
+/*****************  Bit definition for USB_ADDR5_TX register  *****************/
+#define  USB_ADDR5_TX_ADDR5_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 5 */
+
+/*****************  Bit definition for USB_ADDR6_TX register  *****************/
+#define  USB_ADDR6_TX_ADDR6_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 6 */
+
+/*****************  Bit definition for USB_ADDR7_TX register  *****************/
+#define  USB_ADDR7_TX_ADDR7_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 7 */
+
+/*----------------------------------------------------------------------------*/
+
+/*****************  Bit definition for USB_COUNT0_TX register  ****************/
+#define  USB_COUNT0_TX_COUNT0_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 0 */
+
+/*****************  Bit definition for USB_COUNT1_TX register  ****************/
+#define  USB_COUNT1_TX_COUNT1_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 1 */
+
+/*****************  Bit definition for USB_COUNT2_TX register  ****************/
+#define  USB_COUNT2_TX_COUNT2_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 2 */
+
+/*****************  Bit definition for USB_COUNT3_TX register  ****************/
+#define  USB_COUNT3_TX_COUNT3_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 3 */
+
+/*****************  Bit definition for USB_COUNT4_TX register  ****************/
+#define  USB_COUNT4_TX_COUNT4_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 4 */
+
+/*****************  Bit definition for USB_COUNT5_TX register  ****************/
+#define  USB_COUNT5_TX_COUNT5_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 5 */
+
+/*****************  Bit definition for USB_COUNT6_TX register  ****************/
+#define  USB_COUNT6_TX_COUNT6_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 6 */
+
+/*****************  Bit definition for USB_COUNT7_TX register  ****************/
+#define  USB_COUNT7_TX_COUNT7_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 7 */
+
+/*----------------------------------------------------------------------------*/
+
+/****************  Bit definition for USB_COUNT0_TX_0 register  ***************/
+#define  USB_COUNT0_TX_0_COUNT0_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 0 (low) */
+
+/****************  Bit definition for USB_COUNT0_TX_1 register  ***************/
+#define  USB_COUNT0_TX_1_COUNT0_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 0 (high) */
+
+/****************  Bit definition for USB_COUNT1_TX_0 register  ***************/
+#define  USB_COUNT1_TX_0_COUNT1_TX_0          ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 1 (low) */
+
+/****************  Bit definition for USB_COUNT1_TX_1 register  ***************/
+#define  USB_COUNT1_TX_1_COUNT1_TX_1          ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 1 (high) */
+
+/****************  Bit definition for USB_COUNT2_TX_0 register  ***************/
+#define  USB_COUNT2_TX_0_COUNT2_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 2 (low) */
+
+/****************  Bit definition for USB_COUNT2_TX_1 register  ***************/
+#define  USB_COUNT2_TX_1_COUNT2_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 2 (high) */
+
+/****************  Bit definition for USB_COUNT3_TX_0 register  ***************/
+#define  USB_COUNT3_TX_0_COUNT3_TX_0         ((uint16_t)0x000003FF)        /*!< Transmission Byte Count 3 (low) */
+
+/****************  Bit definition for USB_COUNT3_TX_1 register  ***************/
+#define  USB_COUNT3_TX_1_COUNT3_TX_1         ((uint16_t)0x03FF0000)        /*!< Transmission Byte Count 3 (high) */
+
+/****************  Bit definition for USB_COUNT4_TX_0 register  ***************/
+#define  USB_COUNT4_TX_0_COUNT4_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 4 (low) */
+
+/****************  Bit definition for USB_COUNT4_TX_1 register  ***************/
+#define  USB_COUNT4_TX_1_COUNT4_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 4 (high) */
+
+/****************  Bit definition for USB_COUNT5_TX_0 register  ***************/
+#define  USB_COUNT5_TX_0_COUNT5_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 5 (low) */
+
+/****************  Bit definition for USB_COUNT5_TX_1 register  ***************/
+#define  USB_COUNT5_TX_1_COUNT5_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 5 (high) */
+
+/****************  Bit definition for USB_COUNT6_TX_0 register  ***************/
+#define  USB_COUNT6_TX_0_COUNT6_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 6 (low) */
+
+/****************  Bit definition for USB_COUNT6_TX_1 register  ***************/
+#define  USB_COUNT6_TX_1_COUNT6_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 6 (high) */
+
+/****************  Bit definition for USB_COUNT7_TX_0 register  ***************/
+#define  USB_COUNT7_TX_0_COUNT7_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 7 (low) */
+
+/****************  Bit definition for USB_COUNT7_TX_1 register  ***************/
+#define  USB_COUNT7_TX_1_COUNT7_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 7 (high) */
+
+/*----------------------------------------------------------------------------*/
+
+/*****************  Bit definition for USB_ADDR0_RX register  *****************/
+#define  USB_ADDR0_RX_ADDR0_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 0 */
+
+/*****************  Bit definition for USB_ADDR1_RX register  *****************/
+#define  USB_ADDR1_RX_ADDR1_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 1 */
+
+/*****************  Bit definition for USB_ADDR2_RX register  *****************/
+#define  USB_ADDR2_RX_ADDR2_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 2 */
+
+/*****************  Bit definition for USB_ADDR3_RX register  *****************/
+#define  USB_ADDR3_RX_ADDR3_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 3 */
+
+/*****************  Bit definition for USB_ADDR4_RX register  *****************/
+#define  USB_ADDR4_RX_ADDR4_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 4 */
+
+/*****************  Bit definition for USB_ADDR5_RX register  *****************/
+#define  USB_ADDR5_RX_ADDR5_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 5 */
+
+/*****************  Bit definition for USB_ADDR6_RX register  *****************/
+#define  USB_ADDR6_RX_ADDR6_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 6 */
+
+/*****************  Bit definition for USB_ADDR7_RX register  *****************/
+#define  USB_ADDR7_RX_ADDR7_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 7 */
+
+/*----------------------------------------------------------------------------*/
+
+/*****************  Bit definition for USB_COUNT0_RX register  ****************/
+#define  USB_COUNT0_RX_COUNT0_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
+
+#define  USB_COUNT0_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
+#define  USB_COUNT0_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
+#define  USB_COUNT0_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
+#define  USB_COUNT0_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
+#define  USB_COUNT0_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
+#define  USB_COUNT0_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
+
+#define  USB_COUNT0_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
+
+/*****************  Bit definition for USB_COUNT1_RX register  ****************/
+#define  USB_COUNT1_RX_COUNT1_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
+
+#define  USB_COUNT1_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
+#define  USB_COUNT1_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
+#define  USB_COUNT1_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
+#define  USB_COUNT1_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
+#define  USB_COUNT1_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
+#define  USB_COUNT1_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
+
+#define  USB_COUNT1_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
+
+/*****************  Bit definition for USB_COUNT2_RX register  ****************/
+#define  USB_COUNT2_RX_COUNT2_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
+
+#define  USB_COUNT2_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
+#define  USB_COUNT2_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
+#define  USB_COUNT2_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
+#define  USB_COUNT2_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
+#define  USB_COUNT2_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
+#define  USB_COUNT2_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
+
+#define  USB_COUNT2_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
+
+/*****************  Bit definition for USB_COUNT3_RX register  ****************/
+#define  USB_COUNT3_RX_COUNT3_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
+
+#define  USB_COUNT3_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
+#define  USB_COUNT3_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
+#define  USB_COUNT3_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
+#define  USB_COUNT3_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
+#define  USB_COUNT3_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
+#define  USB_COUNT3_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
+
+#define  USB_COUNT3_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
+
+/*****************  Bit definition for USB_COUNT4_RX register  ****************/
+#define  USB_COUNT4_RX_COUNT4_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
+
+#define  USB_COUNT4_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
+#define  USB_COUNT4_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
+#define  USB_COUNT4_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
+#define  USB_COUNT4_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
+#define  USB_COUNT4_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
+#define  USB_COUNT4_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
+
+#define  USB_COUNT4_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
+
+/*****************  Bit definition for USB_COUNT5_RX register  ****************/
+#define  USB_COUNT5_RX_COUNT5_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
+
+#define  USB_COUNT5_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
+#define  USB_COUNT5_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
+#define  USB_COUNT5_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
+#define  USB_COUNT5_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
+#define  USB_COUNT5_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
+#define  USB_COUNT5_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
+
+#define  USB_COUNT5_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
+
+/*****************  Bit definition for USB_COUNT6_RX register  ****************/
+#define  USB_COUNT6_RX_COUNT6_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
+
+#define  USB_COUNT6_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
+#define  USB_COUNT6_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
+#define  USB_COUNT6_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
+#define  USB_COUNT6_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
+#define  USB_COUNT6_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
+#define  USB_COUNT6_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
+
+#define  USB_COUNT6_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
+
+/*****************  Bit definition for USB_COUNT7_RX register  ****************/
+#define  USB_COUNT7_RX_COUNT7_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
+
+#define  USB_COUNT7_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
+#define  USB_COUNT7_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
+#define  USB_COUNT7_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
+#define  USB_COUNT7_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
+#define  USB_COUNT7_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
+#define  USB_COUNT7_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
+
+#define  USB_COUNT7_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
+
+/*----------------------------------------------------------------------------*/
+
+/****************  Bit definition for USB_COUNT0_RX_0 register  ***************/
+#define  USB_COUNT0_RX_0_COUNT0_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
+
+#define  USB_COUNT0_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
+#define  USB_COUNT0_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
+#define  USB_COUNT0_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
+#define  USB_COUNT0_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
+#define  USB_COUNT0_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
+#define  USB_COUNT0_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
+
+#define  USB_COUNT0_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
+
+/****************  Bit definition for USB_COUNT0_RX_1 register  ***************/
+#define  USB_COUNT0_RX_1_COUNT0_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
+
+#define  USB_COUNT0_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
+#define  USB_COUNT0_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 1 */
+#define  USB_COUNT0_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
+#define  USB_COUNT0_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
+#define  USB_COUNT0_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
+#define  USB_COUNT0_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
+
+#define  USB_COUNT0_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
+
+/****************  Bit definition for USB_COUNT1_RX_0 register  ***************/
+#define  USB_COUNT1_RX_0_COUNT1_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
+
+#define  USB_COUNT1_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
+#define  USB_COUNT1_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
+#define  USB_COUNT1_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
+#define  USB_COUNT1_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
+#define  USB_COUNT1_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
+#define  USB_COUNT1_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
+
+#define  USB_COUNT1_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
+
+/****************  Bit definition for USB_COUNT1_RX_1 register  ***************/
+#define  USB_COUNT1_RX_1_COUNT1_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
+
+#define  USB_COUNT1_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
+#define  USB_COUNT1_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
+#define  USB_COUNT1_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
+#define  USB_COUNT1_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
+#define  USB_COUNT1_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
+#define  USB_COUNT1_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
+
+#define  USB_COUNT1_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
+
+/****************  Bit definition for USB_COUNT2_RX_0 register  ***************/
+#define  USB_COUNT2_RX_0_COUNT2_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
+
+#define  USB_COUNT2_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
+#define  USB_COUNT2_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
+#define  USB_COUNT2_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
+#define  USB_COUNT2_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
+#define  USB_COUNT2_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
+#define  USB_COUNT2_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
+
+#define  USB_COUNT2_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
+
+/****************  Bit definition for USB_COUNT2_RX_1 register  ***************/
+#define  USB_COUNT2_RX_1_COUNT2_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
+
+#define  USB_COUNT2_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
+#define  USB_COUNT2_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
+#define  USB_COUNT2_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
+#define  USB_COUNT2_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
+#define  USB_COUNT2_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
+#define  USB_COUNT2_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
+
+#define  USB_COUNT2_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
+
+/****************  Bit definition for USB_COUNT3_RX_0 register  ***************/
+#define  USB_COUNT3_RX_0_COUNT3_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
+
+#define  USB_COUNT3_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
+#define  USB_COUNT3_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
+#define  USB_COUNT3_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
+#define  USB_COUNT3_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
+#define  USB_COUNT3_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
+#define  USB_COUNT3_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
+
+#define  USB_COUNT3_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
+
+/****************  Bit definition for USB_COUNT3_RX_1 register  ***************/
+#define  USB_COUNT3_RX_1_COUNT3_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
+
+#define  USB_COUNT3_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
+#define  USB_COUNT3_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
+#define  USB_COUNT3_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
+#define  USB_COUNT3_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
+#define  USB_COUNT3_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
+#define  USB_COUNT3_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
+
+#define  USB_COUNT3_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
+
+/****************  Bit definition for USB_COUNT4_RX_0 register  ***************/
+#define  USB_COUNT4_RX_0_COUNT4_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
+
+#define  USB_COUNT4_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
+#define  USB_COUNT4_RX_0_NUM_BLOCK_0_0      ((uint32_t)0x00000400)        /*!< Bit 0 */
+#define  USB_COUNT4_RX_0_NUM_BLOCK_0_1      ((uint32_t)0x00000800)        /*!< Bit 1 */
+#define  USB_COUNT4_RX_0_NUM_BLOCK_0_2      ((uint32_t)0x00001000)        /*!< Bit 2 */
+#define  USB_COUNT4_RX_0_NUM_BLOCK_0_3      ((uint32_t)0x00002000)        /*!< Bit 3 */
+#define  USB_COUNT4_RX_0_NUM_BLOCK_0_4      ((uint32_t)0x00004000)        /*!< Bit 4 */
+
+#define  USB_COUNT4_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
+
+/****************  Bit definition for USB_COUNT4_RX_1 register  ***************/
+#define  USB_COUNT4_RX_1_COUNT4_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
+
+#define  USB_COUNT4_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
+#define  USB_COUNT4_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
+#define  USB_COUNT4_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
+#define  USB_COUNT4_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
+#define  USB_COUNT4_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
+#define  USB_COUNT4_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
+
+#define  USB_COUNT4_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
+
+/****************  Bit definition for USB_COUNT5_RX_0 register  ***************/
+#define  USB_COUNT5_RX_0_COUNT5_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
+
+#define  USB_COUNT5_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
+#define  USB_COUNT5_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
+#define  USB_COUNT5_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
+#define  USB_COUNT5_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
+#define  USB_COUNT5_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
+#define  USB_COUNT5_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
+
+#define  USB_COUNT5_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
+
+/****************  Bit definition for USB_COUNT5_RX_1 register  ***************/
+#define  USB_COUNT5_RX_1_COUNT5_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
+
+#define  USB_COUNT5_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
+#define  USB_COUNT5_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
+#define  USB_COUNT5_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
+#define  USB_COUNT5_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
+#define  USB_COUNT5_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
+#define  USB_COUNT5_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
+
+#define  USB_COUNT5_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
+
+/***************  Bit definition for USB_COUNT6_RX_0  register  ***************/
+#define  USB_COUNT6_RX_0_COUNT6_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
+
+#define  USB_COUNT6_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
+#define  USB_COUNT6_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
+#define  USB_COUNT6_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
+#define  USB_COUNT6_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
+#define  USB_COUNT6_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
+#define  USB_COUNT6_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
+
+#define  USB_COUNT6_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
+
+/****************  Bit definition for USB_COUNT6_RX_1 register  ***************/
+#define  USB_COUNT6_RX_1_COUNT6_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
+
+#define  USB_COUNT6_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
+#define  USB_COUNT6_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
+#define  USB_COUNT6_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
+#define  USB_COUNT6_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
+#define  USB_COUNT6_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
+#define  USB_COUNT6_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
+
+#define  USB_COUNT6_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
+
+/***************  Bit definition for USB_COUNT7_RX_0 register  ****************/
+#define  USB_COUNT7_RX_0_COUNT7_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
+
+#define  USB_COUNT7_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
+#define  USB_COUNT7_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
+#define  USB_COUNT7_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
+#define  USB_COUNT7_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
+#define  USB_COUNT7_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
+#define  USB_COUNT7_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
+
+#define  USB_COUNT7_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
+
+/***************  Bit definition for USB_COUNT7_RX_1 register  ****************/
+#define  USB_COUNT7_RX_1_COUNT7_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
+
+#define  USB_COUNT7_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
+#define  USB_COUNT7_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
+#define  USB_COUNT7_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
+#define  USB_COUNT7_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
+#define  USB_COUNT7_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
+#define  USB_COUNT7_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
+
+#define  USB_COUNT7_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
+
+/******************************************************************************/
+/*                                                                            */
+/*                         Controller Area Network                            */
+/*                                                                            */
+/******************************************************************************/
+
+/*!< CAN control and status registers */
+/*******************  Bit definition for CAN_MCR register  ********************/
+#define  CAN_MCR_INRQ                        ((uint16_t)0x0001)            /*!< Initialization Request */
+#define  CAN_MCR_SLEEP                       ((uint16_t)0x0002)            /*!< Sleep Mode Request */
+#define  CAN_MCR_TXFP                        ((uint16_t)0x0004)            /*!< Transmit FIFO Priority */
+#define  CAN_MCR_RFLM                        ((uint16_t)0x0008)            /*!< Receive FIFO Locked Mode */
+#define  CAN_MCR_NART                        ((uint16_t)0x0010)            /*!< No Automatic Retransmission */
+#define  CAN_MCR_AWUM                        ((uint16_t)0x0020)            /*!< Automatic Wakeup Mode */
+#define  CAN_MCR_ABOM                        ((uint16_t)0x0040)            /*!< Automatic Bus-Off Management */
+#define  CAN_MCR_TTCM                        ((uint16_t)0x0080)            /*!< Time Triggered Communication Mode */
+#define  CAN_MCR_RESET                       ((uint16_t)0x8000)            /*!< CAN software master reset */
+
+/*******************  Bit definition for CAN_MSR register  ********************/
+#define  CAN_MSR_INAK                        ((uint16_t)0x0001)            /*!< Initialization Acknowledge */
+#define  CAN_MSR_SLAK                        ((uint16_t)0x0002)            /*!< Sleep Acknowledge */
+#define  CAN_MSR_ERRI                        ((uint16_t)0x0004)            /*!< Error Interrupt */
+#define  CAN_MSR_WKUI                        ((uint16_t)0x0008)            /*!< Wakeup Interrupt */
+#define  CAN_MSR_SLAKI                       ((uint16_t)0x0010)            /*!< Sleep Acknowledge Interrupt */
+#define  CAN_MSR_TXM                         ((uint16_t)0x0100)            /*!< Transmit Mode */
+#define  CAN_MSR_RXM                         ((uint16_t)0x0200)            /*!< Receive Mode */
+#define  CAN_MSR_SAMP                        ((uint16_t)0x0400)            /*!< Last Sample Point */
+#define  CAN_MSR_RX                          ((uint16_t)0x0800)            /*!< CAN Rx Signal */
+
+/*******************  Bit definition for CAN_TSR register  ********************/
+#define  CAN_TSR_RQCP0                       ((uint32_t)0x00000001)        /*!< Request Completed Mailbox0 */
+#define  CAN_TSR_TXOK0                       ((uint32_t)0x00000002)        /*!< Transmission OK of Mailbox0 */
+#define  CAN_TSR_ALST0                       ((uint32_t)0x00000004)        /*!< Arbitration Lost for Mailbox0 */
+#define  CAN_TSR_TERR0                       ((uint32_t)0x00000008)        /*!< Transmission Error of Mailbox0 */
+#define  CAN_TSR_ABRQ0                       ((uint32_t)0x00000080)        /*!< Abort Request for Mailbox0 */
+#define  CAN_TSR_RQCP1                       ((uint32_t)0x00000100)        /*!< Request Completed Mailbox1 */
+#define  CAN_TSR_TXOK1                       ((uint32_t)0x00000200)        /*!< Transmission OK of Mailbox1 */
+#define  CAN_TSR_ALST1                       ((uint32_t)0x00000400)        /*!< Arbitration Lost for Mailbox1 */
+#define  CAN_TSR_TERR1                       ((uint32_t)0x00000800)        /*!< Transmission Error of Mailbox1 */
+#define  CAN_TSR_ABRQ1                       ((uint32_t)0x00008000)        /*!< Abort Request for Mailbox 1 */
+#define  CAN_TSR_RQCP2                       ((uint32_t)0x00010000)        /*!< Request Completed Mailbox2 */
+#define  CAN_TSR_TXOK2                       ((uint32_t)0x00020000)        /*!< Transmission OK of Mailbox 2 */
+#define  CAN_TSR_ALST2                       ((uint32_t)0x00040000)        /*!< Arbitration Lost for mailbox 2 */
+#define  CAN_TSR_TERR2                       ((uint32_t)0x00080000)        /*!< Transmission Error of Mailbox 2 */
+#define  CAN_TSR_ABRQ2                       ((uint32_t)0x00800000)        /*!< Abort Request for Mailbox 2 */
+#define  CAN_TSR_CODE                        ((uint32_t)0x03000000)        /*!< Mailbox Code */
+
+#define  CAN_TSR_TME                         ((uint32_t)0x1C000000)        /*!< TME[2:0] bits */
+#define  CAN_TSR_TME0                        ((uint32_t)0x04000000)        /*!< Transmit Mailbox 0 Empty */
+#define  CAN_TSR_TME1                        ((uint32_t)0x08000000)        /*!< Transmit Mailbox 1 Empty */
+#define  CAN_TSR_TME2                        ((uint32_t)0x10000000)        /*!< Transmit Mailbox 2 Empty */
+
+#define  CAN_TSR_LOW                         ((uint32_t)0xE0000000)        /*!< LOW[2:0] bits */
+#define  CAN_TSR_LOW0                        ((uint32_t)0x20000000)        /*!< Lowest Priority Flag for Mailbox 0 */
+#define  CAN_TSR_LOW1                        ((uint32_t)0x40000000)        /*!< Lowest Priority Flag for Mailbox 1 */
+#define  CAN_TSR_LOW2                        ((uint32_t)0x80000000)        /*!< Lowest Priority Flag for Mailbox 2 */
+
+/*******************  Bit definition for CAN_RF0R register  *******************/
+#define  CAN_RF0R_FMP0                       ((uint8_t)0x03)               /*!< FIFO 0 Message Pending */
+#define  CAN_RF0R_FULL0                      ((uint8_t)0x08)               /*!< FIFO 0 Full */
+#define  CAN_RF0R_FOVR0                      ((uint8_t)0x10)               /*!< FIFO 0 Overrun */
+#define  CAN_RF0R_RFOM0                      ((uint8_t)0x20)               /*!< Release FIFO 0 Output Mailbox */
+
+/*******************  Bit definition for CAN_RF1R register  *******************/
+#define  CAN_RF1R_FMP1                       ((uint8_t)0x03)               /*!< FIFO 1 Message Pending */
+#define  CAN_RF1R_FULL1                      ((uint8_t)0x08)               /*!< FIFO 1 Full */
+#define  CAN_RF1R_FOVR1                      ((uint8_t)0x10)               /*!< FIFO 1 Overrun */
+#define  CAN_RF1R_RFOM1                      ((uint8_t)0x20)               /*!< Release FIFO 1 Output Mailbox */
+
+/********************  Bit definition for CAN_IER register  *******************/
+#define  CAN_IER_TMEIE                       ((uint32_t)0x00000001)        /*!< Transmit Mailbox Empty Interrupt Enable */
+#define  CAN_IER_FMPIE0                      ((uint32_t)0x00000002)        /*!< FIFO Message Pending Interrupt Enable */
+#define  CAN_IER_FFIE0                       ((uint32_t)0x00000004)        /*!< FIFO Full Interrupt Enable */
+#define  CAN_IER_FOVIE0                      ((uint32_t)0x00000008)        /*!< FIFO Overrun Interrupt Enable */
+#define  CAN_IER_FMPIE1                      ((uint32_t)0x00000010)        /*!< FIFO Message Pending Interrupt Enable */
+#define  CAN_IER_FFIE1                       ((uint32_t)0x00000020)        /*!< FIFO Full Interrupt Enable */
+#define  CAN_IER_FOVIE1                      ((uint32_t)0x00000040)        /*!< FIFO Overrun Interrupt Enable */
+#define  CAN_IER_EWGIE                       ((uint32_t)0x00000100)        /*!< Error Warning Interrupt Enable */
+#define  CAN_IER_EPVIE                       ((uint32_t)0x00000200)        /*!< Error Passive Interrupt Enable */
+#define  CAN_IER_BOFIE                       ((uint32_t)0x00000400)        /*!< Bus-Off Interrupt Enable */
+#define  CAN_IER_LECIE                       ((uint32_t)0x00000800)        /*!< Last Error Code Interrupt Enable */
+#define  CAN_IER_ERRIE                       ((uint32_t)0x00008000)        /*!< Error Interrupt Enable */
+#define  CAN_IER_WKUIE                       ((uint32_t)0x00010000)        /*!< Wakeup Interrupt Enable */
+#define  CAN_IER_SLKIE                       ((uint32_t)0x00020000)        /*!< Sleep Interrupt Enable */
+
+/********************  Bit definition for CAN_ESR register  *******************/
+#define  CAN_ESR_EWGF                        ((uint32_t)0x00000001)        /*!< Error Warning Flag */
+#define  CAN_ESR_EPVF                        ((uint32_t)0x00000002)        /*!< Error Passive Flag */
+#define  CAN_ESR_BOFF                        ((uint32_t)0x00000004)        /*!< Bus-Off Flag */
+
+#define  CAN_ESR_LEC                         ((uint32_t)0x00000070)        /*!< LEC[2:0] bits (Last Error Code) */
+#define  CAN_ESR_LEC_0                       ((uint32_t)0x00000010)        /*!< Bit 0 */
+#define  CAN_ESR_LEC_1                       ((uint32_t)0x00000020)        /*!< Bit 1 */
+#define  CAN_ESR_LEC_2                       ((uint32_t)0x00000040)        /*!< Bit 2 */
+
+#define  CAN_ESR_TEC                         ((uint32_t)0x00FF0000)        /*!< Least significant byte of the 9-bit Transmit Error Counter */
+#define  CAN_ESR_REC                         ((uint32_t)0xFF000000)        /*!< Receive Error Counter */
+
+/*******************  Bit definition for CAN_BTR register  ********************/
+#define  CAN_BTR_BRP                         ((uint32_t)0x000003FF)        /*!< Baud Rate Prescaler */
+#define  CAN_BTR_TS1                         ((uint32_t)0x000F0000)        /*!< Time Segment 1 */
+#define  CAN_BTR_TS2                         ((uint32_t)0x00700000)        /*!< Time Segment 2 */
+#define  CAN_BTR_SJW                         ((uint32_t)0x03000000)        /*!< Resynchronization Jump Width */
+#define  CAN_BTR_LBKM                        ((uint32_t)0x40000000)        /*!< Loop Back Mode (Debug) */
+#define  CAN_BTR_SILM                        ((uint32_t)0x80000000)        /*!< Silent Mode */
+
+/*!< Mailbox registers */
+/******************  Bit definition for CAN_TI0R register  ********************/
+#define  CAN_TI0R_TXRQ                       ((uint32_t)0x00000001)        /*!< Transmit Mailbox Request */
+#define  CAN_TI0R_RTR                        ((uint32_t)0x00000002)        /*!< Remote Transmission Request */
+#define  CAN_TI0R_IDE                        ((uint32_t)0x00000004)        /*!< Identifier Extension */
+#define  CAN_TI0R_EXID                       ((uint32_t)0x001FFFF8)        /*!< Extended Identifier */
+#define  CAN_TI0R_STID                       ((uint32_t)0xFFE00000)        /*!< Standard Identifier or Extended Identifier */
+
+/******************  Bit definition for CAN_TDT0R register  *******************/
+#define  CAN_TDT0R_DLC                       ((uint32_t)0x0000000F)        /*!< Data Length Code */
+#define  CAN_TDT0R_TGT                       ((uint32_t)0x00000100)        /*!< Transmit Global Time */
+#define  CAN_TDT0R_TIME                      ((uint32_t)0xFFFF0000)        /*!< Message Time Stamp */
+
+/******************  Bit definition for CAN_TDL0R register  *******************/
+#define  CAN_TDL0R_DATA0                     ((uint32_t)0x000000FF)        /*!< Data byte 0 */
+#define  CAN_TDL0R_DATA1                     ((uint32_t)0x0000FF00)        /*!< Data byte 1 */
+#define  CAN_TDL0R_DATA2                     ((uint32_t)0x00FF0000)        /*!< Data byte 2 */
+#define  CAN_TDL0R_DATA3                     ((uint32_t)0xFF000000)        /*!< Data byte 3 */
+
+/******************  Bit definition for CAN_TDH0R register  *******************/
+#define  CAN_TDH0R_DATA4                     ((uint32_t)0x000000FF)        /*!< Data byte 4 */
+#define  CAN_TDH0R_DATA5                     ((uint32_t)0x0000FF00)        /*!< Data byte 5 */
+#define  CAN_TDH0R_DATA6                     ((uint32_t)0x00FF0000)        /*!< Data byte 6 */
+#define  CAN_TDH0R_DATA7                     ((uint32_t)0xFF000000)        /*!< Data byte 7 */
+
+/*******************  Bit definition for CAN_TI1R register  *******************/
+#define  CAN_TI1R_TXRQ                       ((uint32_t)0x00000001)        /*!< Transmit Mailbox Request */
+#define  CAN_TI1R_RTR                        ((uint32_t)0x00000002)        /*!< Remote Transmission Request */
+#define  CAN_TI1R_IDE                        ((uint32_t)0x00000004)        /*!< Identifier Extension */
+#define  CAN_TI1R_EXID                       ((uint32_t)0x001FFFF8)        /*!< Extended Identifier */
+#define  CAN_TI1R_STID                       ((uint32_t)0xFFE00000)        /*!< Standard Identifier or Extended Identifier */
+
+/*******************  Bit definition for CAN_TDT1R register  ******************/
+#define  CAN_TDT1R_DLC                       ((uint32_t)0x0000000F)        /*!< Data Length Code */
+#define  CAN_TDT1R_TGT                       ((uint32_t)0x00000100)        /*!< Transmit Global Time */
+#define  CAN_TDT1R_TIME                      ((uint32_t)0xFFFF0000)        /*!< Message Time Stamp */
+
+/*******************  Bit definition for CAN_TDL1R register  ******************/
+#define  CAN_TDL1R_DATA0                     ((uint32_t)0x000000FF)        /*!< Data byte 0 */
+#define  CAN_TDL1R_DATA1                     ((uint32_t)0x0000FF00)        /*!< Data byte 1 */
+#define  CAN_TDL1R_DATA2                     ((uint32_t)0x00FF0000)        /*!< Data byte 2 */
+#define  CAN_TDL1R_DATA3                     ((uint32_t)0xFF000000)        /*!< Data byte 3 */
+
+/*******************  Bit definition for CAN_TDH1R register  ******************/
+#define  CAN_TDH1R_DATA4                     ((uint32_t)0x000000FF)        /*!< Data byte 4 */
+#define  CAN_TDH1R_DATA5                     ((uint32_t)0x0000FF00)        /*!< Data byte 5 */
+#define  CAN_TDH1R_DATA6                     ((uint32_t)0x00FF0000)        /*!< Data byte 6 */
+#define  CAN_TDH1R_DATA7                     ((uint32_t)0xFF000000)        /*!< Data byte 7 */
+
+/*******************  Bit definition for CAN_TI2R register  *******************/
+#define  CAN_TI2R_TXRQ                       ((uint32_t)0x00000001)        /*!< Transmit Mailbox Request */
+#define  CAN_TI2R_RTR                        ((uint32_t)0x00000002)        /*!< Remote Transmission Request */
+#define  CAN_TI2R_IDE                        ((uint32_t)0x00000004)        /*!< Identifier Extension */
+#define  CAN_TI2R_EXID                       ((uint32_t)0x001FFFF8)        /*!< Extended identifier */
+#define  CAN_TI2R_STID                       ((uint32_t)0xFFE00000)        /*!< Standard Identifier or Extended Identifier */
+
+/*******************  Bit definition for CAN_TDT2R register  ******************/
+#define  CAN_TDT2R_DLC                       ((uint32_t)0x0000000F)        /*!< Data Length Code */
+#define  CAN_TDT2R_TGT                       ((uint32_t)0x00000100)        /*!< Transmit Global Time */
+#define  CAN_TDT2R_TIME                      ((uint32_t)0xFFFF0000)        /*!< Message Time Stamp */
+
+/*******************  Bit definition for CAN_TDL2R register  ******************/
+#define  CAN_TDL2R_DATA0                     ((uint32_t)0x000000FF)        /*!< Data byte 0 */
+#define  CAN_TDL2R_DATA1                     ((uint32_t)0x0000FF00)        /*!< Data byte 1 */
+#define  CAN_TDL2R_DATA2                     ((uint32_t)0x00FF0000)        /*!< Data byte 2 */
+#define  CAN_TDL2R_DATA3                     ((uint32_t)0xFF000000)        /*!< Data byte 3 */
+
+/*******************  Bit definition for CAN_TDH2R register  ******************/
+#define  CAN_TDH2R_DATA4                     ((uint32_t)0x000000FF)        /*!< Data byte 4 */
+#define  CAN_TDH2R_DATA5                     ((uint32_t)0x0000FF00)        /*!< Data byte 5 */
+#define  CAN_TDH2R_DATA6                     ((uint32_t)0x00FF0000)        /*!< Data byte 6 */
+#define  CAN_TDH2R_DATA7                     ((uint32_t)0xFF000000)        /*!< Data byte 7 */
+
+/*******************  Bit definition for CAN_RI0R register  *******************/
+#define  CAN_RI0R_RTR                        ((uint32_t)0x00000002)        /*!< Remote Transmission Request */
+#define  CAN_RI0R_IDE                        ((uint32_t)0x00000004)        /*!< Identifier Extension */
+#define  CAN_RI0R_EXID                       ((uint32_t)0x001FFFF8)        /*!< Extended Identifier */
+#define  CAN_RI0R_STID                       ((uint32_t)0xFFE00000)        /*!< Standard Identifier or Extended Identifier */
+
+/*******************  Bit definition for CAN_RDT0R register  ******************/
+#define  CAN_RDT0R_DLC                       ((uint32_t)0x0000000F)        /*!< Data Length Code */
+#define  CAN_RDT0R_FMI                       ((uint32_t)0x0000FF00)        /*!< Filter Match Index */
+#define  CAN_RDT0R_TIME                      ((uint32_t)0xFFFF0000)        /*!< Message Time Stamp */
+
+/*******************  Bit definition for CAN_RDL0R register  ******************/
+#define  CAN_RDL0R_DATA0                     ((uint32_t)0x000000FF)        /*!< Data byte 0 */
+#define  CAN_RDL0R_DATA1                     ((uint32_t)0x0000FF00)        /*!< Data byte 1 */
+#define  CAN_RDL0R_DATA2                     ((uint32_t)0x00FF0000)        /*!< Data byte 2 */
+#define  CAN_RDL0R_DATA3                     ((uint32_t)0xFF000000)        /*!< Data byte 3 */
+
+/*******************  Bit definition for CAN_RDH0R register  ******************/
+#define  CAN_RDH0R_DATA4                     ((uint32_t)0x000000FF)        /*!< Data byte 4 */
+#define  CAN_RDH0R_DATA5                     ((uint32_t)0x0000FF00)        /*!< Data byte 5 */
+#define  CAN_RDH0R_DATA6                     ((uint32_t)0x00FF0000)        /*!< Data byte 6 */
+#define  CAN_RDH0R_DATA7                     ((uint32_t)0xFF000000)        /*!< Data byte 7 */
+
+/*******************  Bit definition for CAN_RI1R register  *******************/
+#define  CAN_RI1R_RTR                        ((uint32_t)0x00000002)        /*!< Remote Transmission Request */
+#define  CAN_RI1R_IDE                        ((uint32_t)0x00000004)        /*!< Identifier Extension */
+#define  CAN_RI1R_EXID                       ((uint32_t)0x001FFFF8)        /*!< Extended identifier */
+#define  CAN_RI1R_STID                       ((uint32_t)0xFFE00000)        /*!< Standard Identifier or Extended Identifier */
+
+/*******************  Bit definition for CAN_RDT1R register  ******************/
+#define  CAN_RDT1R_DLC                       ((uint32_t)0x0000000F)        /*!< Data Length Code */
+#define  CAN_RDT1R_FMI                       ((uint32_t)0x0000FF00)        /*!< Filter Match Index */
+#define  CAN_RDT1R_TIME                      ((uint32_t)0xFFFF0000)        /*!< Message Time Stamp */
+
+/*******************  Bit definition for CAN_RDL1R register  ******************/
+#define  CAN_RDL1R_DATA0                     ((uint32_t)0x000000FF)        /*!< Data byte 0 */
+#define  CAN_RDL1R_DATA1                     ((uint32_t)0x0000FF00)        /*!< Data byte 1 */
+#define  CAN_RDL1R_DATA2                     ((uint32_t)0x00FF0000)        /*!< Data byte 2 */
+#define  CAN_RDL1R_DATA3                     ((uint32_t)0xFF000000)        /*!< Data byte 3 */
+
+/*******************  Bit definition for CAN_RDH1R register  ******************/
+#define  CAN_RDH1R_DATA4                     ((uint32_t)0x000000FF)        /*!< Data byte 4 */
+#define  CAN_RDH1R_DATA5                     ((uint32_t)0x0000FF00)        /*!< Data byte 5 */
+#define  CAN_RDH1R_DATA6                     ((uint32_t)0x00FF0000)        /*!< Data byte 6 */
+#define  CAN_RDH1R_DATA7                     ((uint32_t)0xFF000000)        /*!< Data byte 7 */
+
+/*!< CAN filter registers */
+/*******************  Bit definition for CAN_FMR register  ********************/
+#define  CAN_FMR_FINIT                       ((uint8_t)0x01)               /*!< Filter Init Mode */
+
+/*******************  Bit definition for CAN_FM1R register  *******************/
+#define  CAN_FM1R_FBM                        ((uint16_t)0x3FFF)            /*!< Filter Mode */
+#define  CAN_FM1R_FBM0                       ((uint16_t)0x0001)            /*!< Filter Init Mode bit 0 */
+#define  CAN_FM1R_FBM1                       ((uint16_t)0x0002)            /*!< Filter Init Mode bit 1 */
+#define  CAN_FM1R_FBM2                       ((uint16_t)0x0004)            /*!< Filter Init Mode bit 2 */
+#define  CAN_FM1R_FBM3                       ((uint16_t)0x0008)            /*!< Filter Init Mode bit 3 */
+#define  CAN_FM1R_FBM4                       ((uint16_t)0x0010)            /*!< Filter Init Mode bit 4 */
+#define  CAN_FM1R_FBM5                       ((uint16_t)0x0020)            /*!< Filter Init Mode bit 5 */
+#define  CAN_FM1R_FBM6                       ((uint16_t)0x0040)            /*!< Filter Init Mode bit 6 */
+#define  CAN_FM1R_FBM7                       ((uint16_t)0x0080)            /*!< Filter Init Mode bit 7 */
+#define  CAN_FM1R_FBM8                       ((uint16_t)0x0100)            /*!< Filter Init Mode bit 8 */
+#define  CAN_FM1R_FBM9                       ((uint16_t)0x0200)            /*!< Filter Init Mode bit 9 */
+#define  CAN_FM1R_FBM10                      ((uint16_t)0x0400)            /*!< Filter Init Mode bit 10 */
+#define  CAN_FM1R_FBM11                      ((uint16_t)0x0800)            /*!< Filter Init Mode bit 11 */
+#define  CAN_FM1R_FBM12                      ((uint16_t)0x1000)            /*!< Filter Init Mode bit 12 */
+#define  CAN_FM1R_FBM13                      ((uint16_t)0x2000)            /*!< Filter Init Mode bit 13 */
+
+/*******************  Bit definition for CAN_FS1R register  *******************/
+#define  CAN_FS1R_FSC                        ((uint16_t)0x3FFF)            /*!< Filter Scale Configuration */
+#define  CAN_FS1R_FSC0                       ((uint16_t)0x0001)            /*!< Filter Scale Configuration bit 0 */
+#define  CAN_FS1R_FSC1                       ((uint16_t)0x0002)            /*!< Filter Scale Configuration bit 1 */
+#define  CAN_FS1R_FSC2                       ((uint16_t)0x0004)            /*!< Filter Scale Configuration bit 2 */
+#define  CAN_FS1R_FSC3                       ((uint16_t)0x0008)            /*!< Filter Scale Configuration bit 3 */
+#define  CAN_FS1R_FSC4                       ((uint16_t)0x0010)            /*!< Filter Scale Configuration bit 4 */
+#define  CAN_FS1R_FSC5                       ((uint16_t)0x0020)            /*!< Filter Scale Configuration bit 5 */
+#define  CAN_FS1R_FSC6                       ((uint16_t)0x0040)            /*!< Filter Scale Configuration bit 6 */
+#define  CAN_FS1R_FSC7                       ((uint16_t)0x0080)            /*!< Filter Scale Configuration bit 7 */
+#define  CAN_FS1R_FSC8                       ((uint16_t)0x0100)            /*!< Filter Scale Configuration bit 8 */
+#define  CAN_FS1R_FSC9                       ((uint16_t)0x0200)            /*!< Filter Scale Configuration bit 9 */
+#define  CAN_FS1R_FSC10                      ((uint16_t)0x0400)            /*!< Filter Scale Configuration bit 10 */
+#define  CAN_FS1R_FSC11                      ((uint16_t)0x0800)            /*!< Filter Scale Configuration bit 11 */
+#define  CAN_FS1R_FSC12                      ((uint16_t)0x1000)            /*!< Filter Scale Configuration bit 12 */
+#define  CAN_FS1R_FSC13                      ((uint16_t)0x2000)            /*!< Filter Scale Configuration bit 13 */
+
+/******************  Bit definition for CAN_FFA1R register  *******************/
+#define  CAN_FFA1R_FFA                       ((uint16_t)0x3FFF)            /*!< Filter FIFO Assignment */
+#define  CAN_FFA1R_FFA0                      ((uint16_t)0x0001)            /*!< Filter FIFO Assignment for Filter 0 */
+#define  CAN_FFA1R_FFA1                      ((uint16_t)0x0002)            /*!< Filter FIFO Assignment for Filter 1 */
+#define  CAN_FFA1R_FFA2                      ((uint16_t)0x0004)            /*!< Filter FIFO Assignment for Filter 2 */
+#define  CAN_FFA1R_FFA3                      ((uint16_t)0x0008)            /*!< Filter FIFO Assignment for Filter 3 */
+#define  CAN_FFA1R_FFA4                      ((uint16_t)0x0010)            /*!< Filter FIFO Assignment for Filter 4 */
+#define  CAN_FFA1R_FFA5                      ((uint16_t)0x0020)            /*!< Filter FIFO Assignment for Filter 5 */
+#define  CAN_FFA1R_FFA6                      ((uint16_t)0x0040)            /*!< Filter FIFO Assignment for Filter 6 */
+#define  CAN_FFA1R_FFA7                      ((uint16_t)0x0080)            /*!< Filter FIFO Assignment for Filter 7 */
+#define  CAN_FFA1R_FFA8                      ((uint16_t)0x0100)            /*!< Filter FIFO Assignment for Filter 8 */
+#define  CAN_FFA1R_FFA9                      ((uint16_t)0x0200)            /*!< Filter FIFO Assignment for Filter 9 */
+#define  CAN_FFA1R_FFA10                     ((uint16_t)0x0400)            /*!< Filter FIFO Assignment for Filter 10 */
+#define  CAN_FFA1R_FFA11                     ((uint16_t)0x0800)            /*!< Filter FIFO Assignment for Filter 11 */
+#define  CAN_FFA1R_FFA12                     ((uint16_t)0x1000)            /*!< Filter FIFO Assignment for Filter 12 */
+#define  CAN_FFA1R_FFA13                     ((uint16_t)0x2000)            /*!< Filter FIFO Assignment for Filter 13 */
+
+/*******************  Bit definition for CAN_FA1R register  *******************/
+#define  CAN_FA1R_FACT                       ((uint16_t)0x3FFF)            /*!< Filter Active */
+#define  CAN_FA1R_FACT0                      ((uint16_t)0x0001)            /*!< Filter 0 Active */
+#define  CAN_FA1R_FACT1                      ((uint16_t)0x0002)            /*!< Filter 1 Active */
+#define  CAN_FA1R_FACT2                      ((uint16_t)0x0004)            /*!< Filter 2 Active */
+#define  CAN_FA1R_FACT3                      ((uint16_t)0x0008)            /*!< Filter 3 Active */
+#define  CAN_FA1R_FACT4                      ((uint16_t)0x0010)            /*!< Filter 4 Active */
+#define  CAN_FA1R_FACT5                      ((uint16_t)0x0020)            /*!< Filter 5 Active */
+#define  CAN_FA1R_FACT6                      ((uint16_t)0x0040)            /*!< Filter 6 Active */
+#define  CAN_FA1R_FACT7                      ((uint16_t)0x0080)            /*!< Filter 7 Active */
+#define  CAN_FA1R_FACT8                      ((uint16_t)0x0100)            /*!< Filter 8 Active */
+#define  CAN_FA1R_FACT9                      ((uint16_t)0x0200)            /*!< Filter 9 Active */
+#define  CAN_FA1R_FACT10                     ((uint16_t)0x0400)            /*!< Filter 10 Active */
+#define  CAN_FA1R_FACT11                     ((uint16_t)0x0800)            /*!< Filter 11 Active */
+#define  CAN_FA1R_FACT12                     ((uint16_t)0x1000)            /*!< Filter 12 Active */
+#define  CAN_FA1R_FACT13                     ((uint16_t)0x2000)            /*!< Filter 13 Active */
+
+/*******************  Bit definition for CAN_F0R1 register  *******************/
+#define  CAN_F0R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
+#define  CAN_F0R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
+#define  CAN_F0R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
+#define  CAN_F0R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
+#define  CAN_F0R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
+#define  CAN_F0R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
+#define  CAN_F0R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
+#define  CAN_F0R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
+#define  CAN_F0R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
+#define  CAN_F0R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
+#define  CAN_F0R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
+#define  CAN_F0R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
+#define  CAN_F0R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
+#define  CAN_F0R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
+#define  CAN_F0R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
+#define  CAN_F0R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
+#define  CAN_F0R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
+#define  CAN_F0R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
+#define  CAN_F0R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
+#define  CAN_F0R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
+#define  CAN_F0R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
+#define  CAN_F0R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
+#define  CAN_F0R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
+#define  CAN_F0R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
+#define  CAN_F0R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
+#define  CAN_F0R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
+#define  CAN_F0R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
+#define  CAN_F0R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
+#define  CAN_F0R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
+#define  CAN_F0R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
+#define  CAN_F0R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
+#define  CAN_F0R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
+
+/*******************  Bit definition for CAN_F1R1 register  *******************/
+#define  CAN_F1R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
+#define  CAN_F1R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
+#define  CAN_F1R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
+#define  CAN_F1R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
+#define  CAN_F1R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
+#define  CAN_F1R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
+#define  CAN_F1R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
+#define  CAN_F1R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
+#define  CAN_F1R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
+#define  CAN_F1R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
+#define  CAN_F1R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
+#define  CAN_F1R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
+#define  CAN_F1R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
+#define  CAN_F1R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
+#define  CAN_F1R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
+#define  CAN_F1R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
+#define  CAN_F1R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
+#define  CAN_F1R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
+#define  CAN_F1R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
+#define  CAN_F1R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
+#define  CAN_F1R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
+#define  CAN_F1R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
+#define  CAN_F1R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
+#define  CAN_F1R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
+#define  CAN_F1R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
+#define  CAN_F1R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
+#define  CAN_F1R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
+#define  CAN_F1R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
+#define  CAN_F1R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
+#define  CAN_F1R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
+#define  CAN_F1R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
+#define  CAN_F1R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
+
+/*******************  Bit definition for CAN_F2R1 register  *******************/
+#define  CAN_F2R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
+#define  CAN_F2R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
+#define  CAN_F2R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
+#define  CAN_F2R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
+#define  CAN_F2R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
+#define  CAN_F2R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
+#define  CAN_F2R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
+#define  CAN_F2R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
+#define  CAN_F2R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
+#define  CAN_F2R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
+#define  CAN_F2R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
+#define  CAN_F2R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
+#define  CAN_F2R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
+#define  CAN_F2R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
+#define  CAN_F2R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
+#define  CAN_F2R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
+#define  CAN_F2R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
+#define  CAN_F2R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
+#define  CAN_F2R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
+#define  CAN_F2R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
+#define  CAN_F2R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
+#define  CAN_F2R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
+#define  CAN_F2R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
+#define  CAN_F2R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
+#define  CAN_F2R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
+#define  CAN_F2R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
+#define  CAN_F2R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
+#define  CAN_F2R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
+#define  CAN_F2R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
+#define  CAN_F2R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
+#define  CAN_F2R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
+#define  CAN_F2R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
+
+/*******************  Bit definition for CAN_F3R1 register  *******************/
+#define  CAN_F3R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
+#define  CAN_F3R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
+#define  CAN_F3R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
+#define  CAN_F3R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
+#define  CAN_F3R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
+#define  CAN_F3R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
+#define  CAN_F3R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
+#define  CAN_F3R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
+#define  CAN_F3R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
+#define  CAN_F3R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
+#define  CAN_F3R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
+#define  CAN_F3R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
+#define  CAN_F3R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
+#define  CAN_F3R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
+#define  CAN_F3R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
+#define  CAN_F3R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
+#define  CAN_F3R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
+#define  CAN_F3R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
+#define  CAN_F3R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
+#define  CAN_F3R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
+#define  CAN_F3R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
+#define  CAN_F3R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
+#define  CAN_F3R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
+#define  CAN_F3R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
+#define  CAN_F3R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
+#define  CAN_F3R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
+#define  CAN_F3R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
+#define  CAN_F3R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
+#define  CAN_F3R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
+#define  CAN_F3R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
+#define  CAN_F3R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
+#define  CAN_F3R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
+
+/*******************  Bit definition for CAN_F4R1 register  *******************/
+#define  CAN_F4R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
+#define  CAN_F4R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
+#define  CAN_F4R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
+#define  CAN_F4R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
+#define  CAN_F4R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
+#define  CAN_F4R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
+#define  CAN_F4R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
+#define  CAN_F4R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
+#define  CAN_F4R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
+#define  CAN_F4R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
+#define  CAN_F4R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
+#define  CAN_F4R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
+#define  CAN_F4R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
+#define  CAN_F4R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
+#define  CAN_F4R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
+#define  CAN_F4R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
+#define  CAN_F4R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
+#define  CAN_F4R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
+#define  CAN_F4R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
+#define  CAN_F4R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
+#define  CAN_F4R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
+#define  CAN_F4R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
+#define  CAN_F4R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
+#define  CAN_F4R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
+#define  CAN_F4R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
+#define  CAN_F4R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
+#define  CAN_F4R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
+#define  CAN_F4R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
+#define  CAN_F4R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
+#define  CAN_F4R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
+#define  CAN_F4R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
+#define  CAN_F4R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
+
+/*******************  Bit definition for CAN_F5R1 register  *******************/
+#define  CAN_F5R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
+#define  CAN_F5R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
+#define  CAN_F5R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
+#define  CAN_F5R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
+#define  CAN_F5R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
+#define  CAN_F5R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
+#define  CAN_F5R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
+#define  CAN_F5R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
+#define  CAN_F5R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
+#define  CAN_F5R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
+#define  CAN_F5R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
+#define  CAN_F5R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
+#define  CAN_F5R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
+#define  CAN_F5R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
+#define  CAN_F5R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
+#define  CAN_F5R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
+#define  CAN_F5R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
+#define  CAN_F5R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
+#define  CAN_F5R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
+#define  CAN_F5R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
+#define  CAN_F5R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
+#define  CAN_F5R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
+#define  CAN_F5R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
+#define  CAN_F5R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
+#define  CAN_F5R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
+#define  CAN_F5R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
+#define  CAN_F5R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
+#define  CAN_F5R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
+#define  CAN_F5R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
+#define  CAN_F5R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
+#define  CAN_F5R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
+#define  CAN_F5R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
+
+/*******************  Bit definition for CAN_F6R1 register  *******************/
+#define  CAN_F6R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
+#define  CAN_F6R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
+#define  CAN_F6R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
+#define  CAN_F6R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
+#define  CAN_F6R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
+#define  CAN_F6R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
+#define  CAN_F6R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
+#define  CAN_F6R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
+#define  CAN_F6R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
+#define  CAN_F6R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
+#define  CAN_F6R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
+#define  CAN_F6R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
+#define  CAN_F6R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
+#define  CAN_F6R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
+#define  CAN_F6R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
+#define  CAN_F6R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
+#define  CAN_F6R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
+#define  CAN_F6R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
+#define  CAN_F6R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
+#define  CAN_F6R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
+#define  CAN_F6R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
+#define  CAN_F6R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
+#define  CAN_F6R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
+#define  CAN_F6R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
+#define  CAN_F6R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
+#define  CAN_F6R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
+#define  CAN_F6R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
+#define  CAN_F6R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
+#define  CAN_F6R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
+#define  CAN_F6R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
+#define  CAN_F6R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
+#define  CAN_F6R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
+
+/*******************  Bit definition for CAN_F7R1 register  *******************/
+#define  CAN_F7R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
+#define  CAN_F7R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
+#define  CAN_F7R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
+#define  CAN_F7R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
+#define  CAN_F7R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
+#define  CAN_F7R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
+#define  CAN_F7R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
+#define  CAN_F7R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
+#define  CAN_F7R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
+#define  CAN_F7R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
+#define  CAN_F7R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
+#define  CAN_F7R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
+#define  CAN_F7R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
+#define  CAN_F7R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
+#define  CAN_F7R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
+#define  CAN_F7R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
+#define  CAN_F7R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
+#define  CAN_F7R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
+#define  CAN_F7R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
+#define  CAN_F7R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
+#define  CAN_F7R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
+#define  CAN_F7R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
+#define  CAN_F7R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
+#define  CAN_F7R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
+#define  CAN_F7R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
+#define  CAN_F7R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
+#define  CAN_F7R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
+#define  CAN_F7R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
+#define  CAN_F7R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
+#define  CAN_F7R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
+#define  CAN_F7R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
+#define  CAN_F7R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
+
+/*******************  Bit definition for CAN_F8R1 register  *******************/
+#define  CAN_F8R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
+#define  CAN_F8R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
+#define  CAN_F8R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
+#define  CAN_F8R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
+#define  CAN_F8R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
+#define  CAN_F8R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
+#define  CAN_F8R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
+#define  CAN_F8R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
+#define  CAN_F8R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
+#define  CAN_F8R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
+#define  CAN_F8R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
+#define  CAN_F8R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
+#define  CAN_F8R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
+#define  CAN_F8R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
+#define  CAN_F8R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
+#define  CAN_F8R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
+#define  CAN_F8R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
+#define  CAN_F8R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
+#define  CAN_F8R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
+#define  CAN_F8R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
+#define  CAN_F8R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
+#define  CAN_F8R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
+#define  CAN_F8R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
+#define  CAN_F8R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
+#define  CAN_F8R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
+#define  CAN_F8R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
+#define  CAN_F8R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
+#define  CAN_F8R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
+#define  CAN_F8R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
+#define  CAN_F8R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
+#define  CAN_F8R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
+#define  CAN_F8R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
+
+/*******************  Bit definition for CAN_F9R1 register  *******************/
+#define  CAN_F9R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
+#define  CAN_F9R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
+#define  CAN_F9R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
+#define  CAN_F9R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
+#define  CAN_F9R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
+#define  CAN_F9R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
+#define  CAN_F9R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
+#define  CAN_F9R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
+#define  CAN_F9R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
+#define  CAN_F9R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
+#define  CAN_F9R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
+#define  CAN_F9R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
+#define  CAN_F9R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
+#define  CAN_F9R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
+#define  CAN_F9R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
+#define  CAN_F9R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
+#define  CAN_F9R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
+#define  CAN_F9R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
+#define  CAN_F9R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
+#define  CAN_F9R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
+#define  CAN_F9R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
+#define  CAN_F9R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
+#define  CAN_F9R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
+#define  CAN_F9R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
+#define  CAN_F9R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
+#define  CAN_F9R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
+#define  CAN_F9R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
+#define  CAN_F9R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
+#define  CAN_F9R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
+#define  CAN_F9R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
+#define  CAN_F9R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
+#define  CAN_F9R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
+
+/*******************  Bit definition for CAN_F10R1 register  ******************/
+#define  CAN_F10R1_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
+#define  CAN_F10R1_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
+#define  CAN_F10R1_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
+#define  CAN_F10R1_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
+#define  CAN_F10R1_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
+#define  CAN_F10R1_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
+#define  CAN_F10R1_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
+#define  CAN_F10R1_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
+#define  CAN_F10R1_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
+#define  CAN_F10R1_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
+#define  CAN_F10R1_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
+#define  CAN_F10R1_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
+#define  CAN_F10R1_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
+#define  CAN_F10R1_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
+#define  CAN_F10R1_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
+#define  CAN_F10R1_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
+#define  CAN_F10R1_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
+#define  CAN_F10R1_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
+#define  CAN_F10R1_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
+#define  CAN_F10R1_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
+#define  CAN_F10R1_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
+#define  CAN_F10R1_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
+#define  CAN_F10R1_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
+#define  CAN_F10R1_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
+#define  CAN_F10R1_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
+#define  CAN_F10R1_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
+#define  CAN_F10R1_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
+#define  CAN_F10R1_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
+#define  CAN_F10R1_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
+#define  CAN_F10R1_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
+#define  CAN_F10R1_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
+#define  CAN_F10R1_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
+
+/*******************  Bit definition for CAN_F11R1 register  ******************/
+#define  CAN_F11R1_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
+#define  CAN_F11R1_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
+#define  CAN_F11R1_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
+#define  CAN_F11R1_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
+#define  CAN_F11R1_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
+#define  CAN_F11R1_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
+#define  CAN_F11R1_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
+#define  CAN_F11R1_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
+#define  CAN_F11R1_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
+#define  CAN_F11R1_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
+#define  CAN_F11R1_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
+#define  CAN_F11R1_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
+#define  CAN_F11R1_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
+#define  CAN_F11R1_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
+#define  CAN_F11R1_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
+#define  CAN_F11R1_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
+#define  CAN_F11R1_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
+#define  CAN_F11R1_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
+#define  CAN_F11R1_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
+#define  CAN_F11R1_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
+#define  CAN_F11R1_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
+#define  CAN_F11R1_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
+#define  CAN_F11R1_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
+#define  CAN_F11R1_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
+#define  CAN_F11R1_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
+#define  CAN_F11R1_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
+#define  CAN_F11R1_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
+#define  CAN_F11R1_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
+#define  CAN_F11R1_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
+#define  CAN_F11R1_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
+#define  CAN_F11R1_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
+#define  CAN_F11R1_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
+
+/*******************  Bit definition for CAN_F12R1 register  ******************/
+#define  CAN_F12R1_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
+#define  CAN_F12R1_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
+#define  CAN_F12R1_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
+#define  CAN_F12R1_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
+#define  CAN_F12R1_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
+#define  CAN_F12R1_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
+#define  CAN_F12R1_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
+#define  CAN_F12R1_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
+#define  CAN_F12R1_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
+#define  CAN_F12R1_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
+#define  CAN_F12R1_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
+#define  CAN_F12R1_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
+#define  CAN_F12R1_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
+#define  CAN_F12R1_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
+#define  CAN_F12R1_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
+#define  CAN_F12R1_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
+#define  CAN_F12R1_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
+#define  CAN_F12R1_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
+#define  CAN_F12R1_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
+#define  CAN_F12R1_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
+#define  CAN_F12R1_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
+#define  CAN_F12R1_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
+#define  CAN_F12R1_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
+#define  CAN_F12R1_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
+#define  CAN_F12R1_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
+#define  CAN_F12R1_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
+#define  CAN_F12R1_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
+#define  CAN_F12R1_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
+#define  CAN_F12R1_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
+#define  CAN_F12R1_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
+#define  CAN_F12R1_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
+#define  CAN_F12R1_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
+
+/*******************  Bit definition for CAN_F13R1 register  ******************/
+#define  CAN_F13R1_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
+#define  CAN_F13R1_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
+#define  CAN_F13R1_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
+#define  CAN_F13R1_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
+#define  CAN_F13R1_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
+#define  CAN_F13R1_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
+#define  CAN_F13R1_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
+#define  CAN_F13R1_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
+#define  CAN_F13R1_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
+#define  CAN_F13R1_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
+#define  CAN_F13R1_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
+#define  CAN_F13R1_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
+#define  CAN_F13R1_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
+#define  CAN_F13R1_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
+#define  CAN_F13R1_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
+#define  CAN_F13R1_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
+#define  CAN_F13R1_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
+#define  CAN_F13R1_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
+#define  CAN_F13R1_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
+#define  CAN_F13R1_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
+#define  CAN_F13R1_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
+#define  CAN_F13R1_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
+#define  CAN_F13R1_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
+#define  CAN_F13R1_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
+#define  CAN_F13R1_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
+#define  CAN_F13R1_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
+#define  CAN_F13R1_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
+#define  CAN_F13R1_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
+#define  CAN_F13R1_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
+#define  CAN_F13R1_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
+#define  CAN_F13R1_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
+#define  CAN_F13R1_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
+
+/*******************  Bit definition for CAN_F0R2 register  *******************/
+#define  CAN_F0R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
+#define  CAN_F0R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
+#define  CAN_F0R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
+#define  CAN_F0R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
+#define  CAN_F0R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
+#define  CAN_F0R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
+#define  CAN_F0R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
+#define  CAN_F0R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
+#define  CAN_F0R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
+#define  CAN_F0R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
+#define  CAN_F0R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
+#define  CAN_F0R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
+#define  CAN_F0R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
+#define  CAN_F0R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
+#define  CAN_F0R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
+#define  CAN_F0R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
+#define  CAN_F0R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
+#define  CAN_F0R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
+#define  CAN_F0R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
+#define  CAN_F0R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
+#define  CAN_F0R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
+#define  CAN_F0R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
+#define  CAN_F0R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
+#define  CAN_F0R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
+#define  CAN_F0R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
+#define  CAN_F0R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
+#define  CAN_F0R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
+#define  CAN_F0R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
+#define  CAN_F0R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
+#define  CAN_F0R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
+#define  CAN_F0R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
+#define  CAN_F0R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
+
+/*******************  Bit definition for CAN_F1R2 register  *******************/
+#define  CAN_F1R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
+#define  CAN_F1R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
+#define  CAN_F1R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
+#define  CAN_F1R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
+#define  CAN_F1R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
+#define  CAN_F1R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
+#define  CAN_F1R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
+#define  CAN_F1R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
+#define  CAN_F1R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
+#define  CAN_F1R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
+#define  CAN_F1R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
+#define  CAN_F1R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
+#define  CAN_F1R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
+#define  CAN_F1R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
+#define  CAN_F1R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
+#define  CAN_F1R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
+#define  CAN_F1R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
+#define  CAN_F1R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
+#define  CAN_F1R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
+#define  CAN_F1R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
+#define  CAN_F1R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
+#define  CAN_F1R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
+#define  CAN_F1R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
+#define  CAN_F1R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
+#define  CAN_F1R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
+#define  CAN_F1R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
+#define  CAN_F1R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
+#define  CAN_F1R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
+#define  CAN_F1R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
+#define  CAN_F1R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
+#define  CAN_F1R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
+#define  CAN_F1R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
+
+/*******************  Bit definition for CAN_F2R2 register  *******************/
+#define  CAN_F2R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
+#define  CAN_F2R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
+#define  CAN_F2R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
+#define  CAN_F2R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
+#define  CAN_F2R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
+#define  CAN_F2R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
+#define  CAN_F2R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
+#define  CAN_F2R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
+#define  CAN_F2R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
+#define  CAN_F2R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
+#define  CAN_F2R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
+#define  CAN_F2R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
+#define  CAN_F2R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
+#define  CAN_F2R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
+#define  CAN_F2R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
+#define  CAN_F2R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
+#define  CAN_F2R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
+#define  CAN_F2R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
+#define  CAN_F2R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
+#define  CAN_F2R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
+#define  CAN_F2R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
+#define  CAN_F2R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
+#define  CAN_F2R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
+#define  CAN_F2R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
+#define  CAN_F2R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
+#define  CAN_F2R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
+#define  CAN_F2R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
+#define  CAN_F2R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
+#define  CAN_F2R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
+#define  CAN_F2R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
+#define  CAN_F2R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
+#define  CAN_F2R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
+
+/*******************  Bit definition for CAN_F3R2 register  *******************/
+#define  CAN_F3R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
+#define  CAN_F3R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
+#define  CAN_F3R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
+#define  CAN_F3R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
+#define  CAN_F3R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
+#define  CAN_F3R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
+#define  CAN_F3R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
+#define  CAN_F3R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
+#define  CAN_F3R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
+#define  CAN_F3R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
+#define  CAN_F3R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
+#define  CAN_F3R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
+#define  CAN_F3R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
+#define  CAN_F3R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
+#define  CAN_F3R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
+#define  CAN_F3R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
+#define  CAN_F3R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
+#define  CAN_F3R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
+#define  CAN_F3R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
+#define  CAN_F3R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
+#define  CAN_F3R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
+#define  CAN_F3R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
+#define  CAN_F3R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
+#define  CAN_F3R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
+#define  CAN_F3R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
+#define  CAN_F3R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
+#define  CAN_F3R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
+#define  CAN_F3R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
+#define  CAN_F3R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
+#define  CAN_F3R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
+#define  CAN_F3R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
+#define  CAN_F3R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
+
+/*******************  Bit definition for CAN_F4R2 register  *******************/
+#define  CAN_F4R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
+#define  CAN_F4R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
+#define  CAN_F4R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
+#define  CAN_F4R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
+#define  CAN_F4R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
+#define  CAN_F4R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
+#define  CAN_F4R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
+#define  CAN_F4R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
+#define  CAN_F4R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
+#define  CAN_F4R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
+#define  CAN_F4R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
+#define  CAN_F4R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
+#define  CAN_F4R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
+#define  CAN_F4R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
+#define  CAN_F4R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
+#define  CAN_F4R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
+#define  CAN_F4R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
+#define  CAN_F4R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
+#define  CAN_F4R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
+#define  CAN_F4R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
+#define  CAN_F4R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
+#define  CAN_F4R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
+#define  CAN_F4R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
+#define  CAN_F4R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
+#define  CAN_F4R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
+#define  CAN_F4R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
+#define  CAN_F4R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
+#define  CAN_F4R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
+#define  CAN_F4R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
+#define  CAN_F4R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
+#define  CAN_F4R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
+#define  CAN_F4R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
+
+/*******************  Bit definition for CAN_F5R2 register  *******************/
+#define  CAN_F5R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
+#define  CAN_F5R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
+#define  CAN_F5R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
+#define  CAN_F5R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
+#define  CAN_F5R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
+#define  CAN_F5R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
+#define  CAN_F5R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
+#define  CAN_F5R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
+#define  CAN_F5R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
+#define  CAN_F5R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
+#define  CAN_F5R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
+#define  CAN_F5R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
+#define  CAN_F5R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
+#define  CAN_F5R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
+#define  CAN_F5R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
+#define  CAN_F5R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
+#define  CAN_F5R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
+#define  CAN_F5R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
+#define  CAN_F5R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
+#define  CAN_F5R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
+#define  CAN_F5R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
+#define  CAN_F5R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
+#define  CAN_F5R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
+#define  CAN_F5R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
+#define  CAN_F5R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
+#define  CAN_F5R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
+#define  CAN_F5R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
+#define  CAN_F5R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
+#define  CAN_F5R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
+#define  CAN_F5R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
+#define  CAN_F5R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
+#define  CAN_F5R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
+
+/*******************  Bit definition for CAN_F6R2 register  *******************/
+#define  CAN_F6R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
+#define  CAN_F6R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
+#define  CAN_F6R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
+#define  CAN_F6R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
+#define  CAN_F6R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
+#define  CAN_F6R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
+#define  CAN_F6R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
+#define  CAN_F6R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
+#define  CAN_F6R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
+#define  CAN_F6R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
+#define  CAN_F6R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
+#define  CAN_F6R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
+#define  CAN_F6R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
+#define  CAN_F6R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
+#define  CAN_F6R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
+#define  CAN_F6R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
+#define  CAN_F6R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
+#define  CAN_F6R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
+#define  CAN_F6R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
+#define  CAN_F6R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
+#define  CAN_F6R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
+#define  CAN_F6R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
+#define  CAN_F6R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
+#define  CAN_F6R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
+#define  CAN_F6R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
+#define  CAN_F6R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
+#define  CAN_F6R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
+#define  CAN_F6R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
+#define  CAN_F6R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
+#define  CAN_F6R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
+#define  CAN_F6R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
+#define  CAN_F6R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
+
+/*******************  Bit definition for CAN_F7R2 register  *******************/
+#define  CAN_F7R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
+#define  CAN_F7R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
+#define  CAN_F7R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
+#define  CAN_F7R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
+#define  CAN_F7R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
+#define  CAN_F7R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
+#define  CAN_F7R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
+#define  CAN_F7R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
+#define  CAN_F7R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
+#define  CAN_F7R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
+#define  CAN_F7R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
+#define  CAN_F7R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
+#define  CAN_F7R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
+#define  CAN_F7R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
+#define  CAN_F7R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
+#define  CAN_F7R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
+#define  CAN_F7R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
+#define  CAN_F7R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
+#define  CAN_F7R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
+#define  CAN_F7R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
+#define  CAN_F7R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
+#define  CAN_F7R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
+#define  CAN_F7R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
+#define  CAN_F7R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
+#define  CAN_F7R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
+#define  CAN_F7R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
+#define  CAN_F7R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
+#define  CAN_F7R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
+#define  CAN_F7R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
+#define  CAN_F7R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
+#define  CAN_F7R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
+#define  CAN_F7R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
+
+/*******************  Bit definition for CAN_F8R2 register  *******************/
+#define  CAN_F8R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
+#define  CAN_F8R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
+#define  CAN_F8R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
+#define  CAN_F8R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
+#define  CAN_F8R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
+#define  CAN_F8R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
+#define  CAN_F8R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
+#define  CAN_F8R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
+#define  CAN_F8R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
+#define  CAN_F8R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
+#define  CAN_F8R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
+#define  CAN_F8R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
+#define  CAN_F8R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
+#define  CAN_F8R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
+#define  CAN_F8R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
+#define  CAN_F8R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
+#define  CAN_F8R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
+#define  CAN_F8R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
+#define  CAN_F8R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
+#define  CAN_F8R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
+#define  CAN_F8R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
+#define  CAN_F8R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
+#define  CAN_F8R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
+#define  CAN_F8R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
+#define  CAN_F8R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
+#define  CAN_F8R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
+#define  CAN_F8R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
+#define  CAN_F8R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
+#define  CAN_F8R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
+#define  CAN_F8R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
+#define  CAN_F8R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
+#define  CAN_F8R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
+
+/*******************  Bit definition for CAN_F9R2 register  *******************/
+#define  CAN_F9R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
+#define  CAN_F9R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
+#define  CAN_F9R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
+#define  CAN_F9R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
+#define  CAN_F9R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
+#define  CAN_F9R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
+#define  CAN_F9R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
+#define  CAN_F9R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
+#define  CAN_F9R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
+#define  CAN_F9R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
+#define  CAN_F9R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
+#define  CAN_F9R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
+#define  CAN_F9R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
+#define  CAN_F9R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
+#define  CAN_F9R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
+#define  CAN_F9R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
+#define  CAN_F9R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
+#define  CAN_F9R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
+#define  CAN_F9R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
+#define  CAN_F9R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
+#define  CAN_F9R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
+#define  CAN_F9R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
+#define  CAN_F9R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
+#define  CAN_F9R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
+#define  CAN_F9R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
+#define  CAN_F9R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
+#define  CAN_F9R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
+#define  CAN_F9R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
+#define  CAN_F9R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
+#define  CAN_F9R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
+#define  CAN_F9R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
+#define  CAN_F9R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
+
+/*******************  Bit definition for CAN_F10R2 register  ******************/
+#define  CAN_F10R2_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
+#define  CAN_F10R2_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
+#define  CAN_F10R2_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
+#define  CAN_F10R2_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
+#define  CAN_F10R2_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
+#define  CAN_F10R2_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
+#define  CAN_F10R2_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
+#define  CAN_F10R2_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
+#define  CAN_F10R2_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
+#define  CAN_F10R2_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
+#define  CAN_F10R2_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
+#define  CAN_F10R2_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
+#define  CAN_F10R2_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
+#define  CAN_F10R2_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
+#define  CAN_F10R2_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
+#define  CAN_F10R2_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
+#define  CAN_F10R2_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
+#define  CAN_F10R2_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
+#define  CAN_F10R2_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
+#define  CAN_F10R2_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
+#define  CAN_F10R2_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
+#define  CAN_F10R2_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
+#define  CAN_F10R2_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
+#define  CAN_F10R2_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
+#define  CAN_F10R2_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
+#define  CAN_F10R2_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
+#define  CAN_F10R2_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
+#define  CAN_F10R2_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
+#define  CAN_F10R2_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
+#define  CAN_F10R2_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
+#define  CAN_F10R2_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
+#define  CAN_F10R2_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
+
+/*******************  Bit definition for CAN_F11R2 register  ******************/
+#define  CAN_F11R2_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
+#define  CAN_F11R2_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
+#define  CAN_F11R2_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
+#define  CAN_F11R2_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
+#define  CAN_F11R2_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
+#define  CAN_F11R2_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
+#define  CAN_F11R2_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
+#define  CAN_F11R2_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
+#define  CAN_F11R2_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
+#define  CAN_F11R2_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
+#define  CAN_F11R2_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
+#define  CAN_F11R2_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
+#define  CAN_F11R2_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
+#define  CAN_F11R2_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
+#define  CAN_F11R2_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
+#define  CAN_F11R2_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
+#define  CAN_F11R2_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
+#define  CAN_F11R2_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
+#define  CAN_F11R2_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
+#define  CAN_F11R2_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
+#define  CAN_F11R2_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
+#define  CAN_F11R2_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
+#define  CAN_F11R2_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
+#define  CAN_F11R2_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
+#define  CAN_F11R2_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
+#define  CAN_F11R2_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
+#define  CAN_F11R2_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
+#define  CAN_F11R2_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
+#define  CAN_F11R2_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
+#define  CAN_F11R2_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
+#define  CAN_F11R2_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
+#define  CAN_F11R2_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
+
+/*******************  Bit definition for CAN_F12R2 register  ******************/
+#define  CAN_F12R2_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
+#define  CAN_F12R2_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
+#define  CAN_F12R2_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
+#define  CAN_F12R2_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
+#define  CAN_F12R2_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
+#define  CAN_F12R2_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
+#define  CAN_F12R2_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
+#define  CAN_F12R2_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
+#define  CAN_F12R2_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
+#define  CAN_F12R2_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
+#define  CAN_F12R2_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
+#define  CAN_F12R2_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
+#define  CAN_F12R2_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
+#define  CAN_F12R2_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
+#define  CAN_F12R2_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
+#define  CAN_F12R2_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
+#define  CAN_F12R2_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
+#define  CAN_F12R2_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
+#define  CAN_F12R2_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
+#define  CAN_F12R2_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
+#define  CAN_F12R2_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
+#define  CAN_F12R2_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
+#define  CAN_F12R2_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
+#define  CAN_F12R2_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
+#define  CAN_F12R2_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
+#define  CAN_F12R2_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
+#define  CAN_F12R2_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
+#define  CAN_F12R2_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
+#define  CAN_F12R2_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
+#define  CAN_F12R2_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
+#define  CAN_F12R2_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
+#define  CAN_F12R2_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
+
+/*******************  Bit definition for CAN_F13R2 register  ******************/
+#define  CAN_F13R2_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
+#define  CAN_F13R2_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
+#define  CAN_F13R2_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
+#define  CAN_F13R2_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
+#define  CAN_F13R2_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
+#define  CAN_F13R2_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
+#define  CAN_F13R2_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
+#define  CAN_F13R2_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
+#define  CAN_F13R2_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
+#define  CAN_F13R2_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
+#define  CAN_F13R2_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
+#define  CAN_F13R2_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
+#define  CAN_F13R2_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
+#define  CAN_F13R2_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
+#define  CAN_F13R2_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
+#define  CAN_F13R2_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
+#define  CAN_F13R2_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
+#define  CAN_F13R2_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
+#define  CAN_F13R2_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
+#define  CAN_F13R2_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
+#define  CAN_F13R2_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
+#define  CAN_F13R2_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
+#define  CAN_F13R2_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
+#define  CAN_F13R2_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
+#define  CAN_F13R2_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
+#define  CAN_F13R2_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
+#define  CAN_F13R2_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
+#define  CAN_F13R2_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
+#define  CAN_F13R2_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
+#define  CAN_F13R2_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
+#define  CAN_F13R2_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
+#define  CAN_F13R2_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
+
+/******************************************************************************/
+/*                                                                            */
+/*                        Serial Peripheral Interface                         */
+/*                                                                            */
+/******************************************************************************/
+
+/*******************  Bit definition for SPI_CR1 register  ********************/
+#define  SPI_CR1_CPHA                        ((uint16_t)0x0001)            /*!< Clock Phase */
+#define  SPI_CR1_CPOL                        ((uint16_t)0x0002)            /*!< Clock Polarity */
+#define  SPI_CR1_MSTR                        ((uint16_t)0x0004)            /*!< Master Selection */
+
+#define  SPI_CR1_BR                          ((uint16_t)0x0038)            /*!< BR[2:0] bits (Baud Rate Control) */
+#define  SPI_CR1_BR_0                        ((uint16_t)0x0008)            /*!< Bit 0 */
+#define  SPI_CR1_BR_1                        ((uint16_t)0x0010)            /*!< Bit 1 */
+#define  SPI_CR1_BR_2                        ((uint16_t)0x0020)            /*!< Bit 2 */
+
+#define  SPI_CR1_SPE                         ((uint16_t)0x0040)            /*!< SPI Enable */
+#define  SPI_CR1_LSBFIRST                    ((uint16_t)0x0080)            /*!< Frame Format */
+#define  SPI_CR1_SSI                         ((uint16_t)0x0100)            /*!< Internal slave select */
+#define  SPI_CR1_SSM                         ((uint16_t)0x0200)            /*!< Software slave management */
+#define  SPI_CR1_RXONLY                      ((uint16_t)0x0400)            /*!< Receive only */
+#define  SPI_CR1_DFF                         ((uint16_t)0x0800)            /*!< Data Frame Format */
+#define  SPI_CR1_CRCNEXT                     ((uint16_t)0x1000)            /*!< Transmit CRC next */
+#define  SPI_CR1_CRCEN                       ((uint16_t)0x2000)            /*!< Hardware CRC calculation enable */
+#define  SPI_CR1_BIDIOE                      ((uint16_t)0x4000)            /*!< Output enable in bidirectional mode */
+#define  SPI_CR1_BIDIMODE                    ((uint16_t)0x8000)            /*!< Bidirectional data mode enable */
+
+/*******************  Bit definition for SPI_CR2 register  ********************/
+#define  SPI_CR2_RXDMAEN                     ((uint8_t)0x01)               /*!< Rx Buffer DMA Enable */
+#define  SPI_CR2_TXDMAEN                     ((uint8_t)0x02)               /*!< Tx Buffer DMA Enable */
+#define  SPI_CR2_SSOE                        ((uint8_t)0x04)               /*!< SS Output Enable */
+#define  SPI_CR2_ERRIE                       ((uint8_t)0x20)               /*!< Error Interrupt Enable */
+#define  SPI_CR2_RXNEIE                      ((uint8_t)0x40)               /*!< RX buffer Not Empty Interrupt Enable */
+#define  SPI_CR2_TXEIE                       ((uint8_t)0x80)               /*!< Tx buffer Empty Interrupt Enable */
+
+/********************  Bit definition for SPI_SR register  ********************/
+#define  SPI_SR_RXNE                         ((uint8_t)0x01)               /*!< Receive buffer Not Empty */
+#define  SPI_SR_TXE                          ((uint8_t)0x02)               /*!< Transmit buffer Empty */
+#define  SPI_SR_CHSIDE                       ((uint8_t)0x04)               /*!< Channel side */
+#define  SPI_SR_UDR                          ((uint8_t)0x08)               /*!< Underrun flag */
+#define  SPI_SR_CRCERR                       ((uint8_t)0x10)               /*!< CRC Error flag */
+#define  SPI_SR_MODF                         ((uint8_t)0x20)               /*!< Mode fault */
+#define  SPI_SR_OVR                          ((uint8_t)0x40)               /*!< Overrun flag */
+#define  SPI_SR_BSY                          ((uint8_t)0x80)               /*!< Busy flag */
+
+/********************  Bit definition for SPI_DR register  ********************/
+#define  SPI_DR_DR                           ((uint16_t)0xFFFF)            /*!< Data Register */
+
+/*******************  Bit definition for SPI_CRCPR register  ******************/
+#define  SPI_CRCPR_CRCPOLY                   ((uint16_t)0xFFFF)            /*!< CRC polynomial register */
+
+/******************  Bit definition for SPI_RXCRCR register  ******************/
+#define  SPI_RXCRCR_RXCRC                    ((uint16_t)0xFFFF)            /*!< Rx CRC Register */
+
+/******************  Bit definition for SPI_TXCRCR register  ******************/
+#define  SPI_TXCRCR_TXCRC                    ((uint16_t)0xFFFF)            /*!< Tx CRC Register */
+
+/******************  Bit definition for SPI_I2SCFGR register  *****************/
+#define  SPI_I2SCFGR_CHLEN                   ((uint16_t)0x0001)            /*!< Channel length (number of bits per audio channel) */
+
+#define  SPI_I2SCFGR_DATLEN                  ((uint16_t)0x0006)            /*!< DATLEN[1:0] bits (Data length to be transferred) */
+#define  SPI_I2SCFGR_DATLEN_0                ((uint16_t)0x0002)            /*!< Bit 0 */
+#define  SPI_I2SCFGR_DATLEN_1                ((uint16_t)0x0004)            /*!< Bit 1 */
+
+#define  SPI_I2SCFGR_CKPOL                   ((uint16_t)0x0008)            /*!< steady state clock polarity */
+
+#define  SPI_I2SCFGR_I2SSTD                  ((uint16_t)0x0030)            /*!< I2SSTD[1:0] bits (I2S standard selection) */
+#define  SPI_I2SCFGR_I2SSTD_0                ((uint16_t)0x0010)            /*!< Bit 0 */
+#define  SPI_I2SCFGR_I2SSTD_1                ((uint16_t)0x0020)            /*!< Bit 1 */
+
+#define  SPI_I2SCFGR_PCMSYNC                 ((uint16_t)0x0080)            /*!< PCM frame synchronization */
+
+#define  SPI_I2SCFGR_I2SCFG                  ((uint16_t)0x0300)            /*!< I2SCFG[1:0] bits (I2S configuration mode) */
+#define  SPI_I2SCFGR_I2SCFG_0                ((uint16_t)0x0100)            /*!< Bit 0 */
+#define  SPI_I2SCFGR_I2SCFG_1                ((uint16_t)0x0200)            /*!< Bit 1 */
+
+#define  SPI_I2SCFGR_I2SE                    ((uint16_t)0x0400)            /*!< I2S Enable */
+#define  SPI_I2SCFGR_I2SMOD                  ((uint16_t)0x0800)            /*!< I2S mode selection */
+
+/******************  Bit definition for SPI_I2SPR register  *******************/
+#define  SPI_I2SPR_I2SDIV                    ((uint16_t)0x00FF)            /*!< I2S Linear prescaler */
+#define  SPI_I2SPR_ODD                       ((uint16_t)0x0100)            /*!< Odd factor for the prescaler */
+#define  SPI_I2SPR_MCKOE                     ((uint16_t)0x0200)            /*!< Master Clock Output Enable */
+
+/******************************************************************************/
+/*                                                                            */
+/*                      Inter-integrated Circuit Interface                    */
+/*                                                                            */
+/******************************************************************************/
+
+/*******************  Bit definition for I2C_CR1 register  ********************/
+#define  I2C_CR1_PE                          ((uint16_t)0x0001)            /*!< Peripheral Enable */
+#define  I2C_CR1_SMBUS                       ((uint16_t)0x0002)            /*!< SMBus Mode */
+#define  I2C_CR1_SMBTYPE                     ((uint16_t)0x0008)            /*!< SMBus Type */
+#define  I2C_CR1_ENARP                       ((uint16_t)0x0010)            /*!< ARP Enable */
+#define  I2C_CR1_ENPEC                       ((uint16_t)0x0020)            /*!< PEC Enable */
+#define  I2C_CR1_ENGC                        ((uint16_t)0x0040)            /*!< General Call Enable */
+#define  I2C_CR1_NOSTRETCH                   ((uint16_t)0x0080)            /*!< Clock Stretching Disable (Slave mode) */
+#define  I2C_CR1_START                       ((uint16_t)0x0100)            /*!< Start Generation */
+#define  I2C_CR1_STOP                        ((uint16_t)0x0200)            /*!< Stop Generation */
+#define  I2C_CR1_ACK                         ((uint16_t)0x0400)            /*!< Acknowledge Enable */
+#define  I2C_CR1_POS                         ((uint16_t)0x0800)            /*!< Acknowledge/PEC Position (for data reception) */
+#define  I2C_CR1_PEC                         ((uint16_t)0x1000)            /*!< Packet Error Checking */
+#define  I2C_CR1_ALERT                       ((uint16_t)0x2000)            /*!< SMBus Alert */
+#define  I2C_CR1_SWRST                       ((uint16_t)0x8000)            /*!< Software Reset */
+
+/*******************  Bit definition for I2C_CR2 register  ********************/
+#define  I2C_CR2_FREQ                        ((uint16_t)0x003F)            /*!< FREQ[5:0] bits (Peripheral Clock Frequency) */
+#define  I2C_CR2_FREQ_0                      ((uint16_t)0x0001)            /*!< Bit 0 */
+#define  I2C_CR2_FREQ_1                      ((uint16_t)0x0002)            /*!< Bit 1 */
+#define  I2C_CR2_FREQ_2                      ((uint16_t)0x0004)            /*!< Bit 2 */
+#define  I2C_CR2_FREQ_3                      ((uint16_t)0x0008)            /*!< Bit 3 */
+#define  I2C_CR2_FREQ_4                      ((uint16_t)0x0010)            /*!< Bit 4 */
+#define  I2C_CR2_FREQ_5                      ((uint16_t)0x0020)            /*!< Bit 5 */
+
+#define  I2C_CR2_ITERREN                     ((uint16_t)0x0100)            /*!< Error Interrupt Enable */
+#define  I2C_CR2_ITEVTEN                     ((uint16_t)0x0200)            /*!< Event Interrupt Enable */
+#define  I2C_CR2_ITBUFEN                     ((uint16_t)0x0400)            /*!< Buffer Interrupt Enable */
+#define  I2C_CR2_DMAEN                       ((uint16_t)0x0800)            /*!< DMA Requests Enable */
+#define  I2C_CR2_LAST                        ((uint16_t)0x1000)            /*!< DMA Last Transfer */
+
+/*******************  Bit definition for I2C_OAR1 register  *******************/
+#define  I2C_OAR1_ADD1_7                     ((uint16_t)0x00FE)            /*!< Interface Address */
+#define  I2C_OAR1_ADD8_9                     ((uint16_t)0x0300)            /*!< Interface Address */
+
+#define  I2C_OAR1_ADD0                       ((uint16_t)0x0001)            /*!< Bit 0 */
+#define  I2C_OAR1_ADD1                       ((uint16_t)0x0002)            /*!< Bit 1 */
+#define  I2C_OAR1_ADD2                       ((uint16_t)0x0004)            /*!< Bit 2 */
+#define  I2C_OAR1_ADD3                       ((uint16_t)0x0008)            /*!< Bit 3 */
+#define  I2C_OAR1_ADD4                       ((uint16_t)0x0010)            /*!< Bit 4 */
+#define  I2C_OAR1_ADD5                       ((uint16_t)0x0020)            /*!< Bit 5 */
+#define  I2C_OAR1_ADD6                       ((uint16_t)0x0040)            /*!< Bit 6 */
+#define  I2C_OAR1_ADD7                       ((uint16_t)0x0080)            /*!< Bit 7 */
+#define  I2C_OAR1_ADD8                       ((uint16_t)0x0100)            /*!< Bit 8 */
+#define  I2C_OAR1_ADD9                       ((uint16_t)0x0200)            /*!< Bit 9 */
+
+#define  I2C_OAR1_ADDMODE                    ((uint16_t)0x8000)            /*!< Addressing Mode (Slave mode) */
+
+/*******************  Bit definition for I2C_OAR2 register  *******************/
+#define  I2C_OAR2_ENDUAL                     ((uint8_t)0x01)               /*!< Dual addressing mode enable */
+#define  I2C_OAR2_ADD2                       ((uint8_t)0xFE)               /*!< Interface address */
+
+/********************  Bit definition for I2C_DR register  ********************/
+#define  I2C_DR_DR                           ((uint8_t)0xFF)               /*!< 8-bit Data Register */
+
+/*******************  Bit definition for I2C_SR1 register  ********************/
+#define  I2C_SR1_SB                          ((uint16_t)0x0001)            /*!< Start Bit (Master mode) */
+#define  I2C_SR1_ADDR                        ((uint16_t)0x0002)            /*!< Address sent (master mode)/matched (slave mode) */
+#define  I2C_SR1_BTF                         ((uint16_t)0x0004)            /*!< Byte Transfer Finished */
+#define  I2C_SR1_ADD10                       ((uint16_t)0x0008)            /*!< 10-bit header sent (Master mode) */
+#define  I2C_SR1_STOPF                       ((uint16_t)0x0010)            /*!< Stop detection (Slave mode) */
+#define  I2C_SR1_RXNE                        ((uint16_t)0x0040)            /*!< Data Register not Empty (receivers) */
+#define  I2C_SR1_TXE                         ((uint16_t)0x0080)            /*!< Data Register Empty (transmitters) */
+#define  I2C_SR1_BERR                        ((uint16_t)0x0100)            /*!< Bus Error */
+#define  I2C_SR1_ARLO                        ((uint16_t)0x0200)            /*!< Arbitration Lost (master mode) */
+#define  I2C_SR1_AF                          ((uint16_t)0x0400)            /*!< Acknowledge Failure */
+#define  I2C_SR1_OVR                         ((uint16_t)0x0800)            /*!< Overrun/Underrun */
+#define  I2C_SR1_PECERR                      ((uint16_t)0x1000)            /*!< PEC Error in reception */
+#define  I2C_SR1_TIMEOUT                     ((uint16_t)0x4000)            /*!< Timeout or Tlow Error */
+#define  I2C_SR1_SMBALERT                    ((uint16_t)0x8000)            /*!< SMBus Alert */
+
+/*******************  Bit definition for I2C_SR2 register  ********************/
+#define  I2C_SR2_MSL                         ((uint16_t)0x0001)            /*!< Master/Slave */
+#define  I2C_SR2_BUSY                        ((uint16_t)0x0002)            /*!< Bus Busy */
+#define  I2C_SR2_TRA                         ((uint16_t)0x0004)            /*!< Transmitter/Receiver */
+#define  I2C_SR2_GENCALL                     ((uint16_t)0x0010)            /*!< General Call Address (Slave mode) */
+#define  I2C_SR2_SMBDEFAULT                  ((uint16_t)0x0020)            /*!< SMBus Device Default Address (Slave mode) */
+#define  I2C_SR2_SMBHOST                     ((uint16_t)0x0040)            /*!< SMBus Host Header (Slave mode) */
+#define  I2C_SR2_DUALF                       ((uint16_t)0x0080)            /*!< Dual Flag (Slave mode) */
+#define  I2C_SR2_PEC                         ((uint16_t)0xFF00)            /*!< Packet Error Checking Register */
+
+/*******************  Bit definition for I2C_CCR register  ********************/
+#define  I2C_CCR_CCR                         ((uint16_t)0x0FFF)            /*!< Clock Control Register in Fast/Standard mode (Master mode) */
+#define  I2C_CCR_DUTY                        ((uint16_t)0x4000)            /*!< Fast Mode Duty Cycle */
+#define  I2C_CCR_FS                          ((uint16_t)0x8000)            /*!< I2C Master Mode Selection */
+
+/******************  Bit definition for I2C_TRISE register  *******************/
+#define  I2C_TRISE_TRISE                     ((uint8_t)0x3F)               /*!< Maximum Rise Time in Fast/Standard mode (Master mode) */
+
+/******************************************************************************/
+/*                                                                            */
+/*         Universal Synchronous Asynchronous Receiver Transmitter            */
+/*                                                                            */
+/******************************************************************************/
+
+/*******************  Bit definition for USART_SR register  *******************/
+#define  USART_SR_PE                         ((uint16_t)0x0001)            /*!< Parity Error */
+#define  USART_SR_FE                         ((uint16_t)0x0002)            /*!< Framing Error */
+#define  USART_SR_NE                         ((uint16_t)0x0004)            /*!< Noise Error Flag */
+#define  USART_SR_ORE                        ((uint16_t)0x0008)            /*!< OverRun Error */
+#define  USART_SR_IDLE                       ((uint16_t)0x0010)            /*!< IDLE line detected */
+#define  USART_SR_RXNE                       ((uint16_t)0x0020)            /*!< Read Data Register Not Empty */
+#define  USART_SR_TC                         ((uint16_t)0x0040)            /*!< Transmission Complete */
+#define  USART_SR_TXE                        ((uint16_t)0x0080)            /*!< Transmit Data Register Empty */
+#define  USART_SR_LBD                        ((uint16_t)0x0100)            /*!< LIN Break Detection Flag */
+#define  USART_SR_CTS                        ((uint16_t)0x0200)            /*!< CTS Flag */
+
+/*******************  Bit definition for USART_DR register  *******************/
+#define  USART_DR_DR                         ((uint16_t)0x01FF)            /*!< Data value */
+
+/******************  Bit definition for USART_BRR register  *******************/
+#define  USART_BRR_DIV_Fraction              ((uint16_t)0x000F)            /*!< Fraction of USARTDIV */
+#define  USART_BRR_DIV_Mantissa              ((uint16_t)0xFFF0)            /*!< Mantissa of USARTDIV */
+
+/******************  Bit definition for USART_CR1 register  *******************/
+#define  USART_CR1_SBK                       ((uint16_t)0x0001)            /*!< Send Break */
+#define  USART_CR1_RWU                       ((uint16_t)0x0002)            /*!< Receiver wakeup */
+#define  USART_CR1_RE                        ((uint16_t)0x0004)            /*!< Receiver Enable */
+#define  USART_CR1_TE                        ((uint16_t)0x0008)            /*!< Transmitter Enable */
+#define  USART_CR1_IDLEIE                    ((uint16_t)0x0010)            /*!< IDLE Interrupt Enable */
+#define  USART_CR1_RXNEIE                    ((uint16_t)0x0020)            /*!< RXNE Interrupt Enable */
+#define  USART_CR1_TCIE                      ((uint16_t)0x0040)            /*!< Transmission Complete Interrupt Enable */
+#define  USART_CR1_TXEIE                     ((uint16_t)0x0080)            /*!< PE Interrupt Enable */
+#define  USART_CR1_PEIE                      ((uint16_t)0x0100)            /*!< PE Interrupt Enable */
+#define  USART_CR1_PS                        ((uint16_t)0x0200)            /*!< Parity Selection */
+#define  USART_CR1_PCE                       ((uint16_t)0x0400)            /*!< Parity Control Enable */
+#define  USART_CR1_WAKE                      ((uint16_t)0x0800)            /*!< Wakeup method */
+#define  USART_CR1_M                         ((uint16_t)0x1000)            /*!< Word length */
+#define  USART_CR1_UE                        ((uint16_t)0x2000)            /*!< USART Enable */
+#define  USART_CR1_OVER8                     ((uint16_t)0x8000)            /*!< USART Oversmapling 8-bits */
+
+/******************  Bit definition for USART_CR2 register  *******************/
+#define  USART_CR2_ADD                       ((uint16_t)0x000F)            /*!< Address of the USART node */
+#define  USART_CR2_LBDL                      ((uint16_t)0x0020)            /*!< LIN Break Detection Length */
+#define  USART_CR2_LBDIE                     ((uint16_t)0x0040)            /*!< LIN Break Detection Interrupt Enable */
+#define  USART_CR2_LBCL                      ((uint16_t)0x0100)            /*!< Last Bit Clock pulse */
+#define  USART_CR2_CPHA                      ((uint16_t)0x0200)            /*!< Clock Phase */
+#define  USART_CR2_CPOL                      ((uint16_t)0x0400)            /*!< Clock Polarity */
+#define  USART_CR2_CLKEN                     ((uint16_t)0x0800)            /*!< Clock Enable */
+
+#define  USART_CR2_STOP                      ((uint16_t)0x3000)            /*!< STOP[1:0] bits (STOP bits) */
+#define  USART_CR2_STOP_0                    ((uint16_t)0x1000)            /*!< Bit 0 */
+#define  USART_CR2_STOP_1                    ((uint16_t)0x2000)            /*!< Bit 1 */
+
+#define  USART_CR2_LINEN                     ((uint16_t)0x4000)            /*!< LIN mode enable */
+
+/******************  Bit definition for USART_CR3 register  *******************/
+#define  USART_CR3_EIE                       ((uint16_t)0x0001)            /*!< Error Interrupt Enable */
+#define  USART_CR3_IREN                      ((uint16_t)0x0002)            /*!< IrDA mode Enable */
+#define  USART_CR3_IRLP                      ((uint16_t)0x0004)            /*!< IrDA Low-Power */
+#define  USART_CR3_HDSEL                     ((uint16_t)0x0008)            /*!< Half-Duplex Selection */
+#define  USART_CR3_NACK                      ((uint16_t)0x0010)            /*!< Smartcard NACK enable */
+#define  USART_CR3_SCEN                      ((uint16_t)0x0020)            /*!< Smartcard mode enable */
+#define  USART_CR3_DMAR                      ((uint16_t)0x0040)            /*!< DMA Enable Receiver */
+#define  USART_CR3_DMAT                      ((uint16_t)0x0080)            /*!< DMA Enable Transmitter */
+#define  USART_CR3_RTSE                      ((uint16_t)0x0100)            /*!< RTS Enable */
+#define  USART_CR3_CTSE                      ((uint16_t)0x0200)            /*!< CTS Enable */
+#define  USART_CR3_CTSIE                     ((uint16_t)0x0400)            /*!< CTS Interrupt Enable */
+#define  USART_CR3_ONEBIT                    ((uint16_t)0x0800)            /*!< One Bit method */
+
+/******************  Bit definition for USART_GTPR register  ******************/
+#define  USART_GTPR_PSC                      ((uint16_t)0x00FF)            /*!< PSC[7:0] bits (Prescaler value) */
+#define  USART_GTPR_PSC_0                    ((uint16_t)0x0001)            /*!< Bit 0 */
+#define  USART_GTPR_PSC_1                    ((uint16_t)0x0002)            /*!< Bit 1 */
+#define  USART_GTPR_PSC_2                    ((uint16_t)0x0004)            /*!< Bit 2 */
+#define  USART_GTPR_PSC_3                    ((uint16_t)0x0008)            /*!< Bit 3 */
+#define  USART_GTPR_PSC_4                    ((uint16_t)0x0010)            /*!< Bit 4 */
+#define  USART_GTPR_PSC_5                    ((uint16_t)0x0020)            /*!< Bit 5 */
+#define  USART_GTPR_PSC_6                    ((uint16_t)0x0040)            /*!< Bit 6 */
+#define  USART_GTPR_PSC_7                    ((uint16_t)0x0080)            /*!< Bit 7 */
+
+#define  USART_GTPR_GT                       ((uint16_t)0xFF00)            /*!< Guard time value */
+
+/******************************************************************************/
+/*                                                                            */
+/*                                 Debug MCU                                  */
+/*                                                                            */
+/******************************************************************************/
+
+/****************  Bit definition for DBGMCU_IDCODE register  *****************/
+#define  DBGMCU_IDCODE_DEV_ID                ((uint32_t)0x00000FFF)        /*!< Device Identifier */
+
+#define  DBGMCU_IDCODE_REV_ID                ((uint32_t)0xFFFF0000)        /*!< REV_ID[15:0] bits (Revision Identifier) */
+#define  DBGMCU_IDCODE_REV_ID_0              ((uint32_t)0x00010000)        /*!< Bit 0 */
+#define  DBGMCU_IDCODE_REV_ID_1              ((uint32_t)0x00020000)        /*!< Bit 1 */
+#define  DBGMCU_IDCODE_REV_ID_2              ((uint32_t)0x00040000)        /*!< Bit 2 */
+#define  DBGMCU_IDCODE_REV_ID_3              ((uint32_t)0x00080000)        /*!< Bit 3 */
+#define  DBGMCU_IDCODE_REV_ID_4              ((uint32_t)0x00100000)        /*!< Bit 4 */
+#define  DBGMCU_IDCODE_REV_ID_5              ((uint32_t)0x00200000)        /*!< Bit 5 */
+#define  DBGMCU_IDCODE_REV_ID_6              ((uint32_t)0x00400000)        /*!< Bit 6 */
+#define  DBGMCU_IDCODE_REV_ID_7              ((uint32_t)0x00800000)        /*!< Bit 7 */
+#define  DBGMCU_IDCODE_REV_ID_8              ((uint32_t)0x01000000)        /*!< Bit 8 */
+#define  DBGMCU_IDCODE_REV_ID_9              ((uint32_t)0x02000000)        /*!< Bit 9 */
+#define  DBGMCU_IDCODE_REV_ID_10             ((uint32_t)0x04000000)        /*!< Bit 10 */
+#define  DBGMCU_IDCODE_REV_ID_11             ((uint32_t)0x08000000)        /*!< Bit 11 */
+#define  DBGMCU_IDCODE_REV_ID_12             ((uint32_t)0x10000000)        /*!< Bit 12 */
+#define  DBGMCU_IDCODE_REV_ID_13             ((uint32_t)0x20000000)        /*!< Bit 13 */
+#define  DBGMCU_IDCODE_REV_ID_14             ((uint32_t)0x40000000)        /*!< Bit 14 */
+#define  DBGMCU_IDCODE_REV_ID_15             ((uint32_t)0x80000000)        /*!< Bit 15 */
+
+/******************  Bit definition for DBGMCU_CR register  *******************/
+#define  DBGMCU_CR_DBG_SLEEP                 ((uint32_t)0x00000001)        /*!< Debug Sleep Mode */
+#define  DBGMCU_CR_DBG_STOP                  ((uint32_t)0x00000002)        /*!< Debug Stop Mode */
+#define  DBGMCU_CR_DBG_STANDBY               ((uint32_t)0x00000004)        /*!< Debug Standby mode */
+#define  DBGMCU_CR_TRACE_IOEN                ((uint32_t)0x00000020)        /*!< Trace Pin Assignment Control */
+
+#define  DBGMCU_CR_TRACE_MODE                ((uint32_t)0x000000C0)        /*!< TRACE_MODE[1:0] bits (Trace Pin Assignment Control) */
+#define  DBGMCU_CR_TRACE_MODE_0              ((uint32_t)0x00000040)        /*!< Bit 0 */
+#define  DBGMCU_CR_TRACE_MODE_1              ((uint32_t)0x00000080)        /*!< Bit 1 */
+
+#define  DBGMCU_CR_DBG_IWDG_STOP             ((uint32_t)0x00000100)        /*!< Debug Independent Watchdog stopped when Core is halted */
+#define  DBGMCU_CR_DBG_WWDG_STOP             ((uint32_t)0x00000200)        /*!< Debug Window Watchdog stopped when Core is halted */
+#define  DBGMCU_CR_DBG_TIM1_STOP             ((uint32_t)0x00000400)        /*!< TIM1 counter stopped when core is halted */
+#define  DBGMCU_CR_DBG_TIM2_STOP             ((uint32_t)0x00000800)        /*!< TIM2 counter stopped when core is halted */
+#define  DBGMCU_CR_DBG_TIM3_STOP             ((uint32_t)0x00001000)        /*!< TIM3 counter stopped when core is halted */
+#define  DBGMCU_CR_DBG_TIM4_STOP             ((uint32_t)0x00002000)        /*!< TIM4 counter stopped when core is halted */
+#define  DBGMCU_CR_DBG_CAN1_STOP             ((uint32_t)0x00004000)        /*!< Debug CAN1 stopped when Core is halted */
+#define  DBGMCU_CR_DBG_I2C1_SMBUS_TIMEOUT    ((uint32_t)0x00008000)        /*!< SMBUS timeout mode stopped when Core is halted */
+#define  DBGMCU_CR_DBG_I2C2_SMBUS_TIMEOUT    ((uint32_t)0x00010000)        /*!< SMBUS timeout mode stopped when Core is halted */
+#define  DBGMCU_CR_DBG_TIM8_STOP             ((uint32_t)0x00020000)        /*!< TIM8 counter stopped when core is halted */
+#define  DBGMCU_CR_DBG_TIM5_STOP             ((uint32_t)0x00040000)        /*!< TIM5 counter stopped when core is halted */
+#define  DBGMCU_CR_DBG_TIM6_STOP             ((uint32_t)0x00080000)        /*!< TIM6 counter stopped when core is halted */
+#define  DBGMCU_CR_DBG_TIM7_STOP             ((uint32_t)0x00100000)        /*!< TIM7 counter stopped when core is halted */
+#define  DBGMCU_CR_DBG_CAN2_STOP             ((uint32_t)0x00200000)        /*!< Debug CAN2 stopped when Core is halted */
+#define  DBGMCU_CR_DBG_TIM15_STOP            ((uint32_t)0x00400000)        /*!< Debug TIM15 stopped when Core is halted */
+#define  DBGMCU_CR_DBG_TIM16_STOP            ((uint32_t)0x00800000)        /*!< Debug TIM16 stopped when Core is halted */
+#define  DBGMCU_CR_DBG_TIM17_STOP            ((uint32_t)0x01000000)        /*!< Debug TIM17 stopped when Core is halted */
+#define  DBGMCU_CR_DBG_TIM12_STOP            ((uint32_t)0x02000000)        /*!< Debug TIM12 stopped when Core is halted */
+#define  DBGMCU_CR_DBG_TIM13_STOP            ((uint32_t)0x04000000)        /*!< Debug TIM13 stopped when Core is halted */
+#define  DBGMCU_CR_DBG_TIM14_STOP            ((uint32_t)0x08000000)        /*!< Debug TIM14 stopped when Core is halted */
+#define  DBGMCU_CR_DBG_TIM9_STOP             ((uint32_t)0x10000000)        /*!< Debug TIM9 stopped when Core is halted */
+#define  DBGMCU_CR_DBG_TIM10_STOP            ((uint32_t)0x20000000)        /*!< Debug TIM10 stopped when Core is halted */
+#define  DBGMCU_CR_DBG_TIM11_STOP            ((uint32_t)0x40000000)        /*!< Debug TIM11 stopped when Core is halted */
+
+/******************************************************************************/
+/*                                                                            */
+/*                      FLASH and Option Bytes Registers                      */
+/*                                                                            */
+/******************************************************************************/
+
+/*******************  Bit definition for FLASH_ACR register  ******************/
+#define  FLASH_ACR_LATENCY                   ((uint8_t)0x03)               /*!< LATENCY[2:0] bits (Latency) */
+#define  FLASH_ACR_LATENCY_0                 ((uint8_t)0x00)               /*!< Bit 0 */
+#define  FLASH_ACR_LATENCY_1                 ((uint8_t)0x01)               /*!< Bit 0 */
+#define  FLASH_ACR_LATENCY_2                 ((uint8_t)0x02)               /*!< Bit 1 */
+
+#define  FLASH_ACR_HLFCYA                    ((uint8_t)0x08)               /*!< Flash Half Cycle Access Enable */
+#define  FLASH_ACR_PRFTBE                    ((uint8_t)0x10)               /*!< Prefetch Buffer Enable */
+#define  FLASH_ACR_PRFTBS                    ((uint8_t)0x20)               /*!< Prefetch Buffer Status */
+
+/******************  Bit definition for FLASH_KEYR register  ******************/
+#define  FLASH_KEYR_FKEYR                    ((uint32_t)0xFFFFFFFF)        /*!< FPEC Key */
+
+/*****************  Bit definition for FLASH_OPTKEYR register  ****************/
+#define  FLASH_OPTKEYR_OPTKEYR               ((uint32_t)0xFFFFFFFF)        /*!< Option Byte Key */
+
+/******************  Bit definition for FLASH_SR register  *******************/
+#define  FLASH_SR_BSY                        ((uint8_t)0x01)               /*!< Busy */
+#define  FLASH_SR_PGERR                      ((uint8_t)0x04)               /*!< Programming Error */
+#define  FLASH_SR_WRPRTERR                   ((uint8_t)0x10)               /*!< Write Protection Error */
+#define  FLASH_SR_EOP                        ((uint8_t)0x20)               /*!< End of operation */
+
+/*******************  Bit definition for FLASH_CR register  *******************/
+#define  FLASH_CR_PG                         ((uint16_t)0x0001)            /*!< Programming */
+#define  FLASH_CR_PER                        ((uint16_t)0x0002)            /*!< Page Erase */
+#define  FLASH_CR_MER                        ((uint16_t)0x0004)            /*!< Mass Erase */
+#define  FLASH_CR_OPTPG                      ((uint16_t)0x0010)            /*!< Option Byte Programming */
+#define  FLASH_CR_OPTER                      ((uint16_t)0x0020)            /*!< Option Byte Erase */
+#define  FLASH_CR_STRT                       ((uint16_t)0x0040)            /*!< Start */
+#define  FLASH_CR_LOCK                       ((uint16_t)0x0080)            /*!< Lock */
+#define  FLASH_CR_OPTWRE                     ((uint16_t)0x0200)            /*!< Option Bytes Write Enable */
+#define  FLASH_CR_ERRIE                      ((uint16_t)0x0400)            /*!< Error Interrupt Enable */
+#define  FLASH_CR_EOPIE                      ((uint16_t)0x1000)            /*!< End of operation interrupt enable */
+
+/*******************  Bit definition for FLASH_AR register  *******************/
+#define  FLASH_AR_FAR                        ((uint32_t)0xFFFFFFFF)        /*!< Flash Address */
+
+/******************  Bit definition for FLASH_OBR register  *******************/
+#define  FLASH_OBR_OPTERR                    ((uint16_t)0x0001)            /*!< Option Byte Error */
+#define  FLASH_OBR_RDPRT                     ((uint16_t)0x0002)            /*!< Read protection */
+
+#define  FLASH_OBR_USER                      ((uint16_t)0x03FC)            /*!< User Option Bytes */
+#define  FLASH_OBR_WDG_SW                    ((uint16_t)0x0004)            /*!< WDG_SW */
+#define  FLASH_OBR_nRST_STOP                 ((uint16_t)0x0008)            /*!< nRST_STOP */
+#define  FLASH_OBR_nRST_STDBY                ((uint16_t)0x0010)            /*!< nRST_STDBY */
+#define  FLASH_OBR_BFB2                      ((uint16_t)0x0020)            /*!< BFB2 */
+
+/******************  Bit definition for FLASH_WRPR register  ******************/
+#define  FLASH_WRPR_WRP                        ((uint32_t)0xFFFFFFFF)        /*!< Write Protect */
+
+/*----------------------------------------------------------------------------*/
+
+/******************  Bit definition for FLASH_RDP register  *******************/
+#define  FLASH_RDP_RDP                       ((uint32_t)0x000000FF)        /*!< Read protection option byte */
+#define  FLASH_RDP_nRDP                      ((uint32_t)0x0000FF00)        /*!< Read protection complemented option byte */
+
+/******************  Bit definition for FLASH_USER register  ******************/
+#define  FLASH_USER_USER                     ((uint32_t)0x00FF0000)        /*!< User option byte */
+#define  FLASH_USER_nUSER                    ((uint32_t)0xFF000000)        /*!< User complemented option byte */
+
+/******************  Bit definition for FLASH_Data0 register  *****************/
+#define  FLASH_Data0_Data0                   ((uint32_t)0x000000FF)        /*!< User data storage option byte */
+#define  FLASH_Data0_nData0                  ((uint32_t)0x0000FF00)        /*!< User data storage complemented option byte */
+
+/******************  Bit definition for FLASH_Data1 register  *****************/
+#define  FLASH_Data1_Data1                   ((uint32_t)0x00FF0000)        /*!< User data storage option byte */
+#define  FLASH_Data1_nData1                  ((uint32_t)0xFF000000)        /*!< User data storage complemented option byte */
+
+/******************  Bit definition for FLASH_WRP0 register  ******************/
+#define  FLASH_WRP0_WRP0                     ((uint32_t)0x000000FF)        /*!< Flash memory write protection option bytes */
+#define  FLASH_WRP0_nWRP0                    ((uint32_t)0x0000FF00)        /*!< Flash memory write protection complemented option bytes */
+
+/******************  Bit definition for FLASH_WRP1 register  ******************/
+#define  FLASH_WRP1_WRP1                     ((uint32_t)0x00FF0000)        /*!< Flash memory write protection option bytes */
+#define  FLASH_WRP1_nWRP1                    ((uint32_t)0xFF000000)        /*!< Flash memory write protection complemented option bytes */
+
+/******************  Bit definition for FLASH_WRP2 register  ******************/
+#define  FLASH_WRP2_WRP2                     ((uint32_t)0x000000FF)        /*!< Flash memory write protection option bytes */
+#define  FLASH_WRP2_nWRP2                    ((uint32_t)0x0000FF00)        /*!< Flash memory write protection complemented option bytes */
+
+/******************  Bit definition for FLASH_WRP3 register  ******************/
+#define  FLASH_WRP3_WRP3                     ((uint32_t)0x00FF0000)        /*!< Flash memory write protection option bytes */
+#define  FLASH_WRP3_nWRP3                    ((uint32_t)0xFF000000)        /*!< Flash memory write protection complemented option bytes */
+
+#ifdef STM32F10X_CL
+/******************************************************************************/
+/*                Ethernet MAC Registers bits definitions                     */
+/******************************************************************************/
+/* Bit definition for Ethernet MAC Control Register register */
+#define ETH_MACCR_WD      ((uint32_t)0x00800000)  /* Watchdog disable */
+#define ETH_MACCR_JD      ((uint32_t)0x00400000)  /* Jabber disable */
+#define ETH_MACCR_IFG     ((uint32_t)0x000E0000)  /* Inter-frame gap */
+  #define ETH_MACCR_IFG_96Bit     ((uint32_t)0x00000000)  /* Minimum IFG between frames during transmission is 96Bit */
+  #define ETH_MACCR_IFG_88Bit     ((uint32_t)0x00020000)  /* Minimum IFG between frames during transmission is 88Bit */
+  #define ETH_MACCR_IFG_80Bit     ((uint32_t)0x00040000)  /* Minimum IFG between frames during transmission is 80Bit */
+  #define ETH_MACCR_IFG_72Bit     ((uint32_t)0x00060000)  /* Minimum IFG between frames during transmission is 72Bit */
+  #define ETH_MACCR_IFG_64Bit     ((uint32_t)0x00080000)  /* Minimum IFG between frames during transmission is 64Bit */
+  #define ETH_MACCR_IFG_56Bit     ((uint32_t)0x000A0000)  /* Minimum IFG between frames during transmission is 56Bit */
+  #define ETH_MACCR_IFG_48Bit     ((uint32_t)0x000C0000)  /* Minimum IFG between frames during transmission is 48Bit */
+  #define ETH_MACCR_IFG_40Bit     ((uint32_t)0x000E0000)  /* Minimum IFG between frames during transmission is 40Bit */
+#define ETH_MACCR_CSD     ((uint32_t)0x00010000)  /* Carrier sense disable (during transmission) */
+#define ETH_MACCR_FES     ((uint32_t)0x00004000)  /* Fast ethernet speed */
+#define ETH_MACCR_ROD     ((uint32_t)0x00002000)  /* Receive own disable */
+#define ETH_MACCR_LM      ((uint32_t)0x00001000)  /* loopback mode */
+#define ETH_MACCR_DM      ((uint32_t)0x00000800)  /* Duplex mode */
+#define ETH_MACCR_IPCO    ((uint32_t)0x00000400)  /* IP Checksum offload */
+#define ETH_MACCR_RD      ((uint32_t)0x00000200)  /* Retry disable */
+#define ETH_MACCR_APCS    ((uint32_t)0x00000080)  /* Automatic Pad/CRC stripping */
+#define ETH_MACCR_BL      ((uint32_t)0x00000060)  /* Back-off limit: random integer number (r) of slot time delays before rescheduling
+                                                       a transmission attempt during retries after a collision: 0 =< r <2^k */
+  #define ETH_MACCR_BL_10    ((uint32_t)0x00000000)  /* k = min (n, 10) */
+  #define ETH_MACCR_BL_8     ((uint32_t)0x00000020)  /* k = min (n, 8) */
+  #define ETH_MACCR_BL_4     ((uint32_t)0x00000040)  /* k = min (n, 4) */
+  #define ETH_MACCR_BL_1     ((uint32_t)0x00000060)  /* k = min (n, 1) */
+#define ETH_MACCR_DC      ((uint32_t)0x00000010)  /* Defferal check */
+#define ETH_MACCR_TE      ((uint32_t)0x00000008)  /* Transmitter enable */
+#define ETH_MACCR_RE      ((uint32_t)0x00000004)  /* Receiver enable */
+
+/* Bit definition for Ethernet MAC Frame Filter Register */
+#define ETH_MACFFR_RA     ((uint32_t)0x80000000)  /* Receive all */
+#define ETH_MACFFR_HPF    ((uint32_t)0x00000400)  /* Hash or perfect filter */
+#define ETH_MACFFR_SAF    ((uint32_t)0x00000200)  /* Source address filter enable */
+#define ETH_MACFFR_SAIF   ((uint32_t)0x00000100)  /* SA inverse filtering */
+#define ETH_MACFFR_PCF    ((uint32_t)0x000000C0)  /* Pass control frames: 3 cases */
+  #define ETH_MACFFR_PCF_BlockAll                ((uint32_t)0x00000040)  /* MAC filters all control frames from reaching the application */
+  #define ETH_MACFFR_PCF_ForwardAll              ((uint32_t)0x00000080)  /* MAC forwards all control frames to application even if they fail the Address Filter */
+  #define ETH_MACFFR_PCF_ForwardPassedAddrFilter ((uint32_t)0x000000C0)  /* MAC forwards control frames that pass the Address Filter. */
+#define ETH_MACFFR_BFD    ((uint32_t)0x00000020)  /* Broadcast frame disable */
+#define ETH_MACFFR_PAM 	  ((uint32_t)0x00000010)  /* Pass all mutlicast */
+#define ETH_MACFFR_DAIF   ((uint32_t)0x00000008)  /* DA Inverse filtering */
+#define ETH_MACFFR_HM     ((uint32_t)0x00000004)  /* Hash multicast */
+#define ETH_MACFFR_HU     ((uint32_t)0x00000002)  /* Hash unicast */
+#define ETH_MACFFR_PM     ((uint32_t)0x00000001)  /* Promiscuous mode */
+
+/* Bit definition for Ethernet MAC Hash Table High Register */
+#define ETH_MACHTHR_HTH   ((uint32_t)0xFFFFFFFF)  /* Hash table high */
+
+/* Bit definition for Ethernet MAC Hash Table Low Register */
+#define ETH_MACHTLR_HTL   ((uint32_t)0xFFFFFFFF)  /* Hash table low */
+
+/* Bit definition for Ethernet MAC MII Address Register */
+#define ETH_MACMIIAR_PA   ((uint32_t)0x0000F800)  /* Physical layer address */
+#define ETH_MACMIIAR_MR   ((uint32_t)0x000007C0)  /* MII register in the selected PHY */
+#define ETH_MACMIIAR_CR   ((uint32_t)0x0000001C)  /* CR clock range: 6 cases */
+  #define ETH_MACMIIAR_CR_Div42   ((uint32_t)0x00000000)  /* HCLK:60-72 MHz; MDC clock= HCLK/42 */
+  #define ETH_MACMIIAR_CR_Div16   ((uint32_t)0x00000008)  /* HCLK:20-35 MHz; MDC clock= HCLK/16 */
+  #define ETH_MACMIIAR_CR_Div26   ((uint32_t)0x0000000C)  /* HCLK:35-60 MHz; MDC clock= HCLK/26 */
+#define ETH_MACMIIAR_MW   ((uint32_t)0x00000002)  /* MII write */
+#define ETH_MACMIIAR_MB   ((uint32_t)0x00000001)  /* MII busy */
+
+/* Bit definition for Ethernet MAC MII Data Register */
+#define ETH_MACMIIDR_MD   ((uint32_t)0x0000FFFF)  /* MII data: read/write data from/to PHY */
+
+/* Bit definition for Ethernet MAC Flow Control Register */
+#define ETH_MACFCR_PT     ((uint32_t)0xFFFF0000)  /* Pause time */
+#define ETH_MACFCR_ZQPD   ((uint32_t)0x00000080)  /* Zero-quanta pause disable */
+#define ETH_MACFCR_PLT    ((uint32_t)0x00000030)  /* Pause low threshold: 4 cases */
+  #define ETH_MACFCR_PLT_Minus4   ((uint32_t)0x00000000)  /* Pause time minus 4 slot times */
+  #define ETH_MACFCR_PLT_Minus28  ((uint32_t)0x00000010)  /* Pause time minus 28 slot times */
+  #define ETH_MACFCR_PLT_Minus144 ((uint32_t)0x00000020)  /* Pause time minus 144 slot times */
+  #define ETH_MACFCR_PLT_Minus256 ((uint32_t)0x00000030)  /* Pause time minus 256 slot times */
+#define ETH_MACFCR_UPFD   ((uint32_t)0x00000008)  /* Unicast pause frame detect */
+#define ETH_MACFCR_RFCE   ((uint32_t)0x00000004)  /* Receive flow control enable */
+#define ETH_MACFCR_TFCE   ((uint32_t)0x00000002)  /* Transmit flow control enable */
+#define ETH_MACFCR_FCBBPA ((uint32_t)0x00000001)  /* Flow control busy/backpressure activate */
+
+/* Bit definition for Ethernet MAC VLAN Tag Register */
+#define ETH_MACVLANTR_VLANTC ((uint32_t)0x00010000)  /* 12-bit VLAN tag comparison */
+#define ETH_MACVLANTR_VLANTI ((uint32_t)0x0000FFFF)  /* VLAN tag identifier (for receive frames) */
+
+/* Bit definition for Ethernet MAC Remote Wake-UpFrame Filter Register */
+#define ETH_MACRWUFFR_D   ((uint32_t)0xFFFFFFFF)  /* Wake-up frame filter register data */
+/* Eight sequential Writes to this address (offset 0x28) will write all Wake-UpFrame Filter Registers.
+   Eight sequential Reads from this address (offset 0x28) will read all Wake-UpFrame Filter Registers. */
+/* Wake-UpFrame Filter Reg0 : Filter 0 Byte Mask
+   Wake-UpFrame Filter Reg1 : Filter 1 Byte Mask
+   Wake-UpFrame Filter Reg2 : Filter 2 Byte Mask
+   Wake-UpFrame Filter Reg3 : Filter 3 Byte Mask
+   Wake-UpFrame Filter Reg4 : RSVD - Filter3 Command - RSVD - Filter2 Command -
+                              RSVD - Filter1 Command - RSVD - Filter0 Command
+   Wake-UpFrame Filter Re5 : Filter3 Offset - Filter2 Offset - Filter1 Offset - Filter0 Offset
+   Wake-UpFrame Filter Re6 : Filter1 CRC16 - Filter0 CRC16
+   Wake-UpFrame Filter Re7 : Filter3 CRC16 - Filter2 CRC16 */
+
+/* Bit definition for Ethernet MAC PMT Control and Status Register */
+#define ETH_MACPMTCSR_WFFRPR ((uint32_t)0x80000000)  /* Wake-Up Frame Filter Register Pointer Reset */
+#define ETH_MACPMTCSR_GU     ((uint32_t)0x00000200)  /* Global Unicast */
+#define ETH_MACPMTCSR_WFR    ((uint32_t)0x00000040)  /* Wake-Up Frame Received */
+#define ETH_MACPMTCSR_MPR    ((uint32_t)0x00000020)  /* Magic Packet Received */
+#define ETH_MACPMTCSR_WFE    ((uint32_t)0x00000004)  /* Wake-Up Frame Enable */
+#define ETH_MACPMTCSR_MPE    ((uint32_t)0x00000002)  /* Magic Packet Enable */
+#define ETH_MACPMTCSR_PD     ((uint32_t)0x00000001)  /* Power Down */
+
+/* Bit definition for Ethernet MAC Status Register */
+#define ETH_MACSR_TSTS      ((uint32_t)0x00000200)  /* Time stamp trigger status */
+#define ETH_MACSR_MMCTS     ((uint32_t)0x00000040)  /* MMC transmit status */
+#define ETH_MACSR_MMMCRS    ((uint32_t)0x00000020)  /* MMC receive status */
+#define ETH_MACSR_MMCS      ((uint32_t)0x00000010)  /* MMC status */
+#define ETH_MACSR_PMTS      ((uint32_t)0x00000008)  /* PMT status */
+
+/* Bit definition for Ethernet MAC Interrupt Mask Register */
+#define ETH_MACIMR_TSTIM     ((uint32_t)0x00000200)  /* Time stamp trigger interrupt mask */
+#define ETH_MACIMR_PMTIM     ((uint32_t)0x00000008)  /* PMT interrupt mask */
+
+/* Bit definition for Ethernet MAC Address0 High Register */
+#define ETH_MACA0HR_MACA0H   ((uint32_t)0x0000FFFF)  /* MAC address0 high */
+
+/* Bit definition for Ethernet MAC Address0 Low Register */
+#define ETH_MACA0LR_MACA0L   ((uint32_t)0xFFFFFFFF)  /* MAC address0 low */
+
+/* Bit definition for Ethernet MAC Address1 High Register */
+#define ETH_MACA1HR_AE       ((uint32_t)0x80000000)  /* Address enable */
+#define ETH_MACA1HR_SA       ((uint32_t)0x40000000)  /* Source address */
+#define ETH_MACA1HR_MBC      ((uint32_t)0x3F000000)  /* Mask byte control: bits to mask for comparison of the MAC Address bytes */
+  #define ETH_MACA1HR_MBC_HBits15_8    ((uint32_t)0x20000000)  /* Mask MAC Address high reg bits [15:8] */
+  #define ETH_MACA1HR_MBC_HBits7_0     ((uint32_t)0x10000000)  /* Mask MAC Address high reg bits [7:0] */
+  #define ETH_MACA1HR_MBC_LBits31_24   ((uint32_t)0x08000000)  /* Mask MAC Address low reg bits [31:24] */
+  #define ETH_MACA1HR_MBC_LBits23_16   ((uint32_t)0x04000000)  /* Mask MAC Address low reg bits [23:16] */
+  #define ETH_MACA1HR_MBC_LBits15_8    ((uint32_t)0x02000000)  /* Mask MAC Address low reg bits [15:8] */
+  #define ETH_MACA1HR_MBC_LBits7_0     ((uint32_t)0x01000000)  /* Mask MAC Address low reg bits [7:0] */
+#define ETH_MACA1HR_MACA1H   ((uint32_t)0x0000FFFF)  /* MAC address1 high */
+
+/* Bit definition for Ethernet MAC Address1 Low Register */
+#define ETH_MACA1LR_MACA1L   ((uint32_t)0xFFFFFFFF)  /* MAC address1 low */
+
+/* Bit definition for Ethernet MAC Address2 High Register */
+#define ETH_MACA2HR_AE       ((uint32_t)0x80000000)  /* Address enable */
+#define ETH_MACA2HR_SA       ((uint32_t)0x40000000)  /* Source address */
+#define ETH_MACA2HR_MBC      ((uint32_t)0x3F000000)  /* Mask byte control */
+  #define ETH_MACA2HR_MBC_HBits15_8    ((uint32_t)0x20000000)  /* Mask MAC Address high reg bits [15:8] */
+  #define ETH_MACA2HR_MBC_HBits7_0     ((uint32_t)0x10000000)  /* Mask MAC Address high reg bits [7:0] */
+  #define ETH_MACA2HR_MBC_LBits31_24   ((uint32_t)0x08000000)  /* Mask MAC Address low reg bits [31:24] */
+  #define ETH_MACA2HR_MBC_LBits23_16   ((uint32_t)0x04000000)  /* Mask MAC Address low reg bits [23:16] */
+  #define ETH_MACA2HR_MBC_LBits15_8    ((uint32_t)0x02000000)  /* Mask MAC Address low reg bits [15:8] */
+  #define ETH_MACA2HR_MBC_LBits7_0     ((uint32_t)0x01000000)  /* Mask MAC Address low reg bits [70] */
+#define ETH_MACA2HR_MACA2H   ((uint32_t)0x0000FFFF)  /* MAC address1 high */
+
+/* Bit definition for Ethernet MAC Address2 Low Register */
+#define ETH_MACA2LR_MACA2L   ((uint32_t)0xFFFFFFFF)  /* MAC address2 low */
+
+/* Bit definition for Ethernet MAC Address3 High Register */
+#define ETH_MACA3HR_AE       ((uint32_t)0x80000000)  /* Address enable */
+#define ETH_MACA3HR_SA       ((uint32_t)0x40000000)  /* Source address */
+#define ETH_MACA3HR_MBC      ((uint32_t)0x3F000000)  /* Mask byte control */
+  #define ETH_MACA3HR_MBC_HBits15_8    ((uint32_t)0x20000000)  /* Mask MAC Address high reg bits [15:8] */
+  #define ETH_MACA3HR_MBC_HBits7_0     ((uint32_t)0x10000000)  /* Mask MAC Address high reg bits [7:0] */
+  #define ETH_MACA3HR_MBC_LBits31_24   ((uint32_t)0x08000000)  /* Mask MAC Address low reg bits [31:24] */
+  #define ETH_MACA3HR_MBC_LBits23_16   ((uint32_t)0x04000000)  /* Mask MAC Address low reg bits [23:16] */
+  #define ETH_MACA3HR_MBC_LBits15_8    ((uint32_t)0x02000000)  /* Mask MAC Address low reg bits [15:8] */
+  #define ETH_MACA3HR_MBC_LBits7_0     ((uint32_t)0x01000000)  /* Mask MAC Address low reg bits [70] */
+#define ETH_MACA3HR_MACA3H   ((uint32_t)0x0000FFFF)  /* MAC address3 high */
+
+/* Bit definition for Ethernet MAC Address3 Low Register */
+#define ETH_MACA3LR_MACA3L   ((uint32_t)0xFFFFFFFF)  /* MAC address3 low */
+
+/******************************************************************************/
+/*                Ethernet MMC Registers bits definition                      */
+/******************************************************************************/
+
+/* Bit definition for Ethernet MMC Contol Register */
+#define ETH_MMCCR_MCF        ((uint32_t)0x00000008)  /* MMC Counter Freeze */
+#define ETH_MMCCR_ROR        ((uint32_t)0x00000004)  /* Reset on Read */
+#define ETH_MMCCR_CSR        ((uint32_t)0x00000002)  /* Counter Stop Rollover */
+#define ETH_MMCCR_CR         ((uint32_t)0x00000001)  /* Counters Reset */
+
+/* Bit definition for Ethernet MMC Receive Interrupt Register */
+#define ETH_MMCRIR_RGUFS     ((uint32_t)0x00020000)  /* Set when Rx good unicast frames counter reaches half the maximum value */
+#define ETH_MMCRIR_RFAES     ((uint32_t)0x00000040)  /* Set when Rx alignment error counter reaches half the maximum value */
+#define ETH_MMCRIR_RFCES     ((uint32_t)0x00000020)  /* Set when Rx crc error counter reaches half the maximum value */
+
+/* Bit definition for Ethernet MMC Transmit Interrupt Register */
+#define ETH_MMCTIR_TGFS      ((uint32_t)0x00200000)  /* Set when Tx good frame count counter reaches half the maximum value */
+#define ETH_MMCTIR_TGFMSCS   ((uint32_t)0x00008000)  /* Set when Tx good multi col counter reaches half the maximum value */
+#define ETH_MMCTIR_TGFSCS    ((uint32_t)0x00004000)  /* Set when Tx good single col counter reaches half the maximum value */
+
+/* Bit definition for Ethernet MMC Receive Interrupt Mask Register */
+#define ETH_MMCRIMR_RGUFM    ((uint32_t)0x00020000)  /* Mask the interrupt when Rx good unicast frames counter reaches half the maximum value */
+#define ETH_MMCRIMR_RFAEM    ((uint32_t)0x00000040)  /* Mask the interrupt when when Rx alignment error counter reaches half the maximum value */
+#define ETH_MMCRIMR_RFCEM    ((uint32_t)0x00000020)  /* Mask the interrupt when Rx crc error counter reaches half the maximum value */
+
+/* Bit definition for Ethernet MMC Transmit Interrupt Mask Register */
+#define ETH_MMCTIMR_TGFM     ((uint32_t)0x00200000)  /* Mask the interrupt when Tx good frame count counter reaches half the maximum value */
+#define ETH_MMCTIMR_TGFMSCM  ((uint32_t)0x00008000)  /* Mask the interrupt when Tx good multi col counter reaches half the maximum value */
+#define ETH_MMCTIMR_TGFSCM   ((uint32_t)0x00004000)  /* Mask the interrupt when Tx good single col counter reaches half the maximum value */
+
+/* Bit definition for Ethernet MMC Transmitted Good Frames after Single Collision Counter Register */
+#define ETH_MMCTGFSCCR_TGFSCC     ((uint32_t)0xFFFFFFFF)  /* Number of successfully transmitted frames after a single collision in Half-duplex mode. */
+
+/* Bit definition for Ethernet MMC Transmitted Good Frames after More than a Single Collision Counter Register */
+#define ETH_MMCTGFMSCCR_TGFMSCC   ((uint32_t)0xFFFFFFFF)  /* Number of successfully transmitted frames after more than a single collision in Half-duplex mode. */
+
+/* Bit definition for Ethernet MMC Transmitted Good Frames Counter Register */
+#define ETH_MMCTGFCR_TGFC    ((uint32_t)0xFFFFFFFF)  /* Number of good frames transmitted. */
+
+/* Bit definition for Ethernet MMC Received Frames with CRC Error Counter Register */
+#define ETH_MMCRFCECR_RFCEC  ((uint32_t)0xFFFFFFFF)  /* Number of frames received with CRC error. */
+
+/* Bit definition for Ethernet MMC Received Frames with Alignement Error Counter Register */
+#define ETH_MMCRFAECR_RFAEC  ((uint32_t)0xFFFFFFFF)  /* Number of frames received with alignment (dribble) error */
+
+/* Bit definition for Ethernet MMC Received Good Unicast Frames Counter Register */
+#define ETH_MMCRGUFCR_RGUFC  ((uint32_t)0xFFFFFFFF)  /* Number of good unicast frames received. */
+
+/******************************************************************************/
+/*               Ethernet PTP Registers bits definition                       */
+/******************************************************************************/
+
+/* Bit definition for Ethernet PTP Time Stamp Contol Register */
+#define ETH_PTPTSCR_TSARU    ((uint32_t)0x00000020)  /* Addend register update */
+#define ETH_PTPTSCR_TSITE    ((uint32_t)0x00000010)  /* Time stamp interrupt trigger enable */
+#define ETH_PTPTSCR_TSSTU    ((uint32_t)0x00000008)  /* Time stamp update */
+#define ETH_PTPTSCR_TSSTI    ((uint32_t)0x00000004)  /* Time stamp initialize */
+#define ETH_PTPTSCR_TSFCU    ((uint32_t)0x00000002)  /* Time stamp fine or coarse update */
+#define ETH_PTPTSCR_TSE      ((uint32_t)0x00000001)  /* Time stamp enable */
+
+/* Bit definition for Ethernet PTP Sub-Second Increment Register */
+#define ETH_PTPSSIR_STSSI    ((uint32_t)0x000000FF)  /* System time Sub-second increment value */
+
+/* Bit definition for Ethernet PTP Time Stamp High Register */
+#define ETH_PTPTSHR_STS      ((uint32_t)0xFFFFFFFF)  /* System Time second */
+
+/* Bit definition for Ethernet PTP Time Stamp Low Register */
+#define ETH_PTPTSLR_STPNS    ((uint32_t)0x80000000)  /* System Time Positive or negative time */
+#define ETH_PTPTSLR_STSS     ((uint32_t)0x7FFFFFFF)  /* System Time sub-seconds */
+
+/* Bit definition for Ethernet PTP Time Stamp High Update Register */
+#define ETH_PTPTSHUR_TSUS    ((uint32_t)0xFFFFFFFF)  /* Time stamp update seconds */
+
+/* Bit definition for Ethernet PTP Time Stamp Low Update Register */
+#define ETH_PTPTSLUR_TSUPNS  ((uint32_t)0x80000000)  /* Time stamp update Positive or negative time */
+#define ETH_PTPTSLUR_TSUSS   ((uint32_t)0x7FFFFFFF)  /* Time stamp update sub-seconds */
+
+/* Bit definition for Ethernet PTP Time Stamp Addend Register */
+#define ETH_PTPTSAR_TSA      ((uint32_t)0xFFFFFFFF)  /* Time stamp addend */
+
+/* Bit definition for Ethernet PTP Target Time High Register */
+#define ETH_PTPTTHR_TTSH     ((uint32_t)0xFFFFFFFF)  /* Target time stamp high */
+
+/* Bit definition for Ethernet PTP Target Time Low Register */
+#define ETH_PTPTTLR_TTSL     ((uint32_t)0xFFFFFFFF)  /* Target time stamp low */
+
+/******************************************************************************/
+/*                 Ethernet DMA Registers bits definition                     */
+/******************************************************************************/
+
+/* Bit definition for Ethernet DMA Bus Mode Register */
+#define ETH_DMABMR_AAB       ((uint32_t)0x02000000)  /* Address-Aligned beats */
+#define ETH_DMABMR_FPM        ((uint32_t)0x01000000)  /* 4xPBL mode */
+#define ETH_DMABMR_USP       ((uint32_t)0x00800000)  /* Use separate PBL */
+#define ETH_DMABMR_RDP       ((uint32_t)0x007E0000)  /* RxDMA PBL */
+  #define ETH_DMABMR_RDP_1Beat    ((uint32_t)0x00020000)  /* maximum number of beats to be transferred in one RxDMA transaction is 1 */
+  #define ETH_DMABMR_RDP_2Beat    ((uint32_t)0x00040000)  /* maximum number of beats to be transferred in one RxDMA transaction is 2 */
+  #define ETH_DMABMR_RDP_4Beat    ((uint32_t)0x00080000)  /* maximum number of beats to be transferred in one RxDMA transaction is 4 */
+  #define ETH_DMABMR_RDP_8Beat    ((uint32_t)0x00100000)  /* maximum number of beats to be transferred in one RxDMA transaction is 8 */
+  #define ETH_DMABMR_RDP_16Beat   ((uint32_t)0x00200000)  /* maximum number of beats to be transferred in one RxDMA transaction is 16 */
+  #define ETH_DMABMR_RDP_32Beat   ((uint32_t)0x00400000)  /* maximum number of beats to be transferred in one RxDMA transaction is 32 */
+  #define ETH_DMABMR_RDP_4xPBL_4Beat   ((uint32_t)0x01020000)  /* maximum number of beats to be transferred in one RxDMA transaction is 4 */
+  #define ETH_DMABMR_RDP_4xPBL_8Beat   ((uint32_t)0x01040000)  /* maximum number of beats to be transferred in one RxDMA transaction is 8 */
+  #define ETH_DMABMR_RDP_4xPBL_16Beat  ((uint32_t)0x01080000)  /* maximum number of beats to be transferred in one RxDMA transaction is 16 */
+  #define ETH_DMABMR_RDP_4xPBL_32Beat  ((uint32_t)0x01100000)  /* maximum number of beats to be transferred in one RxDMA transaction is 32 */
+  #define ETH_DMABMR_RDP_4xPBL_64Beat  ((uint32_t)0x01200000)  /* maximum number of beats to be transferred in one RxDMA transaction is 64 */
+  #define ETH_DMABMR_RDP_4xPBL_128Beat ((uint32_t)0x01400000)  /* maximum number of beats to be transferred in one RxDMA transaction is 128 */
+#define ETH_DMABMR_FB        ((uint32_t)0x00010000)  /* Fixed Burst */
+#define ETH_DMABMR_RTPR      ((uint32_t)0x0000C000)  /* Rx Tx priority ratio */
+  #define ETH_DMABMR_RTPR_1_1     ((uint32_t)0x00000000)  /* Rx Tx priority ratio */
+  #define ETH_DMABMR_RTPR_2_1     ((uint32_t)0x00004000)  /* Rx Tx priority ratio */
+  #define ETH_DMABMR_RTPR_3_1     ((uint32_t)0x00008000)  /* Rx Tx priority ratio */
+  #define ETH_DMABMR_RTPR_4_1     ((uint32_t)0x0000C000)  /* Rx Tx priority ratio */
+#define ETH_DMABMR_PBL    ((uint32_t)0x00003F00)  /* Programmable burst length */
+  #define ETH_DMABMR_PBL_1Beat    ((uint32_t)0x00000100)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 1 */
+  #define ETH_DMABMR_PBL_2Beat    ((uint32_t)0x00000200)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 2 */
+  #define ETH_DMABMR_PBL_4Beat    ((uint32_t)0x00000400)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */
+  #define ETH_DMABMR_PBL_8Beat    ((uint32_t)0x00000800)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */
+  #define ETH_DMABMR_PBL_16Beat   ((uint32_t)0x00001000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */
+  #define ETH_DMABMR_PBL_32Beat   ((uint32_t)0x00002000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */
+  #define ETH_DMABMR_PBL_4xPBL_4Beat   ((uint32_t)0x01000100)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */
+  #define ETH_DMABMR_PBL_4xPBL_8Beat   ((uint32_t)0x01000200)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */
+  #define ETH_DMABMR_PBL_4xPBL_16Beat  ((uint32_t)0x01000400)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */
+  #define ETH_DMABMR_PBL_4xPBL_32Beat  ((uint32_t)0x01000800)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */
+  #define ETH_DMABMR_PBL_4xPBL_64Beat  ((uint32_t)0x01001000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 64 */
+  #define ETH_DMABMR_PBL_4xPBL_128Beat ((uint32_t)0x01002000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 128 */
+#define ETH_DMABMR_DSL       ((uint32_t)0x0000007C)  /* Descriptor Skip Length */
+#define ETH_DMABMR_DA        ((uint32_t)0x00000002)  /* DMA arbitration scheme */
+#define ETH_DMABMR_SR        ((uint32_t)0x00000001)  /* Software reset */
+
+/* Bit definition for Ethernet DMA Transmit Poll Demand Register */
+#define ETH_DMATPDR_TPD      ((uint32_t)0xFFFFFFFF)  /* Transmit poll demand */
+
+/* Bit definition for Ethernet DMA Receive Poll Demand Register */
+#define ETH_DMARPDR_RPD      ((uint32_t)0xFFFFFFFF)  /* Receive poll demand  */
+
+/* Bit definition for Ethernet DMA Receive Descriptor List Address Register */
+#define ETH_DMARDLAR_SRL     ((uint32_t)0xFFFFFFFF)  /* Start of receive list */
+
+/* Bit definition for Ethernet DMA Transmit Descriptor List Address Register */
+#define ETH_DMATDLAR_STL     ((uint32_t)0xFFFFFFFF)  /* Start of transmit list */
+
+/* Bit definition for Ethernet DMA Status Register */
+#define ETH_DMASR_TSTS       ((uint32_t)0x20000000)  /* Time-stamp trigger status */
+#define ETH_DMASR_PMTS       ((uint32_t)0x10000000)  /* PMT status */
+#define ETH_DMASR_MMCS       ((uint32_t)0x08000000)  /* MMC status */
+#define ETH_DMASR_EBS        ((uint32_t)0x03800000)  /* Error bits status */
+  /* combination with EBS[2:0] for GetFlagStatus function */
+  #define ETH_DMASR_EBS_DescAccess      ((uint32_t)0x02000000)  /* Error bits 0-data buffer, 1-desc. access */
+  #define ETH_DMASR_EBS_ReadTransf      ((uint32_t)0x01000000)  /* Error bits 0-write trnsf, 1-read transfr */
+  #define ETH_DMASR_EBS_DataTransfTx    ((uint32_t)0x00800000)  /* Error bits 0-Rx DMA, 1-Tx DMA */
+#define ETH_DMASR_TPS         ((uint32_t)0x00700000)  /* Transmit process state */
+  #define ETH_DMASR_TPS_Stopped         ((uint32_t)0x00000000)  /* Stopped - Reset or Stop Tx Command issued  */
+  #define ETH_DMASR_TPS_Fetching        ((uint32_t)0x00100000)  /* Running - fetching the Tx descriptor */
+  #define ETH_DMASR_TPS_Waiting         ((uint32_t)0x00200000)  /* Running - waiting for status */
+  #define ETH_DMASR_TPS_Reading         ((uint32_t)0x00300000)  /* Running - reading the data from host memory */
+  #define ETH_DMASR_TPS_Suspended       ((uint32_t)0x00600000)  /* Suspended - Tx Descriptor unavailabe */
+  #define ETH_DMASR_TPS_Closing         ((uint32_t)0x00700000)  /* Running - closing Rx descriptor */
+#define ETH_DMASR_RPS         ((uint32_t)0x000E0000)  /* Receive process state */
+  #define ETH_DMASR_RPS_Stopped         ((uint32_t)0x00000000)  /* Stopped - Reset or Stop Rx Command issued */
+  #define ETH_DMASR_RPS_Fetching        ((uint32_t)0x00020000)  /* Running - fetching the Rx descriptor */
+  #define ETH_DMASR_RPS_Waiting         ((uint32_t)0x00060000)  /* Running - waiting for packet */
+  #define ETH_DMASR_RPS_Suspended       ((uint32_t)0x00080000)  /* Suspended - Rx Descriptor unavailable */
+  #define ETH_DMASR_RPS_Closing         ((uint32_t)0x000A0000)  /* Running - closing descriptor */
+  #define ETH_DMASR_RPS_Queuing         ((uint32_t)0x000E0000)  /* Running - queuing the recieve frame into host memory */
+#define ETH_DMASR_NIS        ((uint32_t)0x00010000)  /* Normal interrupt summary */
+#define ETH_DMASR_AIS        ((uint32_t)0x00008000)  /* Abnormal interrupt summary */
+#define ETH_DMASR_ERS        ((uint32_t)0x00004000)  /* Early receive status */
+#define ETH_DMASR_FBES       ((uint32_t)0x00002000)  /* Fatal bus error status */
+#define ETH_DMASR_ETS        ((uint32_t)0x00000400)  /* Early transmit status */
+#define ETH_DMASR_RWTS       ((uint32_t)0x00000200)  /* Receive watchdog timeout status */
+#define ETH_DMASR_RPSS       ((uint32_t)0x00000100)  /* Receive process stopped status */
+#define ETH_DMASR_RBUS       ((uint32_t)0x00000080)  /* Receive buffer unavailable status */
+#define ETH_DMASR_RS         ((uint32_t)0x00000040)  /* Receive status */
+#define ETH_DMASR_TUS        ((uint32_t)0x00000020)  /* Transmit underflow status */
+#define ETH_DMASR_ROS        ((uint32_t)0x00000010)  /* Receive overflow status */
+#define ETH_DMASR_TJTS       ((uint32_t)0x00000008)  /* Transmit jabber timeout status */
+#define ETH_DMASR_TBUS       ((uint32_t)0x00000004)  /* Transmit buffer unavailable status */
+#define ETH_DMASR_TPSS       ((uint32_t)0x00000002)  /* Transmit process stopped status */
+#define ETH_DMASR_TS         ((uint32_t)0x00000001)  /* Transmit status */
+
+/* Bit definition for Ethernet DMA Operation Mode Register */
+#define ETH_DMAOMR_DTCEFD    ((uint32_t)0x04000000)  /* Disable Dropping of TCP/IP checksum error frames */
+#define ETH_DMAOMR_RSF       ((uint32_t)0x02000000)  /* Receive store and forward */
+#define ETH_DMAOMR_DFRF      ((uint32_t)0x01000000)  /* Disable flushing of received frames */
+#define ETH_DMAOMR_TSF       ((uint32_t)0x00200000)  /* Transmit store and forward */
+#define ETH_DMAOMR_FTF       ((uint32_t)0x00100000)  /* Flush transmit FIFO */
+#define ETH_DMAOMR_TTC       ((uint32_t)0x0001C000)  /* Transmit threshold control */
+  #define ETH_DMAOMR_TTC_64Bytes       ((uint32_t)0x00000000)  /* threshold level of the MTL Transmit FIFO is 64 Bytes */
+  #define ETH_DMAOMR_TTC_128Bytes      ((uint32_t)0x00004000)  /* threshold level of the MTL Transmit FIFO is 128 Bytes */
+  #define ETH_DMAOMR_TTC_192Bytes      ((uint32_t)0x00008000)  /* threshold level of the MTL Transmit FIFO is 192 Bytes */
+  #define ETH_DMAOMR_TTC_256Bytes      ((uint32_t)0x0000C000)  /* threshold level of the MTL Transmit FIFO is 256 Bytes */
+  #define ETH_DMAOMR_TTC_40Bytes       ((uint32_t)0x00010000)  /* threshold level of the MTL Transmit FIFO is 40 Bytes */
+  #define ETH_DMAOMR_TTC_32Bytes       ((uint32_t)0x00014000)  /* threshold level of the MTL Transmit FIFO is 32 Bytes */
+  #define ETH_DMAOMR_TTC_24Bytes       ((uint32_t)0x00018000)  /* threshold level of the MTL Transmit FIFO is 24 Bytes */
+  #define ETH_DMAOMR_TTC_16Bytes       ((uint32_t)0x0001C000)  /* threshold level of the MTL Transmit FIFO is 16 Bytes */
+#define ETH_DMAOMR_ST        ((uint32_t)0x00002000)  /* Start/stop transmission command */
+#define ETH_DMAOMR_FEF       ((uint32_t)0x00000080)  /* Forward error frames */
+#define ETH_DMAOMR_FUGF      ((uint32_t)0x00000040)  /* Forward undersized good frames */
+#define ETH_DMAOMR_RTC       ((uint32_t)0x00000018)  /* receive threshold control */
+  #define ETH_DMAOMR_RTC_64Bytes       ((uint32_t)0x00000000)  /* threshold level of the MTL Receive FIFO is 64 Bytes */
+  #define ETH_DMAOMR_RTC_32Bytes       ((uint32_t)0x00000008)  /* threshold level of the MTL Receive FIFO is 32 Bytes */
+  #define ETH_DMAOMR_RTC_96Bytes       ((uint32_t)0x00000010)  /* threshold level of the MTL Receive FIFO is 96 Bytes */
+  #define ETH_DMAOMR_RTC_128Bytes      ((uint32_t)0x00000018)  /* threshold level of the MTL Receive FIFO is 128 Bytes */
+#define ETH_DMAOMR_OSF       ((uint32_t)0x00000004)  /* operate on second frame */
+#define ETH_DMAOMR_SR        ((uint32_t)0x00000002)  /* Start/stop receive */
+
+/* Bit definition for Ethernet DMA Interrupt Enable Register */
+#define ETH_DMAIER_NISE      ((uint32_t)0x00010000)  /* Normal interrupt summary enable */
+#define ETH_DMAIER_AISE      ((uint32_t)0x00008000)  /* Abnormal interrupt summary enable */
+#define ETH_DMAIER_ERIE      ((uint32_t)0x00004000)  /* Early receive interrupt enable */
+#define ETH_DMAIER_FBEIE     ((uint32_t)0x00002000)  /* Fatal bus error interrupt enable */
+#define ETH_DMAIER_ETIE      ((uint32_t)0x00000400)  /* Early transmit interrupt enable */
+#define ETH_DMAIER_RWTIE     ((uint32_t)0x00000200)  /* Receive watchdog timeout interrupt enable */
+#define ETH_DMAIER_RPSIE     ((uint32_t)0x00000100)  /* Receive process stopped interrupt enable */
+#define ETH_DMAIER_RBUIE     ((uint32_t)0x00000080)  /* Receive buffer unavailable interrupt enable */
+#define ETH_DMAIER_RIE       ((uint32_t)0x00000040)  /* Receive interrupt enable */
+#define ETH_DMAIER_TUIE      ((uint32_t)0x00000020)  /* Transmit Underflow interrupt enable */
+#define ETH_DMAIER_ROIE      ((uint32_t)0x00000010)  /* Receive Overflow interrupt enable */
+#define ETH_DMAIER_TJTIE     ((uint32_t)0x00000008)  /* Transmit jabber timeout interrupt enable */
+#define ETH_DMAIER_TBUIE     ((uint32_t)0x00000004)  /* Transmit buffer unavailable interrupt enable */
+#define ETH_DMAIER_TPSIE     ((uint32_t)0x00000002)  /* Transmit process stopped interrupt enable */
+#define ETH_DMAIER_TIE       ((uint32_t)0x00000001)  /* Transmit interrupt enable */
+
+/* Bit definition for Ethernet DMA Missed Frame and Buffer Overflow Counter Register */
+#define ETH_DMAMFBOCR_OFOC   ((uint32_t)0x10000000)  /* Overflow bit for FIFO overflow counter */
+#define ETH_DMAMFBOCR_MFA    ((uint32_t)0x0FFE0000)  /* Number of frames missed by the application */
+#define ETH_DMAMFBOCR_OMFC   ((uint32_t)0x00010000)  /* Overflow bit for missed frame counter */
+#define ETH_DMAMFBOCR_MFC    ((uint32_t)0x0000FFFF)  /* Number of frames missed by the controller */
+
+/* Bit definition for Ethernet DMA Current Host Transmit Descriptor Register */
+#define ETH_DMACHTDR_HTDAP   ((uint32_t)0xFFFFFFFF)  /* Host transmit descriptor address pointer */
+
+/* Bit definition for Ethernet DMA Current Host Receive Descriptor Register */
+#define ETH_DMACHRDR_HRDAP   ((uint32_t)0xFFFFFFFF)  /* Host receive descriptor address pointer */
+
+/* Bit definition for Ethernet DMA Current Host Transmit Buffer Address Register */
+#define ETH_DMACHTBAR_HTBAP  ((uint32_t)0xFFFFFFFF)  /* Host transmit buffer address pointer */
+
+/* Bit definition for Ethernet DMA Current Host Receive Buffer Address Register */
+#define ETH_DMACHRBAR_HRBAP  ((uint32_t)0xFFFFFFFF)  /* Host receive buffer address pointer */
+#endif /* STM32F10X_CL */
+
+/**
+  * @}
+  */
+
+ /**
+  * @}
+  */
+
+#ifdef USE_STDPERIPH_DRIVER
+  #include "stm32f10x_conf.h"
+#endif
+
+/** @addtogroup Exported_macro
+  * @{
+  */
+
+#define SET_BIT(REG, BIT)     ((REG) |= (BIT))
+
+#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))
+
+#define READ_BIT(REG, BIT)    ((REG) & (BIT))
+
+#define CLEAR_REG(REG)        ((REG) = (0x0))
+
+#define WRITE_REG(REG, VAL)   ((REG) = (VAL))
+
+#define READ_REG(REG)         ((REG))
+
+#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))
+
+/**
+  * @}
+  */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F10x_H */
+
+/**
+  * @}
+  */
+
+  /**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/system_stm32f10x.c b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/system_stm32f10x.c
new file mode 100644
index 0000000..6fb4579
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/system_stm32f10x.c
@@ -0,0 +1,1094 @@
+/**
+  ******************************************************************************
+  * @file    system_stm32f10x.c
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer System Source File.
+  *
+  * 1.  This file provides two functions and one global variable to be called from
+  *     user application:
+  *      - SystemInit(): Setups the system clock (System clock source, PLL Multiplier
+  *                      factors, AHB/APBx prescalers and Flash settings).
+  *                      This function is called at startup just after reset and
+  *                      before branch to main program. This call is made inside
+  *                      the "startup_stm32f10x_xx.s" file.
+  *
+  *      - SystemCoreClock variable: Contains the core clock (HCLK), it can be used
+  *                                  by the user application to setup the SysTick
+  *                                  timer or configure other parameters.
+  *
+  *      - SystemCoreClockUpdate(): Updates the variable SystemCoreClock and must
+  *                                 be called whenever the core clock is changed
+  *                                 during program execution.
+  *
+  * 2. After each device reset the HSI (8 MHz) is used as system clock source.
+  *    Then SystemInit() function is called, in "startup_stm32f10x_xx.s" file, to
+  *    configure the system clock before to branch to main program.
+  *
+  * 3. If the system clock source selected by user fails to startup, the SystemInit()
+  *    function will do nothing and HSI still used as system clock source. User can
+  *    add some code to deal with this issue inside the SetSysClock() function.
+  *
+  * 4. The default value of HSE crystal is set to 8 MHz (or 25 MHz, depedning on
+  *    the product used), refer to "HSE_VALUE" define in "stm32f10x.h" file.
+  *    When HSE is used as system clock source, directly or through PLL, and you
+  *    are using different crystal you have to adapt the HSE value to your own
+  *    configuration.
+  *
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/** @addtogroup CMSIS
+  * @{
+  */
+
+/** @addtogroup stm32f10x_system
+  * @{
+  */
+
+/** @addtogroup STM32F10x_System_Private_Includes
+  * @{
+  */
+
+#include "stm32f10x.h"
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32F10x_System_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32F10x_System_Private_Defines
+  * @{
+  */
+
+/*!< Uncomment the line corresponding to the desired System clock (SYSCLK)
+   frequency (after reset the HSI is used as SYSCLK source)
+
+   IMPORTANT NOTE:
+   ==============
+   1. After each device reset the HSI is used as System clock source.
+
+   2. Please make sure that the selected System clock doesn't exceed your device's
+      maximum frequency.
+
+   3. If none of the define below is enabled, the HSI is used as System clock
+    source.
+
+   4. The System clock configuration functions provided within this file assume that:
+        - For Low, Medium and High density Value line devices an external 8MHz
+          crystal is used to drive the System clock.
+        - For Low, Medium and High density devices an external 8MHz crystal is
+          used to drive the System clock.
+        - For Connectivity line devices an external 25MHz crystal is used to drive
+          the System clock.
+     If you are using different crystal you have to adapt those functions accordingly.
+    */
+
+#if defined (STM32F10X_LD_VL) || (defined STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
+/* #define SYSCLK_FREQ_HSE    HSE_VALUE */
+ #define SYSCLK_FREQ_24MHz  24000000
+#else
+/* #define SYSCLK_FREQ_HSE    HSE_VALUE */
+/* #define SYSCLK_FREQ_24MHz  24000000 */
+/* #define SYSCLK_FREQ_36MHz  36000000 */
+/* #define SYSCLK_FREQ_48MHz  48000000 */
+/* #define SYSCLK_FREQ_56MHz  56000000 */
+#define SYSCLK_FREQ_72MHz  72000000
+#endif
+
+/*!< Uncomment the following line if you need to use external SRAM mounted
+     on STM3210E-EVAL board (STM32 High density and XL-density devices) or on
+     STM32100E-EVAL board (STM32 High-density value line devices) as data memory */
+#if defined (STM32F10X_HD) || (defined STM32F10X_XL) || (defined STM32F10X_HD_VL)
+/* #define DATA_IN_ExtSRAM */
+#endif
+
+/*!< Uncomment the following line if you need to relocate your vector Table in
+     Internal SRAM. */
+/* #define VECT_TAB_SRAM */
+#define VECT_TAB_OFFSET  0x0 /*!< Vector Table base offset field.
+                                  This value must be a multiple of 0x200. */
+
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32F10x_System_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32F10x_System_Private_Variables
+  * @{
+  */
+
+/*******************************************************************************
+*  Clock Definitions
+*******************************************************************************/
+#ifdef SYSCLK_FREQ_HSE
+  uint32_t SystemCoreClock         = SYSCLK_FREQ_HSE;        /*!< System Clock Frequency (Core Clock) */
+#elif defined SYSCLK_FREQ_24MHz
+  uint32_t SystemCoreClock         = SYSCLK_FREQ_24MHz;        /*!< System Clock Frequency (Core Clock) */
+#elif defined SYSCLK_FREQ_36MHz
+  uint32_t SystemCoreClock         = SYSCLK_FREQ_36MHz;        /*!< System Clock Frequency (Core Clock) */
+#elif defined SYSCLK_FREQ_48MHz
+  uint32_t SystemCoreClock         = SYSCLK_FREQ_48MHz;        /*!< System Clock Frequency (Core Clock) */
+#elif defined SYSCLK_FREQ_56MHz
+  uint32_t SystemCoreClock         = SYSCLK_FREQ_56MHz;        /*!< System Clock Frequency (Core Clock) */
+#elif defined SYSCLK_FREQ_72MHz
+  uint32_t SystemCoreClock         = SYSCLK_FREQ_72MHz;        /*!< System Clock Frequency (Core Clock) */
+#else /*!< HSI Selected as System Clock source */
+  uint32_t SystemCoreClock         = HSI_VALUE;        /*!< System Clock Frequency (Core Clock) */
+#endif
+
+__I uint8_t AHBPrescTable[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
+/**
+  * @}
+  */
+
+/** @addtogroup STM32F10x_System_Private_FunctionPrototypes
+  * @{
+  */
+
+static void SetSysClock(void);
+
+#ifdef SYSCLK_FREQ_HSE
+  static void SetSysClockToHSE(void);
+#elif defined SYSCLK_FREQ_24MHz
+  static void SetSysClockTo24(void);
+#elif defined SYSCLK_FREQ_36MHz
+  static void SetSysClockTo36(void);
+#elif defined SYSCLK_FREQ_48MHz
+  static void SetSysClockTo48(void);
+#elif defined SYSCLK_FREQ_56MHz
+  static void SetSysClockTo56(void);
+#elif defined SYSCLK_FREQ_72MHz
+  static void SetSysClockTo72(void);
+#endif
+
+#ifdef DATA_IN_ExtSRAM
+  static void SystemInit_ExtMemCtl(void);
+#endif /* DATA_IN_ExtSRAM */
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32F10x_System_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Setup the microcontroller system
+  *         Initialize the Embedded Flash Interface, the PLL and update the
+  *         SystemCoreClock variable.
+  * @note   This function should be used only after reset.
+  * @param  None
+  * @retval None
+  */
+void SystemInit (void)
+{
+  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
+  /* Set HSION bit */
+  RCC->CR |= (uint32_t)0x00000001;
+
+  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
+#ifndef STM32F10X_CL
+  RCC->CFGR &= (uint32_t)0xF8FF0000;
+#else
+  RCC->CFGR &= (uint32_t)0xF0FF0000;
+#endif /* STM32F10X_CL */
+
+  /* Reset HSEON, CSSON and PLLON bits */
+  RCC->CR &= (uint32_t)0xFEF6FFFF;
+
+  /* Reset HSEBYP bit */
+  RCC->CR &= (uint32_t)0xFFFBFFFF;
+
+  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
+  RCC->CFGR &= (uint32_t)0xFF80FFFF;
+
+#ifdef STM32F10X_CL
+  /* Reset PLL2ON and PLL3ON bits */
+  RCC->CR &= (uint32_t)0xEBFFFFFF;
+
+  /* Disable all interrupts and clear pending bits  */
+  RCC->CIR = 0x00FF0000;
+
+  /* Reset CFGR2 register */
+  RCC->CFGR2 = 0x00000000;
+#elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
+  /* Disable all interrupts and clear pending bits  */
+  RCC->CIR = 0x009F0000;
+
+  /* Reset CFGR2 register */
+  RCC->CFGR2 = 0x00000000;
+#else
+  /* Disable all interrupts and clear pending bits  */
+  RCC->CIR = 0x009F0000;
+#endif /* STM32F10X_CL */
+
+#if defined (STM32F10X_HD) || (defined STM32F10X_XL) || (defined STM32F10X_HD_VL)
+  #ifdef DATA_IN_ExtSRAM
+    SystemInit_ExtMemCtl();
+  #endif /* DATA_IN_ExtSRAM */
+#endif
+
+  /* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */
+  /* Configure the Flash Latency cycles and enable prefetch buffer */
+  SetSysClock();
+
+#ifdef VECT_TAB_SRAM
+  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
+#else
+  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
+#endif
+}
+
+/**
+  * @brief  Update SystemCoreClock variable according to Clock Register Values.
+  *         The SystemCoreClock variable contains the core clock (HCLK), it can
+  *         be used by the user application to setup the SysTick timer or configure
+  *         other parameters.
+  *
+  * @note   Each time the core clock (HCLK) changes, this function must be called
+  *         to update SystemCoreClock variable value. Otherwise, any configuration
+  *         based on this variable will be incorrect.
+  *
+  * @note   - The system frequency computed by this function is not the real
+  *           frequency in the chip. It is calculated based on the predefined
+  *           constant and the selected clock source:
+  *
+  *           - If SYSCLK source is HSI, SystemCoreClock will contain the HSI_VALUE(*)
+  *
+  *           - If SYSCLK source is HSE, SystemCoreClock will contain the HSE_VALUE(**)
+  *
+  *           - If SYSCLK source is PLL, SystemCoreClock will contain the HSE_VALUE(**)
+  *             or HSI_VALUE(*) multiplied by the PLL factors.
+  *
+  *         (*) HSI_VALUE is a constant defined in stm32f1xx.h file (default value
+  *             8 MHz) but the real value may vary depending on the variations
+  *             in voltage and temperature.
+  *
+  *         (**) HSE_VALUE is a constant defined in stm32f1xx.h file (default value
+  *              8 MHz or 25 MHz, depedning on the product used), user has to ensure
+  *              that HSE_VALUE is same as the real frequency of the crystal used.
+  *              Otherwise, this function may have wrong result.
+  *
+  *         - The result of this function could be not correct when using fractional
+  *           value for HSE crystal.
+  * @param  None
+  * @retval None
+  */
+void SystemCoreClockUpdate (void)
+{
+  uint32_t tmp = 0, pllmull = 0, pllsource = 0;
+
+#ifdef  STM32F10X_CL
+  uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
+#endif /* STM32F10X_CL */
+
+#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
+  uint32_t prediv1factor = 0;
+#endif /* STM32F10X_LD_VL or STM32F10X_MD_VL or STM32F10X_HD_VL */
+
+  /* Get SYSCLK source -------------------------------------------------------*/
+  tmp = RCC->CFGR & RCC_CFGR_SWS;
+
+  switch (tmp)
+  {
+    case 0x00:  /* HSI used as system clock */
+      SystemCoreClock = HSI_VALUE;
+      break;
+    case 0x04:  /* HSE used as system clock */
+      SystemCoreClock = HSE_VALUE;
+      break;
+    case 0x08:  /* PLL used as system clock */
+
+      /* Get PLL clock source and multiplication factor ----------------------*/
+      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
+      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
+
+#ifndef STM32F10X_CL
+      pllmull = ( pllmull >> 18) + 2;
+
+      if (pllsource == 0x00)
+      {
+        /* HSI oscillator clock divided by 2 selected as PLL clock entry */
+        SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
+      }
+      else
+      {
+ #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
+       prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
+       /* HSE oscillator clock selected as PREDIV1 clock entry */
+       SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull;
+ #else
+        /* HSE selected as PLL clock entry */
+        if ((RCC->CFGR & RCC_CFGR_PLLXTPRE) != (uint32_t)RESET)
+        {/* HSE oscillator clock divided by 2 */
+          SystemCoreClock = (HSE_VALUE >> 1) * pllmull;
+        }
+        else
+        {
+          SystemCoreClock = HSE_VALUE * pllmull;
+        }
+ #endif
+      }
+#else
+      pllmull = pllmull >> 18;
+
+      if (pllmull != 0x0D)
+      {
+         pllmull += 2;
+      }
+      else
+      { /* PLL multiplication factor = PLL input clock * 6.5 */
+        pllmull = 13 / 2;
+      }
+
+      if (pllsource == 0x00)
+      {
+        /* HSI oscillator clock divided by 2 selected as PLL clock entry */
+        SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
+      }
+      else
+      {/* PREDIV1 selected as PLL clock entry */
+
+        /* Get PREDIV1 clock source and division factor */
+        prediv1source = RCC->CFGR2 & RCC_CFGR2_PREDIV1SRC;
+        prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
+
+        if (prediv1source == 0)
+        {
+          /* HSE oscillator clock selected as PREDIV1 clock entry */
+          SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull;
+        }
+        else
+        {/* PLL2 clock selected as PREDIV1 clock entry */
+
+          /* Get PREDIV2 division factor and PLL2 multiplication factor */
+          prediv2factor = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> 4) + 1;
+          pll2mull = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> 8 ) + 2;
+          SystemCoreClock = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;
+        }
+      }
+#endif /* STM32F10X_CL */
+      break;
+
+    default:
+      SystemCoreClock = HSI_VALUE;
+      break;
+  }
+
+  /* Compute HCLK clock frequency ----------------*/
+  /* Get HCLK prescaler */
+  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
+  /* HCLK clock frequency */
+  SystemCoreClock >>= tmp;
+}
+
+/**
+  * @brief  Configures the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers.
+  * @param  None
+  * @retval None
+  */
+static void SetSysClock(void)
+{
+#ifdef SYSCLK_FREQ_HSE
+  SetSysClockToHSE();
+#elif defined SYSCLK_FREQ_24MHz
+  SetSysClockTo24();
+#elif defined SYSCLK_FREQ_36MHz
+  SetSysClockTo36();
+#elif defined SYSCLK_FREQ_48MHz
+  SetSysClockTo48();
+#elif defined SYSCLK_FREQ_56MHz
+  SetSysClockTo56();
+#elif defined SYSCLK_FREQ_72MHz
+  SetSysClockTo72();
+#endif
+
+ /* If none of the define above is enabled, the HSI is used as System clock
+    source (default after reset) */
+}
+
+/**
+  * @brief  Setup the external memory controller. Called in startup_stm32f10x.s
+  *          before jump to __main
+  * @param  None
+  * @retval None
+  */
+#ifdef DATA_IN_ExtSRAM
+/**
+  * @brief  Setup the external memory controller.
+  *         Called in startup_stm32f10x_xx.s/.c before jump to main.
+  * 	      This function configures the external SRAM mounted on STM3210E-EVAL
+  *         board (STM32 High density devices). This SRAM will be used as program
+  *         data memory (including heap and stack).
+  * @param  None
+  * @retval None
+  */
+void SystemInit_ExtMemCtl(void)
+{
+/*!< FSMC Bank1 NOR/SRAM3 is used for the STM3210E-EVAL, if another Bank is
+  required, then adjust the Register Addresses */
+
+  /* Enable FSMC clock */
+  RCC->AHBENR = 0x00000114;
+
+  /* Enable GPIOD, GPIOE, GPIOF and GPIOG clocks */
+  RCC->APB2ENR = 0x000001E0;
+
+/* ---------------  SRAM Data lines, NOE and NWE configuration ---------------*/
+/*----------------  SRAM Address lines configuration -------------------------*/
+/*----------------  NOE and NWE configuration --------------------------------*/
+/*----------------  NE3 configuration ----------------------------------------*/
+/*----------------  NBL0, NBL1 configuration ---------------------------------*/
+
+  GPIOD->CRL = 0x44BB44BB;
+  GPIOD->CRH = 0xBBBBBBBB;
+
+  GPIOE->CRL = 0xB44444BB;
+  GPIOE->CRH = 0xBBBBBBBB;
+
+  GPIOF->CRL = 0x44BBBBBB;
+  GPIOF->CRH = 0xBBBB4444;
+
+  GPIOG->CRL = 0x44BBBBBB;
+  GPIOG->CRH = 0x44444B44;
+
+/*----------------  FSMC Configuration ---------------------------------------*/
+/*----------------  Enable FSMC Bank1_SRAM Bank ------------------------------*/
+
+  FSMC_Bank1->BTCR[4] = 0x00001011;
+  FSMC_Bank1->BTCR[5] = 0x00000200;
+}
+#endif /* DATA_IN_ExtSRAM */
+
+#ifdef SYSCLK_FREQ_HSE
+/**
+  * @brief  Selects HSE as System clock source and configure HCLK, PCLK2
+  *         and PCLK1 prescalers.
+  * @note   This function should be used only after reset.
+  * @param  None
+  * @retval None
+  */
+static void SetSysClockToHSE(void)
+{
+  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
+
+  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/
+  /* Enable HSE */
+  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
+
+  /* Wait till HSE is ready and if Time out is reached exit */
+  do
+  {
+    HSEStatus = RCC->CR & RCC_CR_HSERDY;
+    StartUpCounter++;
+  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
+
+  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
+  {
+    HSEStatus = (uint32_t)0x01;
+  }
+  else
+  {
+    HSEStatus = (uint32_t)0x00;
+  }
+
+  if (HSEStatus == (uint32_t)0x01)
+  {
+
+#if !defined STM32F10X_LD_VL && !defined STM32F10X_MD_VL && !defined STM32F10X_HD_VL
+    /* Enable Prefetch Buffer */
+    FLASH->ACR |= FLASH_ACR_PRFTBE;
+
+    /* Flash 0 wait state */
+    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
+
+#ifndef STM32F10X_CL
+    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_0;
+#else
+    if (HSE_VALUE <= 24000000)
+	{
+      FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_0;
+	}
+	else
+	{
+      FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_1;
+	}
+#endif /* STM32F10X_CL */
+#endif
+
+    /* HCLK = SYSCLK */
+    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
+
+    /* PCLK2 = HCLK */
+    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
+
+    /* PCLK1 = HCLK */
+    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV1;
+
+    /* Select HSE as system clock source */
+    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
+    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_HSE;
+
+    /* Wait till HSE is used as system clock source */
+    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x04)
+    {
+    }
+  }
+  else
+  { /* If HSE fails to start-up, the application will have wrong clock
+         configuration. User can add here some code to deal with this error */
+  }
+}
+#elif defined SYSCLK_FREQ_24MHz
+/**
+  * @brief  Sets System clock frequency to 24MHz and configure HCLK, PCLK2
+  *         and PCLK1 prescalers.
+  * @note   This function should be used only after reset.
+  * @param  None
+  * @retval None
+  */
+static void SetSysClockTo24(void)
+{
+  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
+
+  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/
+  /* Enable HSE */
+  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
+
+  /* Wait till HSE is ready and if Time out is reached exit */
+  do
+  {
+    HSEStatus = RCC->CR & RCC_CR_HSERDY;
+    StartUpCounter++;
+  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
+
+  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
+  {
+    HSEStatus = (uint32_t)0x01;
+  }
+  else
+  {
+    HSEStatus = (uint32_t)0x00;
+  }
+
+  if (HSEStatus == (uint32_t)0x01)
+  {
+#if !defined STM32F10X_LD_VL && !defined STM32F10X_MD_VL && !defined STM32F10X_HD_VL
+    /* Enable Prefetch Buffer */
+    FLASH->ACR |= FLASH_ACR_PRFTBE;
+
+    /* Flash 0 wait state */
+    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
+    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_0;
+#endif
+
+    /* HCLK = SYSCLK */
+    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
+
+    /* PCLK2 = HCLK */
+    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
+
+    /* PCLK1 = HCLK */
+    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV1;
+
+#ifdef STM32F10X_CL
+    /* Configure PLLs ------------------------------------------------------*/
+    /* PLL configuration: PLLCLK = PREDIV1 * 6 = 24 MHz */
+    RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
+    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 |
+                            RCC_CFGR_PLLMULL6);
+
+    /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
+    /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 10 = 4 MHz */
+    RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
+                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
+    RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
+                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV10);
+
+    /* Enable PLL2 */
+    RCC->CR |= RCC_CR_PLL2ON;
+    /* Wait till PLL2 is ready */
+    while((RCC->CR & RCC_CR_PLL2RDY) == 0)
+    {
+    }
+#elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
+    /*  PLL configuration:  = (HSE / 2) * 6 = 24 MHz */
+    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));
+    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_PREDIV1 | RCC_CFGR_PLLXTPRE_PREDIV1_Div2 | RCC_CFGR_PLLMULL6);
+#else
+    /*  PLL configuration:  = (HSE / 2) * 6 = 24 MHz */
+    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));
+    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLXTPRE_HSE_Div2 | RCC_CFGR_PLLMULL6);
+#endif /* STM32F10X_CL */
+
+    /* Enable PLL */
+    RCC->CR |= RCC_CR_PLLON;
+
+    /* Wait till PLL is ready */
+    while((RCC->CR & RCC_CR_PLLRDY) == 0)
+    {
+    }
+
+    /* Select PLL as system clock source */
+    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
+    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;
+
+    /* Wait till PLL is used as system clock source */
+    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
+    {
+    }
+  }
+  else
+  { /* If HSE fails to start-up, the application will have wrong clock
+         configuration. User can add here some code to deal with this error */
+  }
+}
+#elif defined SYSCLK_FREQ_36MHz
+/**
+  * @brief  Sets System clock frequency to 36MHz and configure HCLK, PCLK2
+  *         and PCLK1 prescalers.
+  * @note   This function should be used only after reset.
+  * @param  None
+  * @retval None
+  */
+static void SetSysClockTo36(void)
+{
+  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
+
+  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/
+  /* Enable HSE */
+  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
+
+  /* Wait till HSE is ready and if Time out is reached exit */
+  do
+  {
+    HSEStatus = RCC->CR & RCC_CR_HSERDY;
+    StartUpCounter++;
+  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
+
+  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
+  {
+    HSEStatus = (uint32_t)0x01;
+  }
+  else
+  {
+    HSEStatus = (uint32_t)0x00;
+  }
+
+  if (HSEStatus == (uint32_t)0x01)
+  {
+    /* Enable Prefetch Buffer */
+    FLASH->ACR |= FLASH_ACR_PRFTBE;
+
+    /* Flash 1 wait state */
+    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
+    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_1;
+
+    /* HCLK = SYSCLK */
+    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
+
+    /* PCLK2 = HCLK */
+    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
+
+    /* PCLK1 = HCLK */
+    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV1;
+
+#ifdef STM32F10X_CL
+    /* Configure PLLs ------------------------------------------------------*/
+
+    /* PLL configuration: PLLCLK = PREDIV1 * 9 = 36 MHz */
+    RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
+    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 |
+                            RCC_CFGR_PLLMULL9);
+
+	/*!< PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
+    /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 10 = 4 MHz */
+
+    RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
+                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
+    RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
+                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV10);
+
+    /* Enable PLL2 */
+    RCC->CR |= RCC_CR_PLL2ON;
+    /* Wait till PLL2 is ready */
+    while((RCC->CR & RCC_CR_PLL2RDY) == 0)
+    {
+    }
+
+#else
+    /*  PLL configuration: PLLCLK = (HSE / 2) * 9 = 36 MHz */
+    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));
+    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLXTPRE_HSE_Div2 | RCC_CFGR_PLLMULL9);
+#endif /* STM32F10X_CL */
+
+    /* Enable PLL */
+    RCC->CR |= RCC_CR_PLLON;
+
+    /* Wait till PLL is ready */
+    while((RCC->CR & RCC_CR_PLLRDY) == 0)
+    {
+    }
+
+    /* Select PLL as system clock source */
+    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
+    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;
+
+    /* Wait till PLL is used as system clock source */
+    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
+    {
+    }
+  }
+  else
+  { /* If HSE fails to start-up, the application will have wrong clock
+         configuration. User can add here some code to deal with this error */
+  }
+}
+#elif defined SYSCLK_FREQ_48MHz
+/**
+  * @brief  Sets System clock frequency to 48MHz and configure HCLK, PCLK2
+  *         and PCLK1 prescalers.
+  * @note   This function should be used only after reset.
+  * @param  None
+  * @retval None
+  */
+static void SetSysClockTo48(void)
+{
+  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
+
+  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/
+  /* Enable HSE */
+  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
+
+  /* Wait till HSE is ready and if Time out is reached exit */
+  do
+  {
+    HSEStatus = RCC->CR & RCC_CR_HSERDY;
+    StartUpCounter++;
+  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
+
+  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
+  {
+    HSEStatus = (uint32_t)0x01;
+  }
+  else
+  {
+    HSEStatus = (uint32_t)0x00;
+  }
+
+  if (HSEStatus == (uint32_t)0x01)
+  {
+    /* Enable Prefetch Buffer */
+    FLASH->ACR |= FLASH_ACR_PRFTBE;
+
+    /* Flash 1 wait state */
+    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
+    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_1;
+
+    /* HCLK = SYSCLK */
+    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
+
+    /* PCLK2 = HCLK */
+    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
+
+    /* PCLK1 = HCLK */
+    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
+
+#ifdef STM32F10X_CL
+    /* Configure PLLs ------------------------------------------------------*/
+    /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
+    /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */
+
+    RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
+                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
+    RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
+                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);
+
+    /* Enable PLL2 */
+    RCC->CR |= RCC_CR_PLL2ON;
+    /* Wait till PLL2 is ready */
+    while((RCC->CR & RCC_CR_PLL2RDY) == 0)
+    {
+    }
+
+
+    /* PLL configuration: PLLCLK = PREDIV1 * 6 = 48 MHz */
+    RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
+    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 |
+                            RCC_CFGR_PLLMULL6);
+#else
+    /*  PLL configuration: PLLCLK = HSE * 6 = 48 MHz */
+    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));
+    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL6);
+#endif /* STM32F10X_CL */
+
+    /* Enable PLL */
+    RCC->CR |= RCC_CR_PLLON;
+
+    /* Wait till PLL is ready */
+    while((RCC->CR & RCC_CR_PLLRDY) == 0)
+    {
+    }
+
+    /* Select PLL as system clock source */
+    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
+    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;
+
+    /* Wait till PLL is used as system clock source */
+    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
+    {
+    }
+  }
+  else
+  { /* If HSE fails to start-up, the application will have wrong clock
+         configuration. User can add here some code to deal with this error */
+  }
+}
+
+#elif defined SYSCLK_FREQ_56MHz
+/**
+  * @brief  Sets System clock frequency to 56MHz and configure HCLK, PCLK2
+  *         and PCLK1 prescalers.
+  * @note   This function should be used only after reset.
+  * @param  None
+  * @retval None
+  */
+static void SetSysClockTo56(void)
+{
+  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
+
+  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/
+  /* Enable HSE */
+  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
+
+  /* Wait till HSE is ready and if Time out is reached exit */
+  do
+  {
+    HSEStatus = RCC->CR & RCC_CR_HSERDY;
+    StartUpCounter++;
+  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
+
+  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
+  {
+    HSEStatus = (uint32_t)0x01;
+  }
+  else
+  {
+    HSEStatus = (uint32_t)0x00;
+  }
+
+  if (HSEStatus == (uint32_t)0x01)
+  {
+    /* Enable Prefetch Buffer */
+    FLASH->ACR |= FLASH_ACR_PRFTBE;
+
+    /* Flash 2 wait state */
+    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
+    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;
+
+    /* HCLK = SYSCLK */
+    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
+
+    /* PCLK2 = HCLK */
+    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
+
+    /* PCLK1 = HCLK */
+    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
+
+#ifdef STM32F10X_CL
+    /* Configure PLLs ------------------------------------------------------*/
+    /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
+    /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */
+
+    RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
+                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
+    RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
+                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);
+
+    /* Enable PLL2 */
+    RCC->CR |= RCC_CR_PLL2ON;
+    /* Wait till PLL2 is ready */
+    while((RCC->CR & RCC_CR_PLL2RDY) == 0)
+    {
+    }
+
+
+    /* PLL configuration: PLLCLK = PREDIV1 * 7 = 56 MHz */
+    RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
+    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 |
+                            RCC_CFGR_PLLMULL7);
+#else
+    /* PLL configuration: PLLCLK = HSE * 7 = 56 MHz */
+    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));
+    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL7);
+
+#endif /* STM32F10X_CL */
+
+    /* Enable PLL */
+    RCC->CR |= RCC_CR_PLLON;
+
+    /* Wait till PLL is ready */
+    while((RCC->CR & RCC_CR_PLLRDY) == 0)
+    {
+    }
+
+    /* Select PLL as system clock source */
+    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
+    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;
+
+    /* Wait till PLL is used as system clock source */
+    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
+    {
+    }
+  }
+  else
+  { /* If HSE fails to start-up, the application will have wrong clock
+         configuration. User can add here some code to deal with this error */
+  }
+}
+
+#elif defined SYSCLK_FREQ_72MHz
+/**
+  * @brief  Sets System clock frequency to 72MHz and configure HCLK, PCLK2
+  *         and PCLK1 prescalers.
+  * @note   This function should be used only after reset.
+  * @param  None
+  * @retval None
+  */
+static void SetSysClockTo72(void)
+{
+  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
+
+  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/
+  /* Enable HSE */
+  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
+
+  /* Wait till HSE is ready and if Time out is reached exit */
+  do
+  {
+    HSEStatus = RCC->CR & RCC_CR_HSERDY;
+    StartUpCounter++;
+  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
+
+  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
+  {
+    HSEStatus = (uint32_t)0x01;
+  }
+  else
+  {
+    HSEStatus = (uint32_t)0x00;
+  }
+
+  if (HSEStatus == (uint32_t)0x01)
+  {
+    /* Enable Prefetch Buffer */
+    FLASH->ACR |= FLASH_ACR_PRFTBE;
+
+    /* Flash 2 wait state */
+    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
+    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;
+
+
+    /* HCLK = SYSCLK */
+    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
+
+    /* PCLK2 = HCLK */
+    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
+
+    /* PCLK1 = HCLK */
+    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
+
+#ifdef STM32F10X_CL
+    /* Configure PLLs ------------------------------------------------------*/
+    /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
+    /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */
+
+    RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
+                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
+    RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
+                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);
+
+    /* Enable PLL2 */
+    RCC->CR |= RCC_CR_PLL2ON;
+    /* Wait till PLL2 is ready */
+    while((RCC->CR & RCC_CR_PLL2RDY) == 0)
+    {
+    }
+
+
+    /* PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz */
+    RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
+    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 |
+                            RCC_CFGR_PLLMULL9);
+#else
+    /*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */
+    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |
+                                        RCC_CFGR_PLLMULL));
+    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);
+#endif /* STM32F10X_CL */
+
+    /* Enable PLL */
+    RCC->CR |= RCC_CR_PLLON;
+
+    /* Wait till PLL is ready */
+    while((RCC->CR & RCC_CR_PLLRDY) == 0)
+    {
+    }
+
+    /* Select PLL as system clock source */
+    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
+    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;
+
+    /* Wait till PLL is used as system clock source */
+    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
+    {
+    }
+  }
+  else
+  { /* If HSE fails to start-up, the application will have wrong clock
+         configuration. User can add here some code to deal with this error */
+  }
+}
+#endif
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/system_stm32f10x.h b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/system_stm32f10x.h
new file mode 100644
index 0000000..739f332
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/system_stm32f10x.h
@@ -0,0 +1,98 @@
+/**
+  ******************************************************************************
+  * @file    system_stm32f10x.h
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer System Header File.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/** @addtogroup CMSIS
+  * @{
+  */
+
+/** @addtogroup stm32f10x_system
+  * @{
+  */
+
+/**
+  * @brief Define to prevent recursive inclusion
+  */
+#ifndef __SYSTEM_STM32F10X_H
+#define __SYSTEM_STM32F10X_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/** @addtogroup STM32F10x_System_Includes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+
+/** @addtogroup STM32F10x_System_Exported_types
+  * @{
+  */
+
+extern uint32_t SystemCoreClock;          /*!< System Clock Frequency (Core Clock) */
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32F10x_System_Exported_Constants
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32F10x_System_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32F10x_System_Exported_Functions
+  * @{
+  */
+
+extern void SystemInit(void);
+extern void SystemCoreClockUpdate(void);
+/**
+  * @}
+  */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__SYSTEM_STM32F10X_H */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CMSIS debug support.htm b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CMSIS debug support.htm
new file mode 100644
index 0000000..efda685
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CMSIS debug support.htm
@@ -0,0 +1,243 @@
+<html>
+
+<head>
+<title>CMSIS Debug Support</title>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
+<meta name="GENERATOR" content="Microsoft FrontPage 6.0">
+<meta name="ProgId" content="FrontPage.Editor.Document">
+<style>
+<!--
+/*-----------------------------------------------------------
+Keil Software CHM Style Sheet
+-----------------------------------------------------------*/
+body         { color: #000000; background-color: #FFFFFF; font-size: 75%; font-family:
+               Verdana, Arial, 'Sans Serif' }
+a:link       { color: #0000FF; text-decoration: underline }
+a:visited    { color: #0000FF; text-decoration: underline }
+a:active     { color: #FF0000; text-decoration: underline }
+a:hover      { color: #FF0000; text-decoration: underline }
+h1           { font-family: Verdana; font-size: 18pt; color: #000080; font-weight: bold;
+               text-align: Center; margin-right: 3 }
+h2           { font-family: Verdana; font-size: 14pt; color: #000080; font-weight: bold;
+               background-color: #CCCCCC; margin-top: 24; margin-bottom: 3;
+               padding: 6 }
+h3           { font-family: Verdana; font-size: 10pt; font-weight: bold; background-color:
+               #CCCCCC; margin-top: 24; margin-bottom: 3; padding: 6 }
+pre          { font-family: Courier New; font-size: 10pt; background-color: #CCFFCC;
+               margin-left: 24; margin-right: 24 }
+ul           { list-style-type: square; margin-top: 6pt; margin-bottom: 0 }
+ol           { margin-top: 6pt; margin-bottom: 0 }
+li           { clear: both; margin-bottom: 6pt }
+table        { font-size: 100%; border-width: 0; padding: 0 }
+th           { color: #FFFFFF; background-color: #000080; text-align: left; vertical-align:
+               bottom; padding-right: 6pt }
+tr           { text-align: left; vertical-align: top }
+td           { text-align: left; vertical-align: top; padding-right: 6pt }
+.ToolT       { font-size: 8pt; color: #808080 }
+.TinyT       { font-size: 8pt; text-align: Center }
+code         { color: #000000; background-color: #E0E0E0; font-family: 'Courier New', Courier;
+               line-height: 120%; font-style: normal }
+/*-----------------------------------------------------------
+Notes
+-----------------------------------------------------------*/
+p.note       { font-weight: bold; clear: both; margin-bottom: 3pt; padding-top: 6pt }
+/*-----------------------------------------------------------
+Expanding/Contracting Divisions
+-----------------------------------------------------------*/
+#expand      { text-decoration: none; margin-bottom: 3pt }
+img.expand   { border-style: none; border-width: medium }
+div.expand   { display: none; margin-left: 9pt; margin-top: 0 }
+/*-----------------------------------------------------------
+Where List Tags
+-----------------------------------------------------------*/
+p.wh         { font-weight: bold; clear: both; margin-top: 6pt; margin-bottom: 3pt }
+table.wh     { width: 100% }
+td.whItem    { white-space: nowrap; font-style: italic; padding-right: 6pt; padding-bottom:
+               6pt }
+td.whDesc    { padding-bottom: 6pt }
+/*-----------------------------------------------------------
+Keil Table Tags
+-----------------------------------------------------------*/
+table.kt     { border: 1pt solid #000000 }
+th.kt        { white-space: nowrap; border-bottom: 1pt solid #000000; padding-left: 6pt;
+               padding-right: 6pt; padding-top: 4pt; padding-bottom: 4pt }
+tr.kt        {  }
+td.kt        { color: #000000; background-color: #E0E0E0; border-top: 1pt solid #A0A0A0;
+               padding-left: 6pt; padding-right: 6pt; padding-top: 2pt;
+               padding-bottom: 2pt }
+/*-----------------------------------------------------------
+-----------------------------------------------------------*/
+-->
+
+</style>
+</head>
+
+<body>
+
+<h1>CMSIS Debug Support</h1>
+
+<hr>
+
+<h2>Cortex-M3 ITM Debug Access</h2>
+<p>
+  The Cortex-M3 incorporates the Instrumented Trace Macrocell (ITM) that provides together with
+  the Serial Viewer Output trace capabilities for the microcontroller system. The ITM has
+  32 communication channels which are able to transmit 32 / 16 / 8 bit values; two ITM
+  communication channels are used by CMSIS to output the following information:
+</p>
+<ul>
+	<li>ITM Channel 0: used for printf-style output via the debug interface.</li>
+	<li>ITM Channel 31: is reserved for RTOS kernel awareness debugging.</li>
+</ul>
+
+<h2>Debug IN / OUT functions</h2>
+<p>CMSIS provides following debug functions:</p>
+<ul>
+	<li>ITM_SendChar (uses ITM channel 0)</li>
+	<li>ITM_ReceiveChar (uses global variable)</li>
+	<li>ITM_CheckChar (uses global variable)</li>
+</ul>
+
+<h3>ITM_SendChar</h3>
+<p>
+  <strong>ITM_SendChar</strong> is used to transmit a character over ITM channel 0 from
+  the microcontroller system to the debug system. <br>
+  Only a 8 bit value is transmitted.
+</p>
+<pre>
+static __INLINE uint32_t ITM_SendChar (uint32_t ch)
+{
+  /* check if debugger connected and ITM channel enabled for tracing */
+  if ((CoreDebug->DEMCR & CoreDebug_DEMCR_TRCENA)  &amp;&amp;
+      (ITM-&gt;TCR & ITM_TCR_ITMENA)                  &amp;&amp;
+      (ITM-&gt;TER & (1UL &lt;&lt; 0))  )
+  {
+    while (ITM-&gt;PORT[0].u32 == 0);
+    ITM-&gt;PORT[0].u8 = (uint8_t)ch;
+  }
+  return (ch);
+}</pre>
+
+<h3>ITM_ReceiveChar</h3>
+<p>
+  ITM communication channel is only capable for OUT direction. For IN direction
+  a globel variable is used. A simple mechansim detects if a character is received.
+  The project to test need to be build with debug information.
+</p>
+
+<p>
+  The globale variable <strong>ITM_RxBuffer</strong> is used to transmit a 8 bit value from debug system
+  to microcontroller system. <strong>ITM_RxBuffer</strong> is 32 bit wide to enshure a proper handshake.
+</p>
+<pre>
+extern volatile int ITM_RxBuffer;                    /* variable to receive characters                             */
+</pre>
+<p>
+  A dedicated bit pattern is used to determin if <strong>ITM_RxBuffer</strong> is empty
+  or contains a valid value.
+</p>
+<pre>
+#define             ITM_RXBUFFER_EMPTY    0x5AA55AA5 /* value identifying ITM_RxBuffer is ready for next character */
+</pre>
+<p>
+  <strong>ITM_ReceiveChar</strong> is used to receive a 8 bit value from the debug system. The function is nonblocking.
+  It returns the received character or '-1' if no character was available.
+</p>
+<pre>
+static __INLINE int ITM_ReceiveChar (void) {
+  int ch = -1;                               /* no character available */
+
+  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY) {
+    ch = ITM_RxBuffer;
+    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
+  }
+
+  return (ch);
+}
+</pre>
+
+<h3>ITM_CheckChar</h3>
+<p>
+  <strong>ITM_CheckChar</strong> is used to check if a character is received.
+</p>
+<pre>
+static __INLINE int ITM_CheckChar (void) {
+
+  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY) {
+    return (0);                                 /* no character available */
+  } else {
+    return (1);                                 /*    character available */
+  }
+}</pre>
+
+
+<h2>ITM Debug Support in uVision</h2>
+<p>
+  uVision uses in a debug session the <strong>Debug (printf) Viewer</strong> window to
+  display the debug data.
+</p>
+<p>Direction microcontroller system -&gt; uVision:</p>
+<ul>
+  <li>
+    Characters received via ITM communication channel 0 are written in a printf style
+    to <strong>Debug (printf) Viewer</strong> window.
+  </li>
+</ul>
+
+<p>Direction uVision -&gt; microcontroller system:</p>
+<ul>
+  <li>Check if <strong>ITM_RxBuffer</strong> variable is available (only performed once).</li>
+  <li>Read character from <strong>Debug (printf) Viewer</strong> window.</li>
+  <li>If <strong>ITM_RxBuffer</strong> empty write character to <strong>ITM_RxBuffer</strong>.</li>
+</ul>
+
+<p class="Note">Note</p>
+<ul>
+  <li><p>Current solution does not use a buffer machanism for trasmitting the characters.</p>
+  </li>
+</ul>
+
+<h2>RTX Kernel awareness in uVision</h2>
+<p>
+  uVision / RTX are using a simple and efficient solution for RTX Kernel awareness.
+  No format overhead is necessary.<br>
+  uVsion debugger decodes the RTX events via the 32 / 16 / 8 bit ITM write access
+  to ITM communication channel 31.
+</p>
+
+<p>Following RTX events are traced:</p>
+<ul>
+  <li>Task Create / Delete event
+    <ol>
+      <li>32 bit access. Task start address is transmitted</li>
+      <li>16 bit access. Task ID and Create/Delete flag are transmitted<br>
+          High byte holds Create/Delete flag, Low byte holds TASK ID.
+      </li>
+    </ol>
+  </li>
+  <li>Task switch event
+    <ol>
+      <li>8 bit access. Task ID of current task is transmitted</li>
+    </ol>
+  </li>
+</ul>
+
+<p class="Note">Note</p>
+<ul>
+  <li><p>Other RTOS information could be retrieved via memory read access in a polling mode manner.</p>
+  </li>
+</ul>
+
+
+<p class="MsoNormal"><span lang="EN-GB">&nbsp;</span></p>
+
+<hr>
+
+<p class="TinyT">Copyright  KEIL - An ARM Company.<br>
+All rights reserved.<br>
+Visit our web site at <a href="http://www.keil.com">www.keil.com</a>.
+</p>
+
+</body>
+
+</html>
\ No newline at end of file
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CMSIS_changes.htm b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CMSIS_changes.htm
new file mode 100644
index 0000000..162ffcc
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CMSIS_changes.htm
@@ -0,0 +1,320 @@
+<html>
+
+<head>
+<title>CMSIS Changes</title>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
+<meta name="GENERATOR" content="Microsoft FrontPage 6.0">
+<meta name="ProgId" content="FrontPage.Editor.Document">
+<style>
+<!--
+/*-----------------------------------------------------------
+Keil Software CHM Style Sheet
+-----------------------------------------------------------*/
+body         { color: #000000; background-color: #FFFFFF; font-size: 75%; font-family:
+               Verdana, Arial, 'Sans Serif' }
+a:link       { color: #0000FF; text-decoration: underline }
+a:visited    { color: #0000FF; text-decoration: underline }
+a:active     { color: #FF0000; text-decoration: underline }
+a:hover      { color: #FF0000; text-decoration: underline }
+h1           { font-family: Verdana; font-size: 18pt; color: #000080; font-weight: bold;
+               text-align: Center; margin-right: 3 }
+h2           { font-family: Verdana; font-size: 14pt; color: #000080; font-weight: bold;
+               background-color: #CCCCCC; margin-top: 24; margin-bottom: 3;
+               padding: 6 }
+h3           { font-family: Verdana; font-size: 10pt; font-weight: bold; background-color:
+               #CCCCCC; margin-top: 24; margin-bottom: 3; padding: 6 }
+pre          { font-family: Courier New; font-size: 10pt; background-color: #CCFFCC;
+               margin-left: 24; margin-right: 24 }
+ul           { list-style-type: square; margin-top: 6pt; margin-bottom: 0 }
+ol           { margin-top: 6pt; margin-bottom: 0 }
+li           { clear: both; margin-bottom: 6pt }
+table        { font-size: 100%; border-width: 0; padding: 0 }
+th           { color: #FFFFFF; background-color: #000080; text-align: left; vertical-align:
+               bottom; padding-right: 6pt }
+tr           { text-align: left; vertical-align: top }
+td           { text-align: left; vertical-align: top; padding-right: 6pt }
+.ToolT       { font-size: 8pt; color: #808080 }
+.TinyT       { font-size: 8pt; text-align: Center }
+code         { color: #000000; background-color: #E0E0E0; font-family: 'Courier New', Courier;
+               line-height: 120%; font-style: normal }
+/*-----------------------------------------------------------
+Notes
+-----------------------------------------------------------*/
+p.note       { font-weight: bold; clear: both; margin-bottom: 3pt; padding-top: 6pt }
+/*-----------------------------------------------------------
+Expanding/Contracting Divisions
+-----------------------------------------------------------*/
+#expand      { text-decoration: none; margin-bottom: 3pt }
+img.expand   { border-style: none; border-width: medium }
+div.expand   { display: none; margin-left: 9pt; margin-top: 0 }
+/*-----------------------------------------------------------
+Where List Tags
+-----------------------------------------------------------*/
+p.wh         { font-weight: bold; clear: both; margin-top: 6pt; margin-bottom: 3pt }
+table.wh     { width: 100% }
+td.whItem    { white-space: nowrap; font-style: italic; padding-right: 6pt; padding-bottom:
+               6pt }
+td.whDesc    { padding-bottom: 6pt }
+/*-----------------------------------------------------------
+Keil Table Tags
+-----------------------------------------------------------*/
+table.kt     { border: 1pt solid #000000 }
+th.kt        { white-space: nowrap; border-bottom: 1pt solid #000000; padding-left: 6pt;
+               padding-right: 6pt; padding-top: 4pt; padding-bottom: 4pt }
+tr.kt        {  }
+td.kt        { color: #000000; background-color: #E0E0E0; border-top: 1pt solid #A0A0A0;
+               padding-left: 6pt; padding-right: 6pt; padding-top: 2pt;
+               padding-bottom: 2pt }
+/*-----------------------------------------------------------
+-----------------------------------------------------------*/
+-->
+
+</style>
+</head>
+
+<body>
+
+<h1>Changes to CMSIS version V1.20</h1>
+
+<hr>
+
+<h2>1. Removed CMSIS Middelware packages</h2>
+<p>
+  CMSIS Middleware is on hold from ARM side until a agreement between all CMSIS partners is found.
+</p>
+
+<h2>2. SystemFrequency renamed to SystemCoreClock</h2>
+<p>
+  The variable name <strong>SystemCoreClock</strong> is more precise than <strong>SystemFrequency</strong>
+  because the variable holds the clock value at which the core is running.
+</p>
+
+<h2>3. Changed startup concept</h2>
+<p>
+  The old startup concept (calling SystemInit_ExtMemCtl from startup file and calling SystemInit
+  from main) has the weakness that it does not work for controllers which need a already
+  configuerd clock system to configure the external memory controller.
+</p>
+
+<h3>Changed startup concept</h3>
+<ul>
+  <li>
+    SystemInit() is called from startup file before <strong>premain</strong>.
+  </li>
+  <li>
+    <strong>SystemInit()</strong> configures the clock system and also configures
+    an existing external memory controller.
+  </li>
+  <li>
+    <strong>SystemInit()</strong> must not use global variables.
+  </li>
+  <li>
+    <strong>SystemCoreClock</strong> is initialized with a correct predefined value.
+  </li>
+  <li>
+    Additional function <strong>void SystemCoreClockUpdate (void)</strong> is provided.<br>
+   <strong>SystemCoreClockUpdate()</strong> updates the variable <strong>SystemCoreClock</strong>
+   and must be called whenever the core clock is changed.<br>
+   <strong>SystemCoreClockUpdate()</strong> evaluates the clock register settings and calculates
+   the current core clock.
+  </li>
+</ul>
+
+
+<h2>4. Advanced Debug Functions</h2>
+<p>
+  ITM communication channel is only capable for OUT direction. To allow also communication for
+  IN direction a simple concept is provided.
+</p>
+<ul>
+  <li>
+    Global variable <strong>volatile int ITM_RxBuffer</strong> used for IN data.
+  </li>
+  <li>
+    Function <strong>int ITM_CheckChar (void)</strong> checks if a new character is available.
+  </li>
+  <li>
+    Function <strong>int ITM_ReceiveChar (void)</strong> retrieves the new character.
+  </li>
+</ul>
+
+<p>
+  For detailed explanation see file <strong>CMSIS debug support.htm</strong>.
+</p>
+
+
+<h2>5. Core Register Bit Definitions</h2>
+<p>
+  Files core_cm3.h and core_cm0.h contain now bit definitions for Core Registers. The name for the
+  defines correspond with the Cortex-M Technical Reference Manual.
+</p>
+<p>
+  e.g. SysTick structure with bit definitions
+</p>
+<pre>
+/** @addtogroup CMSIS_CM3_SysTick CMSIS CM3 SysTick
+  memory mapped structure for SysTick
+  @{
+ */
+typedef struct
+{
+  __IO uint32_t CTRL;                         /*!< Offset: 0x00  SysTick Control and Status Register */
+  __IO uint32_t LOAD;                         /*!< Offset: 0x04  SysTick Reload Value Register       */
+  __IO uint32_t VAL;                          /*!< Offset: 0x08  SysTick Current Value Register      */
+  __I  uint32_t CALIB;                        /*!< Offset: 0x0C  SysTick Calibration Register        */
+} SysTick_Type;
+
+/* SysTick Control / Status Register Definitions */
+#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
+#define SysTick_CTRL_COUNTFLAG_Msk         (1ul << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
+
+#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
+#define SysTick_CTRL_CLKSOURCE_Msk         (1ul << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
+
+#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
+#define SysTick_CTRL_TICKINT_Msk           (1ul << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
+
+#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
+#define SysTick_CTRL_ENABLE_Msk            (1ul << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
+
+/* SysTick Reload Register Definitions */
+#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
+#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFul << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
+
+/* SysTick Current Register Definitions */
+#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
+#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFul << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
+
+/* SysTick Calibration Register Definitions */
+#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
+#define SysTick_CALIB_NOREF_Msk            (1ul << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
+
+#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
+#define SysTick_CALIB_SKEW_Msk             (1ul << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
+
+#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
+#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFul << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
+/*@}*/ /* end of group CMSIS_CM3_SysTick */</pre>
+
+<h2>7. DoxyGen Tags</h2>
+<p>
+  DoxyGen tags in files core_cm3.[c,h] and core_cm0.[c,h] are reworked to create proper documentation
+  using DoxyGen.
+</p>
+
+<h2>8. Folder Structure</h2>
+<p>
+  The folder structure is changed to differentiate the single support packages.
+</p>
+
+  <ul>
+    <li>CM0</li>
+    <li>CM3
+       <ul>
+         <li>CoreSupport</li>
+         <li>DeviceSupport</li>
+           <ul>
+             <li>Vendor
+               <ul>
+                 <li>Device
+                   <ul>
+                      <li>Startup
+                        <ul>
+                          <li>Toolchain</li>
+                          <li>Toolchain</li>
+                          <li>...</li>
+                        </ul>
+                      </li>
+                   </ul>
+                 </li>
+                 <li>Device</li>
+                 <li>...</li>
+               </ul>
+             </li>
+             <li>Vendor</li>
+             <li>...</li>
+           </ul>
+         </li>
+         <li>Example
+           <ul>
+             <li>Toolchain
+               <ul>
+                 <li>Device</li>
+                 <li>Device</li>
+                 <li>...</li>
+               </ul>
+             </li>
+             <li>Toolchain</li>
+             <li>...</li>
+           </ul>
+         </li>
+       </ul>
+    </li>
+
+    <li>Documentation</li>
+  </ul>
+
+<h2>9. Open Points</h2>
+<p>
+  Following points need to be clarified and solved:
+</p>
+<ul>
+  <li>
+    <p>
+      Equivalent C and Assembler startup files.
+    </p>
+    <p>
+      Is there a need for having C startup files although assembler startup files are
+      very efficient and do not need to be changed?
+    <p/>
+  </li>
+  <li>
+    <p>
+      Placing of HEAP in external RAM.
+    </p>
+    <p>
+      It must be possible to place HEAP in external RAM if the device supports an
+      external memory controller.
+    </p>
+  </li>
+  <li>
+    <p>
+      Placing of STACK /HEAP.
+    </p>
+    <p>
+      STACK should always be placed at the end of internal RAM.
+    </p>
+    <p>
+      If HEAP is placed in internal RAM than it should be placed after RW ZI section.
+    </p>
+  </li>
+  <li>
+    <p>
+      Removing core_cm3.c and core_cm0.c.
+    </p>
+    <p>
+      On a long term the functions in core_cm3.c and core_cm0.c must be replaced with
+      appropriate compiler intrinsics.
+    </p>
+  </li>
+</ul>
+
+
+<h2>10. Limitations</h2>
+<p>
+  The following limitations are not covered with the current CMSIS version:
+</p>
+<ul>
+ <li>
+  No <strong>C startup files</strong> for ARM toolchain are provided.
+ </li>
+ <li>
+  No <strong>C startup files</strong> for GNU toolchain are provided.
+ </li>
+ <li>
+  No <strong>C startup files</strong> for IAR toolchain are provided.
+ </li>
+ <li>
+  No <strong>Tasking</strong> projects are provided yet.
+ </li>
+</ul>
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/Documentation/CMSIS_Core.htm b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/Documentation/CMSIS_Core.htm
new file mode 100644
index 0000000..6fd131e
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/Documentation/CMSIS_Core.htm
@@ -0,0 +1,1337 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html xmlns:p="urn:schemas-microsoft-com:office:powerpoint" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office"><head>
+
+  <title>CMSIS: Cortex Microcontroller Software Interface Standard</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
+  <meta name="ProgId" content="FrontPage.Editor.Document">
+  <style>
+<!--
+/*-----------------------------------------------------------Keil Software CHM Style Sheet
+-----------------------------------------------------------*/
+body { color: #000000; background-color: #FFFFFF; font-size: 75%; font-family: Verdana, Arial, 'Sans Serif' }
+a:link { color: #0000FF; text-decoration: underline }
+a:visited { color: #0000FF; text-decoration: underline }
+a:active { color: #FF0000; text-decoration: underline }
+a:hover { color: #FF0000; text-decoration: underline }
+h1 { font-family: Verdana; font-size: 18pt; color: #000080; font-weight: bold; text-align: Center; margin-right: 3 }
+h2 { font-family: Verdana; font-size: 14pt; color: #000080; font-weight: bold; background-color: #CCCCCC; margin-top: 24; margin-bottom: 3; padding: 6 }
+h3 { font-family: Verdana; font-size: 10pt; font-weight: bold; background-color: #CCCCCC; margin-top: 24; margin-bottom: 3; padding: 6 }
+pre { font-family: Courier New; font-size: 10pt; background-color: #CCFFCC; margin-left: 24; margin-right: 24 }
+ul { list-style-type: square; margin-top: 6pt; margin-bottom: 0 }
+ol { margin-top: 6pt; margin-bottom: 0 }
+li { clear: both; margin-bottom: 6pt }
+table { font-size: 100%; border-width: 0; padding: 0 }
+th { color: #FFFFFF; background-color: #000080; text-align: left; vertical-align: bottom; padding-right: 6pt }
+tr { text-align: left; vertical-align: top }
+td { text-align: left; vertical-align: top; padding-right: 6pt }
+.ToolT { font-size: 8pt; color: #808080 }
+.TinyT { font-size: 8pt; text-align: Center }
+code { color: #000000; background-color: #E0E0E0; font-family: 'Courier New', Courier; line-height: 120%; font-style: normal }
+/*-----------------------------------------------------------Notes
+-----------------------------------------------------------*/
+p.note { font-weight: bold; clear: both; margin-bottom: 3pt; padding-top: 6pt }
+/*-----------------------------------------------------------Expanding/Contracting Divisions
+-----------------------------------------------------------*/
+#expand { text-decoration: none; margin-bottom: 3pt }
+img.expand { border-style: none; border-width: medium }
+div.expand { display: none; margin-left: 9pt; margin-top: 0 }
+/*-----------------------------------------------------------Where List Tags
+-----------------------------------------------------------*/
+p.wh { font-weight: bold; clear: both; margin-top: 6pt; margin-bottom: 3pt }
+table.wh { width: 100% }
+td.whItem { white-space: nowrap; font-style: italic; padding-right: 6pt; padding-bottom: 6pt }
+td.whDesc { padding-bottom: 6pt }
+/*-----------------------------------------------------------Keil Table Tags
+-----------------------------------------------------------*/
+table.kt { width: 100%; border: 1pt solid #000000 }
+th.kt { white-space: nowrap; border-bottom: 1pt solid #000000; padding-left: 6pt; padding-right: 6pt; padding-top: 4pt; padding-bottom: 4pt }
+tr.kt { }
+td.kt { color: #000000; background-color: #E0E0E0; border-top: 1pt solid #A0A0A0; padding-left: 6pt; padding-right: 6pt; padding-top: 2pt; padding-bottom: 2pt }
+/*----------------------------------------------------------------------------------------------------------------------*/
+    .style1 {
+	background-color: #E0E0E0;
+}
+.O
+	{color:#1D315B;
+	font-size:149%;}
+    -->
+  </style></head>
+<body>
+<h1>Cortex Microcontroller Software Interface Standard</h1>
+
+<p align="center">This file describes the Cortex Microcontroller Software Interface Standard (CMSIS).</p>
+<p align="center">Version: 1.30 - 30. October 2009</p>
+
+<p class="TinyT">Information in this file, the accompany manuals, and software is<br>
+                 Copyright  ARM Ltd.<br>All rights reserved.
+</p>
+
+<hr>
+
+<p><span style="FONT-WEIGHT: bold">Revision History</span></p>
+<ul>
+	<li>Version 1.00: initial release. </li>
+	<li>Version 1.01: added __LDREX<em>x</em>, __STREX<em>x</em>, and __CLREX.</li>
+	<li>Version 1.02: added Cortex-M0. </li>
+	<li>Version 1.10: second review. </li>
+	<li>Version 1.20: third review. </li>
+	<li>Version 1.30 PRE-RELEASE: reworked Startup Concept, additional Debug Functionality.</li>
+	<li>Version 1.30 2nd PRE-RELEASE: changed folder structure, added doxyGen comments, added Bit definitions.</li>
+	<li>Version 1.30: updated Device Support Packages.</li>
+</ul>
+
+<hr>
+
+<h2>Contents</h2>
+
+<ol>
+  <li class="LI2"><a href="#1">About</a></li>
+  <li class="LI2"><a href="#2">Coding Rules and Conventions</a></li>
+  <li class="LI2"><a href="#3">CMSIS Files</a></li>
+  <li class="LI2"><a href="#4">Core Peripheral Access Layer</a></li>
+  <li class="LI2"><a href="#5">CMSIS Example</a></li>
+</ol>
+
+<h2><a name="1"></a>About</h2>
+
+<p>
+  The <strong>Cortex Microcontroller Software Interface Standard (CMSIS)</strong> answers the challenges
+  that are faced when software components are deployed to physical microcontroller devices based on a
+  Cortex-M0 or Cortex-M3 processor. The CMSIS will be also expanded to future Cortex-M
+  processor cores (the term Cortex-M is used to indicate that). The CMSIS is defined in close co-operation
+  with various silicon and software vendors and provides a common approach to interface to peripherals,
+  real-time operating systems, and middleware components.
+</p>
+
+<p>ARM provides as part of the CMSIS the following software layers that are
+available for various compiler implementations:</p>
+<ul>
+  <li><strong>Core Peripheral Access Layer</strong>: contains name definitions,
+    address definitions and helper functions to
+    access core registers and peripherals. It defines also a device
+    independent interface for RTOS Kernels that includes debug channel
+    definitions.</li>
+</ul>
+
+<p>These software layers are expanded by Silicon partners with:</p>
+<ul>
+  <li><strong>Device Peripheral Access Layer</strong>: provides definitions
+    for all device peripherals</li>
+  <li><strong>Access Functions for Peripherals (optional)</strong>: provides
+    additional helper functions for peripherals</li>
+</ul>
+
+<p>CMSIS defines for a Cortex-M Microcontroller System:</p>
+<ul>
+  <li style="text-align: left;">A common way to access peripheral registers
+    and a common way to define exception vectors.</li>
+  <li style="text-align: left;">The register names of the <strong>Core
+    Peripherals</strong> and<strong> </strong>the names of the <strong>Core
+    Exception Vectors</strong>.</li>
+  <li>An device independent interface for RTOS Kernels including a debug
+    channel.</li>
+</ul>
+
+<p>
+  By using CMSIS compliant software components, the user can easier re-use template code.
+  CMSIS is intended to enable the combination of software components from multiple middleware vendors.
+</p>
+
+<h2><a name="2"></a>Coding Rules and Conventions</h2>
+
+<p>
+  The following section describes the coding rules and conventions used in the CMSIS
+  implementation. It contains also information about data types and version number information.
+</p>
+
+<h3>Essentials</h3>
+<ul>
+  <li>The CMSIS C code conforms to MISRA 2004 rules. In case of MISRA violations,
+      there are disable and enable sequences for PC-LINT inserted.</li>
+  <li>ANSI standard data types defined in the ANSI C header file
+    <strong>&lt;stdint.h&gt;</strong> are used.</li>
+  <li>#define constants that include expressions must be enclosed by
+    parenthesis.</li>
+  <li>Variables and parameters have a complete data type.</li>
+  <li>All functions in the <strong>Core Peripheral Access Layer</strong> are
+    re-entrant.</li>
+  <li>The <strong>Core Peripheral Access Layer</strong> has no blocking code
+    (which means that wait/query loops are done at other software layers).</li>
+  <li>For each exception/interrupt there is definition for:
+  <ul>
+    <li>an exception/interrupt handler with the postfix <strong>_Handler </strong>
+	(for exceptions) or <strong>_IRQHandler</strong> (for interrupts).</li>
+    <li>a default exception/interrupt handler (weak definition) that contains an endless loop.</li>
+    <li>a #define of the interrupt number with the postfix <strong>_IRQn</strong>.</li>
+  </ul></li>
+</ul>
+
+<h3>Recommendations</h3>
+
+<p>The CMSIS recommends the following conventions for identifiers.</p>
+<ul>
+  <li><strong>CAPITAL</strong> names to identify Core Registers, Peripheral Registers, and CPU Instructions.</li>
+  <li><strong>CamelCase</strong> names to identify peripherals access functions and interrupts.</li>
+  <li><strong>PERIPHERAL_</strong> prefix to identify functions that belong to specify peripherals.</li>
+  <li><strong>Doxygen</strong> comments for all functions are included as described under <strong>Function Comments</strong> below.</li>
+</ul>
+
+<b>Comments</b>
+
+<ul>
+  <li>Comments use the ANSI C90 style (<em>/* comment */</em>) or C++ style
+  (<em>// comment</em>). It is assumed that the programming tools support today
+	consistently the C++ comment style.</li>
+  <li><strong>Function Comments</strong> provide for each function the following information:
+  <ul>
+    <li>one-line brief function overview.</li>
+    <li>detailed parameter explanation.</li>
+    <li>detailed information about return values.</li>
+    <li>detailed description of the actual function.</li>
+  </ul>
+  <p><b>Doxygen Example:</b></p>
+  <pre>
+/**
+ * @brief  Enable Interrupt in NVIC Interrupt Controller
+ * @param  IRQn  interrupt number that specifies the interrupt
+ * @return none.
+ * Enable the specified interrupt in the NVIC Interrupt Controller.
+ * Other settings of the interrupt such as priority are not affected.
+ */</pre>
+  </li>
+</ul>
+
+<h3>Data Types and IO Type Qualifiers</h3>
+
+<p>
+  The <strong>Cortex-M HAL</strong> uses the standard types from the standard ANSI C header file
+  <strong>&lt;stdint.h&gt;</strong>. <strong>IO Type Qualifiers</strong> are used to specify the access
+  to peripheral variables. IO Type Qualifiers are indented to be used for automatic generation of
+  debug information of peripheral registers.
+</p>
+
+<table class="kt" border="0" cellpadding="0" cellspacing="0">
+  <tbody>
+    <tr>
+      <th class="kt" nowrap="nowrap">IO Type Qualifier</th>
+      <th class="kt">#define</th>
+      <th class="kt">Description</th>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">__I</td>
+      <td class="kt">volatile const</td>
+      <td class="kt">Read access only</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">__O</td>
+      <td class="kt">volatile</td>
+      <td class="kt">Write access only</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">__IO</td>
+      <td class="kt">volatile</td>
+      <td class="kt">Read and write access</td>
+    </tr>
+  </tbody>
+</table>
+
+<h3>CMSIS Version Number</h3>
+<p>
+  File <strong>core_cm3.h</strong> contains the version number of the CMSIS with the following define:
+</p>
+
+<pre>
+#define __CM3_CMSIS_VERSION_MAIN  (0x01)      /* [31:16] main version       */
+#define __CM3_CMSIS_VERSION_SUB   (0x30)      /* [15:0]  sub version        */
+#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN &lt;&lt; 16) | __CM3_CMSIS_VERSION_SUB)</pre>
+
+<p>
+  File <strong>core_cm0.h</strong> contains the version number of the CMSIS with the following define:
+</p>
+
+<pre>
+#define __CM0_CMSIS_VERSION_MAIN  (0x01)      /* [31:16] main version       */
+#define __CM0_CMSIS_VERSION_SUB   (0x30)      /* [15:0]  sub version        */
+#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN &lt;&lt; 16) | __CM0_CMSIS_VERSION_SUB)</pre>
+
+
+<h3>CMSIS Cortex Core</h3>
+<p>
+  File <strong>core_cm3.h</strong> contains the type of the CMSIS Cortex-M with the following define:
+</p>
+
+<pre>
+#define __CORTEX_M                (0x03)</pre>
+
+<p>
+  File <strong>core_cm0.h</strong> contains the type of the CMSIS Cortex-M with the following define:
+</p>
+
+<pre>
+#define __CORTEX_M                (0x00)</pre>
+
+
+<h2><a name="3"></a>CMSIS Files</h2>
+<p>
+  This section describes the Files provided in context with the CMSIS to access the Cortex-M
+  hardware and peripherals.
+</p>
+
+<table class="kt" border="0" cellpadding="0" cellspacing="0">
+  <tbody>
+    <tr>
+      <th class="kt" nowrap="nowrap">File</th>
+      <th class="kt">Provider</th>
+      <th class="kt">Description</th>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap"><i>device.h</i></td>
+      <td class="kt">Device specific (provided by silicon partner)</td>
+      <td class="kt">Defines the peripherals for the actual device. The file may use
+        several other include files to define the peripherals of the actual device.</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">core_cm0.h</td>
+      <td class="kt">ARM (for RealView ARMCC, IAR, and GNU GCC)</td>
+      <td class="kt">Defines the core peripherals for the Cortex-M0 CPU and core peripherals.</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">core_cm3.h</td>
+      <td class="kt">ARM (for RealView ARMCC, IAR, and GNU GCC)</td>
+      <td class="kt">Defines the core peripherals for the Cortex-M3 CPU and core peripherals.</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">core_cm0.c</td>
+      <td class="kt">ARM (for RealView ARMCC, IAR, and GNU GCC)</td>
+      <td class="kt">Provides helper functions that access core registers.</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">core_cm3.c</td>
+      <td class="kt">ARM (for RealView ARMCC, IAR, and GNU GCC)</td>
+      <td class="kt">Provides helper functions that access core registers.</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">startup<i>_device</i></td>
+      <td class="kt">ARM (adapted by compiler partner / silicon partner)</td>
+      <td class="kt">Provides the Cortex-M startup code and the complete (device specific) Interrupt Vector Table</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">system<i>_device</i></td>
+      <td class="kt">ARM (adapted by silicon partner)</td>
+      <td class="kt">Provides a device specific configuration file for the device. It configures the device initializes
+        typically the oscillator (PLL) that is part of the microcontroller device</td>
+    </tr>
+  </tbody>
+</table>
+
+<h3><em>device.h</em></h3>
+
+<p>
+  The file <em><strong>device.h</strong></em> is provided by the silicon vendor and is the
+  <u><strong>central include file</strong></u> that the application programmer is using in
+  the C source code. This file contains:
+</p>
+<ul>
+  <li>
+	<p><strong>Interrupt Number Definition</strong>: provides interrupt numbers
+	(IRQn) for all core and device specific exceptions and interrupts.</p>
+	</li>
+	<li>
+	<p><strong>Configuration for core_cm0.h / core_cm3.h</strong>: reflects the
+	actual configuration of the Cortex-M processor that is part of the actual
+	device. As such the file <strong>core_cm0.h / core_cm3.h</strong> is included that
+	implements access to processor registers and core peripherals. </p>
+	</li>
+	<li>
+	<p><strong>Device Peripheral Access Layer</strong>: provides definitions
+    for all device peripherals. It contains all data structures and the address
+	mapping for the device specific peripherals. </p>
+	</li>
+  <li><strong>Access Functions for Peripherals (optional)</strong>: provides
+    additional helper functions for peripherals that are useful for programming
+	of these peripherals. Access Functions may be provided as inline functions
+	or can be extern references to a device specific library provided by the
+	silicon vendor.</li>
+</ul>
+
+
+<h4><strong>Interrupt Number Definition</strong></h4>
+
+<p>To access the device specific interrupts the device.h file defines IRQn
+numbers for the complete device using a enum typedef as shown below:</p>
+<pre>
+typedef enum IRQn
+{
+/******  Cortex-M3 Processor Exceptions/Interrupt Numbers ************************************************/
+  NonMaskableInt_IRQn             = -14,      /*!&lt; 2 Non Maskable Interrupt                              */
+  HardFault_IRQn                  = -13,      /*!&lt; 3 Cortex-M3 Hard Fault Interrupt                      */
+  MemoryManagement_IRQn           = -12,      /*!&lt; 4 Cortex-M3 Memory Management Interrupt               */
+  BusFault_IRQn                   = -11,      /*!&lt; 5 Cortex-M3 Bus Fault Interrupt                       */
+  UsageFault_IRQn                 = -10,      /*!&lt; 6 Cortex-M3 Usage Fault Interrupt                     */
+  SVCall_IRQn                     = -5,       /*!&lt; 11 Cortex-M3 SV Call Interrupt                        */
+  DebugMonitor_IRQn               = -4,       /*!&lt; 12 Cortex-M3 Debug Monitor Interrupt                  */
+  PendSV_IRQn                     = -2,       /*!&lt; 14 Cortex-M3 Pend SV Interrupt                        */
+  SysTick_IRQn                    = -1,       /*!&lt; 15 Cortex-M3 System Tick Interrupt                    */
+/******  STM32 specific Interrupt Numbers ****************************************************************/
+  WWDG_STM_IRQn                   = 0,        /*!&lt; Window WatchDog Interrupt                             */
+  PVD_STM_IRQn                    = 1,        /*!&lt; PVD through EXTI Line detection Interrupt             */
+  :
+  :
+  } IRQn_Type;</pre>
+
+
+<h4>Configuration for core_cm0.h / core_cm3.h</h4>
+<p>
+  The Cortex-M core configuration options which are defined for each device implementation. Some
+  configuration options are reflected in the CMSIS layer using the #define settings described below.
+</p>
+<p>
+  To access core peripherals file <em><strong>device.h</strong></em> includes file <b>core_cm0.h / core_cm3.h</b>.
+  Several features in <strong>core_cm0.h / core_cm3.h</strong> are configured by the following defines that must be
+  defined before <strong>#include &lt;core_cm0.h&gt;</strong> / <strong>#include &lt;core_cm3.h&gt;</strong>
+  preprocessor command.
+</p>
+
+<table class="kt" border="0" cellpadding="0" cellspacing="0">
+  <tbody>
+    <tr>
+      <th class="kt" nowrap="nowrap">#define</th>
+      <th class="kt" nowrap="nowrap">File</th>
+      <th class="kt" nowrap="nowrap">Value</th>
+      <th class="kt">Description</th>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">__NVIC_PRIO_BITS</td>
+      <td class="kt">core_cm0.h</td>
+      <td class="kt" nowrap="nowrap">(2)</td>
+      <td class="kt">Number of priority bits implemented in the NVIC (device specific)</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">__NVIC_PRIO_BITS</td>
+      <td class="kt">core_cm3.h</td>
+      <td class="kt" nowrap="nowrap">(2 ... 8)</td>
+      <td class="kt">Number of priority bits implemented in the NVIC (device specific)</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">__MPU_PRESENT</td>
+      <td class="kt">core_cm0.h, core_cm3.h</td>
+      <td class="kt" nowrap="nowrap">(0, 1)</td>
+      <td class="kt">Defines if an MPU is present or not</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">__Vendor_SysTickConfig</td>
+      <td class="kt">core_cm0.h, core_cm3.h</td>
+      <td class="kt" nowrap="nowrap">(1)</td>
+      <td class="kt">When this define is setup to 1, the <strong>SysTickConfig</strong> function
+		in <strong>core_cm3.h</strong> is excluded. In this case the <em><strong>device.h</strong></em>
+		file must contain a vendor specific implementation of this function.</td>
+    </tr>
+  </tbody>
+</table>
+
+
+<h4>Device Peripheral Access Layer</h4>
+<p>
+  Each peripheral uses a prefix which consists of <strong>&lt;device abbreviation&gt;_</strong>
+  and <strong>&lt;peripheral name&gt;_</strong> to identify peripheral registers that access this
+  specific peripheral. The intention of this is to avoid name collisions caused
+  due to short names. If more than one peripheral of the same type exists,
+  identifiers have a postfix (digit or letter). For example:
+</p>
+<ul>
+	<li>&lt;device abbreviation&gt;_UART_Type: defines the generic register layout for all UART channels in a device.
+      <pre>
+typedef struct
+{
+  union {
+  __I  uint8_t  RBR;                     /*!< Offset: 0x000   Receiver Buffer Register    */
+  __O  uint8_t  THR;                     /*!< Offset: 0x000   Transmit Holding Register   */
+  __IO uint8_t  DLL;                     /*!< Offset: 0x000   Divisor Latch LSB           */
+       uint32_t RESERVED0;
+  };
+  union {
+  __IO uint8_t  DLM;                     /*!< Offset: 0x004   Divisor Latch MSB           */
+  __IO uint32_t IER;                     /*!< Offset: 0x004   Interrupt Enable Register   */
+  };
+  union {
+  __I  uint32_t IIR;                     /*!< Offset: 0x008   Interrupt ID Register       */
+  __O  uint8_t  FCR;                     /*!< Offset: 0x008   FIFO Control Register       */
+  };
+  __IO uint8_t  LCR;                     /*!< Offset: 0x00C   Line Control Register       */
+       uint8_t  RESERVED1[7];
+  __I  uint8_t  LSR;                     /*!< Offset: 0x014   Line Status Register        */
+       uint8_t  RESERVED2[7];
+  __IO uint8_t  SCR;                     /*!< Offset: 0x01C   Scratch Pad Register        */
+       uint8_t  RESERVED3[3];
+  __IO uint32_t ACR;                     /*!< Offset: 0x020   Autobaud Control Register   */
+  __IO uint8_t  ICR;                     /*!< Offset: 0x024   IrDA Control Register       */
+       uint8_t  RESERVED4[3];
+  __IO uint8_t  FDR;                     /*!< Offset: 0x028   Fractional Divider Register */
+       uint8_t  RESERVED5[7];
+  __IO uint8_t  TER;                     /*!< Offset: 0x030   Transmit Enable Register    */
+       uint8_t  RESERVED6[39];
+  __I  uint8_t  FIFOLVL;                 /*!< Offset: 0x058   FIFO Level Register         */
+} LPC_UART_TypeDef;</pre>
+  </li>
+	<li>&lt;device abbreviation&gt;_UART1: is a pointer to a register structure that refers to a specific UART.
+      For example UART1-&gt;DR is the data register of UART1.
+      <pre>
+#define LPC_UART2             ((LPC_UART_TypeDef      *) LPC_UART2_BASE    )
+#define LPC_UART3             ((LPC_UART_TypeDef      *) LPC_UART3_BASE    )</pre>
+  </li>
+</ul>
+
+<h5>Minimal Requiements</h5>
+<p>
+  To access the peripheral registers and related function in a device the files <strong><em>device.h</em></strong>
+  and <strong>core_cm0.h</strong> / <strong>core_cm3.h</strong> defines as a minimum:
+</p>
+<ul>
+  <li>The <strong>Register Layout Typedef</strong> for each peripheral that defines all register names.
+      Names that start with RESERVE are used to introduce space into the structure to adjust the addresses of
+      the peripheral registers. For example:
+      <pre>
+typedef struct {
+  __IO uint32_t CTRL;      /* SysTick Control and Status Register */
+  __IO uint32_t LOAD;      /* SysTick Reload Value Register       */
+  __IO uint32_t VAL;       /* SysTick Current Value Register      */
+  __I  uint32_t CALIB;     /* SysTick Calibration Register        */
+  } SysTick_Type;</pre>
+  </li>
+
+  <li>
+    <strong>Base Address</strong> for each peripheral (in case of multiple peripherals
+    that use the same <strong>register layout typedef</strong> multiple base addresses are defined). For example:
+    <pre>
+#define SysTick_BASE (SCS_BASE + 0x0010)            /* SysTick Base Address */</pre>
+  </li>
+
+  <li>
+    <strong>Access Definition</strong> for each peripheral (in case of multiple peripherals that use
+    the same <strong>register layout typedef</strong> multiple access definitions exist, i.e. LPC_UART0,
+    LPC_UART2). For Example:
+    <pre>
+#define SysTick ((SysTick_Type *) SysTick_BASE)     /* SysTick access definition */</pre>
+  </li>
+</ul>
+
+<p>
+  These definitions allow to access the peripheral registers from user code with simple assignments like:
+</p>
+<pre>SysTick-&gt;CTRL = 0;</pre>
+
+<h5>Optional Features</h5>
+<p>In addition the <em> <strong>device.h </strong></em>file may define:</p>
+<ul>
+	<li>
+    #define constants that simplify access to the peripheral registers.
+	  These constant define bit-positions or other specific patterns are that required for the
+    programming of the peripheral registers. The identifiers used start with
+    <strong>&lt;device abbreviation&gt;_</strong> and <strong>&lt;peripheral name&gt;_</strong>.
+    It is recommended to use CAPITAL letters for such #define constants.
+  </li>
+	<li>
+    Functions that perform more complex functions with the peripheral (i.e. status query before
+    a sending register is accessed). Again these function start with
+    <strong>&lt;device abbreviation&gt;_</strong> and <strong>&lt;peripheral name&gt;_</strong>.
+  </li>
+</ul>
+
+<h3>core_cm0.h and core_cm0.c</h3>
+<p>
+  File <b>core_cm0.h</b> describes the data structures for the Cortex-M0 core peripherals and does
+  the address mapping of this structures. It also provides basic access to the Cortex-M0 core registers
+  and core peripherals with efficient functions (defined as <strong>static inline</strong>).
+</p>
+<p>
+  File <b>core_cm0.c</b> defines several helper functions that access processor registers.
+</p>
+<p>Together these files implement the <a href="#4">Core Peripheral Access Layer</a> for a Cortex-M0.</p>
+
+<h3>core_cm3.h and core_cm3.c</h3>
+<p>
+  File <b>core_cm3.h</b> describes the data structures for the Cortex-M3 core peripherals and does
+  the address mapping of this structures. It also provides basic access to the Cortex-M3 core registers
+  and core peripherals with efficient functions (defined as <strong>static inline</strong>).
+</p>
+<p>
+  File <b>core_cm3.c</b> defines several helper functions that access processor registers.
+</p>
+<p>Together these files implement the <a href="#4">Core Peripheral Access Layer</a> for a Cortex-M3.</p>
+
+<h3>startup_<em>device</em></h3>
+<p>
+  A template file for <strong>startup_<em>device</em></strong> is provided by ARM for each supported
+  compiler. It is adapted by the silicon vendor to include interrupt vectors for all device specific
+  interrupt handlers. Each interrupt handler is defined as <strong><em>weak</em></strong> function
+  to an dummy handler. Therefore the interrupt handler can be directly used in application software
+  without any requirements to adapt the <strong>startup_<em>device</em></strong> file.
+</p>
+<p>
+  The following exception names are fixed and define the start of the vector table for a Cortex-M0:
+</p>
+<pre>
+__Vectors       DCD     __initial_sp              ; Top of Stack
+                DCD     Reset_Handler             ; Reset Handler
+                DCD     NMI_Handler               ; NMI Handler
+                DCD     HardFault_Handler         ; Hard Fault Handler
+                DCD     0                         ; Reserved
+                DCD     0                         ; Reserved
+                DCD     0                         ; Reserved
+                DCD     0                         ; Reserved
+                DCD     0                         ; Reserved
+                DCD     0                         ; Reserved
+                DCD     0                         ; Reserved
+                DCD     SVC_Handler               ; SVCall Handler
+                DCD     0                         ; Reserved
+                DCD     0                         ; Reserved
+                DCD     PendSV_Handler            ; PendSV Handler
+                DCD     SysTick_Handler           ; SysTick Handler</pre>
+
+<p>
+  The following exception names are fixed and define the start of the vector table for a Cortex-M3:
+</p>
+<pre>
+__Vectors       DCD     __initial_sp              ; Top of Stack
+                DCD     Reset_Handler             ; Reset Handler
+                DCD     NMI_Handler               ; NMI Handler
+                DCD     HardFault_Handler         ; Hard Fault Handler
+                DCD     MemManage_Handler         ; MPU Fault Handler
+                DCD     BusFault_Handler          ; Bus Fault Handler
+                DCD     UsageFault_Handler        ; Usage Fault Handler
+                DCD     0                         ; Reserved
+                DCD     0                         ; Reserved
+                DCD     0                         ; Reserved
+                DCD     0                         ; Reserved
+                DCD     SVC_Handler               ; SVCall Handler
+                DCD     DebugMon_Handler          ; Debug Monitor Handler
+                DCD     0                         ; Reserved
+                DCD     PendSV_Handler            ; PendSV Handler
+                DCD     SysTick_Handler           ; SysTick Handler</pre>
+
+<p>
+  In the following examples for device specific interrupts are shown:
+</p>
+<pre>
+; External Interrupts
+                DCD     WWDG_IRQHandler           ; Window Watchdog
+                DCD     PVD_IRQHandler            ; PVD through EXTI Line detect
+                DCD     TAMPER_IRQHandler         ; Tamper</pre>
+
+<p>
+  Device specific interrupts must have a dummy function that can be overwritten in user code.
+  Below is an example for this dummy function.
+</p>
+<pre>
+Default_Handler PROC
+                EXPORT WWDG_IRQHandler   [WEAK]
+                EXPORT PVD_IRQHandler    [WEAK]
+                EXPORT TAMPER_IRQHandler [WEAK]
+                :
+                :
+                WWDG_IRQHandler
+                PVD_IRQHandler
+                TAMPER_IRQHandler
+                :
+                :
+                B .
+                ENDP</pre>
+
+<p>
+  The user application may simply define an interrupt handler function by using the handler name
+  as shown below.
+</p>
+<pre>
+void WWDG_IRQHandler(void)
+{
+  :
+  :
+}</pre>
+
+
+<h3><a name="4"></a>system_<em>device</em>.c</h3>
+<p>
+  A template file for <strong>system_<em>device</em>.c</strong> is provided by ARM but adapted by
+  the silicon vendor to match their actual device. As a <strong>minimum requirement</strong>
+  this file must provide a device specific system configuration function and a global variable
+  that contains the system frequency. It configures the device and initializes typically the
+  oscillator (PLL) that is part of the microcontroller device.
+</p>
+<p>
+  The file <strong>system_</strong><em><strong>device</strong></em><strong>.c</strong> must provide
+  as a minimum requirement the SystemInit function as shown below.
+</p>
+
+<table class="kt" border="0" cellpadding="0" cellspacing="0">
+  <tbody>
+    <tr>
+      <th class="kt">Function Definition</th>
+      <th class="kt">Description</th>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">void SystemInit (void)</td>
+      <td class="kt">Setup the microcontroller system. Typically this function configures the
+                     oscillator (PLL) that is part of the microcontroller device. For systems
+                     with variable clock speed it also updates the variable SystemCoreClock.<br>
+                     SystemInit is called from startup<i>_device</i> file.</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">void SystemCoreClockUpdate (void)</td>
+      <td class="kt">Updates the variable SystemCoreClock and must be called whenever the
+                     core clock is changed during program execution. SystemCoreClockUpdate()
+                     evaluates the clock register settings and calculates the current core clock.
+</td>
+    </tr>
+  </tbody>
+</table>
+
+<p>
+  Also part of the file <strong>system_</strong><em><strong>device</strong></em><strong>.c</strong>
+  is the variable <strong>SystemCoreClock</strong> which contains the current CPU clock speed shown below.
+</p>
+
+<table class="kt" border="0" cellpadding="0" cellspacing="0">
+  <tbody>
+    <tr>
+      <th class="kt">Variable Definition</th>
+      <th class="kt">Description</th>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">uint32_t SystemCoreClock</td>
+      <td class="kt">Contains the system core clock (which is the system clock	frequency supplied
+                     to the SysTick timer and the processor core clock). This variable can be
+                     used by the user application to setup the SysTick timer or configure other
+                     parameters. It may also be used by debugger to query the frequency of the
+                     debug timer or configure the trace clock speed.<br>
+                     SystemCoreClock is initialized with a correct predefined value.<br><br>
+		                 The compiler must be configured to avoid the removal of this variable in
+		                 case that the application program is not using it. It is important for
+		                 debug systems that the variable is physically present in memory so that
+		                 it can be examined to configure the debugger.</td>
+    </tr>
+  </tbody>
+</table>
+
+<p class="Note">Note</p>
+<ul>
+  <li><p>The above definitions are the minimum requirements for the file <strong>
+	system_</strong><em><strong>device</strong></em><strong>.c</strong>. This
+	file may export more functions or variables that provide a more flexible
+	configuration of the microcontroller system.</p>
+  </li>
+</ul>
+
+
+<h2>Core Peripheral Access Layer</h2>
+
+<h3>Cortex-M Core Register Access</h3>
+<p>
+  The following functions are defined in <strong>core_cm0.h</strong> / <strong>core_cm3.h</strong>
+  and provide access to Cortex-M core registers.
+</p>
+
+<table class="kt" border="0" cellpadding="0" cellspacing="0">
+  <tbody>
+    <tr>
+      <th class="kt">Function Definition</th>
+      <th class="kt">Core</th>
+      <th class="kt">Core Register</th>
+      <th class="kt">Description</th>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">void __enable_irq (void)</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">PRIMASK = 0</td>
+      <td class="kt">Global Interrupt enable (using the instruction <strong>CPSIE
+		i</strong>)</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">void __disable_irq (void)</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">PRIMASK = 1</td>
+      <td class="kt">Global Interrupt disable (using the instruction <strong>
+		CPSID i</strong>)</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">void __set_PRIMASK (uint32_t value)</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">PRIMASK = value</td>
+      <td class="kt">Assign value to Priority Mask Register (using the instruction
+		<strong>MSR</strong>)</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">uint32_t __get_PRIMASK (void)</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">return PRIMASK</td>
+      <td class="kt">Return Priority Mask Register (using the instruction
+		<strong>MRS</strong>)</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">void __enable_fault_irq (void)</td>
+      <td class="kt">M3</td>
+      <td class="kt">FAULTMASK = 0</td>
+      <td class="kt">Global Fault exception and Interrupt enable (using the
+		instruction <strong>CPSIE
+		f</strong>)</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">void __disable_fault_irq (void)</td>
+      <td class="kt">M3</td>
+      <td class="kt">FAULTMASK = 1</td>
+      <td class="kt">Global Fault exception and Interrupt disable (using the
+		instruction <strong>CPSID f</strong>)</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">void __set_FAULTMASK (uint32_t value)</td>
+      <td class="kt">M3</td>
+      <td class="kt">FAULTMASK = value</td>
+      <td class="kt">Assign value to Fault Mask Register (using the instruction
+		<strong>MSR</strong>)</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">uint32_t __get_FAULTMASK (void)</td>
+      <td class="kt">M3</td>
+      <td class="kt">return FAULTMASK</td>
+      <td class="kt">Return Fault Mask Register (using the instruction <strong>MRS</strong>)</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">void __set_BASEPRI (uint32_t value)</td>
+      <td class="kt">M3</td>
+      <td class="kt">BASEPRI = value</td>
+      <td class="kt">Set Base Priority (using the instruction <strong>MSR</strong>)</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">uiuint32_t __get_BASEPRI (void)</td>
+      <td class="kt">M3</td>
+      <td class="kt">return BASEPRI</td>
+      <td class="kt">Return Base Priority (using the instruction <strong>MRS</strong>)</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">void __set_CONTROL (uint32_t value)</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">CONTROL = value</td>
+      <td class="kt">Set CONTROL register value (using the instruction <strong>MSR</strong>)</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">uint32_t __get_CONTROL (void)</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">return CONTROL</td>
+      <td class="kt">Return Control Register Value (using the instruction
+		<strong>MRS</strong>)</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">void __set_PSP (uint32_t TopOfProcStack)</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">PSP = TopOfProcStack</td>
+      <td class="kt">Set Process Stack Pointer value (using the instruction
+		<strong>MSR</strong>)</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">uint32_t __get_PSP (void)</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">return PSP</td>
+      <td class="kt">Return Process Stack Pointer (using the instruction <strong>MRS</strong>)</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">void __set_MSP (uint32_t TopOfMainStack)</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">MSP = TopOfMainStack</td>
+      <td class="kt">Set Main Stack Pointer (using the instruction <strong>MSR</strong>)</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">uint32_t __get_MSP (void)</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">return MSP</td>
+      <td class="kt">Return Main Stack Pointer (using the instruction <strong>MRS</strong>)</td>
+    </tr>
+  </tbody>
+</table>
+
+<h3>Cortex-M Instruction Access</h3>
+<p>
+  The following functions are defined in <strong>core_cm0.h</strong> / <strong>core_cm3.h</strong>and
+  generate specific Cortex-M instructions. The functions are implemented in the file
+  <strong>core_cm0.c</strong> / <strong>core_cm3.c</strong>.
+</p>
+
+<table class="kt" border="0" cellpadding="0" cellspacing="0">
+  <tbody>
+    <tr>
+      <th class="kt">Name</th>
+      <th class="kt">Core</th>
+      <th class="kt">Generated CPU Instruction</th>
+      <th class="kt">Description</th>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">void __NOP (void)</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">NOP</td>
+      <td class="kt">No Operation</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">void __WFI (void)</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">WFI</td>
+      <td class="kt">Wait for Interrupt</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">void __WFE (void)</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">WFE</td>
+      <td class="kt">Wait for Event</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">void __SEV (void)</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">SEV</td>
+      <td class="kt">Set Event</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">void __ISB (void)</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">ISB</td>
+      <td class="kt">Instruction Synchronization Barrier</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">void __DSB (void)</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">DSB</td>
+      <td class="kt">Data Synchronization Barrier</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">void __DMB (void)</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">DMB</td>
+      <td class="kt">Data Memory Barrier</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">uint32_t __REV (uint32_t value)</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">REV</td>
+      <td class="kt">Reverse byte order in integer value.</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">uint32_t __REV16 (uint16_t value)</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">REV16</td>
+      <td class="kt">Reverse byte order in unsigned short value. </td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">sint32_t __REVSH (sint16_t value)</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">REVSH</td>
+      <td class="kt">Reverse byte order in signed short value with sign extension to integer.</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">uint32_t __RBIT (uint32_t value)</td>
+      <td class="kt">M3</td>
+      <td class="kt">RBIT</td>
+      <td class="kt">Reverse bit order of value</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">uint8_t __LDREXB (uint8_t *addr)</td>
+      <td class="kt">M3</td>
+      <td class="kt">LDREXB</td>
+      <td class="kt">Load exclusive byte</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">uint16_t __LDREXH (uint16_t *addr)</td>
+      <td class="kt">M3</td>
+      <td class="kt">LDREXH</td>
+      <td class="kt">Load exclusive half-word</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">uint32_t __LDREXW (uint32_t *addr)</td>
+      <td class="kt">M3</td>
+      <td class="kt">LDREXW</td>
+      <td class="kt">Load exclusive word</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">uint32_t __STREXB (uint8_t value, uint8_t *addr)</td>
+      <td class="kt">M3</td>
+      <td class="kt">STREXB</td>
+      <td class="kt">Store exclusive byte</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">uint32_t __STREXB (uint16_t value, uint16_t *addr)</td>
+      <td class="kt">M3</td>
+      <td class="kt">STREXH</td>
+      <td class="kt">Store exclusive half-word</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">uint32_t __STREXB (uint32_t value, uint32_t *addr)</td>
+      <td class="kt">M3</td>
+      <td class="kt">STREXW</td>
+      <td class="kt">Store exclusive word</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">void  __CLREX (void)</td>
+      <td class="kt">M3</td>
+      <td class="kt">CLREX</td>
+      <td class="kt">Remove the exclusive lock created by __LDREXB, __LDREXH, or __LDREXW</td>
+    </tr>
+  </tbody>
+</table>
+
+
+<h3>NVIC Access Functions</h3>
+<p>
+  The CMSIS provides access to the NVIC via the register interface structure and several helper
+  functions that simplify the setup of the NVIC. The CMSIS HAL uses IRQ numbers (IRQn) to
+  identify the interrupts. The first device interrupt has the IRQn value 0. Therefore negative
+  IRQn values are used for processor core exceptions.
+</p>
+<p>
+  For the IRQn values of core exceptions the file <strong><em>device.h</em></strong> provides
+  the following enum names.
+</p>
+
+<table class="kt" border="0" cellpadding="0" cellspacing="0">
+  <tbody>
+    <tr>
+      <th class="kt" nowrap="nowrap">Core Exception enum Value</th>
+      <th class="kt">Core</th>
+      <th class="kt">IRQn</th>
+      <th class="kt">Description</th>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">NonMaskableInt_IRQn</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">-14</td>
+      <td class="kt">Cortex-M Non Maskable Interrupt</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">HardFault_IRQn</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">-13</td>
+      <td class="kt">Cortex-M Hard Fault Interrupt</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">MemoryManagement_IRQn</td>
+      <td class="kt">M3</td>
+      <td class="kt">-12</td>
+      <td class="kt">Cortex-M Memory Management Interrupt</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">BusFault_IRQn</td>
+      <td class="kt">M3</td>
+      <td class="kt">-11</td>
+      <td class="kt">Cortex-M Bus Fault Interrupt</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">UsageFault_IRQn</td>
+      <td class="kt">M3</td>
+      <td class="kt">-10</td>
+      <td class="kt">Cortex-M Usage Fault Interrupt</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">SVCall_IRQn</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">-5</td>
+      <td class="kt">Cortex-M SV Call Interrupt </td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">DebugMonitor_IRQn</td>
+      <td class="kt">M3</td>
+      <td class="kt">-4</td>
+      <td class="kt">Cortex-M Debug Monitor Interrupt</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">PendSV_IRQn</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">-2</td>
+      <td class="kt">Cortex-M Pend SV Interrupt</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">SysTick_IRQn</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">-1</td>
+      <td class="kt">Cortex-M System Tick Interrupt</td>
+    </tr>
+  </tbody>
+</table>
+
+<p>The following functions simplify the setup of the NVIC.
+The functions are defined as <strong>static inline</strong>.</p>
+
+<table class="kt" border="0" cellpadding="0" cellspacing="0">
+  <tbody>
+    <tr>
+      <th class="kt" nowrap="nowrap">Name</th>
+      <th class="kt">Core</th>
+      <th class="kt">Parameter</th>
+      <th class="kt">Description</th>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">void NVIC_SetPriorityGrouping (uint32_t PriorityGroup)</td>
+      <td class="kt">M3</td>
+      <td class="kt">Priority Grouping Value</td>
+      <td class="kt">Set the Priority Grouping (Groups . Subgroups)</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">uint32_t NVIC_GetPriorityGrouping (void)</td>
+      <td class="kt">M3</td>
+      <td class="kt">(void)</td>
+      <td class="kt">Get the Priority Grouping (Groups . Subgroups)</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">void NVIC_EnableIRQ (IRQn_Type IRQn)</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">IRQ Number</td>
+      <td class="kt">Enable IRQn</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">void NVIC_DisableIRQ (IRQn_Type IRQn)</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">IRQ Number</td>
+      <td class="kt">Disable IRQn</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">uint32_t NVIC_GetPendingIRQ (IRQn_Type IRQn)</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">IRQ Number</td>
+      <td class="kt">Return 1 if IRQn is pending else 0</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">void NVIC_SetPendingIRQ (IRQn_Type IRQn)</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">IRQ Number</td>
+      <td class="kt">Set IRQn Pending</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">void NVIC_ClearPendingIRQ (IRQn_Type IRQn)</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">IRQ Number</td>
+      <td class="kt">Clear IRQn Pending Status</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">uint32_t NVIC_GetActive (IRQn_Type IRQn)</td>
+      <td class="kt">M3</td>
+      <td class="kt">IRQ Number</td>
+      <td class="kt">Return 1 if IRQn is active else 0</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">void NVIC_SetPriority (IRQn_Type IRQn, uint32_t priority)</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">IRQ Number, Priority</td>
+      <td class="kt">Set Priority for IRQn<br>
+                     (not threadsafe for Cortex-M0)</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">uint32_t NVIC_GetPriority (IRQn_Type IRQn)</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">IRQ Number</td>
+      <td class="kt">Get Priority for IRQn</td>
+    </tr>
+    <tr>
+<!--      <td class="kt" nowrap="nowrap">uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)</td> -->
+      <td class="kt">uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)</td>
+      <td class="kt">M3</td>
+      <td class="kt">IRQ Number, Priority Group, Preemptive Priority, Sub Priority</td>
+      <td class="kt">Encode priority for given group, preemptive and sub priority</td>
+    </tr>
+<!--      <td class="kt" nowrap="nowrap">NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)</td> -->
+      <td class="kt">NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)</td>
+      <td class="kt">M3</td>
+      <td class="kt">IRQ Number, Priority, pointer to Priority Group, pointer to Preemptive Priority, pointer to Sub Priority</td>
+      <td class="kt">Deccode given priority to group, preemptive and sub priority</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">void NVIC_SystemReset (void)</td>
+      <td class="kt">M0, M3</td>
+      <td class="kt">(void)</td>
+      <td class="kt">Resets the System</td>
+    </tr>
+  </tbody>
+</table>
+<p class="Note">Note</p>
+<ul>
+  <li><p>The processor exceptions have negative enum values. Device specific interrupts
+	       have positive enum values and start with 0. The values are defined in
+         <b><em>device.h</em></b> file.
+      </p>
+  </li>
+  <li><p>The values for <b>PreemptPriority</b> and <b>SubPriority</b>
+         used in functions <b>NVIC_EncodePriority</b> and <b>NVIC_DecodePriority</b>
+         depend on the available __NVIC_PRIO_BITS implemented in the NVIC.
+      </p>
+  </li>
+</ul>
+
+
+<h3>SysTick Configuration Function</h3>
+
+<p>The following function is used to configure the SysTick timer and start the
+SysTick interrupt.</p>
+
+<table class="kt" border="0" cellpadding="0" cellspacing="0">
+  <tbody>
+    <tr>
+      <th class="kt" nowrap="nowrap">Name</th>
+      <th class="kt">Parameter</th>
+      <th class="kt">Description</th>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">uint32_t Sys<span class="style1">TickConfig
+		(uint32_t ticks)</span></td>
+      <td class="kt">ticks is SysTick counter reload value</td>
+      <td class="kt">Setup the SysTick timer and enable the SysTick interrupt. After this
+		call the SysTick timer creates interrupts with the specified time
+		interval. <br>
+		<br>
+		Return: 0 when successful, 1 on failure.<br>
+		</td>
+    </tr>
+  </tbody>
+</table>
+
+
+<h3>Cortex-M3 ITM Debug Access</h3>
+
+<p>The Cortex-M3 incorporates the Instrumented Trace Macrocell (ITM) that
+provides together with the Serial Viewer Output trace capabilities for the
+microcontroller system. The ITM has 32 communication channels; two ITM
+communication channels are used by CMSIS to output the following information:</p>
+<ul>
+	<li>ITM Channel 0: implements the <strong>ITM_SendChar</strong> function
+	which can be used for printf-style output via the debug interface.</li>
+	<li>ITM Channel 31: is reserved for the RTOS kernel and can be used for
+	kernel awareness debugging.</li>
+</ul>
+<p class="Note">Note</p>
+<ul>
+  <li><p>The ITM channel 31 is selected for the RTOS kernel since some kernels
+	may use the Privileged level for program execution. ITM
+	channels have 4 groups with 8 channels each, whereby each group can be
+	configured for access rights in the Unprivileged level. The ITM channel 0
+	may be therefore enabled for the user task whereas ITM channel 31 may be
+	accessible only in Privileged level from the RTOS kernel itself.</p>
+  </li>
+</ul>
+
+<p>The prototype of the <strong>ITM_SendChar</strong> routine is shown in the
+table below.</p>
+
+<table class="kt" border="0" cellpadding="0" cellspacing="0">
+  <tbody>
+    <tr>
+      <th class="kt" nowrap="nowrap">Name</th>
+      <th class="kt">Parameter</th>
+      <th class="kt">Description</th>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">void uint32_t ITM_SendChar(uint32_t chr)</td>
+      <td class="kt">character to output</td>
+      <td class="kt">The function outputs a character via the ITM channel 0. The
+		                 function returns when no debugger is connected that has booked the
+		                 output. It is blocking when a debugger is connected, but the
+		                 previous character send is not transmitted. <br><br>
+		                 Return: the input character 'chr'.</td>
+    </tr>
+  </tbody>
+</table>
+
+<p>
+  Example for the usage of the ITM Channel 31 for RTOS Kernels:
+</p>
+<pre>
+  // check if debugger connected and ITM channel enabled for tracing
+  if ((CoreDebug-&gt;DEMCR &amp; CoreDebug_DEMCR_TRCENA) &amp;&amp;
+  (ITM-&gt;TCR &amp; ITM_TCR_ITMENA) &amp;&amp;
+  (ITM-&gt;TER &amp; (1UL &lt;&lt; 31))) {
+    // transmit trace data
+    while (ITM-&gt;PORT31_U32 == 0);
+    ITM-&gt;PORT[31].u8 = task_id;      // id of next task
+    while (ITM-&gt;PORT[31].u32 == 0);
+    ITM-&gt;PORT[31].u32 = task_status; // status information
+  }</pre>
+
+
+<h3>Cortex-M3 additional Debug Access</h3>
+
+<p>CMSIS provides additional debug functions to enlarge the Cortex-M3 Debug Access.
+Data can be transmitted via a certain global buffer variable towards the target system.</p>
+
+<p>The buffer variable and the prototypes of the additional functions are shown in the
+table below.</p>
+
+<table class="kt" border="0" cellpadding="0" cellspacing="0">
+  <tbody>
+    <tr>
+      <th class="kt" nowrap="nowrap">Name</th>
+      <th class="kt">Parameter</th>
+      <th class="kt">Description</th>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">extern volatile int ITM_RxBuffer</td>
+      <td class="kt"> </td>
+      <td class="kt">Buffer to transmit data towards debug system. <br><br>
+		                 Value 0x5AA55AA5 indicates that buffer is empty.</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">int ITM_ReceiveChar (void)</td>
+      <td class="kt">none</td>
+      <td class="kt">The nonblocking functions returns the character stored in
+                     ITM_RxBuffer. <br><br>
+		                 Return: -1 indicates that no character was received.</td>
+    </tr>
+    <tr>
+      <td class="kt" nowrap="nowrap">int ITM_CheckChar (void)</td>
+      <td class="kt">none</td>
+      <td class="kt">The function checks if a character is available in ITM_RxBuffer. <br><br>
+		                 Return: 1 indicates that a character is available, 0 indicates that
+                     no character is available.</td>
+    </tr>
+  </tbody>
+</table>
+
+
+<h2><a name="5"></a>CMSIS Example</h2>
+<p>
+  The following section shows a typical example for using the CMSIS layer in user applications.
+  The example is based on a STM32F10x Device.
+</p>
+<pre>
+#include "stm32f10x.h"
+
+volatile uint32_t msTicks;                       /* timeTicks counter */
+
+void SysTick_Handler(void) {
+  msTicks++;                                     /* increment timeTicks counter */
+}
+
+__INLINE static void Delay (uint32_t dlyTicks) {
+  uint32_t curTicks = msTicks;
+
+  while ((msTicks - curTicks) &lt; dlyTicks);
+}
+
+__INLINE static void LED_Config(void) {
+  ;                                              /* Configure the LEDs */
+}
+
+__INLINE static void LED_On (uint32_t led) {
+  ;                                              /* Turn On  LED */
+}
+
+__INLINE static void LED_Off (uint32_t led) {
+  ;                                              /* Turn Off LED */
+}
+
+int main (void) {
+  if (SysTick_Config (SystemCoreClock / 1000)) { /* Setup SysTick for 1 msec interrupts */
+    ;                                            /* Handle Error */
+    while (1);
+  }
+
+  LED_Config();                                  /* configure the LEDs */
+
+  while(1) {
+    LED_On (0x100);                              /* Turn  on the LED   */
+    Delay (100);                                 /* delay  100 Msec    */
+    LED_Off (0x100);                             /* Turn off the LED   */
+    Delay (100);                                 /* delay  100 Msec    */
+  }
+}</pre>
+
+
+</body></html>
\ No newline at end of file
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/License.doc b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/License.doc
new file mode 100644
index 0000000000000000000000000000000000000000..b6b8acecc137bca709444106cba045d3d01daedd
GIT binary patch
literal 39936
zcmeI53w&Hvz3*2ZZBuBVr4Jqg-IP)q2qBafkZ1Flwy9}S@}SfrFqxSo(<U=vX3{i3
zAs~XN$g4aqf*_(-go}XO<Mqn@fJdncSK-J}UUDybJ%R{QtCyqP3q9Z8+IvrSl9?n0
z@x|=&o3;0P{?~u~*MI&0Yp-mcdUDoFUwGhvpPNzFsiwrdvunDU8i+6Aex?6B)0hVC
z75C1rUAq*$3UFJv{*E~C+Lyj<O3s~LYRry(9?>8g!^m<m@E0Fu%wDErW5>oP(odvq
z?1-P~rSnWxy)k$1Uu5y=1Ks4`kH|Iruxr=e*@t}heulg3&0El=OJVTdj~gA%QG|Cj
zO)+Lpu`#RnaU+7^2}E5={8@zmi%^7jOmp+yxSuhvaXWRk`>gP6Zlm7w=<qbJ(b3^t
z>Y;hFFQKl<gbT@c>HfxaQ}ERf8S{OfPon%>RWR!E`Qf)aD%tq)`9jqjy!`t7(C??8
zN6#<tu$FT32w(Sz8Xc;=jiisRXY{l96TJL-f^n0%_xm?deSZBu9ey~OHge_h>+|{a
z7IHL08H<m<WZCi`NHN;Wm%F>+OOzPDoR@5VzOOM$dFX^6)r68iU4Fg?y;)TbzaJ;w
zfA-UD=0C%aU$0-4&mXn(2YTc4*$@5p{bxV)%jXOIe4|5O9{n(1c|ZOc=#m^xbd7Gu
zfA;z8Kj#bm`hEQn3@<~+{E9)35(eW{#(!42uD!^k`MrctL%f<0wU(VHKEEdlwYX3W
z-7+I9V|p%J1rF>!2i7P1Q%++%5=%s4PA2KJrwO`aPAl=m)Fq=aC!B~nt$ndbyfYpN
zXX43()0s@!Ty@D*Cbq>{6OW{lkz^v1O7`@`QWWmY41`lLry-Gvr8>h@)S97|a4LFY
zd3oEahE^xkRPVI6hFYA)hPqHwUC60f*%At^2{pAjq}Di%p_Mg_fyl+zdl|P?IJKd+
zb)is`v%b0ASsZF;TSYZBPHRKc%Epk>&{W@WMnipjO=G3g+~UW&)lqvx+xiNphQ@1J
z*3kBvhPF_>vv>hd3o4uy6reT{<}|Ocx2?_XEl^k2Tn~v9Yh4?vYgo}xSJT$e+~m~M
z)itkKThp|jw#g3V9+g#&ZGed8rpEQox`xI^o2A*!K>ccG{L0&!Z4YUtu9;5R2HRHE
zwAol%4y|o-Y8o4TO4~v$Yg+04C^~A_J9QBC5jB5(gUiuv;tUB5O|5Ozpd=!i#mIFH
z(AF+qDypt|t?in}WR)V<Bxu*rXe8j1y6O|HF?Q%zZHS86VJAeW3u1;#zh(OfJ~phd
z9j<S7nwsgbUq#*`l|JX&o8AlCHQ4IKnws^tVUJgpu5h@l8N&z|G(tcso!WMHyjoW^
zw>Q>1Yg>?)HYB1Y)Yjgjv6_SwAe>cBdHMB$Il0a0jfE3wI|<Y7RE=n=zWa$;r3QkN
zd_)t$g!j^j)0E5%#53J#se^c;%XR>wV_iv}DxJ|Jq`SjCJx(H-apH+cPd`0e9Ivp2
z;=O%6vEEoB<7%X2r;|i)rJTP0j-GhBI~H})L88-6D%KfGNzFy6%T_U>yC+dIRfiLU
zPAn0o4iOiNbSIKM$*y=ztPW?K-teH)5pxo;NGzQWrv{}md&8Sz4hpd!)v4lrsbsW2
zl2KG2`ce8)l*J&?))7fUx@r_7#u8HLbo6H&X-{>VlD+9z&t|g6w)CZFwP(;t$1)lO
zO52{q)1%b$;#gHzm7{jzQpcSsR5QJbrYnhrhh4EmEEUcqQ$%!xBb&Umo_I$poDyY_
z?sC(wqtXed)3M$TRYxM+*~DFtKPNex!#(k+HySA?8tdrqa?<`vK%s8bzgC5loNylu
zaF-G&NcM>s@jE@3&cu4vKr|KKOap%Llbn`@);gFH>5kKAreC$dXN>~6d$s-q6D#a!
zGMv5P^rnGiYE#-SVtw6%Y1-{^dcuRr{tW%>goBw_7wsb!k$5W7AJ0H~I^LB?pCm#S
z$2V6vEp3g%Ea{GSbvr$=&9NRtN+aUS-~`n%!OH!`Ze>eNQ(J5KF)S0U{T&<WkpxNW
zE}hyOPa`w7wz{4$Qk8a=R6562I!kRQmbnT}64f#2Kzf3XP?{b&{fQ`ClMt#~ti`a3
z?ouf{&LFLlVZ>!|xWY*eB<M3;>`cXC2o)m|OQezfm_xl<9wnc!$>|FZYNDx;{zSO5
zGu{)o{K|C4Q&CcpacGp4u(+ebiBSq75SC;#?oKu@inclsD_7*lvo9oVzK}o<B9d~N
zvQutxG}ajx?FhfiAUM+z>q!ov8InkN-=GR)6$F&|m1#1josM`yQ&%i<jT3i9!pOW+
zGVH*>zL>aK$-GP)72AS3N+YE1V}@Z!qhG|nN+*>Z4EMlpakkPy{(7PVaps+6v9+^K
zEJu$`cQporCz3V#BQ#Q0&-V4F`jRLYq%|tJOZHh^*&W`jN#jMuqLoN{q91FE=@HB@
z9IHIZPRLX_ScPJtJNmWx)BViLL8ZYyJO2mbG#iblGpRUANhzLkLwR+_Bi&ZVAUnA=
z*-3OVUU7$e(N}4ozCp-DFggdVz@(+EJ>zqf)w!7A^_Dh~<IWO)k?XA>tw&<(uXum2
zOsaIJd=z=Mvs2U9YL(PxmJ=2~@hpYT$!I-*S7`*-E``JE*zjDEov;M0(l&~jV@-H1
zFs=&lX1k^gn#5HDEDd&il#3yk&V@j74pY+;9&q#6d6ck<A6+w?A(M&`Db0YiAY%&M
zRVBA_%2wzXteRvuT#}(r3npR_ttt;~iNyL?MbpDpKu=c3xvC=^i6m3eu>2k?zMd*M
zrqXKCaOAxHxLt!C%lt|w6VIR;#U<&DSXw5@#HvgM^6TTQl9bAf#S>L{O!UHGmZOYZ
z<41bIn<Hsg-H%Vd>=S%3=4?M1;ecHtG<OlL%77ICWelj)q_-B6n9d~o`dHaW%PIi0
zu}^?q0z5NED@4`+z-V$gZnfC3JX#?dq1BMk;lZ)1okV|FmBW7+;0in|l_j1G-U273
z<*5wFP-8adn0)R+$O4u2o!hGNV>K@(w6|+oLbB3vA#n^B)ZkIIF7UiLFS-?fz*$$*
zqBXoBge!aI+LlmjYo*h$W^H2wrQ`*))wH#@HMguMwyCbMy&i|E5;w37H=xb+JFN#<
zX({px1}eo5S`%uiTSXf+wGEB9t(8tIMOs(X)Tv(QbUa)e+tl3D(6pk323+@<)>kyN
zH9?W}XKS3bH7#uob?uEcEza8ZmbJ~Tp-C}9j*m-w$O*NyG`F;RY@oBDmNV$MnAy^>
za#fpLI<huXd5avrHO=)|ADL{;W7v+D+DOJ0+@LcWTJfaulUFzmZJ0K=T@+YT^ATM6
zHR8DK73sKKaAPIyS|1m`X@o0Iy6B-qeS2M-&EFQPTh-Lu*t}AsR3B=sYiX!uc*xcg
zq7Ix=Ja?z9VNIy2e5rU65EpOq#d~{WQCT}E4`zKYmP5wf5OF6ba}ASdb2#2(4JS`Z
z<DFKAcvD{n602RnZgPz^S=1>suJswHR(4#tD;#I)%KUQ8ylgQH<&pN*Kz9<8T8o5h
zd1vP+=6<iW-?TJN!t}CJHs~u^drMSB`q2lyG1dZV%9;UM8!$zb!MZe9>>c4WbF{w?
zS10U5dcyJE>|%xqO<`0IdeCP<1xBO#D^qmXu7i2QHrp7YtZEESXqosG&Vp>E3p|%t
zbWwL4p8H!;*1GW@AQZI+O|Fi>_UnagFV$TNu=ebj$pn!-rQF=IKvg=M<M5k>7=4<K
zMX<EA#97lT+-3dIY*iG>>QFhB(Ezd01)hM7RMvJ$qUxSO&mCRh3W?u0ScFLs>xw~6
zr>r=)MbQ@PV)3QPa1<ex#m3r;aG+r$F+@1g1(75No>?g5dAkD%zf(}&i;b&+p?DN~
zEu89zb89Oexy*<A@eSy_ODF?zeRd%IjRU)?vQQ#g)_1THCE3V|k1GWdY?-%KZal*h
ztJ!ltBnbG6crYo=L)qcI@w7Z7Px^dWk};D~IV=sh>N6;cr5Z~NOO^(1jBrsPB2P<8
z50-l@C38l$y`&?Sip1giAnsl`oz&g{3GxBFCRF19`vP(%{Y{D7tsw5363~eUEN4ls
zWr)FMyF#*MBSqRqq$(YaN9@*tJH@j3B1|OogsXkzN82q3*@<DxXv^E+G^w;!ogF;P
zN^iGB&Bqdqe#8n8Yw|MmUsKZ8Az3ql(sr}LI*M6oCU*3STj@<F(QjAvQ9i80x{maU
z$I4=j2gz6>+zU4mU?w2DDz?j3aNdpLvhvULhXC!s;OSYtM1$<UU|coP1C0#L`PN>}
zX^0;7#oPK9vdJOdZuCfs$N2pT1c;p~_Mkd#*J!{O{7Lj<q<vI=oL!2v8=qn3;cIu`
zaHGw<x;1v5?v=f6owm4iv=WA`cUQZ)iYpcCvF5ot5tNPL&iBN7*;uh=mWHQGraKD3
z6TWb7vLB@&&(cnWzHr<sQSrt1zXF?+mXZ;j(!jL0E<C2Xs=C^>>TQFTDD;x&Ov^V{
zCs=8$E>Nf7WDbh6f-how!&~CL{k_y;RTmT{2V5oZ?K5dhgZae<%<&#;$0ydxudLFs
zR-^<U1JvKKX|KX4VqcEExUAZj8zYI9kLIfZn=j<%s|hG*lvoYQQJvOUqU@9C8Vv+H
zqW$imQJK=coyS1qUb`CNUQ0osjQD1!D`YWr+SIFZ)-zmThE}2_%_im1*)PpzXPlIX
zh_}rJ>++<aJz+(JH#r$^yJu7jyhri+*hn?JPoWvQ#AY31$i|ZfYh2E2!Ev`e7azk$
zlI557ETVW~kqmTNarU3A+SnXVda@0bfz}Z!cOObLFlDoBa7j@+0aj{!YO*6K=Pu={
zUu*ezRj`37{gq-tk>!PUiLtOCEZuQdNyf|?UUoYy5@%`iG>v*avVOZ+#AI?eqqGsi
zIK<ewW4dERBqDaM2g-FN*$ho+56<0_TvEaKBJ6h4AgR?3x@aHvs4jmiBtRM#&j{vZ
z#dCO}9iEY_ZvBy-SeVr`!uGRvOs(zE0k7E$*9Pi9ER3<2R_}Y_+V@gtwE0jj&2Eh;
z*-hC!cWUhIfOU<bx})%xj;gL+x@6f=XDq3zcAC~4y{eXi<t63irT*`1oSid5^>QZ8
zTJ9`}Mx8ZWxaM37oU@LQbF?zV`?@t)@pGz=L$z<lnU(>tq`LZqxzndlpY7B)*WnJV
z4YjnbcNWwk@BNHYlO<$<Gp3TUq|JpWOC5Estyvjz<{UFuDsi^c)XrN!xgv9x&{Uq5
z)FQ)?qbYcFv??zz-~AW1f9?{T^V+Y>m{UO?I1i*i8hiyj1QzXK%rbEIp2mC?+zY+|
zUjFgR-@5DitsA$l+q&X}!$p`gxBJ$zkD7Vivris0b*uL=&8v&e>ELV-=Gh!Dulvhq
zY|EWSX{C*m<FI+%w=KLnXX)NmrZfTi%ZkX=a?lqh%5~&Ktp#e#Ql{SJ>{q2<n|fY*
zL{Tu)S!I{_{qO6x<Co2?`X<a>F|Yfe;&o<O*(DQYJ$i0;!^SmmQ1wnCKgatRe}B9+
zw)cQNIk7SW^l)6S7bL(|FgS~oaE#%PISKYOc!m>A8IIum2K;+aF5mOR8}FjFmx5(}
z5PbM%@Zo{H51$XFjCcqp1n=QR$-<KI?NdxqcafQWSJcb_8x|IwwXi6>u%s*cwSgmz
z;anlP?DJOhm@#mY=e;jGuz1#GzkK^_!gC32`kNKo?V+YX`p8<x=HAQJHZs?6U4gbG
z7(rSjB4(Dx|I-{xy67-t-hMmSxx)QFHU~;eO;J&?^!PJiI`iG1_a}3o0Da&s@c+Qa
zS*k7rn~+}V1z#sz!u@{+J73uO!-v20@V3jh^>2H)YyHY40p?ZstAe!qC>1tRF&;Xv
zTT^D-Jggv^CP4-3SEAKLVxBV%9e(@;r=T0#omX<_pmgcQFXm3mmd;y$R;Me+s2+@6
z0jN(Ca2$G}ChsarTk3_|mkHaVrhIGeEREe)!G8e{g0F+e!H>Ydfqw^o1kIcZUkhR&
z13nIJ05^g!fv<z@;CtXna2RXF;XrG~R#1(uJPX7@3cUWp_7}E4^yM3_82&fN{r0Zy
z?b~k%$j<OBvN0+78Js(s`@VR%i!a<5PXh9BYS^~Pn}eG3N+#4N8@G>7*>25~FJ5rw
z__fiZte{cSF_IVNAdN*DWI#W-0DKDE0{%O=mUVs`coIAX{sm;$f9_ufe**s>%*P&B
z0PX{ig6{y?2s?kd^XZ+B?R@$hPv8CYV>f+bAiiPshSmHGkL}32?A*|DnR70~=}({Y
z^So)lKKa{u)AH6i8Qnu3l^>U<(6(kpYu@%H1^N1vSF*Ak$(w^#mt?+?x8}R{cqV7s
zej1-SoTQ!$_64VbCeRGR;5G0DXv4-k2b>4e;0ACHxDPxHehPj8ehpp)vI*Y+zXxxD
zU0@a`-46qcz~Nvi*aU6@H-lTiz2H&sZSc?F8Sv_}+h2X?)jMB(_SI+Yk8WPw{_IuH
zUUlbH7kK|VFX+4~JAXE;`0V&&#5hivCtKTuvxwRxapOt_d7eDvt_kx@xcX7gg!E)7
zpRhKwSo|&HIQjwLXfTbxJ}Cp!!CG)SXa{G30dPLJ99#je2KR!Oz#HHl@cIj{KmPE2
zw|(ZKzS}Ok?K9`x)^yP+BPVzEDJ#<(KK!$svN^1AkDhhj1UY`aWJm5C6KIOO+8|5a
zU9*qOU2`@^-c_2mrKR)D_Iy6-aKH2Bn54u_C@E&P=BdWJ>|kTApU?O?#{3pE;}fg}
zr-M&|E5WCLe1)sPXTde#T5vts25tm5frIfS=7SyCvF7HL;KOslhY=|w9{wemZN$Tf
zZ13jb$zav*;{*QQ@b&2MZT7BoZ_^dM;iF5;9($Ye?PaET+pNWh78Sd3_RlLv`*3+Z
zJ_*|x4=-<S35S`dIXmY7Za^zI8$>`C*aU6{KLalUhrdWW1bhsf4L%QU2mc$q1P<aa
zl@10CVCW!7L8c^EGe8Ke0+)j;z&7wL@G#i<^QRtpfPYWj5%_oYQx9AeZ?pfzD|DJx
z{CVBat~+;pEt<_ap@qZ@cI(VLOS5zQj`L2>J&&_F^6Ck+z{FbS6X^>ks6Vfk$x@J4
zk3zveCzs`{-x2>G1&1;BD?k`r3#1Ef0;f2}EC&r>JxGHL_^;rfz-z$Q89TXu6TJG9
zNBQ@)&+Fe+{JU_|$5xt2UF^xpd&=(>1@`3VRbF2#%M(qkoccGL<42YMBX15@I`WPz
zb+|dk8yh!AUP`ml`e&5uY@KR*T&u*)(RdXff(`)ZEx`T<SAna+bs)G7q|xmcfs4T<
z;0mC%L2JTifYyYof!2iUfYyW?fYyYY!E4WbhyR}Y&La=paouH`AGjm-vGwl1dStI;
zqa?)lihnq#WW=bnmlgS*%hY+@N;P}CCEO>{vm+|MI_H=pF(0kZ?-_h+_G@{|iIX|&
z%(j|W(#Dfh`Xb3NyCe7PZWk?z=A<StJIIw!<^s9Q0UDR@g2%v5!871_@B*058omcO
z5F7;jb=~3qFt7+54vqp<;Al_{mV#yAG_V}hfLc%wLLdYB!610!`R_gd2LHbK{2LG6
zcgGu7ZoV=M{NK|NiG$~LuRZEFrh4_PoP9Rzj{juQ<9X8qy<HfTuDtafHC7Tw=M6|B
zqdQtweL*$8q|TVzE$Q&&mJ;euPHAG))R$aofqqPWu4JV%AC2>6r)fMd02hL-KzqUZ
z+y4>U!N1q^^snFgHws5&8}aa~V79{j`_6%YrD%8eOK1AF<;*;`<y6hV^Fglhf908{
z{^$3<@xD|20cs#SAM>tJ=!`#X<n2{%-H|PyZ$6vd(_Ut3r8(xB?xOkkUs~ndzrE&=
z`^%;+0Eb?4$CQQOu>08+y8pYy`+*tPe7E=mG*lmuu3la|*X)Cvc`L6aOS63*zRN}x
zZVDWDA33lbQ}K7Zip_E}BP)DUO_NEQl<75L(?i=*Kl@=E?PtzeRa6=#>|HgzEDbVX
zEOGUwX8F!tUoiD%#uPtw9#1jTNsax~nK6!8%Y6!T+220XP239FO^~Xq#l+3;cYU33
zxRx2FjS?Ny5F__UDi1XKzKMIX^rurz(H<o|?#&cp!ip|7ylgd#%_j4QUEd}&S<0r_
zdK}Y8duiLYuWpx``OAyUPQDT&-pG{H=b2W~c9<{9#Gu=la^|nyKKk&?lvAXVON~RR
z;-ZnI)UzbD`=va?AX}=+R4l*K%qps~-?DMr+SBr=%j;`D<I&-j*EhfZ6WU`z(JITG
zmFe?nd4{QlvL61atppruBmWk!Py3iTjNwd<29<C$sDz_IB^(W!X^t@K%$??#q9bg}
z)_$Rvt&~dHTDoknIn=_-)LOpCRAg$4Y6E#^j2H(8-mat74pTw7nY20bhy;;b7qd$R
zOY3#7@2ZGzrH=0D)1ogb+CV<f#lz1;mCbU?a?AJ?5e#1%jWqZwqkRw9lLj<yJy>VG
zAOW_5!RhRxajNRa2*lHR3(s5j47+u|0jj@@o!RU6Wp{;L`QL(OcGcE`)4?afmEcq0
zCU7wQaKHsXJ8zmQDTnVcNfID0drv#r`(S*&duZIP{BR?ipT1}B>3{Y<*jBzgLHe25
z*|MBK$leF*4BiLp&q4oH_m1L8F#o%}SDnQ<%G$OVj=!`_=u2!@fzN_#z_s9dunpV@
ze3_Xakeds+-|ETF&CqN=Mx}7bgYLNsX)YfMeDV13L6Hegwb*NjU%|bK#+eT#|0rpD
zS9`r3A{5-q_B~J9czVL}W#%|_=1Ci;&Y_Z9e5w=<2`>&*nOn@c_MO=KuY-eY@_W_4
zwlBH)GwuCI+xTfyJ<V&6Wz6tW(7T4FDQ!w1jTeFbHSLz=+~%QkqB_TG@BL20tnx0m
zf8~Mx&GwU!o12&Okh_0H-S8z?jzcp3H71QiHvUy4zRU`=hq>opme;{F4&M1!Ze9=B
z<aaL<%PF6`f4SSU%^6GQUZeUTS{Kg$!I(5mHt%wI9V~~*n@zKFJ=1?A9D1U<lpuOf
z$Fy<u=s0OZ<D@aRYAR>n|2pOJ=us<!dD4pV%ct9iJbKjDnI~<WIz66=Z@PwrkvbN0
z9-qwxrnmLZG{(XW9(EG?_`lq%fKDOnB&tp$>O`7OCFx{>-cG;ixNi@&Q?0iWnxD8v
zMss*SAYCP$gjs9k`cTC1;@TVnRJTsJ=q-oJY94Y>!8kx^defnKEBZbRJ_4G-Mc`WS
zIdCVq3)~GJ0{;ZQ34RUq9z=bZJukEChN0Q*_V*C`d%$oE9oumNxoC2SC@#jM!3VK^
zqqMD{=jG<$-)RE4-}l^QhK7dpcNH^n?TdF@N5V`~wnO_Iwh(h;Z&R{E63o`!4z?1A
zpT5JNK|E%!VzY-WXDBm;Smm!J+{cSABA!15!P(w(huHTB4a_u8s2PJNY|2b&iH7sE
zk|NvotQ{&~lL?b>{t|F0xB_VLlY{XLcpe<Ys4N22U@52t_27KqI~>#a+_;Nrgwr6@
z4TtY(NaS1h_uaN~;w0M80G$f@JY0=zT?a0rCl>>`-0Gpf#QSbmK37XzcosYdd~V29
zAI%ZD?mjn4=;=s^BgGTI<(l%byTIj-i#7yY-VP8e9!iG(4d~horqF4<QD`jN!z^7i
z(>$_tAM^OYZ1eK@b4)|~T=O-~R9}7Ee&(qI_BZoW2bv9==bLjY9rMTehnPb)Ei}cv
zK|FuO;pWAXBaBW<=-lDG$!fb*^@~%EHT$nS*60Mv_YXMHJkxoy(K-A#SJasM!YfQI
zf3$Vil+{LWt98moXJ_@-PKow)M(1)uQ`Z}923=aZ!E88TgPGd3!9>qL+vvQ++_S>w
zbG02t@53+LZ<D#bwAbjYpthlI8rW<u+d5!$HshXCFEBb`Q@&`(oYVSovvtlV%*%&e
zVg9w`N~3e2`kS)aGp{yZOkQJj!nS|K4d%JT4d(gg8_n&NpELjGoZF3#OX&pXmb&}Q
z5eGhKblUc<6TfA;TOKw#Lvrthj~bl<)d>Tg_xV)mW9H3;+l@|y>&)+~XMNA;&5qvh
zu0H#5^U8)FnR{!VG9_pH*tB2twE5-v|7wnQerj}5_jKo36FL4_qZ2(Z)x2o*R|z_S
zaAfx{%qe^P%IN&M-XZJ6LVM$D=IQd+%}e#K8=ZpeDEXb4y5%kNO3&M-YVj^R#&@Ha
zwH0+Un#kWavfD(YY8DF>33RV_?OJYz{Ml{HnIAe~&*3LO4=T%7HQGg6E{(yDcFrVj
z?d<z)0!cH#uVN*1{^jO!HC?f<@1WJcmyoWUcMVk)7f&sjQaYu$r1XmOjYIU1Uyp5w
zh&J|1d)etrliWl&K-faN+BHs)zKnW`&6Fuc#YNMm7Ef{KhNvCBhIHF%2JOyfl6^~K
zj$LG1-*akdv97$W*RZz}x4WIRlr00vrM66%ssa=jsUf>}-0e}wiFu~vF=e0J&+K@r
zm@mKEEaxnJ;&S1|6F;+}*bYxEENNhx7E4c4qGaZ=gd<}WqwA0oW0wK9H8-yCJ6R5t
zO}k^tL#*_dTypSI{ej&6_N(o(GPa_^h26PEj{!sMU1i69{5*}5FVBAb$Z*w}dY-;x
z*WN6>ry280<baLpi-i+O@$dam>Q2`Z`|JORie0<>30`B?BYpiyuKTtj!mLRc{W|Qn
zC;4q>Hn~sTHf&`%jFH2gY1+|mV6ODp_aB;jdRGz#aY`rbOic2QMYXx*LuQMuzb~7|
zrEHqHkobFfC-M@KU60;KP_N$kXjY|t@(bbn#({Uxx~Rr6^%oKI(kE`;`KRXYnfF{<
zW{y1k>(5ma_b>^PBc<OARPqiW%l|bX&HYCpGqa3L@&@J*O6@v?lJ;ssnUl*2RaYY+
zFG5TYA&!9ALMV&;GD3Ne(!|nww-T~~nY#$3zV9WJH}DXl=+NAd`C1S7)<y2`n(ISX
zd`ZD+@ITe#euTvT)QS6TIzDDV9jZ(H(WQIQeqrR^JzpxWACopZUsE#G8)hN#%O!e~
zDZc8HEvNaZG*r5=pHJ7PZk=YnkQIqJ>-aDs@ymf(@ts2zEZ5JXvv)TC?7Kzw{?27d
z{a+@6_ZkE7L7`R#g<3Nd`t)&IxC$I7aG=0}0tX5lC~%;_fdU5#94K(0z<~k>K7bs^
z=l{!(EdI$4e{yTphh|=X6aIhYpYE$CZpx^*K78*=Ab*{J{T|mx?^9kd1hfb6Nx-2-
za}Cg&JMA6F*S`bEm;VZoFMmJK+r9q=<oiDgRQFz^e0=%hHK|^wF%z}^t@b|U=W3ro
zq4wz%er5kXZ9ClN4G)F@(OwJQ`@X>pY7_V5-K*zq`u_%4TGWR6CBEpY28z=w7?rpP
zh~`^>{Piz;&q~w2$H-3@+N@%sAKlnuOVNBb%KHSNt=-=p(L2zw-#T>ZRjYjQFuQA^
z4;2zsxC$I7aG=0}0tX5lC~%;_fdU5#94K(0z<~k>{_Z&-|5N^@{7!j)@=fKn>V3U@
zY`v$~yLma9^26nm%g2^KDo;~Bz24!=cb8|W)3oy6N1x8ssaqYL;i#DPF6R?E;1I9?
zyu$&Og@lKJMc{C-7*v2Gz>%O590jU?+*0|^#{iX;|Icw9vkV*ujt3_Io$6KkNrWeZ
zQ^2W!qcmnYr~yiU8`OLEdKNwimrly*?|~f?vZr`boPyh(YaXXZd_GBrrcReMx%)N*
zE9`^!^VFQxm*~ubB8R-VW9(@-_b;ivsND+o;_oiizT{TnWC|ZjrU$)qT<h#<qbO%a
zlAJ`+-!{9anI=<@@*F_>MTBZw*JR68N!YliaPCm8>a?PG-@qtzTACE&pQv*4=K5Vs
z`{H;hm~8txd*YveoHC~8yGPFn9{+9UC)t0UTl3p5GIjJ;XUUrRTkVZX*{y3Iw3pxZ
zWc#lM&fBe4#?Sn2+8@8h-AjEh?Mrq)D7r4lr^3C<fg(n~gauwtqjk5|=$vQMocd&>
zU;jHIYZ|O+)p<3d?3~tpm7iX9g89RTAN+I9wcVQ;h1?Ty;4iuU4^_6tk7NCBgs4Yd
zGXeW;_)97i(V8p0u>QZd^<Vm5L-CJp|Gyi3{}K2izrgng6s{)j-PHBBTE<`hCmR2P
zjqtZRg71wkjsF%P9WVqW2e$(G6M84FXQjQ@_s^=M@CF(t{Ec0I4gXKFuvkA_1^>_G
g!+ZG+YJlCX=dW%57tSBCAIe6m^l&ZsOP@db55$o82LJ#7

literal 0
HcmV?d00001

diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/Release_Notes.html b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/Release_Notes.html
new file mode 100644
index 0000000..633e42e
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/Release_Notes.html
@@ -0,0 +1,342 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:w="urn:schemas-microsoft-com:office:word" xmlns="http://www.w3.org/TR/REC-html40"><head>
+
+
+
+
+
+
+
+
+<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+<link rel="File-List" href="Library_files/filelist.xml">
+<link rel="Edit-Time-Data" href="Library_files/editdata.mso"><!--[if !mso]> <style> v\:* {behavior:url(#default#VML);} o\:* {behavior:url(#default#VML);} w\:* {behavior:url(#default#VML);} .shape {behavior:url(#default#VML);} </style> <![endif]--><title>Release Notes for STM32F10x Standard Peripherals Library Drivers</title><!--[if gte mso 9]><xml> <o:DocumentProperties> <o:Author>STMicroelectronics</o:Author> <o:LastAuthor>STMicroelectronics</o:LastAuthor> <o:Revision>37</o:Revision> <o:TotalTime>136</o:TotalTime> <o:Created>2009-02-27T19:26:00Z</o:Created> <o:LastSaved>2009-03-01T17:56:00Z</o:LastSaved> <o:Pages>1</o:Pages> <o:Words>522</o:Words> <o:Characters>2977</o:Characters> <o:Company>STMicroelectronics</o:Company> <o:Lines>24</o:Lines> <o:Paragraphs>6</o:Paragraphs> <o:CharactersWithSpaces>3493</o:CharactersWithSpaces> <o:Version>11.6568</o:Version> </o:DocumentProperties> </xml><![endif]--><!--[if gte mso 9]><xml> <w:WordDocument> <w:Zoom>110</w:Zoom> <w:ValidateAgainstSchemas/> <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid> <w:IgnoreMixedContent>false</w:IgnoreMixedContent> <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText> <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel> </w:WordDocument> </xml><![endif]--><!--[if gte mso 9]><xml> <w:LatentStyles DefLockedState="false" LatentStyleCount="156"> </w:LatentStyles> </xml><![endif]-->
+
+
+
+<style>
+<!--
+/* Style Definitions */
+p.MsoNormal, li.MsoNormal, div.MsoNormal
+{mso-style-parent:"";
+margin:0in;
+margin-bottom:.0001pt;
+mso-pagination:widow-orphan;
+font-size:12.0pt;
+font-family:"Times New Roman";
+mso-fareast-font-family:"Times New Roman";}
+h2
+{mso-style-next:Normal;
+margin-top:12.0pt;
+margin-right:0in;
+margin-bottom:3.0pt;
+margin-left:0in;
+mso-pagination:widow-orphan;
+page-break-after:avoid;
+mso-outline-level:2;
+font-size:14.0pt;
+font-family:Arial;
+font-weight:bold;
+font-style:italic;}
+a:link, span.MsoHyperlink
+{color:blue;
+text-decoration:underline;
+text-underline:single;}
+a:visited, span.MsoHyperlinkFollowed
+{color:blue;
+text-decoration:underline;
+text-underline:single;}
+p
+{mso-margin-top-alt:auto;
+margin-right:0in;
+mso-margin-bottom-alt:auto;
+margin-left:0in;
+mso-pagination:widow-orphan;
+font-size:12.0pt;
+font-family:"Times New Roman";
+mso-fareast-font-family:"Times New Roman";}
+@page Section1
+{size:8.5in 11.0in;
+margin:1.0in 1.25in 1.0in 1.25in;
+mso-header-margin:.5in;
+mso-footer-margin:.5in;
+mso-paper-source:0;}
+div.Section1
+{page:Section1;}
+-->
+</style><!--[if gte mso 10]> <style> /* Style Definitions */ table.MsoNormalTable {mso-style-name:"Table Normal"; mso-tstyle-rowband-size:0; mso-tstyle-colband-size:0; mso-style-noshow:yes; mso-style-parent:""; mso-padding-alt:0in 5.4pt 0in 5.4pt; mso-para-margin:0in; mso-para-margin-bottom:.0001pt; mso-pagination:widow-orphan; font-size:10.0pt; font-family:"Times New Roman"; mso-ansi-language:#0400; mso-fareast-language:#0400; mso-bidi-language:#0400;} </style> <![endif]--><!--[if gte mso 9]><xml> <o:shapedefaults v:ext="edit" spidmax="5122"/> </xml><![endif]--><!--[if gte mso 9]><xml> <o:shapelayout v:ext="edit"> <o:idmap v:ext="edit" data="1"/> </o:shapelayout></xml><![endif]--></head>
+<body lang="EN-US" link="blue" vlink="blue">
+<div class="Section1">
+<p class="MsoNormal"><span style="font-family: Arial;"><o:p><br>
+</o:p></span></p>
+<div align="center">
+<table class="MsoNormalTable" style="width: 675pt;" border="0" cellpadding="0" cellspacing="0" width="900">
+<tbody>
+<tr style="">
+<td style="padding: 0cm;" valign="top">
+<table class="MsoNormalTable" style="width: 675pt;" border="0" cellpadding="0" cellspacing="0" width="900">
+<tbody>
+          <tr>
+            <td style="vertical-align: top;"><span style="font-size: 8pt; font-family: Arial; color: blue;"><a href="../../Release_Notes.html">Back to Release page</a></span></td>
+          </tr>
+<tr style="">
+<td style="padding: 1.5pt;">
+<h1 style="margin-bottom: 18pt; text-align: center;" align="center"><span style="font-size: 20pt; font-family: Verdana; color: rgb(51, 102, 255);">Release
+Notes for STM32F10x Standard Peripherals Library Drivers
+(StdPeriph_Driver)</span><span style="font-size: 20pt; font-family: Verdana;"><o:p></o:p></span></h1>
+<p class="MsoNormal" style="text-align: center;" align="center"><span style="font-size: 10pt; font-family: Arial; color: black;">Copyright 2011 STMicroelectronics</span><span style="color: black;"><u1:p></u1:p><o:p></o:p></span></p>
+<p class="MsoNormal" style="text-align: center;" align="center"><span style="font-size: 10pt; font-family: Arial; color: black;"><img alt="" id="_x0000_i1025" src="../../_htmresc/logo.bmp" style="border: 0px solid ; width: 86px; height: 65px;"></span><span style="font-size: 10pt;"><o:p></o:p></span></p>
+</td>
+</tr>
+</tbody>
+</table>
+<p class="MsoNormal"><span style="font-family: Arial; display: none;"><o:p>&nbsp;</o:p></span></p>
+<table class="MsoNormalTable" style="width: 675pt;" border="0" cellpadding="0" width="900">
+<tbody>
+<tr>
+<td style="padding: 0cm;" valign="top">
+<h2 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial;"><span style="font-size: 12pt; color: white;">Contents<o:p></o:p></span></h2>
+<ol style="margin-top: 0cm;" start="1" type="1">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"><a href="#History">STM32F10x Standard Peripherals Library
+Drivers update History</a><o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"><a href="#License">License</a><o:p></o:p></span></li>
+</ol>
+<span style="font-family: &quot;Times New Roman&quot;;">
+</span>
+<h2 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial;"><a name="History"></a><span style="font-size: 12pt; color: white;">STM32F10x Standard
+Peripherals Library Drivers&nbsp; update History</span></h2><br>
+            <h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; margin-right: 500pt; width: 167px;"><span style="font-size: 10pt; font-family: Arial; color: white;">V3.5.0 / 11-March-2011<o:p></o:p></span></h3>
+            <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 18pt;"><b style=""><u><span style="font-size: 10pt; font-family: Verdana; color: black;">Main
+Changes<o:p></o:p></span></u></b></p>
+
+            <ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_can.h/.c files:</span></li>
+              <ul>
+                <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Add 5 new functions</span></li>
+                <ul>
+                  <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">3
+new functions controlling the counter errors: CAN_GetLastErrorCode(),
+CAN_GetReceiveErrorCounter() and CAN_GetLSBTransmitErrorCounter().</span></li>
+                </ul>
+                <ul>
+                  <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">1 new function to select the CAN operating mode: CAN_OperatingModeRequest().</span></li>
+                </ul>
+                <ul>
+                  <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">1 new function to support CAN TT mode: CAN_TTComModeCmd().</span><span style="font-size: 10pt; font-family: Verdana;"><br>
+  </span></li>
+                </ul>
+                <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">CAN_TransmitStatus() function updated to support all CAN transmit intermediate states<br>
+                  </span></li>
+              </ul>
+              <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_i2c.h/.c files:</span></li>
+              <ul>
+                <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Add 1 new function:</span></li>
+                <ul>
+                  <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">I2C_NACKPositionConfig():
+This function configures the same bit (POS) as I2C_PECPositionConfig()
+but is intended to be used in I2C mode while I2C_PECPositionConfig() is
+intended to used in SMBUS mode.</span></li>
+                </ul>
+              </ul>
+              <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_tim.h/.c files:</span></li>
+              <ul>
+                <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Change the <span style="font-style: italic;">TIM_DMABurstLength_xBytes</span> definitions to <span style="font-style: italic;">TIM_DMABurstLength_xTansfers</span><br>
+                  </span></li>
+              </ul>
+
+
+            </ul>
+
+            <h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; margin-right: 558.05pt;"><span style="font-size: 10pt; font-family: Arial; color: white;">3.4.0
+- 10/15/2010</span></h3>
+
+            <ol style="margin-top: 0in;" start="1" type="1">
+<li class="MsoNormal" style=""><b><i><span style="font-size: 10pt; font-family: Verdana;">General</span></i></b><i><span style="font-size: 10pt; font-family: Verdana;"> </span></i><i><span style="font-size: 10pt;"><o:p></o:p></span></i></li>
+            </ol>
+
+            <ul style="margin-top: 0in;" type="disc">
+<li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Add support for <span style="font-weight: bold;">STM32F10x High-density value line </span>devices.</span></li>
+            </ul>
+
+            <ol style="margin-top: 0in;" start="2" type="1">
+<li class="MsoNormal" style=""><b><i><span style="font-size: 10pt; font-family: Verdana;">STM32F10x_StdPeriph_Driver</span></i></b><b><i><span style="font-size: 10pt;"><o:p></o:p></span></i></b></li>
+            </ol>
+
+
+            <ul style="margin-top: 0in;" type="disc">
+
+              <li class="MsoNormal"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_bkp.h/.c</span></li>
+              <ul>
+<li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">Delete BKP registers definition from stm32f10x_bkp.c and use defines within stm32f10x.h file. </span></span></li>
+              </ul>
+              <li class="MsoNormal"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_can.h/.c</span></li>
+              <ul>
+<li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">Delete CAN registers definition from stm32f10x_can.c and use defines within stm32f10x.h file.<br>
+</span></span></li>
+                <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">Update the wording of some defines and Asserts macro. <br>
+                  </span></span></li>
+                <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">CAN_GetFlagStatus()
+and CAN_ClearFlag() functions: updated to support new flags (were not
+supported in previous version). These flags are:&nbsp; CAN_FLAG_RQCP0,
+CAN_FLAG_RQCP1, CAN_FLAG_RQCP2, CAN_FLAG_FMP1, CAN_FLAG_FF1,
+CAN_FLAG_FOV1, CAN_FLAG_FMP0, CAN_FLAG_FF0,&nbsp;&nbsp; CAN_FLAG_FOV0,
+CAN_FLAG_WKU, CAN_FLAG_SLAK and CAN_FLAG_LEC. <br>
+                  </span></span></li>
+                <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">CAN_GetITStatus()
+function: add a check of the interrupt enable bit before getting the
+status of corresponding interrupt pending bit. <br>
+                  </span></span></li>
+                <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">CAN_ClearITPendingBit() function: correct the procedure to clear the interrupt pending bit. <br>
+                  </span></span></li>
+              </ul>
+              <li class="MsoNormal"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_crc.h/.c</span></li>
+              <ul>
+<li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">Delete CRC registers definition from stm32f10x_crc.c and use defines within stm32f10x.h file.</span></span></li>
+              </ul>
+              <li class="MsoNormal"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_dac.h/.c</span></li>
+              <ul>
+<li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">Delete DAC registers definition from stm32f10x_dac.c and use defines within stm32f10x.h file. </span></span></li>
+              </ul>
+              <li class="MsoNormal"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_dbgmcu.h/.c</span></li>
+              <ul>
+<li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">Delete DBGMCU registers definition from stm32f10x_dbgmcu.c and use defines within stm32f10x.h file. </span></span></li>
+              </ul>
+              <li class="MsoNormal"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_dma.h/.c</span></li>
+              <ul>
+<li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">Delete DMA registers definition from stm32f10x_dma.c and use defines within stm32f10x.h file.</span></span></li>
+                <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">Add new function "void DMA_SetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx, uint16_t DataNumber);"<br>
+                  </span></span></li>
+              </ul>
+              <li class="MsoNormal"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_flash.h/.c</span></li>
+              <ul>
+<li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">FLASH functions (Erase and Program) updated to always clear the "PG", "MER" and "PER" bits even in case of TimeOut Error.</span><span style="font-style: italic;"></span></span></li>
+              </ul>
+              <li class="MsoNormal"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_fsmc.h/.c</span></li>
+              <ul>
+<li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">Add new member "FSMC_AsynchronousWait" in "FSMC_NORSRAMInitTypeDef" structure.</span><span style="font-style: italic;"></span></span></li>
+              </ul>
+              <li class="MsoNormal"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_gpio.h/.c</span></li>
+              <ul>
+<li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">GPIO_PinRemapConfig()</span> function: add new values for <span style="font-style: italic;">GPIO_Remap</span> parameter, to support new <span style="font-style: italic;">remap for TIM6, TIM7 and DAC DMA requests, TIM12 and DAC Triggers / DMA2_Channel5 Interrupt mapping.</span></span></li>
+              </ul>
+              <li class="MsoNormal"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_pwr.h/.c</span></li>
+              <ul>
+<li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">Delete PWR registers definition from stm32f10x_pwr.c and use defines within stm32f10x.h and core_cm3.h files.</span></span></li>
+              </ul>
+              <li class="MsoNormal"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_rtc.h/.c</span></li>
+              <ul>
+<li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">Delete RTC registers definition from stm32f10x_rtc.c and use defines within stm32f10x.h file.</span></span></li>
+              </ul>
+              <li class="MsoNormal"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_spi.h/.c</span></li>
+              <ul>
+<li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">Add new definition for I2S Audio Clock frequencies "I2S_AudioFreq_192k".</span></span></li>
+              </ul>
+              <li class="MsoNormal"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_tim.h/.c</span></li>
+<ul><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">Add new definition for TIM Input Capture Polarity "TIM_ICPolarity_BothEdge".</span></span></li></ul>
+
+            </ul>
+
+            <h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; margin-right: 558.05pt;"><span style="font-size: 10pt; font-family: Arial; color: white;">3.3.0
+- 04/16/2010</span></h3>
+
+<ol style="margin-top: 0in;" start="1" type="1"><li class="MsoNormal" style=""><b><i><span style="font-size: 10pt; font-family: Verdana;">General</span></i></b><i><span style="font-size: 10pt; font-family: Verdana;"> </span></i><i><span style="font-size: 10pt;"><o:p></o:p></span></i></li></ol>
+<ul style="margin-top: 0in;" type="disc"><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Add support for <span style="font-weight: bold;">STM32F10x XL-density </span>devices.</span></li><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">I2C driver: events description and management enhancement.</span></li></ul>
+<ol style="margin-top: 0in;" start="2" type="1"><li class="MsoNormal" style=""><b><i><span style="font-size: 10pt; font-family: Verdana;">STM32F10x_StdPeriph_Driver</span></i></b><b><i><span style="font-size: 10pt;"><o:p></o:p></span></i></b></li></ol>
+<ul style="margin-top: 0in;" type="disc"><li class="MsoNormal"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_dbgmcu.h/.c</span></li><ul><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">DBGMCU_Config()</span> function: add new values <span style="font-style: italic;">DBGMCU_TIMx_STOP</span> (x: 9..14) for <span style="font-style: italic;">DBGMCU_Periph</span> parameter.</span></li></ul><li class="MsoNormal"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_flash.h/.c:
+updated to support Bank2 of XL-density devices (up to 1MByte of Flash
+memory). For more details, refer to the description provided within
+stm32f10x_flash.c file.</span></li><li class="MsoNormal"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_gpio.h/.c</span></li><ul><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">GPIO_PinRemapConfig()</span> function: add new values for <span style="font-style: italic;">GPIO_Remap</span> parameter, to support new <span style="font-style: italic;">remap for FSMC_NADV pin and TIM9..11,13,14.</span></span></li></ul><li class="MsoNormal"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_i2c.h/.c: I2C events description and management enhancement. <br></span></li><ul><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">I2C_CheckEvent()</span>
+function: updated to check whether the last event contains the
+I2C_EVENT&nbsp; (instead of check whether the last event is equal to
+I2C_EVENT)<br></span></li></ul><ul><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Add
+detailed description of I2C events and how to manage them using the
+functions provided by this driver. For more information, refer to
+stm32f10x_i2c.h and stm32f10x_i2c.c files.</span></li></ul><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_rcc.h/.c: updated to support TIM9..TIM14 APB clock and reset configuration</span></li><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_tim.h/.c: updated to support new Timers TIM9..TIM14.</span></li><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_sdio.h:&nbsp;</span></li><ul><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">SDIO_SetSDIOReadWaitMode() function: correct values of SDIO_ReadWaitMode parameter<br>change <br>&nbsp;
+#define
+SDIO_ReadWaitMode_CLK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+&nbsp; ((uint32_t)0x00000000)<br>&nbsp; #define
+SDIO_ReadWaitMode_DATA2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+((uint32_t)0x00000001)<br>by<br>&nbsp; #define
+SDIO_ReadWaitMode_CLK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+&nbsp; ((uint32_t)0x00000001)<br>&nbsp; #define
+SDIO_ReadWaitMode_DATA2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+((uint32_t)0x00000000)</span></li></ul></ul>
+<h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; margin-right: 558.05pt;"><span style="font-size: 10pt; font-family: Arial; color: white;">3.2.0
+- 03/01/2010</span></h3>
+<ol style="margin-top: 0in;" start="1" type="1">
+<li class="MsoNormal" style=""><b><i><span style="font-size: 10pt; font-family: Verdana;">General</span></i></b><i><span style="font-size: 10pt; font-family: Verdana;"> </span></i><i><span style="font-size: 10pt;"><o:p></o:p></span></i></li>
+</ol>
+<ul style="margin-top: 0in;" type="disc">
+
+<li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Add support
+for&nbsp;<b>STM32 Low-density Value line (STM32F100x4/6) and
+Medium-density Value line (STM32F100x8/B) devices</b>.</span></li>
+              <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Almost
+peripherals drivers were updated to support Value
+line devices features</span></li>
+              <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Drivers limitations fix and enhancements. </span><span style="font-size: 10pt;"><o:p></o:p></span></li>
+
+</ul>
+<ol style="margin-top: 0in;" start="2" type="1">
+<li class="MsoNormal" style=""><b><i><span style="font-size: 10pt; font-family: Verdana;">STM32F10x_StdPeriph_Driver</span></i></b><b><i><span style="font-size: 10pt;"><o:p></o:p></span></i></b></li>
+</ol>
+<ul style="margin-top: 0in;" type="disc">
+<li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Add new
+firmware driver for CEC peripheral: stm32f10x_cec.h and stm32f10x_cec.c</span></li>
+              <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Timers drivers stm32f10x_tim.h/.c: add support for new General Purpose Timers: TIM15, TIM16 and TIM17.</span></li>
+              <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">RCC driver: add support for new Value peripherals: HDMI-CEC, TIM15, TIM16 and TIM17.</span></li>
+              <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">GPIO driver: add new remap parameters for TIM1, TIM15, TIM16, TIM17 and HDMI-CEC: </span><span style="font-size: 10pt; font-family: Verdana;">GPIO_Remap_TIM1_DMA, </span><span style="font-size: 10pt; font-family: Verdana;">GPIO_Remap_TIM15, GPIO_Remap_TIM16, GPIO_Remap_TIM17, GPIO_Remap_CEC.</span></li>
+              <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">USART
+driver: add support for Oversampling by 8 mode and onebit method. 2
+functions has been added: USART_OverSampling8Cmd() and
+USART_OneBitMethodCmd().<br>
+                </span></li>
+              <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">DAC
+driver: add new functions handling the DAC under run feature:
+DAC_ITConfig(), DAC_GetFlagStatus(), DAC_ClearFlag(), DAC_GetITStatus()
+and DAC_ClearITPendingBit().</span></li>
+              <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">DBGMCU driver: add new parameters for TIM15, TIM16 and TIM17: DBGMCU_TIM15_STOP, DBGMCU_TIM16_STOP, DBGMCU_TIM17_STOP.<br>
+                </span></li>
+              <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">FLASH
+driver: the FLASH_EraseOptionBytes() function updated. This is now just
+erasing the option bytes without modifying the RDP status either
+enabled or disabled.</span></li>
+              <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">PWR
+driver: the PWR_EnterSTOPMode() function updated. When woken up from
+STOP mode, this function resets again the SLEEPDEEP bit in the
+Cortex-M3 System Control register to allow Sleep mode entering.</span></li>
+
+
+</ul>
+<h2 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial;"><a name="License"></a><span style="font-size: 12pt; color: white;">License<o:p></o:p></span></h2>
+<p class="MsoNormal" style="margin: 4.5pt 0cm;"><span style="font-size: 10pt; font-family: Verdana; color: black;">The
+enclosed firmware and all the related documentation are not covered by
+a License Agreement, if you need such License you can contact your
+local STMicroelectronics office.<u1:p></u1:p><o:p></o:p></span></p>
+<p class="MsoNormal"><b style=""><span style="font-size: 10pt; font-family: Verdana; color: black;">THE
+PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO
+SAVE TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR
+ANY DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY
+CLAIMS ARISING FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY
+CUSTOMERS OF THE CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH
+THEIR PRODUCTS. <o:p></o:p></span></b></p>
+<p class="MsoNormal"><span style="color: black;"><o:p>&nbsp;</o:p></span></p>
+<div class="MsoNormal" style="text-align: center;" align="center"><span style="color: black;">
+<hr align="center" size="2" width="100%"></span></div>
+<p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 18pt; text-align: center;" align="center"><span style="font-size: 10pt; font-family: Verdana; color: black;">For
+complete documentation on </span><span style="font-size: 10pt; font-family: Verdana;">STM32(<span style="color: black;">CORTEX M3) 32-Bit Microcontrollers
+visit </span><u><span style="color: blue;"><a href="http://www.st.com/stm32" target="_blank">www.st.com/STM32</a></span></u></span><span style="color: black;"><o:p></o:p></span></p>
+</td>
+</tr>
+</tbody>
+</table>
+<p class="MsoNormal"><span style="font-size: 10pt;"><o:p></o:p></span></p>
+</td>
+</tr>
+</tbody>
+</table>
+</div>
+<p class="MsoNormal"><o:p>&nbsp;</o:p></p>
+</div>
+</body></html>
\ No newline at end of file
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/misc.h b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/misc.h
new file mode 100644
index 0000000..7d401ca
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/misc.h
@@ -0,0 +1,220 @@
+/**
+  ******************************************************************************
+  * @file    misc.h
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file contains all the functions prototypes for the miscellaneous
+  *          firmware library functions (add-on to CMSIS functions).
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __MISC_H
+#define __MISC_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup MISC
+  * @{
+  */
+
+/** @defgroup MISC_Exported_Types
+  * @{
+  */
+
+/**
+  * @brief  NVIC Init Structure definition
+  */
+
+typedef struct
+{
+  uint8_t NVIC_IRQChannel;                    /*!< Specifies the IRQ channel to be enabled or disabled.
+                                                   This parameter can be a value of @ref IRQn_Type
+                                                   (For the complete STM32 Devices IRQ Channels list, please
+                                                    refer to stm32f10x.h file) */
+
+  uint8_t NVIC_IRQChannelPreemptionPriority;  /*!< Specifies the pre-emption priority for the IRQ channel
+                                                   specified in NVIC_IRQChannel. This parameter can be a value
+                                                   between 0 and 15 as described in the table @ref NVIC_Priority_Table */
+
+  uint8_t NVIC_IRQChannelSubPriority;         /*!< Specifies the subpriority level for the IRQ channel specified
+                                                   in NVIC_IRQChannel. This parameter can be a value
+                                                   between 0 and 15 as described in the table @ref NVIC_Priority_Table */
+
+  FunctionalState NVIC_IRQChannelCmd;         /*!< Specifies whether the IRQ channel defined in NVIC_IRQChannel
+                                                   will be enabled or disabled.
+                                                   This parameter can be set either to ENABLE or DISABLE */
+} NVIC_InitTypeDef;
+
+/**
+  * @}
+  */
+
+/** @defgroup NVIC_Priority_Table
+  * @{
+  */
+
+/**
+@code
+ The table below gives the allowed values of the pre-emption priority and subpriority according
+ to the Priority Grouping configuration performed by NVIC_PriorityGroupConfig function
+  ============================================================================================================================
+    NVIC_PriorityGroup   | NVIC_IRQChannelPreemptionPriority | NVIC_IRQChannelSubPriority  | Description
+  ============================================================================================================================
+   NVIC_PriorityGroup_0  |                0                  |            0-15             |   0 bits for pre-emption priority
+                         |                                   |                             |   4 bits for subpriority
+  ----------------------------------------------------------------------------------------------------------------------------
+   NVIC_PriorityGroup_1  |                0-1                |            0-7              |   1 bits for pre-emption priority
+                         |                                   |                             |   3 bits for subpriority
+  ----------------------------------------------------------------------------------------------------------------------------
+   NVIC_PriorityGroup_2  |                0-3                |            0-3              |   2 bits for pre-emption priority
+                         |                                   |                             |   2 bits for subpriority
+  ----------------------------------------------------------------------------------------------------------------------------
+   NVIC_PriorityGroup_3  |                0-7                |            0-1              |   3 bits for pre-emption priority
+                         |                                   |                             |   1 bits for subpriority
+  ----------------------------------------------------------------------------------------------------------------------------
+   NVIC_PriorityGroup_4  |                0-15               |            0                |   4 bits for pre-emption priority
+                         |                                   |                             |   0 bits for subpriority
+  ============================================================================================================================
+@endcode
+*/
+
+/**
+  * @}
+  */
+
+/** @defgroup MISC_Exported_Constants
+  * @{
+  */
+
+/** @defgroup Vector_Table_Base
+  * @{
+  */
+
+#define NVIC_VectTab_RAM             ((uint32_t)0x20000000)
+#define NVIC_VectTab_FLASH           ((uint32_t)0x08000000)
+#define IS_NVIC_VECTTAB(VECTTAB) (((VECTTAB) == NVIC_VectTab_RAM) || \
+                                  ((VECTTAB) == NVIC_VectTab_FLASH))
+/**
+  * @}
+  */
+
+/** @defgroup System_Low_Power
+  * @{
+  */
+
+#define NVIC_LP_SEVONPEND            ((uint8_t)0x10)
+#define NVIC_LP_SLEEPDEEP            ((uint8_t)0x04)
+#define NVIC_LP_SLEEPONEXIT          ((uint8_t)0x02)
+#define IS_NVIC_LP(LP) (((LP) == NVIC_LP_SEVONPEND) || \
+                        ((LP) == NVIC_LP_SLEEPDEEP) || \
+                        ((LP) == NVIC_LP_SLEEPONEXIT))
+/**
+  * @}
+  */
+
+/** @defgroup Preemption_Priority_Group
+  * @{
+  */
+
+#define NVIC_PriorityGroup_0         ((uint32_t)0x700) /*!< 0 bits for pre-emption priority
+                                                            4 bits for subpriority */
+#define NVIC_PriorityGroup_1         ((uint32_t)0x600) /*!< 1 bits for pre-emption priority
+                                                            3 bits for subpriority */
+#define NVIC_PriorityGroup_2         ((uint32_t)0x500) /*!< 2 bits for pre-emption priority
+                                                            2 bits for subpriority */
+#define NVIC_PriorityGroup_3         ((uint32_t)0x400) /*!< 3 bits for pre-emption priority
+                                                            1 bits for subpriority */
+#define NVIC_PriorityGroup_4         ((uint32_t)0x300) /*!< 4 bits for pre-emption priority
+                                                            0 bits for subpriority */
+
+#define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PriorityGroup_0) || \
+                                       ((GROUP) == NVIC_PriorityGroup_1) || \
+                                       ((GROUP) == NVIC_PriorityGroup_2) || \
+                                       ((GROUP) == NVIC_PriorityGroup_3) || \
+                                       ((GROUP) == NVIC_PriorityGroup_4))
+
+#define IS_NVIC_PREEMPTION_PRIORITY(PRIORITY)  ((PRIORITY) < 0x10)
+
+#define IS_NVIC_SUB_PRIORITY(PRIORITY)  ((PRIORITY) < 0x10)
+
+#define IS_NVIC_OFFSET(OFFSET)  ((OFFSET) < 0x000FFFFF)
+
+/**
+  * @}
+  */
+
+/** @defgroup SysTick_clock_source
+  * @{
+  */
+
+#define SysTick_CLKSource_HCLK_Div8    ((uint32_t)0xFFFFFFFB)
+#define SysTick_CLKSource_HCLK         ((uint32_t)0x00000004)
+#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SysTick_CLKSource_HCLK) || \
+                                       ((SOURCE) == SysTick_CLKSource_HCLK_Div8))
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup MISC_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup MISC_Exported_Functions
+  * @{
+  */
+
+void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup);
+void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);
+void NVIC_SetVectorTable(uint32_t NVIC_VectTab, uint32_t Offset);
+void NVIC_SystemLPConfig(uint8_t LowPowerMode, FunctionalState NewState);
+void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __MISC_H */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_adc.h b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_adc.h
new file mode 100644
index 0000000..d1b2653
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_adc.h
@@ -0,0 +1,483 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_adc.h
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file contains all the functions prototypes for the ADC firmware
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F10x_ADC_H
+#define __STM32F10x_ADC_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup ADC
+  * @{
+  */
+
+/** @defgroup ADC_Exported_Types
+  * @{
+  */
+
+/**
+  * @brief  ADC Init structure definition
+  */
+
+typedef struct
+{
+  uint32_t ADC_Mode;                      /*!< Configures the ADC to operate in independent or
+                                               dual mode.
+                                               This parameter can be a value of @ref ADC_mode */
+
+  FunctionalState ADC_ScanConvMode;       /*!< Specifies whether the conversion is performed in
+                                               Scan (multichannels) or Single (one channel) mode.
+                                               This parameter can be set to ENABLE or DISABLE */
+
+  FunctionalState ADC_ContinuousConvMode; /*!< Specifies whether the conversion is performed in
+                                               Continuous or Single mode.
+                                               This parameter can be set to ENABLE or DISABLE. */
+
+  uint32_t ADC_ExternalTrigConv;          /*!< Defines the external trigger used to start the analog
+                                               to digital conversion of regular channels. This parameter
+                                               can be a value of @ref ADC_external_trigger_sources_for_regular_channels_conversion */
+
+  uint32_t ADC_DataAlign;                 /*!< Specifies whether the ADC data alignment is left or right.
+                                               This parameter can be a value of @ref ADC_data_align */
+
+  uint8_t ADC_NbrOfChannel;               /*!< Specifies the number of ADC channels that will be converted
+                                               using the sequencer for regular channel group.
+                                               This parameter must range from 1 to 16. */
+}ADC_InitTypeDef;
+/**
+  * @}
+  */
+
+/** @defgroup ADC_Exported_Constants
+  * @{
+  */
+
+#define IS_ADC_ALL_PERIPH(PERIPH) (((PERIPH) == ADC1) || \
+                                   ((PERIPH) == ADC2) || \
+                                   ((PERIPH) == ADC3))
+
+#define IS_ADC_DMA_PERIPH(PERIPH) (((PERIPH) == ADC1) || \
+                                   ((PERIPH) == ADC3))
+
+/** @defgroup ADC_mode
+  * @{
+  */
+
+#define ADC_Mode_Independent                       ((uint32_t)0x00000000)
+#define ADC_Mode_RegInjecSimult                    ((uint32_t)0x00010000)
+#define ADC_Mode_RegSimult_AlterTrig               ((uint32_t)0x00020000)
+#define ADC_Mode_InjecSimult_FastInterl            ((uint32_t)0x00030000)
+#define ADC_Mode_InjecSimult_SlowInterl            ((uint32_t)0x00040000)
+#define ADC_Mode_InjecSimult                       ((uint32_t)0x00050000)
+#define ADC_Mode_RegSimult                         ((uint32_t)0x00060000)
+#define ADC_Mode_FastInterl                        ((uint32_t)0x00070000)
+#define ADC_Mode_SlowInterl                        ((uint32_t)0x00080000)
+#define ADC_Mode_AlterTrig                         ((uint32_t)0x00090000)
+
+#define IS_ADC_MODE(MODE) (((MODE) == ADC_Mode_Independent) || \
+                           ((MODE) == ADC_Mode_RegInjecSimult) || \
+                           ((MODE) == ADC_Mode_RegSimult_AlterTrig) || \
+                           ((MODE) == ADC_Mode_InjecSimult_FastInterl) || \
+                           ((MODE) == ADC_Mode_InjecSimult_SlowInterl) || \
+                           ((MODE) == ADC_Mode_InjecSimult) || \
+                           ((MODE) == ADC_Mode_RegSimult) || \
+                           ((MODE) == ADC_Mode_FastInterl) || \
+                           ((MODE) == ADC_Mode_SlowInterl) || \
+                           ((MODE) == ADC_Mode_AlterTrig))
+/**
+  * @}
+  */
+
+/** @defgroup ADC_external_trigger_sources_for_regular_channels_conversion
+  * @{
+  */
+
+#define ADC_ExternalTrigConv_T1_CC1                ((uint32_t)0x00000000) /*!< For ADC1 and ADC2 */
+#define ADC_ExternalTrigConv_T1_CC2                ((uint32_t)0x00020000) /*!< For ADC1 and ADC2 */
+#define ADC_ExternalTrigConv_T2_CC2                ((uint32_t)0x00060000) /*!< For ADC1 and ADC2 */
+#define ADC_ExternalTrigConv_T3_TRGO               ((uint32_t)0x00080000) /*!< For ADC1 and ADC2 */
+#define ADC_ExternalTrigConv_T4_CC4                ((uint32_t)0x000A0000) /*!< For ADC1 and ADC2 */
+#define ADC_ExternalTrigConv_Ext_IT11_TIM8_TRGO    ((uint32_t)0x000C0000) /*!< For ADC1 and ADC2 */
+
+#define ADC_ExternalTrigConv_T1_CC3                ((uint32_t)0x00040000) /*!< For ADC1, ADC2 and ADC3 */
+#define ADC_ExternalTrigConv_None                  ((uint32_t)0x000E0000) /*!< For ADC1, ADC2 and ADC3 */
+
+#define ADC_ExternalTrigConv_T3_CC1                ((uint32_t)0x00000000) /*!< For ADC3 only */
+#define ADC_ExternalTrigConv_T2_CC3                ((uint32_t)0x00020000) /*!< For ADC3 only */
+#define ADC_ExternalTrigConv_T8_CC1                ((uint32_t)0x00060000) /*!< For ADC3 only */
+#define ADC_ExternalTrigConv_T8_TRGO               ((uint32_t)0x00080000) /*!< For ADC3 only */
+#define ADC_ExternalTrigConv_T5_CC1                ((uint32_t)0x000A0000) /*!< For ADC3 only */
+#define ADC_ExternalTrigConv_T5_CC3                ((uint32_t)0x000C0000) /*!< For ADC3 only */
+
+#define IS_ADC_EXT_TRIG(REGTRIG) (((REGTRIG) == ADC_ExternalTrigConv_T1_CC1) || \
+                                  ((REGTRIG) == ADC_ExternalTrigConv_T1_CC2) || \
+                                  ((REGTRIG) == ADC_ExternalTrigConv_T1_CC3) || \
+                                  ((REGTRIG) == ADC_ExternalTrigConv_T2_CC2) || \
+                                  ((REGTRIG) == ADC_ExternalTrigConv_T3_TRGO) || \
+                                  ((REGTRIG) == ADC_ExternalTrigConv_T4_CC4) || \
+                                  ((REGTRIG) == ADC_ExternalTrigConv_Ext_IT11_TIM8_TRGO) || \
+                                  ((REGTRIG) == ADC_ExternalTrigConv_None) || \
+                                  ((REGTRIG) == ADC_ExternalTrigConv_T3_CC1) || \
+                                  ((REGTRIG) == ADC_ExternalTrigConv_T2_CC3) || \
+                                  ((REGTRIG) == ADC_ExternalTrigConv_T8_CC1) || \
+                                  ((REGTRIG) == ADC_ExternalTrigConv_T8_TRGO) || \
+                                  ((REGTRIG) == ADC_ExternalTrigConv_T5_CC1) || \
+                                  ((REGTRIG) == ADC_ExternalTrigConv_T5_CC3))
+/**
+  * @}
+  */
+
+/** @defgroup ADC_data_align
+  * @{
+  */
+
+#define ADC_DataAlign_Right                        ((uint32_t)0x00000000)
+#define ADC_DataAlign_Left                         ((uint32_t)0x00000800)
+#define IS_ADC_DATA_ALIGN(ALIGN) (((ALIGN) == ADC_DataAlign_Right) || \
+                                  ((ALIGN) == ADC_DataAlign_Left))
+/**
+  * @}
+  */
+
+/** @defgroup ADC_channels
+  * @{
+  */
+
+#define ADC_Channel_0                               ((uint8_t)0x00)
+#define ADC_Channel_1                               ((uint8_t)0x01)
+#define ADC_Channel_2                               ((uint8_t)0x02)
+#define ADC_Channel_3                               ((uint8_t)0x03)
+#define ADC_Channel_4                               ((uint8_t)0x04)
+#define ADC_Channel_5                               ((uint8_t)0x05)
+#define ADC_Channel_6                               ((uint8_t)0x06)
+#define ADC_Channel_7                               ((uint8_t)0x07)
+#define ADC_Channel_8                               ((uint8_t)0x08)
+#define ADC_Channel_9                               ((uint8_t)0x09)
+#define ADC_Channel_10                              ((uint8_t)0x0A)
+#define ADC_Channel_11                              ((uint8_t)0x0B)
+#define ADC_Channel_12                              ((uint8_t)0x0C)
+#define ADC_Channel_13                              ((uint8_t)0x0D)
+#define ADC_Channel_14                              ((uint8_t)0x0E)
+#define ADC_Channel_15                              ((uint8_t)0x0F)
+#define ADC_Channel_16                              ((uint8_t)0x10)
+#define ADC_Channel_17                              ((uint8_t)0x11)
+
+#define ADC_Channel_TempSensor                      ((uint8_t)ADC_Channel_16)
+#define ADC_Channel_Vrefint                         ((uint8_t)ADC_Channel_17)
+
+#define IS_ADC_CHANNEL(CHANNEL) (((CHANNEL) == ADC_Channel_0) || ((CHANNEL) == ADC_Channel_1) || \
+                                 ((CHANNEL) == ADC_Channel_2) || ((CHANNEL) == ADC_Channel_3) || \
+                                 ((CHANNEL) == ADC_Channel_4) || ((CHANNEL) == ADC_Channel_5) || \
+                                 ((CHANNEL) == ADC_Channel_6) || ((CHANNEL) == ADC_Channel_7) || \
+                                 ((CHANNEL) == ADC_Channel_8) || ((CHANNEL) == ADC_Channel_9) || \
+                                 ((CHANNEL) == ADC_Channel_10) || ((CHANNEL) == ADC_Channel_11) || \
+                                 ((CHANNEL) == ADC_Channel_12) || ((CHANNEL) == ADC_Channel_13) || \
+                                 ((CHANNEL) == ADC_Channel_14) || ((CHANNEL) == ADC_Channel_15) || \
+                                 ((CHANNEL) == ADC_Channel_16) || ((CHANNEL) == ADC_Channel_17))
+/**
+  * @}
+  */
+
+/** @defgroup ADC_sampling_time
+  * @{
+  */
+
+#define ADC_SampleTime_1Cycles5                    ((uint8_t)0x00)
+#define ADC_SampleTime_7Cycles5                    ((uint8_t)0x01)
+#define ADC_SampleTime_13Cycles5                   ((uint8_t)0x02)
+#define ADC_SampleTime_28Cycles5                   ((uint8_t)0x03)
+#define ADC_SampleTime_41Cycles5                   ((uint8_t)0x04)
+#define ADC_SampleTime_55Cycles5                   ((uint8_t)0x05)
+#define ADC_SampleTime_71Cycles5                   ((uint8_t)0x06)
+#define ADC_SampleTime_239Cycles5                  ((uint8_t)0x07)
+#define IS_ADC_SAMPLE_TIME(TIME) (((TIME) == ADC_SampleTime_1Cycles5) || \
+                                  ((TIME) == ADC_SampleTime_7Cycles5) || \
+                                  ((TIME) == ADC_SampleTime_13Cycles5) || \
+                                  ((TIME) == ADC_SampleTime_28Cycles5) || \
+                                  ((TIME) == ADC_SampleTime_41Cycles5) || \
+                                  ((TIME) == ADC_SampleTime_55Cycles5) || \
+                                  ((TIME) == ADC_SampleTime_71Cycles5) || \
+                                  ((TIME) == ADC_SampleTime_239Cycles5))
+/**
+  * @}
+  */
+
+/** @defgroup ADC_external_trigger_sources_for_injected_channels_conversion
+  * @{
+  */
+
+#define ADC_ExternalTrigInjecConv_T2_TRGO           ((uint32_t)0x00002000) /*!< For ADC1 and ADC2 */
+#define ADC_ExternalTrigInjecConv_T2_CC1            ((uint32_t)0x00003000) /*!< For ADC1 and ADC2 */
+#define ADC_ExternalTrigInjecConv_T3_CC4            ((uint32_t)0x00004000) /*!< For ADC1 and ADC2 */
+#define ADC_ExternalTrigInjecConv_T4_TRGO           ((uint32_t)0x00005000) /*!< For ADC1 and ADC2 */
+#define ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4 ((uint32_t)0x00006000) /*!< For ADC1 and ADC2 */
+
+#define ADC_ExternalTrigInjecConv_T1_TRGO           ((uint32_t)0x00000000) /*!< For ADC1, ADC2 and ADC3 */
+#define ADC_ExternalTrigInjecConv_T1_CC4            ((uint32_t)0x00001000) /*!< For ADC1, ADC2 and ADC3 */
+#define ADC_ExternalTrigInjecConv_None              ((uint32_t)0x00007000) /*!< For ADC1, ADC2 and ADC3 */
+
+#define ADC_ExternalTrigInjecConv_T4_CC3            ((uint32_t)0x00002000) /*!< For ADC3 only */
+#define ADC_ExternalTrigInjecConv_T8_CC2            ((uint32_t)0x00003000) /*!< For ADC3 only */
+#define ADC_ExternalTrigInjecConv_T8_CC4            ((uint32_t)0x00004000) /*!< For ADC3 only */
+#define ADC_ExternalTrigInjecConv_T5_TRGO           ((uint32_t)0x00005000) /*!< For ADC3 only */
+#define ADC_ExternalTrigInjecConv_T5_CC4            ((uint32_t)0x00006000) /*!< For ADC3 only */
+
+#define IS_ADC_EXT_INJEC_TRIG(INJTRIG) (((INJTRIG) == ADC_ExternalTrigInjecConv_T1_TRGO) || \
+                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T1_CC4) || \
+                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_TRGO) || \
+                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_CC1) || \
+                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T3_CC4) || \
+                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_TRGO) || \
+                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4) || \
+                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_None) || \
+                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC3) || \
+                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC2) || \
+                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC4) || \
+                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T5_TRGO) || \
+                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T5_CC4))
+/**
+  * @}
+  */
+
+/** @defgroup ADC_injected_channel_selection
+  * @{
+  */
+
+#define ADC_InjectedChannel_1                       ((uint8_t)0x14)
+#define ADC_InjectedChannel_2                       ((uint8_t)0x18)
+#define ADC_InjectedChannel_3                       ((uint8_t)0x1C)
+#define ADC_InjectedChannel_4                       ((uint8_t)0x20)
+#define IS_ADC_INJECTED_CHANNEL(CHANNEL) (((CHANNEL) == ADC_InjectedChannel_1) || \
+                                          ((CHANNEL) == ADC_InjectedChannel_2) || \
+                                          ((CHANNEL) == ADC_InjectedChannel_3) || \
+                                          ((CHANNEL) == ADC_InjectedChannel_4))
+/**
+  * @}
+  */
+
+/** @defgroup ADC_analog_watchdog_selection
+  * @{
+  */
+
+#define ADC_AnalogWatchdog_SingleRegEnable         ((uint32_t)0x00800200)
+#define ADC_AnalogWatchdog_SingleInjecEnable       ((uint32_t)0x00400200)
+#define ADC_AnalogWatchdog_SingleRegOrInjecEnable  ((uint32_t)0x00C00200)
+#define ADC_AnalogWatchdog_AllRegEnable            ((uint32_t)0x00800000)
+#define ADC_AnalogWatchdog_AllInjecEnable          ((uint32_t)0x00400000)
+#define ADC_AnalogWatchdog_AllRegAllInjecEnable    ((uint32_t)0x00C00000)
+#define ADC_AnalogWatchdog_None                    ((uint32_t)0x00000000)
+
+#define IS_ADC_ANALOG_WATCHDOG(WATCHDOG) (((WATCHDOG) == ADC_AnalogWatchdog_SingleRegEnable) || \
+                                          ((WATCHDOG) == ADC_AnalogWatchdog_SingleInjecEnable) || \
+                                          ((WATCHDOG) == ADC_AnalogWatchdog_SingleRegOrInjecEnable) || \
+                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllRegEnable) || \
+                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllInjecEnable) || \
+                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllRegAllInjecEnable) || \
+                                          ((WATCHDOG) == ADC_AnalogWatchdog_None))
+/**
+  * @}
+  */
+
+/** @defgroup ADC_interrupts_definition
+  * @{
+  */
+
+#define ADC_IT_EOC                                 ((uint16_t)0x0220)
+#define ADC_IT_AWD                                 ((uint16_t)0x0140)
+#define ADC_IT_JEOC                                ((uint16_t)0x0480)
+
+#define IS_ADC_IT(IT) ((((IT) & (uint16_t)0xF81F) == 0x00) && ((IT) != 0x00))
+
+#define IS_ADC_GET_IT(IT) (((IT) == ADC_IT_EOC) || ((IT) == ADC_IT_AWD) || \
+                           ((IT) == ADC_IT_JEOC))
+/**
+  * @}
+  */
+
+/** @defgroup ADC_flags_definition
+  * @{
+  */
+
+#define ADC_FLAG_AWD                               ((uint8_t)0x01)
+#define ADC_FLAG_EOC                               ((uint8_t)0x02)
+#define ADC_FLAG_JEOC                              ((uint8_t)0x04)
+#define ADC_FLAG_JSTRT                             ((uint8_t)0x08)
+#define ADC_FLAG_STRT                              ((uint8_t)0x10)
+#define IS_ADC_CLEAR_FLAG(FLAG) ((((FLAG) & (uint8_t)0xE0) == 0x00) && ((FLAG) != 0x00))
+#define IS_ADC_GET_FLAG(FLAG) (((FLAG) == ADC_FLAG_AWD) || ((FLAG) == ADC_FLAG_EOC) || \
+                               ((FLAG) == ADC_FLAG_JEOC) || ((FLAG)== ADC_FLAG_JSTRT) || \
+                               ((FLAG) == ADC_FLAG_STRT))
+/**
+  * @}
+  */
+
+/** @defgroup ADC_thresholds
+  * @{
+  */
+
+#define IS_ADC_THRESHOLD(THRESHOLD) ((THRESHOLD) <= 0xFFF)
+
+/**
+  * @}
+  */
+
+/** @defgroup ADC_injected_offset
+  * @{
+  */
+
+#define IS_ADC_OFFSET(OFFSET) ((OFFSET) <= 0xFFF)
+
+/**
+  * @}
+  */
+
+/** @defgroup ADC_injected_length
+  * @{
+  */
+
+#define IS_ADC_INJECTED_LENGTH(LENGTH) (((LENGTH) >= 0x1) && ((LENGTH) <= 0x4))
+
+/**
+  * @}
+  */
+
+/** @defgroup ADC_injected_rank
+  * @{
+  */
+
+#define IS_ADC_INJECTED_RANK(RANK) (((RANK) >= 0x1) && ((RANK) <= 0x4))
+
+/**
+  * @}
+  */
+
+
+/** @defgroup ADC_regular_length
+  * @{
+  */
+
+#define IS_ADC_REGULAR_LENGTH(LENGTH) (((LENGTH) >= 0x1) && ((LENGTH) <= 0x10))
+/**
+  * @}
+  */
+
+/** @defgroup ADC_regular_rank
+  * @{
+  */
+
+#define IS_ADC_REGULAR_RANK(RANK) (((RANK) >= 0x1) && ((RANK) <= 0x10))
+
+/**
+  * @}
+  */
+
+/** @defgroup ADC_regular_discontinuous_mode_number
+  * @{
+  */
+
+#define IS_ADC_REGULAR_DISC_NUMBER(NUMBER) (((NUMBER) >= 0x1) && ((NUMBER) <= 0x8))
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup ADC_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup ADC_Exported_Functions
+  * @{
+  */
+
+void ADC_DeInit(ADC_TypeDef* ADCx);
+void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct);
+void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct);
+void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState);
+void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState);
+void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState);
+void ADC_ResetCalibration(ADC_TypeDef* ADCx);
+FlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx);
+void ADC_StartCalibration(ADC_TypeDef* ADCx);
+FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx);
+void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
+FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx);
+void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number);
+void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
+void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);
+void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
+uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx);
+uint32_t ADC_GetDualModeConversionValue(void);
+void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
+void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
+void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv);
+void ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
+void ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
+FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx);
+void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);
+void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length);
+void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset);
+uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel);
+void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog);
+void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold, uint16_t LowThreshold);
+void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel);
+void ADC_TempSensorVrefintCmd(FunctionalState NewState);
+FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG);
+void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG);
+ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT);
+void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__STM32F10x_ADC_H */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_bkp.h b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_bkp.h
new file mode 100644
index 0000000..b620753
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_bkp.h
@@ -0,0 +1,195 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_bkp.h
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file contains all the functions prototypes for the BKP firmware
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F10x_BKP_H
+#define __STM32F10x_BKP_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup BKP
+  * @{
+  */
+
+/** @defgroup BKP_Exported_Types
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup BKP_Exported_Constants
+  * @{
+  */
+
+/** @defgroup Tamper_Pin_active_level
+  * @{
+  */
+
+#define BKP_TamperPinLevel_High           ((uint16_t)0x0000)
+#define BKP_TamperPinLevel_Low            ((uint16_t)0x0001)
+#define IS_BKP_TAMPER_PIN_LEVEL(LEVEL) (((LEVEL) == BKP_TamperPinLevel_High) || \
+                                        ((LEVEL) == BKP_TamperPinLevel_Low))
+/**
+  * @}
+  */
+
+/** @defgroup RTC_output_source_to_output_on_the_Tamper_pin
+  * @{
+  */
+
+#define BKP_RTCOutputSource_None          ((uint16_t)0x0000)
+#define BKP_RTCOutputSource_CalibClock    ((uint16_t)0x0080)
+#define BKP_RTCOutputSource_Alarm         ((uint16_t)0x0100)
+#define BKP_RTCOutputSource_Second        ((uint16_t)0x0300)
+#define IS_BKP_RTC_OUTPUT_SOURCE(SOURCE) (((SOURCE) == BKP_RTCOutputSource_None) || \
+                                          ((SOURCE) == BKP_RTCOutputSource_CalibClock) || \
+                                          ((SOURCE) == BKP_RTCOutputSource_Alarm) || \
+                                          ((SOURCE) == BKP_RTCOutputSource_Second))
+/**
+  * @}
+  */
+
+/** @defgroup Data_Backup_Register
+  * @{
+  */
+
+#define BKP_DR1                           ((uint16_t)0x0004)
+#define BKP_DR2                           ((uint16_t)0x0008)
+#define BKP_DR3                           ((uint16_t)0x000C)
+#define BKP_DR4                           ((uint16_t)0x0010)
+#define BKP_DR5                           ((uint16_t)0x0014)
+#define BKP_DR6                           ((uint16_t)0x0018)
+#define BKP_DR7                           ((uint16_t)0x001C)
+#define BKP_DR8                           ((uint16_t)0x0020)
+#define BKP_DR9                           ((uint16_t)0x0024)
+#define BKP_DR10                          ((uint16_t)0x0028)
+#define BKP_DR11                          ((uint16_t)0x0040)
+#define BKP_DR12                          ((uint16_t)0x0044)
+#define BKP_DR13                          ((uint16_t)0x0048)
+#define BKP_DR14                          ((uint16_t)0x004C)
+#define BKP_DR15                          ((uint16_t)0x0050)
+#define BKP_DR16                          ((uint16_t)0x0054)
+#define BKP_DR17                          ((uint16_t)0x0058)
+#define BKP_DR18                          ((uint16_t)0x005C)
+#define BKP_DR19                          ((uint16_t)0x0060)
+#define BKP_DR20                          ((uint16_t)0x0064)
+#define BKP_DR21                          ((uint16_t)0x0068)
+#define BKP_DR22                          ((uint16_t)0x006C)
+#define BKP_DR23                          ((uint16_t)0x0070)
+#define BKP_DR24                          ((uint16_t)0x0074)
+#define BKP_DR25                          ((uint16_t)0x0078)
+#define BKP_DR26                          ((uint16_t)0x007C)
+#define BKP_DR27                          ((uint16_t)0x0080)
+#define BKP_DR28                          ((uint16_t)0x0084)
+#define BKP_DR29                          ((uint16_t)0x0088)
+#define BKP_DR30                          ((uint16_t)0x008C)
+#define BKP_DR31                          ((uint16_t)0x0090)
+#define BKP_DR32                          ((uint16_t)0x0094)
+#define BKP_DR33                          ((uint16_t)0x0098)
+#define BKP_DR34                          ((uint16_t)0x009C)
+#define BKP_DR35                          ((uint16_t)0x00A0)
+#define BKP_DR36                          ((uint16_t)0x00A4)
+#define BKP_DR37                          ((uint16_t)0x00A8)
+#define BKP_DR38                          ((uint16_t)0x00AC)
+#define BKP_DR39                          ((uint16_t)0x00B0)
+#define BKP_DR40                          ((uint16_t)0x00B4)
+#define BKP_DR41                          ((uint16_t)0x00B8)
+#define BKP_DR42                          ((uint16_t)0x00BC)
+
+#define IS_BKP_DR(DR) (((DR) == BKP_DR1)  || ((DR) == BKP_DR2)  || ((DR) == BKP_DR3)  || \
+                       ((DR) == BKP_DR4)  || ((DR) == BKP_DR5)  || ((DR) == BKP_DR6)  || \
+                       ((DR) == BKP_DR7)  || ((DR) == BKP_DR8)  || ((DR) == BKP_DR9)  || \
+                       ((DR) == BKP_DR10) || ((DR) == BKP_DR11) || ((DR) == BKP_DR12) || \
+                       ((DR) == BKP_DR13) || ((DR) == BKP_DR14) || ((DR) == BKP_DR15) || \
+                       ((DR) == BKP_DR16) || ((DR) == BKP_DR17) || ((DR) == BKP_DR18) || \
+                       ((DR) == BKP_DR19) || ((DR) == BKP_DR20) || ((DR) == BKP_DR21) || \
+                       ((DR) == BKP_DR22) || ((DR) == BKP_DR23) || ((DR) == BKP_DR24) || \
+                       ((DR) == BKP_DR25) || ((DR) == BKP_DR26) || ((DR) == BKP_DR27) || \
+                       ((DR) == BKP_DR28) || ((DR) == BKP_DR29) || ((DR) == BKP_DR30) || \
+                       ((DR) == BKP_DR31) || ((DR) == BKP_DR32) || ((DR) == BKP_DR33) || \
+                       ((DR) == BKP_DR34) || ((DR) == BKP_DR35) || ((DR) == BKP_DR36) || \
+                       ((DR) == BKP_DR37) || ((DR) == BKP_DR38) || ((DR) == BKP_DR39) || \
+                       ((DR) == BKP_DR40) || ((DR) == BKP_DR41) || ((DR) == BKP_DR42))
+
+#define IS_BKP_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x7F)
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup BKP_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup BKP_Exported_Functions
+  * @{
+  */
+
+void BKP_DeInit(void);
+void BKP_TamperPinLevelConfig(uint16_t BKP_TamperPinLevel);
+void BKP_TamperPinCmd(FunctionalState NewState);
+void BKP_ITConfig(FunctionalState NewState);
+void BKP_RTCOutputConfig(uint16_t BKP_RTCOutputSource);
+void BKP_SetRTCCalibrationValue(uint8_t CalibrationValue);
+void BKP_WriteBackupRegister(uint16_t BKP_DR, uint16_t Data);
+uint16_t BKP_ReadBackupRegister(uint16_t BKP_DR);
+FlagStatus BKP_GetFlagStatus(void);
+void BKP_ClearFlag(void);
+ITStatus BKP_GetITStatus(void);
+void BKP_ClearITPendingBit(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F10x_BKP_H */
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_can.h b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_can.h
new file mode 100644
index 0000000..648f747
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_can.h
@@ -0,0 +1,697 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_can.h
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file contains all the functions prototypes for the CAN firmware
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F10x_CAN_H
+#define __STM32F10x_CAN_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup CAN
+  * @{
+  */
+
+/** @defgroup CAN_Exported_Types
+  * @{
+  */
+
+#define IS_CAN_ALL_PERIPH(PERIPH) (((PERIPH) == CAN1) || \
+                                   ((PERIPH) == CAN2))
+
+/**
+  * @brief  CAN init structure definition
+  */
+
+typedef struct
+{
+  uint16_t CAN_Prescaler;   /*!< Specifies the length of a time quantum.
+                                 It ranges from 1 to 1024. */
+
+  uint8_t CAN_Mode;         /*!< Specifies the CAN operating mode.
+                                 This parameter can be a value of
+                                @ref CAN_operating_mode */
+
+  uint8_t CAN_SJW;          /*!< Specifies the maximum number of time quanta
+                                 the CAN hardware is allowed to lengthen or
+                                 shorten a bit to perform resynchronization.
+                                 This parameter can be a value of
+                                 @ref CAN_synchronisation_jump_width */
+
+  uint8_t CAN_BS1;          /*!< Specifies the number of time quanta in Bit
+                                 Segment 1. This parameter can be a value of
+                                 @ref CAN_time_quantum_in_bit_segment_1 */
+
+  uint8_t CAN_BS2;          /*!< Specifies the number of time quanta in Bit
+                                 Segment 2.
+                                 This parameter can be a value of
+                                 @ref CAN_time_quantum_in_bit_segment_2 */
+
+  FunctionalState CAN_TTCM; /*!< Enable or disable the time triggered
+                                 communication mode. This parameter can be set
+                                 either to ENABLE or DISABLE. */
+
+  FunctionalState CAN_ABOM;  /*!< Enable or disable the automatic bus-off
+                                  management. This parameter can be set either
+                                  to ENABLE or DISABLE. */
+
+  FunctionalState CAN_AWUM;  /*!< Enable or disable the automatic wake-up mode.
+                                  This parameter can be set either to ENABLE or
+                                  DISABLE. */
+
+  FunctionalState CAN_NART;  /*!< Enable or disable the no-automatic
+                                  retransmission mode. This parameter can be
+                                  set either to ENABLE or DISABLE. */
+
+  FunctionalState CAN_RFLM;  /*!< Enable or disable the Receive FIFO Locked mode.
+                                  This parameter can be set either to ENABLE
+                                  or DISABLE. */
+
+  FunctionalState CAN_TXFP;  /*!< Enable or disable the transmit FIFO priority.
+                                  This parameter can be set either to ENABLE
+                                  or DISABLE. */
+} CAN_InitTypeDef;
+
+/**
+  * @brief  CAN filter init structure definition
+  */
+
+typedef struct
+{
+  uint16_t CAN_FilterIdHigh;         /*!< Specifies the filter identification number (MSBs for a 32-bit
+                                              configuration, first one for a 16-bit configuration).
+                                              This parameter can be a value between 0x0000 and 0xFFFF */
+
+  uint16_t CAN_FilterIdLow;          /*!< Specifies the filter identification number (LSBs for a 32-bit
+                                              configuration, second one for a 16-bit configuration).
+                                              This parameter can be a value between 0x0000 and 0xFFFF */
+
+  uint16_t CAN_FilterMaskIdHigh;     /*!< Specifies the filter mask number or identification number,
+                                              according to the mode (MSBs for a 32-bit configuration,
+                                              first one for a 16-bit configuration).
+                                              This parameter can be a value between 0x0000 and 0xFFFF */
+
+  uint16_t CAN_FilterMaskIdLow;      /*!< Specifies the filter mask number or identification number,
+                                              according to the mode (LSBs for a 32-bit configuration,
+                                              second one for a 16-bit configuration).
+                                              This parameter can be a value between 0x0000 and 0xFFFF */
+
+  uint16_t CAN_FilterFIFOAssignment; /*!< Specifies the FIFO (0 or 1) which will be assigned to the filter.
+                                              This parameter can be a value of @ref CAN_filter_FIFO */
+
+  uint8_t CAN_FilterNumber;          /*!< Specifies the filter which will be initialized. It ranges from 0 to 13. */
+
+  uint8_t CAN_FilterMode;            /*!< Specifies the filter mode to be initialized.
+                                              This parameter can be a value of @ref CAN_filter_mode */
+
+  uint8_t CAN_FilterScale;           /*!< Specifies the filter scale.
+                                              This parameter can be a value of @ref CAN_filter_scale */
+
+  FunctionalState CAN_FilterActivation; /*!< Enable or disable the filter.
+                                              This parameter can be set either to ENABLE or DISABLE. */
+} CAN_FilterInitTypeDef;
+
+/**
+  * @brief  CAN Tx message structure definition
+  */
+
+typedef struct
+{
+  uint32_t StdId;  /*!< Specifies the standard identifier.
+                        This parameter can be a value between 0 to 0x7FF. */
+
+  uint32_t ExtId;  /*!< Specifies the extended identifier.
+                        This parameter can be a value between 0 to 0x1FFFFFFF. */
+
+  uint8_t IDE;     /*!< Specifies the type of identifier for the message that
+                        will be transmitted. This parameter can be a value
+                        of @ref CAN_identifier_type */
+
+  uint8_t RTR;     /*!< Specifies the type of frame for the message that will
+                        be transmitted. This parameter can be a value of
+                        @ref CAN_remote_transmission_request */
+
+  uint8_t DLC;     /*!< Specifies the length of the frame that will be
+                        transmitted. This parameter can be a value between
+                        0 to 8 */
+
+  uint8_t Data[8]; /*!< Contains the data to be transmitted. It ranges from 0
+                        to 0xFF. */
+} CanTxMsg;
+
+/**
+  * @brief  CAN Rx message structure definition
+  */
+
+typedef struct
+{
+  uint32_t StdId;  /*!< Specifies the standard identifier.
+                        This parameter can be a value between 0 to 0x7FF. */
+
+  uint32_t ExtId;  /*!< Specifies the extended identifier.
+                        This parameter can be a value between 0 to 0x1FFFFFFF. */
+
+  uint8_t IDE;     /*!< Specifies the type of identifier for the message that
+                        will be received. This parameter can be a value of
+                        @ref CAN_identifier_type */
+
+  uint8_t RTR;     /*!< Specifies the type of frame for the received message.
+                        This parameter can be a value of
+                        @ref CAN_remote_transmission_request */
+
+  uint8_t DLC;     /*!< Specifies the length of the frame that will be received.
+                        This parameter can be a value between 0 to 8 */
+
+  uint8_t Data[8]; /*!< Contains the data to be received. It ranges from 0 to
+                        0xFF. */
+
+  uint8_t FMI;     /*!< Specifies the index of the filter the message stored in
+                        the mailbox passes through. This parameter can be a
+                        value between 0 to 0xFF */
+} CanRxMsg;
+
+/**
+  * @}
+  */
+
+/** @defgroup CAN_Exported_Constants
+  * @{
+  */
+
+/** @defgroup CAN_sleep_constants
+  * @{
+  */
+
+#define CAN_InitStatus_Failed              ((uint8_t)0x00) /*!< CAN initialization failed */
+#define CAN_InitStatus_Success             ((uint8_t)0x01) /*!< CAN initialization OK */
+
+/**
+  * @}
+  */
+
+/** @defgroup CAN_Mode
+  * @{
+  */
+
+#define CAN_Mode_Normal             ((uint8_t)0x00)  /*!< normal mode */
+#define CAN_Mode_LoopBack           ((uint8_t)0x01)  /*!< loopback mode */
+#define CAN_Mode_Silent             ((uint8_t)0x02)  /*!< silent mode */
+#define CAN_Mode_Silent_LoopBack    ((uint8_t)0x03)  /*!< loopback combined with silent mode */
+
+#define IS_CAN_MODE(MODE) (((MODE) == CAN_Mode_Normal) || \
+                           ((MODE) == CAN_Mode_LoopBack)|| \
+                           ((MODE) == CAN_Mode_Silent) || \
+                           ((MODE) == CAN_Mode_Silent_LoopBack))
+/**
+  * @}
+  */
+
+
+/**
+  * @defgroup CAN_Operating_Mode
+  * @{
+  */
+#define CAN_OperatingMode_Initialization  ((uint8_t)0x00) /*!< Initialization mode */
+#define CAN_OperatingMode_Normal          ((uint8_t)0x01) /*!< Normal mode */
+#define CAN_OperatingMode_Sleep           ((uint8_t)0x02) /*!< sleep mode */
+
+
+#define IS_CAN_OPERATING_MODE(MODE) (((MODE) == CAN_OperatingMode_Initialization) ||\
+                                    ((MODE) == CAN_OperatingMode_Normal)|| \
+																		((MODE) == CAN_OperatingMode_Sleep))
+/**
+  * @}
+  */
+
+/**
+  * @defgroup CAN_Mode_Status
+  * @{
+  */
+
+#define CAN_ModeStatus_Failed    ((uint8_t)0x00)                /*!< CAN entering the specific mode failed */
+#define CAN_ModeStatus_Success   ((uint8_t)!CAN_ModeStatus_Failed)   /*!< CAN entering the specific mode Succeed */
+
+
+/**
+  * @}
+  */
+
+/** @defgroup CAN_synchronisation_jump_width
+  * @{
+  */
+
+#define CAN_SJW_1tq                 ((uint8_t)0x00)  /*!< 1 time quantum */
+#define CAN_SJW_2tq                 ((uint8_t)0x01)  /*!< 2 time quantum */
+#define CAN_SJW_3tq                 ((uint8_t)0x02)  /*!< 3 time quantum */
+#define CAN_SJW_4tq                 ((uint8_t)0x03)  /*!< 4 time quantum */
+
+#define IS_CAN_SJW(SJW) (((SJW) == CAN_SJW_1tq) || ((SJW) == CAN_SJW_2tq)|| \
+                         ((SJW) == CAN_SJW_3tq) || ((SJW) == CAN_SJW_4tq))
+/**
+  * @}
+  */
+
+/** @defgroup CAN_time_quantum_in_bit_segment_1
+  * @{
+  */
+
+#define CAN_BS1_1tq                 ((uint8_t)0x00)  /*!< 1 time quantum */
+#define CAN_BS1_2tq                 ((uint8_t)0x01)  /*!< 2 time quantum */
+#define CAN_BS1_3tq                 ((uint8_t)0x02)  /*!< 3 time quantum */
+#define CAN_BS1_4tq                 ((uint8_t)0x03)  /*!< 4 time quantum */
+#define CAN_BS1_5tq                 ((uint8_t)0x04)  /*!< 5 time quantum */
+#define CAN_BS1_6tq                 ((uint8_t)0x05)  /*!< 6 time quantum */
+#define CAN_BS1_7tq                 ((uint8_t)0x06)  /*!< 7 time quantum */
+#define CAN_BS1_8tq                 ((uint8_t)0x07)  /*!< 8 time quantum */
+#define CAN_BS1_9tq                 ((uint8_t)0x08)  /*!< 9 time quantum */
+#define CAN_BS1_10tq                ((uint8_t)0x09)  /*!< 10 time quantum */
+#define CAN_BS1_11tq                ((uint8_t)0x0A)  /*!< 11 time quantum */
+#define CAN_BS1_12tq                ((uint8_t)0x0B)  /*!< 12 time quantum */
+#define CAN_BS1_13tq                ((uint8_t)0x0C)  /*!< 13 time quantum */
+#define CAN_BS1_14tq                ((uint8_t)0x0D)  /*!< 14 time quantum */
+#define CAN_BS1_15tq                ((uint8_t)0x0E)  /*!< 15 time quantum */
+#define CAN_BS1_16tq                ((uint8_t)0x0F)  /*!< 16 time quantum */
+
+#define IS_CAN_BS1(BS1) ((BS1) <= CAN_BS1_16tq)
+/**
+  * @}
+  */
+
+/** @defgroup CAN_time_quantum_in_bit_segment_2
+  * @{
+  */
+
+#define CAN_BS2_1tq                 ((uint8_t)0x00)  /*!< 1 time quantum */
+#define CAN_BS2_2tq                 ((uint8_t)0x01)  /*!< 2 time quantum */
+#define CAN_BS2_3tq                 ((uint8_t)0x02)  /*!< 3 time quantum */
+#define CAN_BS2_4tq                 ((uint8_t)0x03)  /*!< 4 time quantum */
+#define CAN_BS2_5tq                 ((uint8_t)0x04)  /*!< 5 time quantum */
+#define CAN_BS2_6tq                 ((uint8_t)0x05)  /*!< 6 time quantum */
+#define CAN_BS2_7tq                 ((uint8_t)0x06)  /*!< 7 time quantum */
+#define CAN_BS2_8tq                 ((uint8_t)0x07)  /*!< 8 time quantum */
+
+#define IS_CAN_BS2(BS2) ((BS2) <= CAN_BS2_8tq)
+
+/**
+  * @}
+  */
+
+/** @defgroup CAN_clock_prescaler
+  * @{
+  */
+
+#define IS_CAN_PRESCALER(PRESCALER) (((PRESCALER) >= 1) && ((PRESCALER) <= 1024))
+
+/**
+  * @}
+  */
+
+/** @defgroup CAN_filter_number
+  * @{
+  */
+#ifndef STM32F10X_CL
+  #define IS_CAN_FILTER_NUMBER(NUMBER) ((NUMBER) <= 13)
+#else
+  #define IS_CAN_FILTER_NUMBER(NUMBER) ((NUMBER) <= 27)
+#endif /* STM32F10X_CL */
+/**
+  * @}
+  */
+
+/** @defgroup CAN_filter_mode
+  * @{
+  */
+
+#define CAN_FilterMode_IdMask       ((uint8_t)0x00)  /*!< identifier/mask mode */
+#define CAN_FilterMode_IdList       ((uint8_t)0x01)  /*!< identifier list mode */
+
+#define IS_CAN_FILTER_MODE(MODE) (((MODE) == CAN_FilterMode_IdMask) || \
+                                  ((MODE) == CAN_FilterMode_IdList))
+/**
+  * @}
+  */
+
+/** @defgroup CAN_filter_scale
+  * @{
+  */
+
+#define CAN_FilterScale_16bit       ((uint8_t)0x00) /*!< Two 16-bit filters */
+#define CAN_FilterScale_32bit       ((uint8_t)0x01) /*!< One 32-bit filter */
+
+#define IS_CAN_FILTER_SCALE(SCALE) (((SCALE) == CAN_FilterScale_16bit) || \
+                                    ((SCALE) == CAN_FilterScale_32bit))
+
+/**
+  * @}
+  */
+
+/** @defgroup CAN_filter_FIFO
+  * @{
+  */
+
+#define CAN_Filter_FIFO0             ((uint8_t)0x00)  /*!< Filter FIFO 0 assignment for filter x */
+#define CAN_Filter_FIFO1             ((uint8_t)0x01)  /*!< Filter FIFO 1 assignment for filter x */
+#define IS_CAN_FILTER_FIFO(FIFO) (((FIFO) == CAN_FilterFIFO0) || \
+                                  ((FIFO) == CAN_FilterFIFO1))
+/**
+  * @}
+  */
+
+/** @defgroup Start_bank_filter_for_slave_CAN
+  * @{
+  */
+#define IS_CAN_BANKNUMBER(BANKNUMBER) (((BANKNUMBER) >= 1) && ((BANKNUMBER) <= 27))
+/**
+  * @}
+  */
+
+/** @defgroup CAN_Tx
+  * @{
+  */
+
+#define IS_CAN_TRANSMITMAILBOX(TRANSMITMAILBOX) ((TRANSMITMAILBOX) <= ((uint8_t)0x02))
+#define IS_CAN_STDID(STDID)   ((STDID) <= ((uint32_t)0x7FF))
+#define IS_CAN_EXTID(EXTID)   ((EXTID) <= ((uint32_t)0x1FFFFFFF))
+#define IS_CAN_DLC(DLC)       ((DLC) <= ((uint8_t)0x08))
+
+/**
+  * @}
+  */
+
+/** @defgroup CAN_identifier_type
+  * @{
+  */
+
+#define CAN_Id_Standard             ((uint32_t)0x00000000)  /*!< Standard Id */
+#define CAN_Id_Extended             ((uint32_t)0x00000004)  /*!< Extended Id */
+#define IS_CAN_IDTYPE(IDTYPE) (((IDTYPE) == CAN_Id_Standard) || \
+                               ((IDTYPE) == CAN_Id_Extended))
+/**
+  * @}
+  */
+
+/** @defgroup CAN_remote_transmission_request
+  * @{
+  */
+
+#define CAN_RTR_Data                ((uint32_t)0x00000000)  /*!< Data frame */
+#define CAN_RTR_Remote              ((uint32_t)0x00000002)  /*!< Remote frame */
+#define IS_CAN_RTR(RTR) (((RTR) == CAN_RTR_Data) || ((RTR) == CAN_RTR_Remote))
+
+/**
+  * @}
+  */
+
+/** @defgroup CAN_transmit_constants
+  * @{
+  */
+
+#define CAN_TxStatus_Failed         ((uint8_t)0x00)/*!< CAN transmission failed */
+#define CAN_TxStatus_Ok             ((uint8_t)0x01) /*!< CAN transmission succeeded */
+#define CAN_TxStatus_Pending        ((uint8_t)0x02) /*!< CAN transmission pending */
+#define CAN_TxStatus_NoMailBox      ((uint8_t)0x04) /*!< CAN cell did not provide an empty mailbox */
+
+/**
+  * @}
+  */
+
+/** @defgroup CAN_receive_FIFO_number_constants
+  * @{
+  */
+
+#define CAN_FIFO0                 ((uint8_t)0x00) /*!< CAN FIFO 0 used to receive */
+#define CAN_FIFO1                 ((uint8_t)0x01) /*!< CAN FIFO 1 used to receive */
+
+#define IS_CAN_FIFO(FIFO) (((FIFO) == CAN_FIFO0) || ((FIFO) == CAN_FIFO1))
+
+/**
+  * @}
+  */
+
+/** @defgroup CAN_sleep_constants
+  * @{
+  */
+
+#define CAN_Sleep_Failed     ((uint8_t)0x00) /*!< CAN did not enter the sleep mode */
+#define CAN_Sleep_Ok         ((uint8_t)0x01) /*!< CAN entered the sleep mode */
+
+/**
+  * @}
+  */
+
+/** @defgroup CAN_wake_up_constants
+  * @{
+  */
+
+#define CAN_WakeUp_Failed        ((uint8_t)0x00) /*!< CAN did not leave the sleep mode */
+#define CAN_WakeUp_Ok            ((uint8_t)0x01) /*!< CAN leaved the sleep mode */
+
+/**
+  * @}
+  */
+
+/**
+  * @defgroup   CAN_Error_Code_constants
+  * @{
+  */
+
+#define CAN_ErrorCode_NoErr           ((uint8_t)0x00) /*!< No Error */
+#define	CAN_ErrorCode_StuffErr        ((uint8_t)0x10) /*!< Stuff Error */
+#define	CAN_ErrorCode_FormErr         ((uint8_t)0x20) /*!< Form Error */
+#define	CAN_ErrorCode_ACKErr          ((uint8_t)0x30) /*!< Acknowledgment Error */
+#define	CAN_ErrorCode_BitRecessiveErr ((uint8_t)0x40) /*!< Bit Recessive Error */
+#define	CAN_ErrorCode_BitDominantErr  ((uint8_t)0x50) /*!< Bit Dominant Error */
+#define	CAN_ErrorCode_CRCErr          ((uint8_t)0x60) /*!< CRC Error  */
+#define	CAN_ErrorCode_SoftwareSetErr  ((uint8_t)0x70) /*!< Software Set Error */
+
+
+/**
+  * @}
+  */
+
+/** @defgroup CAN_flags
+  * @{
+  */
+/* If the flag is 0x3XXXXXXX, it means that it can be used with CAN_GetFlagStatus()
+   and CAN_ClearFlag() functions. */
+/* If the flag is 0x1XXXXXXX, it means that it can only be used with CAN_GetFlagStatus() function.  */
+
+/* Transmit Flags */
+#define CAN_FLAG_RQCP0             ((uint32_t)0x38000001) /*!< Request MailBox0 Flag */
+#define CAN_FLAG_RQCP1             ((uint32_t)0x38000100) /*!< Request MailBox1 Flag */
+#define CAN_FLAG_RQCP2             ((uint32_t)0x38010000) /*!< Request MailBox2 Flag */
+
+/* Receive Flags */
+#define CAN_FLAG_FMP0              ((uint32_t)0x12000003) /*!< FIFO 0 Message Pending Flag */
+#define CAN_FLAG_FF0               ((uint32_t)0x32000008) /*!< FIFO 0 Full Flag            */
+#define CAN_FLAG_FOV0              ((uint32_t)0x32000010) /*!< FIFO 0 Overrun Flag         */
+#define CAN_FLAG_FMP1              ((uint32_t)0x14000003) /*!< FIFO 1 Message Pending Flag */
+#define CAN_FLAG_FF1               ((uint32_t)0x34000008) /*!< FIFO 1 Full Flag            */
+#define CAN_FLAG_FOV1              ((uint32_t)0x34000010) /*!< FIFO 1 Overrun Flag         */
+
+/* Operating Mode Flags */
+#define CAN_FLAG_WKU               ((uint32_t)0x31000008) /*!< Wake up Flag */
+#define CAN_FLAG_SLAK              ((uint32_t)0x31000012) /*!< Sleep acknowledge Flag */
+/* Note: When SLAK intterupt is disabled (SLKIE=0), no polling on SLAKI is possible.
+         In this case the SLAK bit can be polled.*/
+
+/* Error Flags */
+#define CAN_FLAG_EWG               ((uint32_t)0x10F00001) /*!< Error Warning Flag   */
+#define CAN_FLAG_EPV               ((uint32_t)0x10F00002) /*!< Error Passive Flag   */
+#define CAN_FLAG_BOF               ((uint32_t)0x10F00004) /*!< Bus-Off Flag         */
+#define CAN_FLAG_LEC               ((uint32_t)0x30F00070) /*!< Last error code Flag */
+
+#define IS_CAN_GET_FLAG(FLAG) (((FLAG) == CAN_FLAG_LEC)  || ((FLAG) == CAN_FLAG_BOF)   || \
+                               ((FLAG) == CAN_FLAG_EPV)  || ((FLAG) == CAN_FLAG_EWG)   || \
+                               ((FLAG) == CAN_FLAG_WKU)  || ((FLAG) == CAN_FLAG_FOV0)  || \
+                               ((FLAG) == CAN_FLAG_FF0)  || ((FLAG) == CAN_FLAG_FMP0)  || \
+                               ((FLAG) == CAN_FLAG_FOV1) || ((FLAG) == CAN_FLAG_FF1)   || \
+                               ((FLAG) == CAN_FLAG_FMP1) || ((FLAG) == CAN_FLAG_RQCP2) || \
+                               ((FLAG) == CAN_FLAG_RQCP1)|| ((FLAG) == CAN_FLAG_RQCP0) || \
+                               ((FLAG) == CAN_FLAG_SLAK ))
+
+#define IS_CAN_CLEAR_FLAG(FLAG)(((FLAG) == CAN_FLAG_LEC) || ((FLAG) == CAN_FLAG_RQCP2) || \
+                                ((FLAG) == CAN_FLAG_RQCP1)  || ((FLAG) == CAN_FLAG_RQCP0) || \
+                                ((FLAG) == CAN_FLAG_FF0)  || ((FLAG) == CAN_FLAG_FOV0) ||\
+                                ((FLAG) == CAN_FLAG_FF1) || ((FLAG) == CAN_FLAG_FOV1) || \
+                                ((FLAG) == CAN_FLAG_WKU) || ((FLAG) == CAN_FLAG_SLAK))
+/**
+  * @}
+  */
+
+
+/** @defgroup CAN_interrupts
+  * @{
+  */
+
+
+
+#define CAN_IT_TME                  ((uint32_t)0x00000001) /*!< Transmit mailbox empty Interrupt*/
+
+/* Receive Interrupts */
+#define CAN_IT_FMP0                 ((uint32_t)0x00000002) /*!< FIFO 0 message pending Interrupt*/
+#define CAN_IT_FF0                  ((uint32_t)0x00000004) /*!< FIFO 0 full Interrupt*/
+#define CAN_IT_FOV0                 ((uint32_t)0x00000008) /*!< FIFO 0 overrun Interrupt*/
+#define CAN_IT_FMP1                 ((uint32_t)0x00000010) /*!< FIFO 1 message pending Interrupt*/
+#define CAN_IT_FF1                  ((uint32_t)0x00000020) /*!< FIFO 1 full Interrupt*/
+#define CAN_IT_FOV1                 ((uint32_t)0x00000040) /*!< FIFO 1 overrun Interrupt*/
+
+/* Operating Mode Interrupts */
+#define CAN_IT_WKU                  ((uint32_t)0x00010000) /*!< Wake-up Interrupt*/
+#define CAN_IT_SLK                  ((uint32_t)0x00020000) /*!< Sleep acknowledge Interrupt*/
+
+/* Error Interrupts */
+#define CAN_IT_EWG                  ((uint32_t)0x00000100) /*!< Error warning Interrupt*/
+#define CAN_IT_EPV                  ((uint32_t)0x00000200) /*!< Error passive Interrupt*/
+#define CAN_IT_BOF                  ((uint32_t)0x00000400) /*!< Bus-off Interrupt*/
+#define CAN_IT_LEC                  ((uint32_t)0x00000800) /*!< Last error code Interrupt*/
+#define CAN_IT_ERR                  ((uint32_t)0x00008000) /*!< Error Interrupt*/
+
+/* Flags named as Interrupts : kept only for FW compatibility */
+#define CAN_IT_RQCP0   CAN_IT_TME
+#define CAN_IT_RQCP1   CAN_IT_TME
+#define CAN_IT_RQCP2   CAN_IT_TME
+
+
+#define IS_CAN_IT(IT)        (((IT) == CAN_IT_TME) || ((IT) == CAN_IT_FMP0)  ||\
+                             ((IT) == CAN_IT_FF0)  || ((IT) == CAN_IT_FOV0)  ||\
+                             ((IT) == CAN_IT_FMP1) || ((IT) == CAN_IT_FF1)   ||\
+                             ((IT) == CAN_IT_FOV1) || ((IT) == CAN_IT_EWG)   ||\
+                             ((IT) == CAN_IT_EPV)  || ((IT) == CAN_IT_BOF)   ||\
+                             ((IT) == CAN_IT_LEC)  || ((IT) == CAN_IT_ERR)   ||\
+                             ((IT) == CAN_IT_WKU)  || ((IT) == CAN_IT_SLK))
+
+#define IS_CAN_CLEAR_IT(IT) (((IT) == CAN_IT_TME) || ((IT) == CAN_IT_FF0)    ||\
+                             ((IT) == CAN_IT_FOV0)|| ((IT) == CAN_IT_FF1)    ||\
+                             ((IT) == CAN_IT_FOV1)|| ((IT) == CAN_IT_EWG)    ||\
+                             ((IT) == CAN_IT_EPV) || ((IT) == CAN_IT_BOF)    ||\
+                             ((IT) == CAN_IT_LEC) || ((IT) == CAN_IT_ERR)    ||\
+                             ((IT) == CAN_IT_WKU) || ((IT) == CAN_IT_SLK))
+
+/**
+  * @}
+  */
+
+/** @defgroup CAN_Legacy
+  * @{
+  */
+#define CANINITFAILED               CAN_InitStatus_Failed
+#define CANINITOK                   CAN_InitStatus_Success
+#define CAN_FilterFIFO0             CAN_Filter_FIFO0
+#define CAN_FilterFIFO1             CAN_Filter_FIFO1
+#define CAN_ID_STD                  CAN_Id_Standard
+#define CAN_ID_EXT                  CAN_Id_Extended
+#define CAN_RTR_DATA                CAN_RTR_Data
+#define CAN_RTR_REMOTE              CAN_RTR_Remote
+#define CANTXFAILE                  CAN_TxStatus_Failed
+#define CANTXOK                     CAN_TxStatus_Ok
+#define CANTXPENDING                CAN_TxStatus_Pending
+#define CAN_NO_MB                   CAN_TxStatus_NoMailBox
+#define CANSLEEPFAILED              CAN_Sleep_Failed
+#define CANSLEEPOK                  CAN_Sleep_Ok
+#define CANWAKEUPFAILED             CAN_WakeUp_Failed
+#define CANWAKEUPOK                 CAN_WakeUp_Ok
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup CAN_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup CAN_Exported_Functions
+  * @{
+  */
+/*  Function used to set the CAN configuration to the default reset state *****/
+void CAN_DeInit(CAN_TypeDef* CANx);
+
+/* Initialization and Configuration functions *********************************/
+uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct);
+void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct);
+void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct);
+void CAN_SlaveStartBank(uint8_t CAN_BankNumber);
+void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState);
+void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState);
+
+/* Transmit functions *********************************************************/
+uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage);
+uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox);
+void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox);
+
+/* Receive functions **********************************************************/
+void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage);
+void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber);
+uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber);
+
+
+/* Operation modes functions **************************************************/
+uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode);
+uint8_t CAN_Sleep(CAN_TypeDef* CANx);
+uint8_t CAN_WakeUp(CAN_TypeDef* CANx);
+
+/* Error management functions *************************************************/
+uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx);
+uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx);
+uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx);
+
+/* Interrupts and flags management functions **********************************/
+void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState);
+FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG);
+void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG);
+ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT);
+void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F10x_CAN_H */
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_cec.h b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_cec.h
new file mode 100644
index 0000000..a3f8fc7
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_cec.h
@@ -0,0 +1,210 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_cec.h
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file contains all the functions prototypes for the CEC firmware
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F10x_CEC_H
+#define __STM32F10x_CEC_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup CEC
+  * @{
+  */
+
+
+/** @defgroup CEC_Exported_Types
+  * @{
+  */
+
+/**
+  * @brief  CEC Init structure definition
+  */
+typedef struct
+{
+  uint16_t CEC_BitTimingMode; /*!< Configures the CEC Bit Timing Error Mode.
+                               This parameter can be a value of @ref CEC_BitTiming_Mode */
+  uint16_t CEC_BitPeriodMode; /*!< Configures the CEC Bit Period Error Mode.
+                               This parameter can be a value of @ref CEC_BitPeriod_Mode */
+}CEC_InitTypeDef;
+
+/**
+  * @}
+  */
+
+/** @defgroup CEC_Exported_Constants
+  * @{
+  */
+
+/** @defgroup CEC_BitTiming_Mode
+  * @{
+  */
+#define CEC_BitTimingStdMode                    ((uint16_t)0x00) /*!< Bit timing error Standard Mode */
+#define CEC_BitTimingErrFreeMode                CEC_CFGR_BTEM   /*!< Bit timing error Free Mode */
+
+#define IS_CEC_BIT_TIMING_ERROR_MODE(MODE) (((MODE) == CEC_BitTimingStdMode) || \
+                                            ((MODE) == CEC_BitTimingErrFreeMode))
+/**
+  * @}
+  */
+
+/** @defgroup CEC_BitPeriod_Mode
+  * @{
+  */
+#define CEC_BitPeriodStdMode                    ((uint16_t)0x00) /*!< Bit period error Standard Mode */
+#define CEC_BitPeriodFlexibleMode                CEC_CFGR_BPEM   /*!< Bit period error Flexible Mode */
+
+#define IS_CEC_BIT_PERIOD_ERROR_MODE(MODE) (((MODE) == CEC_BitPeriodStdMode) || \
+                                            ((MODE) == CEC_BitPeriodFlexibleMode))
+/**
+  * @}
+  */
+
+
+/** @defgroup CEC_interrupts_definition
+  * @{
+  */
+#define CEC_IT_TERR                              CEC_CSR_TERR
+#define CEC_IT_TBTRF                             CEC_CSR_TBTRF
+#define CEC_IT_RERR                              CEC_CSR_RERR
+#define CEC_IT_RBTF                              CEC_CSR_RBTF
+#define IS_CEC_GET_IT(IT) (((IT) == CEC_IT_TERR) || ((IT) == CEC_IT_TBTRF) || \
+                           ((IT) == CEC_IT_RERR) || ((IT) == CEC_IT_RBTF))
+/**
+  * @}
+  */
+
+
+/** @defgroup CEC_Own_Address
+  * @{
+  */
+#define IS_CEC_ADDRESS(ADDRESS) ((ADDRESS) < 0x10)
+/**
+  * @}
+  */
+
+/** @defgroup CEC_Prescaler
+  * @{
+  */
+#define IS_CEC_PRESCALER(PRESCALER) ((PRESCALER) <= 0x3FFF)
+
+/**
+  * @}
+  */
+
+/** @defgroup CEC_flags_definition
+  * @{
+  */
+
+/**
+  * @brief  ESR register flags
+  */
+#define CEC_FLAG_BTE                            ((uint32_t)0x10010000)
+#define CEC_FLAG_BPE                            ((uint32_t)0x10020000)
+#define CEC_FLAG_RBTFE                          ((uint32_t)0x10040000)
+#define CEC_FLAG_SBE                            ((uint32_t)0x10080000)
+#define CEC_FLAG_ACKE                           ((uint32_t)0x10100000)
+#define CEC_FLAG_LINE                           ((uint32_t)0x10200000)
+#define CEC_FLAG_TBTFE                          ((uint32_t)0x10400000)
+
+/**
+  * @brief  CSR register flags
+  */
+#define CEC_FLAG_TEOM                           ((uint32_t)0x00000002)
+#define CEC_FLAG_TERR                           ((uint32_t)0x00000004)
+#define CEC_FLAG_TBTRF                          ((uint32_t)0x00000008)
+#define CEC_FLAG_RSOM                           ((uint32_t)0x00000010)
+#define CEC_FLAG_REOM                           ((uint32_t)0x00000020)
+#define CEC_FLAG_RERR                           ((uint32_t)0x00000040)
+#define CEC_FLAG_RBTF                           ((uint32_t)0x00000080)
+
+#define IS_CEC_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFFFFFF03) == 0x00) && ((FLAG) != 0x00))
+
+#define IS_CEC_GET_FLAG(FLAG) (((FLAG) == CEC_FLAG_BTE) || ((FLAG) == CEC_FLAG_BPE) || \
+                               ((FLAG) == CEC_FLAG_RBTFE) || ((FLAG)== CEC_FLAG_SBE) || \
+                               ((FLAG) == CEC_FLAG_ACKE) || ((FLAG) == CEC_FLAG_LINE) || \
+                               ((FLAG) == CEC_FLAG_TBTFE) || ((FLAG) == CEC_FLAG_TEOM) || \
+                               ((FLAG) == CEC_FLAG_TERR) || ((FLAG) == CEC_FLAG_TBTRF) || \
+                               ((FLAG) == CEC_FLAG_RSOM) || ((FLAG) == CEC_FLAG_REOM) || \
+                               ((FLAG) == CEC_FLAG_RERR) || ((FLAG) == CEC_FLAG_RBTF))
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup CEC_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup CEC_Exported_Functions
+  * @{
+  */
+void CEC_DeInit(void);
+void CEC_Init(CEC_InitTypeDef* CEC_InitStruct);
+void CEC_Cmd(FunctionalState NewState);
+void CEC_ITConfig(FunctionalState NewState);
+void CEC_OwnAddressConfig(uint8_t CEC_OwnAddress);
+void CEC_SetPrescaler(uint16_t CEC_Prescaler);
+void CEC_SendDataByte(uint8_t Data);
+uint8_t CEC_ReceiveDataByte(void);
+void CEC_StartOfMessage(void);
+void CEC_EndOfMessageCmd(FunctionalState NewState);
+FlagStatus CEC_GetFlagStatus(uint32_t CEC_FLAG);
+void CEC_ClearFlag(uint32_t CEC_FLAG);
+ITStatus CEC_GetITStatus(uint8_t CEC_IT);
+void CEC_ClearITPendingBit(uint16_t CEC_IT);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F10x_CEC_H */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_crc.h b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_crc.h
new file mode 100644
index 0000000..658a51c
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_crc.h
@@ -0,0 +1,94 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_crc.h
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file contains all the functions prototypes for the CRC firmware
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F10x_CRC_H
+#define __STM32F10x_CRC_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup CRC
+  * @{
+  */
+
+/** @defgroup CRC_Exported_Types
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup CRC_Exported_Constants
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup CRC_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup CRC_Exported_Functions
+  * @{
+  */
+
+void CRC_ResetDR(void);
+uint32_t CRC_CalcCRC(uint32_t Data);
+uint32_t CRC_CalcBlockCRC(uint32_t pBuffer[], uint32_t BufferLength);
+uint32_t CRC_GetCRC(void);
+void CRC_SetIDRegister(uint8_t IDValue);
+uint8_t CRC_GetIDRegister(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F10x_CRC_H */
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_dac.h b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_dac.h
new file mode 100644
index 0000000..7106164
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_dac.h
@@ -0,0 +1,317 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_dac.h
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file contains all the functions prototypes for the DAC firmware
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F10x_DAC_H
+#define __STM32F10x_DAC_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup DAC
+  * @{
+  */
+
+/** @defgroup DAC_Exported_Types
+  * @{
+  */
+
+/**
+  * @brief  DAC Init structure definition
+  */
+
+typedef struct
+{
+  uint32_t DAC_Trigger;                      /*!< Specifies the external trigger for the selected DAC channel.
+                                                  This parameter can be a value of @ref DAC_trigger_selection */
+
+  uint32_t DAC_WaveGeneration;               /*!< Specifies whether DAC channel noise waves or triangle waves
+                                                  are generated, or whether no wave is generated.
+                                                  This parameter can be a value of @ref DAC_wave_generation */
+
+  uint32_t DAC_LFSRUnmask_TriangleAmplitude; /*!< Specifies the LFSR mask for noise wave generation or
+                                                  the maximum amplitude triangle generation for the DAC channel.
+                                                  This parameter can be a value of @ref DAC_lfsrunmask_triangleamplitude */
+
+  uint32_t DAC_OutputBuffer;                 /*!< Specifies whether the DAC channel output buffer is enabled or disabled.
+                                                  This parameter can be a value of @ref DAC_output_buffer */
+}DAC_InitTypeDef;
+
+/**
+  * @}
+  */
+
+/** @defgroup DAC_Exported_Constants
+  * @{
+  */
+
+/** @defgroup DAC_trigger_selection
+  * @{
+  */
+
+#define DAC_Trigger_None                   ((uint32_t)0x00000000) /*!< Conversion is automatic once the DAC1_DHRxxxx register
+                                                                       has been loaded, and not by external trigger */
+#define DAC_Trigger_T6_TRGO                ((uint32_t)0x00000004) /*!< TIM6 TRGO selected as external conversion trigger for DAC channel */
+#define DAC_Trigger_T8_TRGO                ((uint32_t)0x0000000C) /*!< TIM8 TRGO selected as external conversion trigger for DAC channel
+                                                                       only in High-density devices*/
+#define DAC_Trigger_T3_TRGO                ((uint32_t)0x0000000C) /*!< TIM8 TRGO selected as external conversion trigger for DAC channel
+                                                                       only in Connectivity line, Medium-density and Low-density Value Line devices */
+#define DAC_Trigger_T7_TRGO                ((uint32_t)0x00000014) /*!< TIM7 TRGO selected as external conversion trigger for DAC channel */
+#define DAC_Trigger_T5_TRGO                ((uint32_t)0x0000001C) /*!< TIM5 TRGO selected as external conversion trigger for DAC channel */
+#define DAC_Trigger_T15_TRGO               ((uint32_t)0x0000001C) /*!< TIM15 TRGO selected as external conversion trigger for DAC channel
+                                                                       only in Medium-density and Low-density Value Line devices*/
+#define DAC_Trigger_T2_TRGO                ((uint32_t)0x00000024) /*!< TIM2 TRGO selected as external conversion trigger for DAC channel */
+#define DAC_Trigger_T4_TRGO                ((uint32_t)0x0000002C) /*!< TIM4 TRGO selected as external conversion trigger for DAC channel */
+#define DAC_Trigger_Ext_IT9                ((uint32_t)0x00000034) /*!< EXTI Line9 event selected as external conversion trigger for DAC channel */
+#define DAC_Trigger_Software               ((uint32_t)0x0000003C) /*!< Conversion started by software trigger for DAC channel */
+
+#define IS_DAC_TRIGGER(TRIGGER) (((TRIGGER) == DAC_Trigger_None) || \
+                                 ((TRIGGER) == DAC_Trigger_T6_TRGO) || \
+                                 ((TRIGGER) == DAC_Trigger_T8_TRGO) || \
+                                 ((TRIGGER) == DAC_Trigger_T7_TRGO) || \
+                                 ((TRIGGER) == DAC_Trigger_T5_TRGO) || \
+                                 ((TRIGGER) == DAC_Trigger_T2_TRGO) || \
+                                 ((TRIGGER) == DAC_Trigger_T4_TRGO) || \
+                                 ((TRIGGER) == DAC_Trigger_Ext_IT9) || \
+                                 ((TRIGGER) == DAC_Trigger_Software))
+
+/**
+  * @}
+  */
+
+/** @defgroup DAC_wave_generation
+  * @{
+  */
+
+#define DAC_WaveGeneration_None            ((uint32_t)0x00000000)
+#define DAC_WaveGeneration_Noise           ((uint32_t)0x00000040)
+#define DAC_WaveGeneration_Triangle        ((uint32_t)0x00000080)
+#define IS_DAC_GENERATE_WAVE(WAVE) (((WAVE) == DAC_WaveGeneration_None) || \
+                                    ((WAVE) == DAC_WaveGeneration_Noise) || \
+                                    ((WAVE) == DAC_WaveGeneration_Triangle))
+/**
+  * @}
+  */
+
+/** @defgroup DAC_lfsrunmask_triangleamplitude
+  * @{
+  */
+
+#define DAC_LFSRUnmask_Bit0                ((uint32_t)0x00000000) /*!< Unmask DAC channel LFSR bit0 for noise wave generation */
+#define DAC_LFSRUnmask_Bits1_0             ((uint32_t)0x00000100) /*!< Unmask DAC channel LFSR bit[1:0] for noise wave generation */
+#define DAC_LFSRUnmask_Bits2_0             ((uint32_t)0x00000200) /*!< Unmask DAC channel LFSR bit[2:0] for noise wave generation */
+#define DAC_LFSRUnmask_Bits3_0             ((uint32_t)0x00000300) /*!< Unmask DAC channel LFSR bit[3:0] for noise wave generation */
+#define DAC_LFSRUnmask_Bits4_0             ((uint32_t)0x00000400) /*!< Unmask DAC channel LFSR bit[4:0] for noise wave generation */
+#define DAC_LFSRUnmask_Bits5_0             ((uint32_t)0x00000500) /*!< Unmask DAC channel LFSR bit[5:0] for noise wave generation */
+#define DAC_LFSRUnmask_Bits6_0             ((uint32_t)0x00000600) /*!< Unmask DAC channel LFSR bit[6:0] for noise wave generation */
+#define DAC_LFSRUnmask_Bits7_0             ((uint32_t)0x00000700) /*!< Unmask DAC channel LFSR bit[7:0] for noise wave generation */
+#define DAC_LFSRUnmask_Bits8_0             ((uint32_t)0x00000800) /*!< Unmask DAC channel LFSR bit[8:0] for noise wave generation */
+#define DAC_LFSRUnmask_Bits9_0             ((uint32_t)0x00000900) /*!< Unmask DAC channel LFSR bit[9:0] for noise wave generation */
+#define DAC_LFSRUnmask_Bits10_0            ((uint32_t)0x00000A00) /*!< Unmask DAC channel LFSR bit[10:0] for noise wave generation */
+#define DAC_LFSRUnmask_Bits11_0            ((uint32_t)0x00000B00) /*!< Unmask DAC channel LFSR bit[11:0] for noise wave generation */
+#define DAC_TriangleAmplitude_1            ((uint32_t)0x00000000) /*!< Select max triangle amplitude of 1 */
+#define DAC_TriangleAmplitude_3            ((uint32_t)0x00000100) /*!< Select max triangle amplitude of 3 */
+#define DAC_TriangleAmplitude_7            ((uint32_t)0x00000200) /*!< Select max triangle amplitude of 7 */
+#define DAC_TriangleAmplitude_15           ((uint32_t)0x00000300) /*!< Select max triangle amplitude of 15 */
+#define DAC_TriangleAmplitude_31           ((uint32_t)0x00000400) /*!< Select max triangle amplitude of 31 */
+#define DAC_TriangleAmplitude_63           ((uint32_t)0x00000500) /*!< Select max triangle amplitude of 63 */
+#define DAC_TriangleAmplitude_127          ((uint32_t)0x00000600) /*!< Select max triangle amplitude of 127 */
+#define DAC_TriangleAmplitude_255          ((uint32_t)0x00000700) /*!< Select max triangle amplitude of 255 */
+#define DAC_TriangleAmplitude_511          ((uint32_t)0x00000800) /*!< Select max triangle amplitude of 511 */
+#define DAC_TriangleAmplitude_1023         ((uint32_t)0x00000900) /*!< Select max triangle amplitude of 1023 */
+#define DAC_TriangleAmplitude_2047         ((uint32_t)0x00000A00) /*!< Select max triangle amplitude of 2047 */
+#define DAC_TriangleAmplitude_4095         ((uint32_t)0x00000B00) /*!< Select max triangle amplitude of 4095 */
+
+#define IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(VALUE) (((VALUE) == DAC_LFSRUnmask_Bit0) || \
+                                                      ((VALUE) == DAC_LFSRUnmask_Bits1_0) || \
+                                                      ((VALUE) == DAC_LFSRUnmask_Bits2_0) || \
+                                                      ((VALUE) == DAC_LFSRUnmask_Bits3_0) || \
+                                                      ((VALUE) == DAC_LFSRUnmask_Bits4_0) || \
+                                                      ((VALUE) == DAC_LFSRUnmask_Bits5_0) || \
+                                                      ((VALUE) == DAC_LFSRUnmask_Bits6_0) || \
+                                                      ((VALUE) == DAC_LFSRUnmask_Bits7_0) || \
+                                                      ((VALUE) == DAC_LFSRUnmask_Bits8_0) || \
+                                                      ((VALUE) == DAC_LFSRUnmask_Bits9_0) || \
+                                                      ((VALUE) == DAC_LFSRUnmask_Bits10_0) || \
+                                                      ((VALUE) == DAC_LFSRUnmask_Bits11_0) || \
+                                                      ((VALUE) == DAC_TriangleAmplitude_1) || \
+                                                      ((VALUE) == DAC_TriangleAmplitude_3) || \
+                                                      ((VALUE) == DAC_TriangleAmplitude_7) || \
+                                                      ((VALUE) == DAC_TriangleAmplitude_15) || \
+                                                      ((VALUE) == DAC_TriangleAmplitude_31) || \
+                                                      ((VALUE) == DAC_TriangleAmplitude_63) || \
+                                                      ((VALUE) == DAC_TriangleAmplitude_127) || \
+                                                      ((VALUE) == DAC_TriangleAmplitude_255) || \
+                                                      ((VALUE) == DAC_TriangleAmplitude_511) || \
+                                                      ((VALUE) == DAC_TriangleAmplitude_1023) || \
+                                                      ((VALUE) == DAC_TriangleAmplitude_2047) || \
+                                                      ((VALUE) == DAC_TriangleAmplitude_4095))
+/**
+  * @}
+  */
+
+/** @defgroup DAC_output_buffer
+  * @{
+  */
+
+#define DAC_OutputBuffer_Enable            ((uint32_t)0x00000000)
+#define DAC_OutputBuffer_Disable           ((uint32_t)0x00000002)
+#define IS_DAC_OUTPUT_BUFFER_STATE(STATE) (((STATE) == DAC_OutputBuffer_Enable) || \
+                                           ((STATE) == DAC_OutputBuffer_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup DAC_Channel_selection
+  * @{
+  */
+
+#define DAC_Channel_1                      ((uint32_t)0x00000000)
+#define DAC_Channel_2                      ((uint32_t)0x00000010)
+#define IS_DAC_CHANNEL(CHANNEL) (((CHANNEL) == DAC_Channel_1) || \
+                                 ((CHANNEL) == DAC_Channel_2))
+/**
+  * @}
+  */
+
+/** @defgroup DAC_data_alignment
+  * @{
+  */
+
+#define DAC_Align_12b_R                    ((uint32_t)0x00000000)
+#define DAC_Align_12b_L                    ((uint32_t)0x00000004)
+#define DAC_Align_8b_R                     ((uint32_t)0x00000008)
+#define IS_DAC_ALIGN(ALIGN) (((ALIGN) == DAC_Align_12b_R) || \
+                             ((ALIGN) == DAC_Align_12b_L) || \
+                             ((ALIGN) == DAC_Align_8b_R))
+/**
+  * @}
+  */
+
+/** @defgroup DAC_wave_generation
+  * @{
+  */
+
+#define DAC_Wave_Noise                     ((uint32_t)0x00000040)
+#define DAC_Wave_Triangle                  ((uint32_t)0x00000080)
+#define IS_DAC_WAVE(WAVE) (((WAVE) == DAC_Wave_Noise) || \
+                           ((WAVE) == DAC_Wave_Triangle))
+/**
+  * @}
+  */
+
+/** @defgroup DAC_data
+  * @{
+  */
+
+#define IS_DAC_DATA(DATA) ((DATA) <= 0xFFF0)
+/**
+  * @}
+  */
+#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL)  || defined (STM32F10X_HD_VL)
+/** @defgroup DAC_interrupts_definition
+  * @{
+  */
+
+#define DAC_IT_DMAUDR                      ((uint32_t)0x00002000)
+#define IS_DAC_IT(IT) (((IT) == DAC_IT_DMAUDR))
+
+/**
+  * @}
+  */
+
+/** @defgroup DAC_flags_definition
+  * @{
+  */
+
+#define DAC_FLAG_DMAUDR                    ((uint32_t)0x00002000)
+#define IS_DAC_FLAG(FLAG) (((FLAG) == DAC_FLAG_DMAUDR))
+
+/**
+  * @}
+  */
+#endif
+
+/**
+  * @}
+  */
+
+/** @defgroup DAC_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DAC_Exported_Functions
+  * @{
+  */
+
+void DAC_DeInit(void);
+void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct);
+void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct);
+void DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState);
+#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
+void DAC_ITConfig(uint32_t DAC_Channel, uint32_t DAC_IT, FunctionalState NewState);
+#endif
+void DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState);
+void DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState);
+void DAC_DualSoftwareTriggerCmd(FunctionalState NewState);
+void DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState);
+void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data);
+void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data);
+void DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1);
+uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel);
+#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
+FlagStatus DAC_GetFlagStatus(uint32_t DAC_Channel, uint32_t DAC_FLAG);
+void DAC_ClearFlag(uint32_t DAC_Channel, uint32_t DAC_FLAG);
+ITStatus DAC_GetITStatus(uint32_t DAC_Channel, uint32_t DAC_IT);
+void DAC_ClearITPendingBit(uint32_t DAC_Channel, uint32_t DAC_IT);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__STM32F10x_DAC_H */
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_dbgmcu.h b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_dbgmcu.h
new file mode 100644
index 0000000..1e6a68a
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_dbgmcu.h
@@ -0,0 +1,119 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_dbgmcu.h
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file contains all the functions prototypes for the DBGMCU
+  *          firmware library.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F10x_DBGMCU_H
+#define __STM32F10x_DBGMCU_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup DBGMCU
+  * @{
+  */
+
+/** @defgroup DBGMCU_Exported_Types
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DBGMCU_Exported_Constants
+  * @{
+  */
+
+#define DBGMCU_SLEEP                 ((uint32_t)0x00000001)
+#define DBGMCU_STOP                  ((uint32_t)0x00000002)
+#define DBGMCU_STANDBY               ((uint32_t)0x00000004)
+#define DBGMCU_IWDG_STOP             ((uint32_t)0x00000100)
+#define DBGMCU_WWDG_STOP             ((uint32_t)0x00000200)
+#define DBGMCU_TIM1_STOP             ((uint32_t)0x00000400)
+#define DBGMCU_TIM2_STOP             ((uint32_t)0x00000800)
+#define DBGMCU_TIM3_STOP             ((uint32_t)0x00001000)
+#define DBGMCU_TIM4_STOP             ((uint32_t)0x00002000)
+#define DBGMCU_CAN1_STOP             ((uint32_t)0x00004000)
+#define DBGMCU_I2C1_SMBUS_TIMEOUT    ((uint32_t)0x00008000)
+#define DBGMCU_I2C2_SMBUS_TIMEOUT    ((uint32_t)0x00010000)
+#define DBGMCU_TIM8_STOP             ((uint32_t)0x00020000)
+#define DBGMCU_TIM5_STOP             ((uint32_t)0x00040000)
+#define DBGMCU_TIM6_STOP             ((uint32_t)0x00080000)
+#define DBGMCU_TIM7_STOP             ((uint32_t)0x00100000)
+#define DBGMCU_CAN2_STOP             ((uint32_t)0x00200000)
+#define DBGMCU_TIM15_STOP            ((uint32_t)0x00400000)
+#define DBGMCU_TIM16_STOP            ((uint32_t)0x00800000)
+#define DBGMCU_TIM17_STOP            ((uint32_t)0x01000000)
+#define DBGMCU_TIM12_STOP            ((uint32_t)0x02000000)
+#define DBGMCU_TIM13_STOP            ((uint32_t)0x04000000)
+#define DBGMCU_TIM14_STOP            ((uint32_t)0x08000000)
+#define DBGMCU_TIM9_STOP             ((uint32_t)0x10000000)
+#define DBGMCU_TIM10_STOP            ((uint32_t)0x20000000)
+#define DBGMCU_TIM11_STOP            ((uint32_t)0x40000000)
+
+#define IS_DBGMCU_PERIPH(PERIPH) ((((PERIPH) & 0x800000F8) == 0x00) && ((PERIPH) != 0x00))
+/**
+  * @}
+  */
+
+/** @defgroup DBGMCU_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DBGMCU_Exported_Functions
+  * @{
+  */
+
+uint32_t DBGMCU_GetREVID(void);
+uint32_t DBGMCU_GetDEVID(void);
+void DBGMCU_Config(uint32_t DBGMCU_Periph, FunctionalState NewState);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F10x_DBGMCU_H */
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_dma.h b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_dma.h
new file mode 100644
index 0000000..b5dc6a8
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_dma.h
@@ -0,0 +1,439 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_dma.h
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file contains all the functions prototypes for the DMA firmware
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F10x_DMA_H
+#define __STM32F10x_DMA_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup DMA
+  * @{
+  */
+
+/** @defgroup DMA_Exported_Types
+  * @{
+  */
+
+/**
+  * @brief  DMA Init structure definition
+  */
+
+typedef struct
+{
+  uint32_t DMA_PeripheralBaseAddr; /*!< Specifies the peripheral base address for DMAy Channelx. */
+
+  uint32_t DMA_MemoryBaseAddr;     /*!< Specifies the memory base address for DMAy Channelx. */
+
+  uint32_t DMA_DIR;                /*!< Specifies if the peripheral is the source or destination.
+                                        This parameter can be a value of @ref DMA_data_transfer_direction */
+
+  uint32_t DMA_BufferSize;         /*!< Specifies the buffer size, in data unit, of the specified Channel.
+                                        The data unit is equal to the configuration set in DMA_PeripheralDataSize
+                                        or DMA_MemoryDataSize members depending in the transfer direction. */
+
+  uint32_t DMA_PeripheralInc;      /*!< Specifies whether the Peripheral address register is incremented or not.
+                                        This parameter can be a value of @ref DMA_peripheral_incremented_mode */
+
+  uint32_t DMA_MemoryInc;          /*!< Specifies whether the memory address register is incremented or not.
+                                        This parameter can be a value of @ref DMA_memory_incremented_mode */
+
+  uint32_t DMA_PeripheralDataSize; /*!< Specifies the Peripheral data width.
+                                        This parameter can be a value of @ref DMA_peripheral_data_size */
+
+  uint32_t DMA_MemoryDataSize;     /*!< Specifies the Memory data width.
+                                        This parameter can be a value of @ref DMA_memory_data_size */
+
+  uint32_t DMA_Mode;               /*!< Specifies the operation mode of the DMAy Channelx.
+                                        This parameter can be a value of @ref DMA_circular_normal_mode.
+                                        @note: The circular buffer mode cannot be used if the memory-to-memory
+                                              data transfer is configured on the selected Channel */
+
+  uint32_t DMA_Priority;           /*!< Specifies the software priority for the DMAy Channelx.
+                                        This parameter can be a value of @ref DMA_priority_level */
+
+  uint32_t DMA_M2M;                /*!< Specifies if the DMAy Channelx will be used in memory-to-memory transfer.
+                                        This parameter can be a value of @ref DMA_memory_to_memory */
+}DMA_InitTypeDef;
+
+/**
+  * @}
+  */
+
+/** @defgroup DMA_Exported_Constants
+  * @{
+  */
+
+#define IS_DMA_ALL_PERIPH(PERIPH) (((PERIPH) == DMA1_Channel1) || \
+                                   ((PERIPH) == DMA1_Channel2) || \
+                                   ((PERIPH) == DMA1_Channel3) || \
+                                   ((PERIPH) == DMA1_Channel4) || \
+                                   ((PERIPH) == DMA1_Channel5) || \
+                                   ((PERIPH) == DMA1_Channel6) || \
+                                   ((PERIPH) == DMA1_Channel7) || \
+                                   ((PERIPH) == DMA2_Channel1) || \
+                                   ((PERIPH) == DMA2_Channel2) || \
+                                   ((PERIPH) == DMA2_Channel3) || \
+                                   ((PERIPH) == DMA2_Channel4) || \
+                                   ((PERIPH) == DMA2_Channel5))
+
+/** @defgroup DMA_data_transfer_direction
+  * @{
+  */
+
+#define DMA_DIR_PeripheralDST              ((uint32_t)0x00000010)
+#define DMA_DIR_PeripheralSRC              ((uint32_t)0x00000000)
+#define IS_DMA_DIR(DIR) (((DIR) == DMA_DIR_PeripheralDST) || \
+                         ((DIR) == DMA_DIR_PeripheralSRC))
+/**
+  * @}
+  */
+
+/** @defgroup DMA_peripheral_incremented_mode
+  * @{
+  */
+
+#define DMA_PeripheralInc_Enable           ((uint32_t)0x00000040)
+#define DMA_PeripheralInc_Disable          ((uint32_t)0x00000000)
+#define IS_DMA_PERIPHERAL_INC_STATE(STATE) (((STATE) == DMA_PeripheralInc_Enable) || \
+                                            ((STATE) == DMA_PeripheralInc_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup DMA_memory_incremented_mode
+  * @{
+  */
+
+#define DMA_MemoryInc_Enable               ((uint32_t)0x00000080)
+#define DMA_MemoryInc_Disable              ((uint32_t)0x00000000)
+#define IS_DMA_MEMORY_INC_STATE(STATE) (((STATE) == DMA_MemoryInc_Enable) || \
+                                        ((STATE) == DMA_MemoryInc_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup DMA_peripheral_data_size
+  * @{
+  */
+
+#define DMA_PeripheralDataSize_Byte        ((uint32_t)0x00000000)
+#define DMA_PeripheralDataSize_HalfWord    ((uint32_t)0x00000100)
+#define DMA_PeripheralDataSize_Word        ((uint32_t)0x00000200)
+#define IS_DMA_PERIPHERAL_DATA_SIZE(SIZE) (((SIZE) == DMA_PeripheralDataSize_Byte) || \
+                                           ((SIZE) == DMA_PeripheralDataSize_HalfWord) || \
+                                           ((SIZE) == DMA_PeripheralDataSize_Word))
+/**
+  * @}
+  */
+
+/** @defgroup DMA_memory_data_size
+  * @{
+  */
+
+#define DMA_MemoryDataSize_Byte            ((uint32_t)0x00000000)
+#define DMA_MemoryDataSize_HalfWord        ((uint32_t)0x00000400)
+#define DMA_MemoryDataSize_Word            ((uint32_t)0x00000800)
+#define IS_DMA_MEMORY_DATA_SIZE(SIZE) (((SIZE) == DMA_MemoryDataSize_Byte) || \
+                                       ((SIZE) == DMA_MemoryDataSize_HalfWord) || \
+                                       ((SIZE) == DMA_MemoryDataSize_Word))
+/**
+  * @}
+  */
+
+/** @defgroup DMA_circular_normal_mode
+  * @{
+  */
+
+#define DMA_Mode_Circular                  ((uint32_t)0x00000020)
+#define DMA_Mode_Normal                    ((uint32_t)0x00000000)
+#define IS_DMA_MODE(MODE) (((MODE) == DMA_Mode_Circular) || ((MODE) == DMA_Mode_Normal))
+/**
+  * @}
+  */
+
+/** @defgroup DMA_priority_level
+  * @{
+  */
+
+#define DMA_Priority_VeryHigh              ((uint32_t)0x00003000)
+#define DMA_Priority_High                  ((uint32_t)0x00002000)
+#define DMA_Priority_Medium                ((uint32_t)0x00001000)
+#define DMA_Priority_Low                   ((uint32_t)0x00000000)
+#define IS_DMA_PRIORITY(PRIORITY) (((PRIORITY) == DMA_Priority_VeryHigh) || \
+                                   ((PRIORITY) == DMA_Priority_High) || \
+                                   ((PRIORITY) == DMA_Priority_Medium) || \
+                                   ((PRIORITY) == DMA_Priority_Low))
+/**
+  * @}
+  */
+
+/** @defgroup DMA_memory_to_memory
+  * @{
+  */
+
+#define DMA_M2M_Enable                     ((uint32_t)0x00004000)
+#define DMA_M2M_Disable                    ((uint32_t)0x00000000)
+#define IS_DMA_M2M_STATE(STATE) (((STATE) == DMA_M2M_Enable) || ((STATE) == DMA_M2M_Disable))
+
+/**
+  * @}
+  */
+
+/** @defgroup DMA_interrupts_definition
+  * @{
+  */
+
+#define DMA_IT_TC                          ((uint32_t)0x00000002)
+#define DMA_IT_HT                          ((uint32_t)0x00000004)
+#define DMA_IT_TE                          ((uint32_t)0x00000008)
+#define IS_DMA_CONFIG_IT(IT) ((((IT) & 0xFFFFFFF1) == 0x00) && ((IT) != 0x00))
+
+#define DMA1_IT_GL1                        ((uint32_t)0x00000001)
+#define DMA1_IT_TC1                        ((uint32_t)0x00000002)
+#define DMA1_IT_HT1                        ((uint32_t)0x00000004)
+#define DMA1_IT_TE1                        ((uint32_t)0x00000008)
+#define DMA1_IT_GL2                        ((uint32_t)0x00000010)
+#define DMA1_IT_TC2                        ((uint32_t)0x00000020)
+#define DMA1_IT_HT2                        ((uint32_t)0x00000040)
+#define DMA1_IT_TE2                        ((uint32_t)0x00000080)
+#define DMA1_IT_GL3                        ((uint32_t)0x00000100)
+#define DMA1_IT_TC3                        ((uint32_t)0x00000200)
+#define DMA1_IT_HT3                        ((uint32_t)0x00000400)
+#define DMA1_IT_TE3                        ((uint32_t)0x00000800)
+#define DMA1_IT_GL4                        ((uint32_t)0x00001000)
+#define DMA1_IT_TC4                        ((uint32_t)0x00002000)
+#define DMA1_IT_HT4                        ((uint32_t)0x00004000)
+#define DMA1_IT_TE4                        ((uint32_t)0x00008000)
+#define DMA1_IT_GL5                        ((uint32_t)0x00010000)
+#define DMA1_IT_TC5                        ((uint32_t)0x00020000)
+#define DMA1_IT_HT5                        ((uint32_t)0x00040000)
+#define DMA1_IT_TE5                        ((uint32_t)0x00080000)
+#define DMA1_IT_GL6                        ((uint32_t)0x00100000)
+#define DMA1_IT_TC6                        ((uint32_t)0x00200000)
+#define DMA1_IT_HT6                        ((uint32_t)0x00400000)
+#define DMA1_IT_TE6                        ((uint32_t)0x00800000)
+#define DMA1_IT_GL7                        ((uint32_t)0x01000000)
+#define DMA1_IT_TC7                        ((uint32_t)0x02000000)
+#define DMA1_IT_HT7                        ((uint32_t)0x04000000)
+#define DMA1_IT_TE7                        ((uint32_t)0x08000000)
+
+#define DMA2_IT_GL1                        ((uint32_t)0x10000001)
+#define DMA2_IT_TC1                        ((uint32_t)0x10000002)
+#define DMA2_IT_HT1                        ((uint32_t)0x10000004)
+#define DMA2_IT_TE1                        ((uint32_t)0x10000008)
+#define DMA2_IT_GL2                        ((uint32_t)0x10000010)
+#define DMA2_IT_TC2                        ((uint32_t)0x10000020)
+#define DMA2_IT_HT2                        ((uint32_t)0x10000040)
+#define DMA2_IT_TE2                        ((uint32_t)0x10000080)
+#define DMA2_IT_GL3                        ((uint32_t)0x10000100)
+#define DMA2_IT_TC3                        ((uint32_t)0x10000200)
+#define DMA2_IT_HT3                        ((uint32_t)0x10000400)
+#define DMA2_IT_TE3                        ((uint32_t)0x10000800)
+#define DMA2_IT_GL4                        ((uint32_t)0x10001000)
+#define DMA2_IT_TC4                        ((uint32_t)0x10002000)
+#define DMA2_IT_HT4                        ((uint32_t)0x10004000)
+#define DMA2_IT_TE4                        ((uint32_t)0x10008000)
+#define DMA2_IT_GL5                        ((uint32_t)0x10010000)
+#define DMA2_IT_TC5                        ((uint32_t)0x10020000)
+#define DMA2_IT_HT5                        ((uint32_t)0x10040000)
+#define DMA2_IT_TE5                        ((uint32_t)0x10080000)
+
+#define IS_DMA_CLEAR_IT(IT) (((((IT) & 0xF0000000) == 0x00) || (((IT) & 0xEFF00000) == 0x00)) && ((IT) != 0x00))
+
+#define IS_DMA_GET_IT(IT) (((IT) == DMA1_IT_GL1) || ((IT) == DMA1_IT_TC1) || \
+                           ((IT) == DMA1_IT_HT1) || ((IT) == DMA1_IT_TE1) || \
+                           ((IT) == DMA1_IT_GL2) || ((IT) == DMA1_IT_TC2) || \
+                           ((IT) == DMA1_IT_HT2) || ((IT) == DMA1_IT_TE2) || \
+                           ((IT) == DMA1_IT_GL3) || ((IT) == DMA1_IT_TC3) || \
+                           ((IT) == DMA1_IT_HT3) || ((IT) == DMA1_IT_TE3) || \
+                           ((IT) == DMA1_IT_GL4) || ((IT) == DMA1_IT_TC4) || \
+                           ((IT) == DMA1_IT_HT4) || ((IT) == DMA1_IT_TE4) || \
+                           ((IT) == DMA1_IT_GL5) || ((IT) == DMA1_IT_TC5) || \
+                           ((IT) == DMA1_IT_HT5) || ((IT) == DMA1_IT_TE5) || \
+                           ((IT) == DMA1_IT_GL6) || ((IT) == DMA1_IT_TC6) || \
+                           ((IT) == DMA1_IT_HT6) || ((IT) == DMA1_IT_TE6) || \
+                           ((IT) == DMA1_IT_GL7) || ((IT) == DMA1_IT_TC7) || \
+                           ((IT) == DMA1_IT_HT7) || ((IT) == DMA1_IT_TE7) || \
+                           ((IT) == DMA2_IT_GL1) || ((IT) == DMA2_IT_TC1) || \
+                           ((IT) == DMA2_IT_HT1) || ((IT) == DMA2_IT_TE1) || \
+                           ((IT) == DMA2_IT_GL2) || ((IT) == DMA2_IT_TC2) || \
+                           ((IT) == DMA2_IT_HT2) || ((IT) == DMA2_IT_TE2) || \
+                           ((IT) == DMA2_IT_GL3) || ((IT) == DMA2_IT_TC3) || \
+                           ((IT) == DMA2_IT_HT3) || ((IT) == DMA2_IT_TE3) || \
+                           ((IT) == DMA2_IT_GL4) || ((IT) == DMA2_IT_TC4) || \
+                           ((IT) == DMA2_IT_HT4) || ((IT) == DMA2_IT_TE4) || \
+                           ((IT) == DMA2_IT_GL5) || ((IT) == DMA2_IT_TC5) || \
+                           ((IT) == DMA2_IT_HT5) || ((IT) == DMA2_IT_TE5))
+
+/**
+  * @}
+  */
+
+/** @defgroup DMA_flags_definition
+  * @{
+  */
+#define DMA1_FLAG_GL1                      ((uint32_t)0x00000001)
+#define DMA1_FLAG_TC1                      ((uint32_t)0x00000002)
+#define DMA1_FLAG_HT1                      ((uint32_t)0x00000004)
+#define DMA1_FLAG_TE1                      ((uint32_t)0x00000008)
+#define DMA1_FLAG_GL2                      ((uint32_t)0x00000010)
+#define DMA1_FLAG_TC2                      ((uint32_t)0x00000020)
+#define DMA1_FLAG_HT2                      ((uint32_t)0x00000040)
+#define DMA1_FLAG_TE2                      ((uint32_t)0x00000080)
+#define DMA1_FLAG_GL3                      ((uint32_t)0x00000100)
+#define DMA1_FLAG_TC3                      ((uint32_t)0x00000200)
+#define DMA1_FLAG_HT3                      ((uint32_t)0x00000400)
+#define DMA1_FLAG_TE3                      ((uint32_t)0x00000800)
+#define DMA1_FLAG_GL4                      ((uint32_t)0x00001000)
+#define DMA1_FLAG_TC4                      ((uint32_t)0x00002000)
+#define DMA1_FLAG_HT4                      ((uint32_t)0x00004000)
+#define DMA1_FLAG_TE4                      ((uint32_t)0x00008000)
+#define DMA1_FLAG_GL5                      ((uint32_t)0x00010000)
+#define DMA1_FLAG_TC5                      ((uint32_t)0x00020000)
+#define DMA1_FLAG_HT5                      ((uint32_t)0x00040000)
+#define DMA1_FLAG_TE5                      ((uint32_t)0x00080000)
+#define DMA1_FLAG_GL6                      ((uint32_t)0x00100000)
+#define DMA1_FLAG_TC6                      ((uint32_t)0x00200000)
+#define DMA1_FLAG_HT6                      ((uint32_t)0x00400000)
+#define DMA1_FLAG_TE6                      ((uint32_t)0x00800000)
+#define DMA1_FLAG_GL7                      ((uint32_t)0x01000000)
+#define DMA1_FLAG_TC7                      ((uint32_t)0x02000000)
+#define DMA1_FLAG_HT7                      ((uint32_t)0x04000000)
+#define DMA1_FLAG_TE7                      ((uint32_t)0x08000000)
+
+#define DMA2_FLAG_GL1                      ((uint32_t)0x10000001)
+#define DMA2_FLAG_TC1                      ((uint32_t)0x10000002)
+#define DMA2_FLAG_HT1                      ((uint32_t)0x10000004)
+#define DMA2_FLAG_TE1                      ((uint32_t)0x10000008)
+#define DMA2_FLAG_GL2                      ((uint32_t)0x10000010)
+#define DMA2_FLAG_TC2                      ((uint32_t)0x10000020)
+#define DMA2_FLAG_HT2                      ((uint32_t)0x10000040)
+#define DMA2_FLAG_TE2                      ((uint32_t)0x10000080)
+#define DMA2_FLAG_GL3                      ((uint32_t)0x10000100)
+#define DMA2_FLAG_TC3                      ((uint32_t)0x10000200)
+#define DMA2_FLAG_HT3                      ((uint32_t)0x10000400)
+#define DMA2_FLAG_TE3                      ((uint32_t)0x10000800)
+#define DMA2_FLAG_GL4                      ((uint32_t)0x10001000)
+#define DMA2_FLAG_TC4                      ((uint32_t)0x10002000)
+#define DMA2_FLAG_HT4                      ((uint32_t)0x10004000)
+#define DMA2_FLAG_TE4                      ((uint32_t)0x10008000)
+#define DMA2_FLAG_GL5                      ((uint32_t)0x10010000)
+#define DMA2_FLAG_TC5                      ((uint32_t)0x10020000)
+#define DMA2_FLAG_HT5                      ((uint32_t)0x10040000)
+#define DMA2_FLAG_TE5                      ((uint32_t)0x10080000)
+
+#define IS_DMA_CLEAR_FLAG(FLAG) (((((FLAG) & 0xF0000000) == 0x00) || (((FLAG) & 0xEFF00000) == 0x00)) && ((FLAG) != 0x00))
+
+#define IS_DMA_GET_FLAG(FLAG) (((FLAG) == DMA1_FLAG_GL1) || ((FLAG) == DMA1_FLAG_TC1) || \
+                               ((FLAG) == DMA1_FLAG_HT1) || ((FLAG) == DMA1_FLAG_TE1) || \
+                               ((FLAG) == DMA1_FLAG_GL2) || ((FLAG) == DMA1_FLAG_TC2) || \
+                               ((FLAG) == DMA1_FLAG_HT2) || ((FLAG) == DMA1_FLAG_TE2) || \
+                               ((FLAG) == DMA1_FLAG_GL3) || ((FLAG) == DMA1_FLAG_TC3) || \
+                               ((FLAG) == DMA1_FLAG_HT3) || ((FLAG) == DMA1_FLAG_TE3) || \
+                               ((FLAG) == DMA1_FLAG_GL4) || ((FLAG) == DMA1_FLAG_TC4) || \
+                               ((FLAG) == DMA1_FLAG_HT4) || ((FLAG) == DMA1_FLAG_TE4) || \
+                               ((FLAG) == DMA1_FLAG_GL5) || ((FLAG) == DMA1_FLAG_TC5) || \
+                               ((FLAG) == DMA1_FLAG_HT5) || ((FLAG) == DMA1_FLAG_TE5) || \
+                               ((FLAG) == DMA1_FLAG_GL6) || ((FLAG) == DMA1_FLAG_TC6) || \
+                               ((FLAG) == DMA1_FLAG_HT6) || ((FLAG) == DMA1_FLAG_TE6) || \
+                               ((FLAG) == DMA1_FLAG_GL7) || ((FLAG) == DMA1_FLAG_TC7) || \
+                               ((FLAG) == DMA1_FLAG_HT7) || ((FLAG) == DMA1_FLAG_TE7) || \
+                               ((FLAG) == DMA2_FLAG_GL1) || ((FLAG) == DMA2_FLAG_TC1) || \
+                               ((FLAG) == DMA2_FLAG_HT1) || ((FLAG) == DMA2_FLAG_TE1) || \
+                               ((FLAG) == DMA2_FLAG_GL2) || ((FLAG) == DMA2_FLAG_TC2) || \
+                               ((FLAG) == DMA2_FLAG_HT2) || ((FLAG) == DMA2_FLAG_TE2) || \
+                               ((FLAG) == DMA2_FLAG_GL3) || ((FLAG) == DMA2_FLAG_TC3) || \
+                               ((FLAG) == DMA2_FLAG_HT3) || ((FLAG) == DMA2_FLAG_TE3) || \
+                               ((FLAG) == DMA2_FLAG_GL4) || ((FLAG) == DMA2_FLAG_TC4) || \
+                               ((FLAG) == DMA2_FLAG_HT4) || ((FLAG) == DMA2_FLAG_TE4) || \
+                               ((FLAG) == DMA2_FLAG_GL5) || ((FLAG) == DMA2_FLAG_TC5) || \
+                               ((FLAG) == DMA2_FLAG_HT5) || ((FLAG) == DMA2_FLAG_TE5))
+/**
+  * @}
+  */
+
+/** @defgroup DMA_Buffer_Size
+  * @{
+  */
+
+#define IS_DMA_BUFFER_SIZE(SIZE) (((SIZE) >= 0x1) && ((SIZE) < 0x10000))
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DMA_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DMA_Exported_Functions
+  * @{
+  */
+
+void DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx);
+void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct);
+void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct);
+void DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState);
+void DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, uint32_t DMA_IT, FunctionalState NewState);
+void DMA_SetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx, uint16_t DataNumber);
+uint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx);
+FlagStatus DMA_GetFlagStatus(uint32_t DMAy_FLAG);
+void DMA_ClearFlag(uint32_t DMAy_FLAG);
+ITStatus DMA_GetITStatus(uint32_t DMAy_IT);
+void DMA_ClearITPendingBit(uint32_t DMAy_IT);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__STM32F10x_DMA_H */
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_exti.h b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_exti.h
new file mode 100644
index 0000000..a1ab7d0
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_exti.h
@@ -0,0 +1,184 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_exti.h
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file contains all the functions prototypes for the EXTI firmware
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F10x_EXTI_H
+#define __STM32F10x_EXTI_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup EXTI
+  * @{
+  */
+
+/** @defgroup EXTI_Exported_Types
+  * @{
+  */
+
+/**
+  * @brief  EXTI mode enumeration
+  */
+
+typedef enum
+{
+  EXTI_Mode_Interrupt = 0x00,
+  EXTI_Mode_Event = 0x04
+}EXTIMode_TypeDef;
+
+#define IS_EXTI_MODE(MODE) (((MODE) == EXTI_Mode_Interrupt) || ((MODE) == EXTI_Mode_Event))
+
+/**
+  * @brief  EXTI Trigger enumeration
+  */
+
+typedef enum
+{
+  EXTI_Trigger_Rising = 0x08,
+  EXTI_Trigger_Falling = 0x0C,
+  EXTI_Trigger_Rising_Falling = 0x10
+}EXTITrigger_TypeDef;
+
+#define IS_EXTI_TRIGGER(TRIGGER) (((TRIGGER) == EXTI_Trigger_Rising) || \
+                                  ((TRIGGER) == EXTI_Trigger_Falling) || \
+                                  ((TRIGGER) == EXTI_Trigger_Rising_Falling))
+/**
+  * @brief  EXTI Init Structure definition
+  */
+
+typedef struct
+{
+  uint32_t EXTI_Line;               /*!< Specifies the EXTI lines to be enabled or disabled.
+                                         This parameter can be any combination of @ref EXTI_Lines */
+
+  EXTIMode_TypeDef EXTI_Mode;       /*!< Specifies the mode for the EXTI lines.
+                                         This parameter can be a value of @ref EXTIMode_TypeDef */
+
+  EXTITrigger_TypeDef EXTI_Trigger; /*!< Specifies the trigger signal active edge for the EXTI lines.
+                                         This parameter can be a value of @ref EXTIMode_TypeDef */
+
+  FunctionalState EXTI_LineCmd;     /*!< Specifies the new state of the selected EXTI lines.
+                                         This parameter can be set either to ENABLE or DISABLE */
+}EXTI_InitTypeDef;
+
+/**
+  * @}
+  */
+
+/** @defgroup EXTI_Exported_Constants
+  * @{
+  */
+
+/** @defgroup EXTI_Lines
+  * @{
+  */
+
+#define EXTI_Line0       ((uint32_t)0x00001)  /*!< External interrupt line 0 */
+#define EXTI_Line1       ((uint32_t)0x00002)  /*!< External interrupt line 1 */
+#define EXTI_Line2       ((uint32_t)0x00004)  /*!< External interrupt line 2 */
+#define EXTI_Line3       ((uint32_t)0x00008)  /*!< External interrupt line 3 */
+#define EXTI_Line4       ((uint32_t)0x00010)  /*!< External interrupt line 4 */
+#define EXTI_Line5       ((uint32_t)0x00020)  /*!< External interrupt line 5 */
+#define EXTI_Line6       ((uint32_t)0x00040)  /*!< External interrupt line 6 */
+#define EXTI_Line7       ((uint32_t)0x00080)  /*!< External interrupt line 7 */
+#define EXTI_Line8       ((uint32_t)0x00100)  /*!< External interrupt line 8 */
+#define EXTI_Line9       ((uint32_t)0x00200)  /*!< External interrupt line 9 */
+#define EXTI_Line10      ((uint32_t)0x00400)  /*!< External interrupt line 10 */
+#define EXTI_Line11      ((uint32_t)0x00800)  /*!< External interrupt line 11 */
+#define EXTI_Line12      ((uint32_t)0x01000)  /*!< External interrupt line 12 */
+#define EXTI_Line13      ((uint32_t)0x02000)  /*!< External interrupt line 13 */
+#define EXTI_Line14      ((uint32_t)0x04000)  /*!< External interrupt line 14 */
+#define EXTI_Line15      ((uint32_t)0x08000)  /*!< External interrupt line 15 */
+#define EXTI_Line16      ((uint32_t)0x10000)  /*!< External interrupt line 16 Connected to the PVD Output */
+#define EXTI_Line17      ((uint32_t)0x20000)  /*!< External interrupt line 17 Connected to the RTC Alarm event */
+#define EXTI_Line18      ((uint32_t)0x40000)  /*!< External interrupt line 18 Connected to the USB Device/USB OTG FS
+                                                   Wakeup from suspend event */
+#define EXTI_Line19      ((uint32_t)0x80000)  /*!< External interrupt line 19 Connected to the Ethernet Wakeup event */
+
+#define IS_EXTI_LINE(LINE) ((((LINE) & (uint32_t)0xFFF00000) == 0x00) && ((LINE) != (uint16_t)0x00))
+#define IS_GET_EXTI_LINE(LINE) (((LINE) == EXTI_Line0) || ((LINE) == EXTI_Line1) || \
+                            ((LINE) == EXTI_Line2) || ((LINE) == EXTI_Line3) || \
+                            ((LINE) == EXTI_Line4) || ((LINE) == EXTI_Line5) || \
+                            ((LINE) == EXTI_Line6) || ((LINE) == EXTI_Line7) || \
+                            ((LINE) == EXTI_Line8) || ((LINE) == EXTI_Line9) || \
+                            ((LINE) == EXTI_Line10) || ((LINE) == EXTI_Line11) || \
+                            ((LINE) == EXTI_Line12) || ((LINE) == EXTI_Line13) || \
+                            ((LINE) == EXTI_Line14) || ((LINE) == EXTI_Line15) || \
+                            ((LINE) == EXTI_Line16) || ((LINE) == EXTI_Line17) || \
+                            ((LINE) == EXTI_Line18) || ((LINE) == EXTI_Line19))
+
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup EXTI_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup EXTI_Exported_Functions
+  * @{
+  */
+
+void EXTI_DeInit(void);
+void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct);
+void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct);
+void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line);
+FlagStatus EXTI_GetFlagStatus(uint32_t EXTI_Line);
+void EXTI_ClearFlag(uint32_t EXTI_Line);
+ITStatus EXTI_GetITStatus(uint32_t EXTI_Line);
+void EXTI_ClearITPendingBit(uint32_t EXTI_Line);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F10x_EXTI_H */
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_flash.h b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_flash.h
new file mode 100644
index 0000000..f46d4e8
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_flash.h
@@ -0,0 +1,426 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_flash.h
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file contains all the functions prototypes for the FLASH
+  *          firmware library.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F10x_FLASH_H
+#define __STM32F10x_FLASH_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup FLASH
+  * @{
+  */
+
+/** @defgroup FLASH_Exported_Types
+  * @{
+  */
+
+/**
+  * @brief  FLASH Status
+  */
+
+typedef enum
+{
+  FLASH_BUSY = 1,
+  FLASH_ERROR_PG,
+  FLASH_ERROR_WRP,
+  FLASH_COMPLETE,
+  FLASH_TIMEOUT
+}FLASH_Status;
+
+/**
+  * @}
+  */
+
+/** @defgroup FLASH_Exported_Constants
+  * @{
+  */
+
+/** @defgroup Flash_Latency
+  * @{
+  */
+
+#define FLASH_Latency_0                ((uint32_t)0x00000000)  /*!< FLASH Zero Latency cycle */
+#define FLASH_Latency_1                ((uint32_t)0x00000001)  /*!< FLASH One Latency cycle */
+#define FLASH_Latency_2                ((uint32_t)0x00000002)  /*!< FLASH Two Latency cycles */
+#define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_Latency_0) || \
+                                   ((LATENCY) == FLASH_Latency_1) || \
+                                   ((LATENCY) == FLASH_Latency_2))
+/**
+  * @}
+  */
+
+/** @defgroup Half_Cycle_Enable_Disable
+  * @{
+  */
+
+#define FLASH_HalfCycleAccess_Enable   ((uint32_t)0x00000008)  /*!< FLASH Half Cycle Enable */
+#define FLASH_HalfCycleAccess_Disable  ((uint32_t)0x00000000)  /*!< FLASH Half Cycle Disable */
+#define IS_FLASH_HALFCYCLEACCESS_STATE(STATE) (((STATE) == FLASH_HalfCycleAccess_Enable) || \
+                                               ((STATE) == FLASH_HalfCycleAccess_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup Prefetch_Buffer_Enable_Disable
+  * @{
+  */
+
+#define FLASH_PrefetchBuffer_Enable    ((uint32_t)0x00000010)  /*!< FLASH Prefetch Buffer Enable */
+#define FLASH_PrefetchBuffer_Disable   ((uint32_t)0x00000000)  /*!< FLASH Prefetch Buffer Disable */
+#define IS_FLASH_PREFETCHBUFFER_STATE(STATE) (((STATE) == FLASH_PrefetchBuffer_Enable) || \
+                                              ((STATE) == FLASH_PrefetchBuffer_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup Option_Bytes_Write_Protection
+  * @{
+  */
+
+/* Values to be used with STM32 Low and Medium density devices */
+#define FLASH_WRProt_Pages0to3         ((uint32_t)0x00000001) /*!< STM32 Low and Medium density devices: Write protection of page 0 to 3 */
+#define FLASH_WRProt_Pages4to7         ((uint32_t)0x00000002) /*!< STM32 Low and Medium density devices: Write protection of page 4 to 7 */
+#define FLASH_WRProt_Pages8to11        ((uint32_t)0x00000004) /*!< STM32 Low and Medium density devices: Write protection of page 8 to 11 */
+#define FLASH_WRProt_Pages12to15       ((uint32_t)0x00000008) /*!< STM32 Low and Medium density devices: Write protection of page 12 to 15 */
+#define FLASH_WRProt_Pages16to19       ((uint32_t)0x00000010) /*!< STM32 Low and Medium density devices: Write protection of page 16 to 19 */
+#define FLASH_WRProt_Pages20to23       ((uint32_t)0x00000020) /*!< STM32 Low and Medium density devices: Write protection of page 20 to 23 */
+#define FLASH_WRProt_Pages24to27       ((uint32_t)0x00000040) /*!< STM32 Low and Medium density devices: Write protection of page 24 to 27 */
+#define FLASH_WRProt_Pages28to31       ((uint32_t)0x00000080) /*!< STM32 Low and Medium density devices: Write protection of page 28 to 31 */
+
+/* Values to be used with STM32 Medium-density devices */
+#define FLASH_WRProt_Pages32to35       ((uint32_t)0x00000100) /*!< STM32 Medium-density devices: Write protection of page 32 to 35 */
+#define FLASH_WRProt_Pages36to39       ((uint32_t)0x00000200) /*!< STM32 Medium-density devices: Write protection of page 36 to 39 */
+#define FLASH_WRProt_Pages40to43       ((uint32_t)0x00000400) /*!< STM32 Medium-density devices: Write protection of page 40 to 43 */
+#define FLASH_WRProt_Pages44to47       ((uint32_t)0x00000800) /*!< STM32 Medium-density devices: Write protection of page 44 to 47 */
+#define FLASH_WRProt_Pages48to51       ((uint32_t)0x00001000) /*!< STM32 Medium-density devices: Write protection of page 48 to 51 */
+#define FLASH_WRProt_Pages52to55       ((uint32_t)0x00002000) /*!< STM32 Medium-density devices: Write protection of page 52 to 55 */
+#define FLASH_WRProt_Pages56to59       ((uint32_t)0x00004000) /*!< STM32 Medium-density devices: Write protection of page 56 to 59 */
+#define FLASH_WRProt_Pages60to63       ((uint32_t)0x00008000) /*!< STM32 Medium-density devices: Write protection of page 60 to 63 */
+#define FLASH_WRProt_Pages64to67       ((uint32_t)0x00010000) /*!< STM32 Medium-density devices: Write protection of page 64 to 67 */
+#define FLASH_WRProt_Pages68to71       ((uint32_t)0x00020000) /*!< STM32 Medium-density devices: Write protection of page 68 to 71 */
+#define FLASH_WRProt_Pages72to75       ((uint32_t)0x00040000) /*!< STM32 Medium-density devices: Write protection of page 72 to 75 */
+#define FLASH_WRProt_Pages76to79       ((uint32_t)0x00080000) /*!< STM32 Medium-density devices: Write protection of page 76 to 79 */
+#define FLASH_WRProt_Pages80to83       ((uint32_t)0x00100000) /*!< STM32 Medium-density devices: Write protection of page 80 to 83 */
+#define FLASH_WRProt_Pages84to87       ((uint32_t)0x00200000) /*!< STM32 Medium-density devices: Write protection of page 84 to 87 */
+#define FLASH_WRProt_Pages88to91       ((uint32_t)0x00400000) /*!< STM32 Medium-density devices: Write protection of page 88 to 91 */
+#define FLASH_WRProt_Pages92to95       ((uint32_t)0x00800000) /*!< STM32 Medium-density devices: Write protection of page 92 to 95 */
+#define FLASH_WRProt_Pages96to99       ((uint32_t)0x01000000) /*!< STM32 Medium-density devices: Write protection of page 96 to 99 */
+#define FLASH_WRProt_Pages100to103     ((uint32_t)0x02000000) /*!< STM32 Medium-density devices: Write protection of page 100 to 103 */
+#define FLASH_WRProt_Pages104to107     ((uint32_t)0x04000000) /*!< STM32 Medium-density devices: Write protection of page 104 to 107 */
+#define FLASH_WRProt_Pages108to111     ((uint32_t)0x08000000) /*!< STM32 Medium-density devices: Write protection of page 108 to 111 */
+#define FLASH_WRProt_Pages112to115     ((uint32_t)0x10000000) /*!< STM32 Medium-density devices: Write protection of page 112 to 115 */
+#define FLASH_WRProt_Pages116to119     ((uint32_t)0x20000000) /*!< STM32 Medium-density devices: Write protection of page 115 to 119 */
+#define FLASH_WRProt_Pages120to123     ((uint32_t)0x40000000) /*!< STM32 Medium-density devices: Write protection of page 120 to 123 */
+#define FLASH_WRProt_Pages124to127     ((uint32_t)0x80000000) /*!< STM32 Medium-density devices: Write protection of page 124 to 127 */
+
+/* Values to be used with STM32 High-density and STM32F10X Connectivity line devices */
+#define FLASH_WRProt_Pages0to1         ((uint32_t)0x00000001) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 0 to 1 */
+#define FLASH_WRProt_Pages2to3         ((uint32_t)0x00000002) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 2 to 3 */
+#define FLASH_WRProt_Pages4to5         ((uint32_t)0x00000004) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 4 to 5 */
+#define FLASH_WRProt_Pages6to7         ((uint32_t)0x00000008) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 6 to 7 */
+#define FLASH_WRProt_Pages8to9         ((uint32_t)0x00000010) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 8 to 9 */
+#define FLASH_WRProt_Pages10to11       ((uint32_t)0x00000020) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 10 to 11 */
+#define FLASH_WRProt_Pages12to13       ((uint32_t)0x00000040) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 12 to 13 */
+#define FLASH_WRProt_Pages14to15       ((uint32_t)0x00000080) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 14 to 15 */
+#define FLASH_WRProt_Pages16to17       ((uint32_t)0x00000100) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 16 to 17 */
+#define FLASH_WRProt_Pages18to19       ((uint32_t)0x00000200) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 18 to 19 */
+#define FLASH_WRProt_Pages20to21       ((uint32_t)0x00000400) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 20 to 21 */
+#define FLASH_WRProt_Pages22to23       ((uint32_t)0x00000800) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 22 to 23 */
+#define FLASH_WRProt_Pages24to25       ((uint32_t)0x00001000) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 24 to 25 */
+#define FLASH_WRProt_Pages26to27       ((uint32_t)0x00002000) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 26 to 27 */
+#define FLASH_WRProt_Pages28to29       ((uint32_t)0x00004000) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 28 to 29 */
+#define FLASH_WRProt_Pages30to31       ((uint32_t)0x00008000) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 30 to 31 */
+#define FLASH_WRProt_Pages32to33       ((uint32_t)0x00010000) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 32 to 33 */
+#define FLASH_WRProt_Pages34to35       ((uint32_t)0x00020000) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 34 to 35 */
+#define FLASH_WRProt_Pages36to37       ((uint32_t)0x00040000) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 36 to 37 */
+#define FLASH_WRProt_Pages38to39       ((uint32_t)0x00080000) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 38 to 39 */
+#define FLASH_WRProt_Pages40to41       ((uint32_t)0x00100000) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 40 to 41 */
+#define FLASH_WRProt_Pages42to43       ((uint32_t)0x00200000) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 42 to 43 */
+#define FLASH_WRProt_Pages44to45       ((uint32_t)0x00400000) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 44 to 45 */
+#define FLASH_WRProt_Pages46to47       ((uint32_t)0x00800000) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 46 to 47 */
+#define FLASH_WRProt_Pages48to49       ((uint32_t)0x01000000) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 48 to 49 */
+#define FLASH_WRProt_Pages50to51       ((uint32_t)0x02000000) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 50 to 51 */
+#define FLASH_WRProt_Pages52to53       ((uint32_t)0x04000000) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 52 to 53 */
+#define FLASH_WRProt_Pages54to55       ((uint32_t)0x08000000) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 54 to 55 */
+#define FLASH_WRProt_Pages56to57       ((uint32_t)0x10000000) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 56 to 57 */
+#define FLASH_WRProt_Pages58to59       ((uint32_t)0x20000000) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 58 to 59 */
+#define FLASH_WRProt_Pages60to61       ((uint32_t)0x40000000) /*!< STM32 High-density, XL-density and Connectivity line devices:
+                                                                   Write protection of page 60 to 61 */
+#define FLASH_WRProt_Pages62to127      ((uint32_t)0x80000000) /*!< STM32 Connectivity line devices: Write protection of page 62 to 127 */
+#define FLASH_WRProt_Pages62to255      ((uint32_t)0x80000000) /*!< STM32 Medium-density devices: Write protection of page 62 to 255 */
+#define FLASH_WRProt_Pages62to511      ((uint32_t)0x80000000) /*!< STM32 XL-density devices: Write protection of page 62 to 511 */
+
+#define FLASH_WRProt_AllPages          ((uint32_t)0xFFFFFFFF) /*!< Write protection of all Pages */
+
+#define IS_FLASH_WRPROT_PAGE(PAGE) (((PAGE) != 0x00000000))
+
+#define IS_FLASH_ADDRESS(ADDRESS) (((ADDRESS) >= 0x08000000) && ((ADDRESS) < 0x080FFFFF))
+
+#define IS_OB_DATA_ADDRESS(ADDRESS) (((ADDRESS) == 0x1FFFF804) || ((ADDRESS) == 0x1FFFF806))
+
+/**
+  * @}
+  */
+
+/** @defgroup Option_Bytes_IWatchdog
+  * @{
+  */
+
+#define OB_IWDG_SW                     ((uint16_t)0x0001)  /*!< Software IWDG selected */
+#define OB_IWDG_HW                     ((uint16_t)0x0000)  /*!< Hardware IWDG selected */
+#define IS_OB_IWDG_SOURCE(SOURCE) (((SOURCE) == OB_IWDG_SW) || ((SOURCE) == OB_IWDG_HW))
+
+/**
+  * @}
+  */
+
+/** @defgroup Option_Bytes_nRST_STOP
+  * @{
+  */
+
+#define OB_STOP_NoRST                  ((uint16_t)0x0002) /*!< No reset generated when entering in STOP */
+#define OB_STOP_RST                    ((uint16_t)0x0000) /*!< Reset generated when entering in STOP */
+#define IS_OB_STOP_SOURCE(SOURCE) (((SOURCE) == OB_STOP_NoRST) || ((SOURCE) == OB_STOP_RST))
+
+/**
+  * @}
+  */
+
+/** @defgroup Option_Bytes_nRST_STDBY
+  * @{
+  */
+
+#define OB_STDBY_NoRST                 ((uint16_t)0x0004) /*!< No reset generated when entering in STANDBY */
+#define OB_STDBY_RST                   ((uint16_t)0x0000) /*!< Reset generated when entering in STANDBY */
+#define IS_OB_STDBY_SOURCE(SOURCE) (((SOURCE) == OB_STDBY_NoRST) || ((SOURCE) == OB_STDBY_RST))
+
+#ifdef STM32F10X_XL
+/**
+  * @}
+  */
+/** @defgroup FLASH_Boot
+  * @{
+  */
+#define FLASH_BOOT_Bank1  ((uint16_t)0x0000) /*!< At startup, if boot pins are set in boot from user Flash position
+                                                  and this parameter is selected the device will boot from Bank1(Default) */
+#define FLASH_BOOT_Bank2  ((uint16_t)0x0001) /*!< At startup, if boot pins are set in boot from user Flash position
+                                                  and this parameter is selected the device will boot from Bank 2 or Bank 1,
+                                                  depending on the activation of the bank */
+#define IS_FLASH_BOOT(BOOT) (((BOOT) == FLASH_BOOT_Bank1) || ((BOOT) == FLASH_BOOT_Bank2))
+#endif
+/**
+  * @}
+  */
+/** @defgroup FLASH_Interrupts
+  * @{
+  */
+#ifdef STM32F10X_XL
+#define FLASH_IT_BANK2_ERROR                 ((uint32_t)0x80000400)  /*!< FPEC BANK2 error interrupt source */
+#define FLASH_IT_BANK2_EOP                   ((uint32_t)0x80001000)  /*!< End of FLASH BANK2 Operation Interrupt source */
+
+#define FLASH_IT_BANK1_ERROR                 FLASH_IT_ERROR          /*!< FPEC BANK1 error interrupt source */
+#define FLASH_IT_BANK1_EOP                   FLASH_IT_EOP            /*!< End of FLASH BANK1 Operation Interrupt source */
+
+#define FLASH_IT_ERROR                 ((uint32_t)0x00000400)  /*!< FPEC BANK1 error interrupt source */
+#define FLASH_IT_EOP                   ((uint32_t)0x00001000)  /*!< End of FLASH BANK1 Operation Interrupt source */
+#define IS_FLASH_IT(IT) ((((IT) & (uint32_t)0x7FFFEBFF) == 0x00000000) && (((IT) != 0x00000000)))
+#else
+#define FLASH_IT_ERROR                 ((uint32_t)0x00000400)  /*!< FPEC error interrupt source */
+#define FLASH_IT_EOP                   ((uint32_t)0x00001000)  /*!< End of FLASH Operation Interrupt source */
+#define FLASH_IT_BANK1_ERROR           FLASH_IT_ERROR          /*!< FPEC BANK1 error interrupt source */
+#define FLASH_IT_BANK1_EOP             FLASH_IT_EOP            /*!< End of FLASH BANK1 Operation Interrupt source */
+
+#define IS_FLASH_IT(IT) ((((IT) & (uint32_t)0xFFFFEBFF) == 0x00000000) && (((IT) != 0x00000000)))
+#endif
+
+/**
+  * @}
+  */
+
+/** @defgroup FLASH_Flags
+  * @{
+  */
+#ifdef STM32F10X_XL
+#define FLASH_FLAG_BANK2_BSY                 ((uint32_t)0x80000001)  /*!< FLASH BANK2 Busy flag */
+#define FLASH_FLAG_BANK2_EOP                 ((uint32_t)0x80000020)  /*!< FLASH BANK2 End of Operation flag */
+#define FLASH_FLAG_BANK2_PGERR               ((uint32_t)0x80000004)  /*!< FLASH BANK2 Program error flag */
+#define FLASH_FLAG_BANK2_WRPRTERR            ((uint32_t)0x80000010)  /*!< FLASH BANK2 Write protected error flag */
+
+#define FLASH_FLAG_BANK1_BSY                 FLASH_FLAG_BSY       /*!< FLASH BANK1 Busy flag*/
+#define FLASH_FLAG_BANK1_EOP                 FLASH_FLAG_EOP       /*!< FLASH BANK1 End of Operation flag */
+#define FLASH_FLAG_BANK1_PGERR               FLASH_FLAG_PGERR     /*!< FLASH BANK1 Program error flag */
+#define FLASH_FLAG_BANK1_WRPRTERR            FLASH_FLAG_WRPRTERR  /*!< FLASH BANK1 Write protected error flag */
+
+#define FLASH_FLAG_BSY                 ((uint32_t)0x00000001)  /*!< FLASH Busy flag */
+#define FLASH_FLAG_EOP                 ((uint32_t)0x00000020)  /*!< FLASH End of Operation flag */
+#define FLASH_FLAG_PGERR               ((uint32_t)0x00000004)  /*!< FLASH Program error flag */
+#define FLASH_FLAG_WRPRTERR            ((uint32_t)0x00000010)  /*!< FLASH Write protected error flag */
+#define FLASH_FLAG_OPTERR              ((uint32_t)0x00000001)  /*!< FLASH Option Byte error flag */
+
+#define IS_FLASH_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0x7FFFFFCA) == 0x00000000) && ((FLAG) != 0x00000000))
+#define IS_FLASH_GET_FLAG(FLAG)  (((FLAG) == FLASH_FLAG_BSY) || ((FLAG) == FLASH_FLAG_EOP) || \
+                                  ((FLAG) == FLASH_FLAG_PGERR) || ((FLAG) == FLASH_FLAG_WRPRTERR) || \
+                                  ((FLAG) == FLASH_FLAG_OPTERR)|| \
+                                  ((FLAG) == FLASH_FLAG_BANK1_BSY) || ((FLAG) == FLASH_FLAG_BANK1_EOP) || \
+                                  ((FLAG) == FLASH_FLAG_BANK1_PGERR) || ((FLAG) == FLASH_FLAG_BANK1_WRPRTERR) || \
+                                  ((FLAG) == FLASH_FLAG_BANK2_BSY) || ((FLAG) == FLASH_FLAG_BANK2_EOP) || \
+                                  ((FLAG) == FLASH_FLAG_BANK2_PGERR) || ((FLAG) == FLASH_FLAG_BANK2_WRPRTERR))
+#else
+#define FLASH_FLAG_BSY                 ((uint32_t)0x00000001)  /*!< FLASH Busy flag */
+#define FLASH_FLAG_EOP                 ((uint32_t)0x00000020)  /*!< FLASH End of Operation flag */
+#define FLASH_FLAG_PGERR               ((uint32_t)0x00000004)  /*!< FLASH Program error flag */
+#define FLASH_FLAG_WRPRTERR            ((uint32_t)0x00000010)  /*!< FLASH Write protected error flag */
+#define FLASH_FLAG_OPTERR              ((uint32_t)0x00000001)  /*!< FLASH Option Byte error flag */
+
+#define FLASH_FLAG_BANK1_BSY                 FLASH_FLAG_BSY       /*!< FLASH BANK1 Busy flag*/
+#define FLASH_FLAG_BANK1_EOP                 FLASH_FLAG_EOP       /*!< FLASH BANK1 End of Operation flag */
+#define FLASH_FLAG_BANK1_PGERR               FLASH_FLAG_PGERR     /*!< FLASH BANK1 Program error flag */
+#define FLASH_FLAG_BANK1_WRPRTERR            FLASH_FLAG_WRPRTERR  /*!< FLASH BANK1 Write protected error flag */
+
+#define IS_FLASH_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFFFFFFCA) == 0x00000000) && ((FLAG) != 0x00000000))
+#define IS_FLASH_GET_FLAG(FLAG)  (((FLAG) == FLASH_FLAG_BSY) || ((FLAG) == FLASH_FLAG_EOP) || \
+                                  ((FLAG) == FLASH_FLAG_PGERR) || ((FLAG) == FLASH_FLAG_WRPRTERR) || \
+								  ((FLAG) == FLASH_FLAG_BANK1_BSY) || ((FLAG) == FLASH_FLAG_BANK1_EOP) || \
+                                  ((FLAG) == FLASH_FLAG_BANK1_PGERR) || ((FLAG) == FLASH_FLAG_BANK1_WRPRTERR) || \
+                                  ((FLAG) == FLASH_FLAG_OPTERR))
+#endif
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup FLASH_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup FLASH_Exported_Functions
+  * @{
+  */
+
+/*------------ Functions used for all STM32F10x devices -----*/
+void FLASH_SetLatency(uint32_t FLASH_Latency);
+void FLASH_HalfCycleAccessCmd(uint32_t FLASH_HalfCycleAccess);
+void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer);
+void FLASH_Unlock(void);
+void FLASH_Lock(void);
+FLASH_Status FLASH_ErasePage(uint32_t Page_Address);
+FLASH_Status FLASH_EraseAllPages(void);
+FLASH_Status FLASH_EraseOptionBytes(void);
+FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data);
+FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data);
+FLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data);
+FLASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages);
+FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState);
+FLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY);
+uint32_t FLASH_GetUserOptionByte(void);
+uint32_t FLASH_GetWriteProtectionOptionByte(void);
+FlagStatus FLASH_GetReadOutProtectionStatus(void);
+FlagStatus FLASH_GetPrefetchBufferStatus(void);
+void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState);
+FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG);
+void FLASH_ClearFlag(uint32_t FLASH_FLAG);
+FLASH_Status FLASH_GetStatus(void);
+FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout);
+
+/*------------ New function used for all STM32F10x devices -----*/
+void FLASH_UnlockBank1(void);
+void FLASH_LockBank1(void);
+FLASH_Status FLASH_EraseAllBank1Pages(void);
+FLASH_Status FLASH_GetBank1Status(void);
+FLASH_Status FLASH_WaitForLastBank1Operation(uint32_t Timeout);
+
+#ifdef STM32F10X_XL
+/*---- New Functions used only with STM32F10x_XL density devices -----*/
+void FLASH_UnlockBank2(void);
+void FLASH_LockBank2(void);
+FLASH_Status FLASH_EraseAllBank2Pages(void);
+FLASH_Status FLASH_GetBank2Status(void);
+FLASH_Status FLASH_WaitForLastBank2Operation(uint32_t Timeout);
+FLASH_Status FLASH_BootConfig(uint16_t FLASH_BOOT);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F10x_FLASH_H */
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_fsmc.h b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_fsmc.h
new file mode 100644
index 0000000..ee707e7
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_fsmc.h
@@ -0,0 +1,733 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_fsmc.h
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file contains all the functions prototypes for the FSMC firmware
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F10x_FSMC_H
+#define __STM32F10x_FSMC_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup FSMC
+  * @{
+  */
+
+/** @defgroup FSMC_Exported_Types
+  * @{
+  */
+
+/**
+  * @brief  Timing parameters For NOR/SRAM Banks
+  */
+
+typedef struct
+{
+  uint32_t FSMC_AddressSetupTime;       /*!< Defines the number of HCLK cycles to configure
+                                             the duration of the address setup time.
+                                             This parameter can be a value between 0 and 0xF.
+                                             @note: It is not used with synchronous NOR Flash memories. */
+
+  uint32_t FSMC_AddressHoldTime;        /*!< Defines the number of HCLK cycles to configure
+                                             the duration of the address hold time.
+                                             This parameter can be a value between 0 and 0xF.
+                                             @note: It is not used with synchronous NOR Flash memories.*/
+
+  uint32_t FSMC_DataSetupTime;          /*!< Defines the number of HCLK cycles to configure
+                                             the duration of the data setup time.
+                                             This parameter can be a value between 0 and 0xFF.
+                                             @note: It is used for SRAMs, ROMs and asynchronous multiplexed NOR Flash memories. */
+
+  uint32_t FSMC_BusTurnAroundDuration;  /*!< Defines the number of HCLK cycles to configure
+                                             the duration of the bus turnaround.
+                                             This parameter can be a value between 0 and 0xF.
+                                             @note: It is only used for multiplexed NOR Flash memories. */
+
+  uint32_t FSMC_CLKDivision;            /*!< Defines the period of CLK clock output signal, expressed in number of HCLK cycles.
+                                             This parameter can be a value between 1 and 0xF.
+                                             @note: This parameter is not used for asynchronous NOR Flash, SRAM or ROM accesses. */
+
+  uint32_t FSMC_DataLatency;            /*!< Defines the number of memory clock cycles to issue
+                                             to the memory before getting the first data.
+                                             The value of this parameter depends on the memory type as shown below:
+                                              - It must be set to 0 in case of a CRAM
+                                              - It is don't care in asynchronous NOR, SRAM or ROM accesses
+                                              - It may assume a value between 0 and 0xF in NOR Flash memories
+                                                with synchronous burst mode enable */
+
+  uint32_t FSMC_AccessMode;             /*!< Specifies the asynchronous access mode.
+                                             This parameter can be a value of @ref FSMC_Access_Mode */
+}FSMC_NORSRAMTimingInitTypeDef;
+
+/**
+  * @brief  FSMC NOR/SRAM Init structure definition
+  */
+
+typedef struct
+{
+  uint32_t FSMC_Bank;                /*!< Specifies the NOR/SRAM memory bank that will be used.
+                                          This parameter can be a value of @ref FSMC_NORSRAM_Bank */
+
+  uint32_t FSMC_DataAddressMux;      /*!< Specifies whether the address and data values are
+                                          multiplexed on the databus or not.
+                                          This parameter can be a value of @ref FSMC_Data_Address_Bus_Multiplexing */
+
+  uint32_t FSMC_MemoryType;          /*!< Specifies the type of external memory attached to
+                                          the corresponding memory bank.
+                                          This parameter can be a value of @ref FSMC_Memory_Type */
+
+  uint32_t FSMC_MemoryDataWidth;     /*!< Specifies the external memory device width.
+                                          This parameter can be a value of @ref FSMC_Data_Width */
+
+  uint32_t FSMC_BurstAccessMode;     /*!< Enables or disables the burst access mode for Flash memory,
+                                          valid only with synchronous burst Flash memories.
+                                          This parameter can be a value of @ref FSMC_Burst_Access_Mode */
+
+  uint32_t FSMC_AsynchronousWait;     /*!< Enables or disables wait signal during asynchronous transfers,
+                                          valid only with asynchronous Flash memories.
+                                          This parameter can be a value of @ref FSMC_AsynchronousWait */
+
+  uint32_t FSMC_WaitSignalPolarity;  /*!< Specifies the wait signal polarity, valid only when accessing
+                                          the Flash memory in burst mode.
+                                          This parameter can be a value of @ref FSMC_Wait_Signal_Polarity */
+
+  uint32_t FSMC_WrapMode;            /*!< Enables or disables the Wrapped burst access mode for Flash
+                                          memory, valid only when accessing Flash memories in burst mode.
+                                          This parameter can be a value of @ref FSMC_Wrap_Mode */
+
+  uint32_t FSMC_WaitSignalActive;    /*!< Specifies if the wait signal is asserted by the memory one
+                                          clock cycle before the wait state or during the wait state,
+                                          valid only when accessing memories in burst mode.
+                                          This parameter can be a value of @ref FSMC_Wait_Timing */
+
+  uint32_t FSMC_WriteOperation;      /*!< Enables or disables the write operation in the selected bank by the FSMC.
+                                          This parameter can be a value of @ref FSMC_Write_Operation */
+
+  uint32_t FSMC_WaitSignal;          /*!< Enables or disables the wait-state insertion via wait
+                                          signal, valid for Flash memory access in burst mode.
+                                          This parameter can be a value of @ref FSMC_Wait_Signal */
+
+  uint32_t FSMC_ExtendedMode;        /*!< Enables or disables the extended mode.
+                                          This parameter can be a value of @ref FSMC_Extended_Mode */
+
+  uint32_t FSMC_WriteBurst;          /*!< Enables or disables the write burst operation.
+                                          This parameter can be a value of @ref FSMC_Write_Burst */
+
+  FSMC_NORSRAMTimingInitTypeDef* FSMC_ReadWriteTimingStruct; /*!< Timing Parameters for write and read access if the  ExtendedMode is not used*/
+
+  FSMC_NORSRAMTimingInitTypeDef* FSMC_WriteTimingStruct;     /*!< Timing Parameters for write access if the  ExtendedMode is used*/
+}FSMC_NORSRAMInitTypeDef;
+
+/**
+  * @brief  Timing parameters For FSMC NAND and PCCARD Banks
+  */
+
+typedef struct
+{
+  uint32_t FSMC_SetupTime;      /*!< Defines the number of HCLK cycles to setup address before
+                                     the command assertion for NAND-Flash read or write access
+                                     to common/Attribute or I/O memory space (depending on
+                                     the memory space timing to be configured).
+                                     This parameter can be a value between 0 and 0xFF.*/
+
+  uint32_t FSMC_WaitSetupTime;  /*!< Defines the minimum number of HCLK cycles to assert the
+                                     command for NAND-Flash read or write access to
+                                     common/Attribute or I/O memory space (depending on the
+                                     memory space timing to be configured).
+                                     This parameter can be a number between 0x00 and 0xFF */
+
+  uint32_t FSMC_HoldSetupTime;  /*!< Defines the number of HCLK clock cycles to hold address
+                                     (and data for write access) after the command deassertion
+                                     for NAND-Flash read or write access to common/Attribute
+                                     or I/O memory space (depending on the memory space timing
+                                     to be configured).
+                                     This parameter can be a number between 0x00 and 0xFF */
+
+  uint32_t FSMC_HiZSetupTime;   /*!< Defines the number of HCLK clock cycles during which the
+                                     databus is kept in HiZ after the start of a NAND-Flash
+                                     write access to common/Attribute or I/O memory space (depending
+                                     on the memory space timing to be configured).
+                                     This parameter can be a number between 0x00 and 0xFF */
+}FSMC_NAND_PCCARDTimingInitTypeDef;
+
+/**
+  * @brief  FSMC NAND Init structure definition
+  */
+
+typedef struct
+{
+  uint32_t FSMC_Bank;              /*!< Specifies the NAND memory bank that will be used.
+                                      This parameter can be a value of @ref FSMC_NAND_Bank */
+
+  uint32_t FSMC_Waitfeature;      /*!< Enables or disables the Wait feature for the NAND Memory Bank.
+                                       This parameter can be any value of @ref FSMC_Wait_feature */
+
+  uint32_t FSMC_MemoryDataWidth;  /*!< Specifies the external memory device width.
+                                       This parameter can be any value of @ref FSMC_Data_Width */
+
+  uint32_t FSMC_ECC;              /*!< Enables or disables the ECC computation.
+                                       This parameter can be any value of @ref FSMC_ECC */
+
+  uint32_t FSMC_ECCPageSize;      /*!< Defines the page size for the extended ECC.
+                                       This parameter can be any value of @ref FSMC_ECC_Page_Size */
+
+  uint32_t FSMC_TCLRSetupTime;    /*!< Defines the number of HCLK cycles to configure the
+                                       delay between CLE low and RE low.
+                                       This parameter can be a value between 0 and 0xFF. */
+
+  uint32_t FSMC_TARSetupTime;     /*!< Defines the number of HCLK cycles to configure the
+                                       delay between ALE low and RE low.
+                                       This parameter can be a number between 0x0 and 0xFF */
+
+  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_CommonSpaceTimingStruct;   /*!< FSMC Common Space Timing */
+
+  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_AttributeSpaceTimingStruct; /*!< FSMC Attribute Space Timing */
+}FSMC_NANDInitTypeDef;
+
+/**
+  * @brief  FSMC PCCARD Init structure definition
+  */
+
+typedef struct
+{
+  uint32_t FSMC_Waitfeature;    /*!< Enables or disables the Wait feature for the Memory Bank.
+                                    This parameter can be any value of @ref FSMC_Wait_feature */
+
+  uint32_t FSMC_TCLRSetupTime;  /*!< Defines the number of HCLK cycles to configure the
+                                     delay between CLE low and RE low.
+                                     This parameter can be a value between 0 and 0xFF. */
+
+  uint32_t FSMC_TARSetupTime;   /*!< Defines the number of HCLK cycles to configure the
+                                     delay between ALE low and RE low.
+                                     This parameter can be a number between 0x0 and 0xFF */
+
+
+  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_CommonSpaceTimingStruct; /*!< FSMC Common Space Timing */
+
+  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_AttributeSpaceTimingStruct;  /*!< FSMC Attribute Space Timing */
+
+  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_IOSpaceTimingStruct; /*!< FSMC IO Space Timing */
+}FSMC_PCCARDInitTypeDef;
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Exported_Constants
+  * @{
+  */
+
+/** @defgroup FSMC_NORSRAM_Bank
+  * @{
+  */
+#define FSMC_Bank1_NORSRAM1                             ((uint32_t)0x00000000)
+#define FSMC_Bank1_NORSRAM2                             ((uint32_t)0x00000002)
+#define FSMC_Bank1_NORSRAM3                             ((uint32_t)0x00000004)
+#define FSMC_Bank1_NORSRAM4                             ((uint32_t)0x00000006)
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_NAND_Bank
+  * @{
+  */
+#define FSMC_Bank2_NAND                                 ((uint32_t)0x00000010)
+#define FSMC_Bank3_NAND                                 ((uint32_t)0x00000100)
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_PCCARD_Bank
+  * @{
+  */
+#define FSMC_Bank4_PCCARD                               ((uint32_t)0x00001000)
+/**
+  * @}
+  */
+
+#define IS_FSMC_NORSRAM_BANK(BANK) (((BANK) == FSMC_Bank1_NORSRAM1) || \
+                                    ((BANK) == FSMC_Bank1_NORSRAM2) || \
+                                    ((BANK) == FSMC_Bank1_NORSRAM3) || \
+                                    ((BANK) == FSMC_Bank1_NORSRAM4))
+
+#define IS_FSMC_NAND_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
+                                 ((BANK) == FSMC_Bank3_NAND))
+
+#define IS_FSMC_GETFLAG_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
+                                    ((BANK) == FSMC_Bank3_NAND) || \
+                                    ((BANK) == FSMC_Bank4_PCCARD))
+
+#define IS_FSMC_IT_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
+                               ((BANK) == FSMC_Bank3_NAND) || \
+                               ((BANK) == FSMC_Bank4_PCCARD))
+
+/** @defgroup NOR_SRAM_Controller
+  * @{
+  */
+
+/** @defgroup FSMC_Data_Address_Bus_Multiplexing
+  * @{
+  */
+
+#define FSMC_DataAddressMux_Disable                       ((uint32_t)0x00000000)
+#define FSMC_DataAddressMux_Enable                        ((uint32_t)0x00000002)
+#define IS_FSMC_MUX(MUX) (((MUX) == FSMC_DataAddressMux_Disable) || \
+                          ((MUX) == FSMC_DataAddressMux_Enable))
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Memory_Type
+  * @{
+  */
+
+#define FSMC_MemoryType_SRAM                            ((uint32_t)0x00000000)
+#define FSMC_MemoryType_PSRAM                           ((uint32_t)0x00000004)
+#define FSMC_MemoryType_NOR                             ((uint32_t)0x00000008)
+#define IS_FSMC_MEMORY(MEMORY) (((MEMORY) == FSMC_MemoryType_SRAM) || \
+                                ((MEMORY) == FSMC_MemoryType_PSRAM)|| \
+                                ((MEMORY) == FSMC_MemoryType_NOR))
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Data_Width
+  * @{
+  */
+
+#define FSMC_MemoryDataWidth_8b                         ((uint32_t)0x00000000)
+#define FSMC_MemoryDataWidth_16b                        ((uint32_t)0x00000010)
+#define IS_FSMC_MEMORY_WIDTH(WIDTH) (((WIDTH) == FSMC_MemoryDataWidth_8b) || \
+                                     ((WIDTH) == FSMC_MemoryDataWidth_16b))
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Burst_Access_Mode
+  * @{
+  */
+
+#define FSMC_BurstAccessMode_Disable                    ((uint32_t)0x00000000)
+#define FSMC_BurstAccessMode_Enable                     ((uint32_t)0x00000100)
+#define IS_FSMC_BURSTMODE(STATE) (((STATE) == FSMC_BurstAccessMode_Disable) || \
+                                  ((STATE) == FSMC_BurstAccessMode_Enable))
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_AsynchronousWait
+  * @{
+  */
+#define FSMC_AsynchronousWait_Disable                   ((uint32_t)0x00000000)
+#define FSMC_AsynchronousWait_Enable                    ((uint32_t)0x00008000)
+#define IS_FSMC_ASYNWAIT(STATE) (((STATE) == FSMC_AsynchronousWait_Disable) || \
+                                 ((STATE) == FSMC_AsynchronousWait_Enable))
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Wait_Signal_Polarity
+  * @{
+  */
+
+#define FSMC_WaitSignalPolarity_Low                     ((uint32_t)0x00000000)
+#define FSMC_WaitSignalPolarity_High                    ((uint32_t)0x00000200)
+#define IS_FSMC_WAIT_POLARITY(POLARITY) (((POLARITY) == FSMC_WaitSignalPolarity_Low) || \
+                                         ((POLARITY) == FSMC_WaitSignalPolarity_High))
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Wrap_Mode
+  * @{
+  */
+
+#define FSMC_WrapMode_Disable                           ((uint32_t)0x00000000)
+#define FSMC_WrapMode_Enable                            ((uint32_t)0x00000400)
+#define IS_FSMC_WRAP_MODE(MODE) (((MODE) == FSMC_WrapMode_Disable) || \
+                                 ((MODE) == FSMC_WrapMode_Enable))
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Wait_Timing
+  * @{
+  */
+
+#define FSMC_WaitSignalActive_BeforeWaitState           ((uint32_t)0x00000000)
+#define FSMC_WaitSignalActive_DuringWaitState           ((uint32_t)0x00000800)
+#define IS_FSMC_WAIT_SIGNAL_ACTIVE(ACTIVE) (((ACTIVE) == FSMC_WaitSignalActive_BeforeWaitState) || \
+                                            ((ACTIVE) == FSMC_WaitSignalActive_DuringWaitState))
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Write_Operation
+  * @{
+  */
+
+#define FSMC_WriteOperation_Disable                     ((uint32_t)0x00000000)
+#define FSMC_WriteOperation_Enable                      ((uint32_t)0x00001000)
+#define IS_FSMC_WRITE_OPERATION(OPERATION) (((OPERATION) == FSMC_WriteOperation_Disable) || \
+                                            ((OPERATION) == FSMC_WriteOperation_Enable))
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Wait_Signal
+  * @{
+  */
+
+#define FSMC_WaitSignal_Disable                         ((uint32_t)0x00000000)
+#define FSMC_WaitSignal_Enable                          ((uint32_t)0x00002000)
+#define IS_FSMC_WAITE_SIGNAL(SIGNAL) (((SIGNAL) == FSMC_WaitSignal_Disable) || \
+                                      ((SIGNAL) == FSMC_WaitSignal_Enable))
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Extended_Mode
+  * @{
+  */
+
+#define FSMC_ExtendedMode_Disable                       ((uint32_t)0x00000000)
+#define FSMC_ExtendedMode_Enable                        ((uint32_t)0x00004000)
+
+#define IS_FSMC_EXTENDED_MODE(MODE) (((MODE) == FSMC_ExtendedMode_Disable) || \
+                                     ((MODE) == FSMC_ExtendedMode_Enable))
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Write_Burst
+  * @{
+  */
+
+#define FSMC_WriteBurst_Disable                         ((uint32_t)0x00000000)
+#define FSMC_WriteBurst_Enable                          ((uint32_t)0x00080000)
+#define IS_FSMC_WRITE_BURST(BURST) (((BURST) == FSMC_WriteBurst_Disable) || \
+                                    ((BURST) == FSMC_WriteBurst_Enable))
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Address_Setup_Time
+  * @{
+  */
+
+#define IS_FSMC_ADDRESS_SETUP_TIME(TIME) ((TIME) <= 0xF)
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Address_Hold_Time
+  * @{
+  */
+
+#define IS_FSMC_ADDRESS_HOLD_TIME(TIME) ((TIME) <= 0xF)
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Data_Setup_Time
+  * @{
+  */
+
+#define IS_FSMC_DATASETUP_TIME(TIME) (((TIME) > 0) && ((TIME) <= 0xFF))
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Bus_Turn_around_Duration
+  * @{
+  */
+
+#define IS_FSMC_TURNAROUND_TIME(TIME) ((TIME) <= 0xF)
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_CLK_Division
+  * @{
+  */
+
+#define IS_FSMC_CLK_DIV(DIV) ((DIV) <= 0xF)
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Data_Latency
+  * @{
+  */
+
+#define IS_FSMC_DATA_LATENCY(LATENCY) ((LATENCY) <= 0xF)
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Access_Mode
+  * @{
+  */
+
+#define FSMC_AccessMode_A                               ((uint32_t)0x00000000)
+#define FSMC_AccessMode_B                               ((uint32_t)0x10000000)
+#define FSMC_AccessMode_C                               ((uint32_t)0x20000000)
+#define FSMC_AccessMode_D                               ((uint32_t)0x30000000)
+#define IS_FSMC_ACCESS_MODE(MODE) (((MODE) == FSMC_AccessMode_A) || \
+                                   ((MODE) == FSMC_AccessMode_B) || \
+                                   ((MODE) == FSMC_AccessMode_C) || \
+                                   ((MODE) == FSMC_AccessMode_D))
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup NAND_PCCARD_Controller
+  * @{
+  */
+
+/** @defgroup FSMC_Wait_feature
+  * @{
+  */
+
+#define FSMC_Waitfeature_Disable                        ((uint32_t)0x00000000)
+#define FSMC_Waitfeature_Enable                         ((uint32_t)0x00000002)
+#define IS_FSMC_WAIT_FEATURE(FEATURE) (((FEATURE) == FSMC_Waitfeature_Disable) || \
+                                       ((FEATURE) == FSMC_Waitfeature_Enable))
+
+/**
+  * @}
+  */
+
+
+/** @defgroup FSMC_ECC
+  * @{
+  */
+
+#define FSMC_ECC_Disable                                ((uint32_t)0x00000000)
+#define FSMC_ECC_Enable                                 ((uint32_t)0x00000040)
+#define IS_FSMC_ECC_STATE(STATE) (((STATE) == FSMC_ECC_Disable) || \
+                                  ((STATE) == FSMC_ECC_Enable))
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_ECC_Page_Size
+  * @{
+  */
+
+#define FSMC_ECCPageSize_256Bytes                       ((uint32_t)0x00000000)
+#define FSMC_ECCPageSize_512Bytes                       ((uint32_t)0x00020000)
+#define FSMC_ECCPageSize_1024Bytes                      ((uint32_t)0x00040000)
+#define FSMC_ECCPageSize_2048Bytes                      ((uint32_t)0x00060000)
+#define FSMC_ECCPageSize_4096Bytes                      ((uint32_t)0x00080000)
+#define FSMC_ECCPageSize_8192Bytes                      ((uint32_t)0x000A0000)
+#define IS_FSMC_ECCPAGE_SIZE(SIZE) (((SIZE) == FSMC_ECCPageSize_256Bytes) || \
+                                    ((SIZE) == FSMC_ECCPageSize_512Bytes) || \
+                                    ((SIZE) == FSMC_ECCPageSize_1024Bytes) || \
+                                    ((SIZE) == FSMC_ECCPageSize_2048Bytes) || \
+                                    ((SIZE) == FSMC_ECCPageSize_4096Bytes) || \
+                                    ((SIZE) == FSMC_ECCPageSize_8192Bytes))
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_TCLR_Setup_Time
+  * @{
+  */
+
+#define IS_FSMC_TCLR_TIME(TIME) ((TIME) <= 0xFF)
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_TAR_Setup_Time
+  * @{
+  */
+
+#define IS_FSMC_TAR_TIME(TIME) ((TIME) <= 0xFF)
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Setup_Time
+  * @{
+  */
+
+#define IS_FSMC_SETUP_TIME(TIME) ((TIME) <= 0xFF)
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Wait_Setup_Time
+  * @{
+  */
+
+#define IS_FSMC_WAIT_TIME(TIME) ((TIME) <= 0xFF)
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Hold_Setup_Time
+  * @{
+  */
+
+#define IS_FSMC_HOLD_TIME(TIME) ((TIME) <= 0xFF)
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_HiZ_Setup_Time
+  * @{
+  */
+
+#define IS_FSMC_HIZ_TIME(TIME) ((TIME) <= 0xFF)
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Interrupt_sources
+  * @{
+  */
+
+#define FSMC_IT_RisingEdge                              ((uint32_t)0x00000008)
+#define FSMC_IT_Level                                   ((uint32_t)0x00000010)
+#define FSMC_IT_FallingEdge                             ((uint32_t)0x00000020)
+#define IS_FSMC_IT(IT) ((((IT) & (uint32_t)0xFFFFFFC7) == 0x00000000) && ((IT) != 0x00000000))
+#define IS_FSMC_GET_IT(IT) (((IT) == FSMC_IT_RisingEdge) || \
+                            ((IT) == FSMC_IT_Level) || \
+                            ((IT) == FSMC_IT_FallingEdge))
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Flags
+  * @{
+  */
+
+#define FSMC_FLAG_RisingEdge                            ((uint32_t)0x00000001)
+#define FSMC_FLAG_Level                                 ((uint32_t)0x00000002)
+#define FSMC_FLAG_FallingEdge                           ((uint32_t)0x00000004)
+#define FSMC_FLAG_FEMPT                                 ((uint32_t)0x00000040)
+#define IS_FSMC_GET_FLAG(FLAG) (((FLAG) == FSMC_FLAG_RisingEdge) || \
+                                ((FLAG) == FSMC_FLAG_Level) || \
+                                ((FLAG) == FSMC_FLAG_FallingEdge) || \
+                                ((FLAG) == FSMC_FLAG_FEMPT))
+
+#define IS_FSMC_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFFFFFFF8) == 0x00000000) && ((FLAG) != 0x00000000))
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Exported_Functions
+  * @{
+  */
+
+void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank);
+void FSMC_NANDDeInit(uint32_t FSMC_Bank);
+void FSMC_PCCARDDeInit(void);
+void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct);
+void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct);
+void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct);
+void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct);
+void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct);
+void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct);
+void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState);
+void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState);
+void FSMC_PCCARDCmd(FunctionalState NewState);
+void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState);
+uint32_t FSMC_GetECC(uint32_t FSMC_Bank);
+void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState);
+FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG);
+void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG);
+ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT);
+void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__STM32F10x_FSMC_H */
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_gpio.h b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_gpio.h
new file mode 100644
index 0000000..b8aa49a
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_gpio.h
@@ -0,0 +1,385 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_gpio.h
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file contains all the functions prototypes for the GPIO
+  *          firmware library.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F10x_GPIO_H
+#define __STM32F10x_GPIO_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup GPIO
+  * @{
+  */
+
+/** @defgroup GPIO_Exported_Types
+  * @{
+  */
+
+#define IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) || \
+                                    ((PERIPH) == GPIOB) || \
+                                    ((PERIPH) == GPIOC) || \
+                                    ((PERIPH) == GPIOD) || \
+                                    ((PERIPH) == GPIOE) || \
+                                    ((PERIPH) == GPIOF) || \
+                                    ((PERIPH) == GPIOG))
+
+/**
+  * @brief  Output Maximum frequency selection
+  */
+
+typedef enum
+{
+  GPIO_Speed_10MHz = 1,
+  GPIO_Speed_2MHz,
+  GPIO_Speed_50MHz
+}GPIOSpeed_TypeDef;
+#define IS_GPIO_SPEED(SPEED) (((SPEED) == GPIO_Speed_10MHz) || ((SPEED) == GPIO_Speed_2MHz) || \
+                              ((SPEED) == GPIO_Speed_50MHz))
+
+/**
+  * @brief  Configuration Mode enumeration
+  */
+
+typedef enum
+{ GPIO_Mode_AIN = 0x0,
+  GPIO_Mode_IN_FLOATING = 0x04,
+  GPIO_Mode_IPD = 0x28,
+  GPIO_Mode_IPU = 0x48,
+  GPIO_Mode_Out_OD = 0x14,
+  GPIO_Mode_Out_PP = 0x10,
+  GPIO_Mode_AF_OD = 0x1C,
+  GPIO_Mode_AF_PP = 0x18
+}GPIOMode_TypeDef;
+
+#define IS_GPIO_MODE(MODE) (((MODE) == GPIO_Mode_AIN) || ((MODE) == GPIO_Mode_IN_FLOATING) || \
+                            ((MODE) == GPIO_Mode_IPD) || ((MODE) == GPIO_Mode_IPU) || \
+                            ((MODE) == GPIO_Mode_Out_OD) || ((MODE) == GPIO_Mode_Out_PP) || \
+                            ((MODE) == GPIO_Mode_AF_OD) || ((MODE) == GPIO_Mode_AF_PP))
+
+/**
+  * @brief  GPIO Init structure definition
+  */
+
+typedef struct
+{
+  uint16_t GPIO_Pin;             /*!< Specifies the GPIO pins to be configured.
+                                      This parameter can be any value of @ref GPIO_pins_define */
+
+  GPIOSpeed_TypeDef GPIO_Speed;  /*!< Specifies the speed for the selected pins.
+                                      This parameter can be a value of @ref GPIOSpeed_TypeDef */
+
+  GPIOMode_TypeDef GPIO_Mode;    /*!< Specifies the operating mode for the selected pins.
+                                      This parameter can be a value of @ref GPIOMode_TypeDef */
+}GPIO_InitTypeDef;
+
+
+/**
+  * @brief  Bit_SET and Bit_RESET enumeration
+  */
+
+typedef enum
+{ Bit_RESET = 0,
+  Bit_SET
+}BitAction;
+
+#define IS_GPIO_BIT_ACTION(ACTION) (((ACTION) == Bit_RESET) || ((ACTION) == Bit_SET))
+
+/**
+  * @}
+  */
+
+/** @defgroup GPIO_Exported_Constants
+  * @{
+  */
+
+/** @defgroup GPIO_pins_define
+  * @{
+  */
+
+#define GPIO_Pin_0                 ((uint16_t)0x0001)  /*!< Pin 0 selected */
+#define GPIO_Pin_1                 ((uint16_t)0x0002)  /*!< Pin 1 selected */
+#define GPIO_Pin_2                 ((uint16_t)0x0004)  /*!< Pin 2 selected */
+#define GPIO_Pin_3                 ((uint16_t)0x0008)  /*!< Pin 3 selected */
+#define GPIO_Pin_4                 ((uint16_t)0x0010)  /*!< Pin 4 selected */
+#define GPIO_Pin_5                 ((uint16_t)0x0020)  /*!< Pin 5 selected */
+#define GPIO_Pin_6                 ((uint16_t)0x0040)  /*!< Pin 6 selected */
+#define GPIO_Pin_7                 ((uint16_t)0x0080)  /*!< Pin 7 selected */
+#define GPIO_Pin_8                 ((uint16_t)0x0100)  /*!< Pin 8 selected */
+#define GPIO_Pin_9                 ((uint16_t)0x0200)  /*!< Pin 9 selected */
+#define GPIO_Pin_10                ((uint16_t)0x0400)  /*!< Pin 10 selected */
+#define GPIO_Pin_11                ((uint16_t)0x0800)  /*!< Pin 11 selected */
+#define GPIO_Pin_12                ((uint16_t)0x1000)  /*!< Pin 12 selected */
+#define GPIO_Pin_13                ((uint16_t)0x2000)  /*!< Pin 13 selected */
+#define GPIO_Pin_14                ((uint16_t)0x4000)  /*!< Pin 14 selected */
+#define GPIO_Pin_15                ((uint16_t)0x8000)  /*!< Pin 15 selected */
+#define GPIO_Pin_All               ((uint16_t)0xFFFF)  /*!< All pins selected */
+
+#define IS_GPIO_PIN(PIN) ((((PIN) & (uint16_t)0x00) == 0x00) && ((PIN) != (uint16_t)0x00))
+
+#define IS_GET_GPIO_PIN(PIN) (((PIN) == GPIO_Pin_0) || \
+                              ((PIN) == GPIO_Pin_1) || \
+                              ((PIN) == GPIO_Pin_2) || \
+                              ((PIN) == GPIO_Pin_3) || \
+                              ((PIN) == GPIO_Pin_4) || \
+                              ((PIN) == GPIO_Pin_5) || \
+                              ((PIN) == GPIO_Pin_6) || \
+                              ((PIN) == GPIO_Pin_7) || \
+                              ((PIN) == GPIO_Pin_8) || \
+                              ((PIN) == GPIO_Pin_9) || \
+                              ((PIN) == GPIO_Pin_10) || \
+                              ((PIN) == GPIO_Pin_11) || \
+                              ((PIN) == GPIO_Pin_12) || \
+                              ((PIN) == GPIO_Pin_13) || \
+                              ((PIN) == GPIO_Pin_14) || \
+                              ((PIN) == GPIO_Pin_15))
+
+/**
+  * @}
+  */
+
+/** @defgroup GPIO_Remap_define
+  * @{
+  */
+
+#define GPIO_Remap_SPI1             ((uint32_t)0x00000001)  /*!< SPI1 Alternate Function mapping */
+#define GPIO_Remap_I2C1             ((uint32_t)0x00000002)  /*!< I2C1 Alternate Function mapping */
+#define GPIO_Remap_USART1           ((uint32_t)0x00000004)  /*!< USART1 Alternate Function mapping */
+#define GPIO_Remap_USART2           ((uint32_t)0x00000008)  /*!< USART2 Alternate Function mapping */
+#define GPIO_PartialRemap_USART3    ((uint32_t)0x00140010)  /*!< USART3 Partial Alternate Function mapping */
+#define GPIO_FullRemap_USART3       ((uint32_t)0x00140030)  /*!< USART3 Full Alternate Function mapping */
+#define GPIO_PartialRemap_TIM1      ((uint32_t)0x00160040)  /*!< TIM1 Partial Alternate Function mapping */
+#define GPIO_FullRemap_TIM1         ((uint32_t)0x001600C0)  /*!< TIM1 Full Alternate Function mapping */
+#define GPIO_PartialRemap1_TIM2     ((uint32_t)0x00180100)  /*!< TIM2 Partial1 Alternate Function mapping */
+#define GPIO_PartialRemap2_TIM2     ((uint32_t)0x00180200)  /*!< TIM2 Partial2 Alternate Function mapping */
+#define GPIO_FullRemap_TIM2         ((uint32_t)0x00180300)  /*!< TIM2 Full Alternate Function mapping */
+#define GPIO_PartialRemap_TIM3      ((uint32_t)0x001A0800)  /*!< TIM3 Partial Alternate Function mapping */
+#define GPIO_FullRemap_TIM3         ((uint32_t)0x001A0C00)  /*!< TIM3 Full Alternate Function mapping */
+#define GPIO_Remap_TIM4             ((uint32_t)0x00001000)  /*!< TIM4 Alternate Function mapping */
+#define GPIO_Remap1_CAN1            ((uint32_t)0x001D4000)  /*!< CAN1 Alternate Function mapping */
+#define GPIO_Remap2_CAN1            ((uint32_t)0x001D6000)  /*!< CAN1 Alternate Function mapping */
+#define GPIO_Remap_PD01             ((uint32_t)0x00008000)  /*!< PD01 Alternate Function mapping */
+#define GPIO_Remap_TIM5CH4_LSI      ((uint32_t)0x00200001)  /*!< LSI connected to TIM5 Channel4 input capture for calibration */
+#define GPIO_Remap_ADC1_ETRGINJ     ((uint32_t)0x00200002)  /*!< ADC1 External Trigger Injected Conversion remapping */
+#define GPIO_Remap_ADC1_ETRGREG     ((uint32_t)0x00200004)  /*!< ADC1 External Trigger Regular Conversion remapping */
+#define GPIO_Remap_ADC2_ETRGINJ     ((uint32_t)0x00200008)  /*!< ADC2 External Trigger Injected Conversion remapping */
+#define GPIO_Remap_ADC2_ETRGREG     ((uint32_t)0x00200010)  /*!< ADC2 External Trigger Regular Conversion remapping */
+#define GPIO_Remap_ETH              ((uint32_t)0x00200020)  /*!< Ethernet remapping (only for Connectivity line devices) */
+#define GPIO_Remap_CAN2             ((uint32_t)0x00200040)  /*!< CAN2 remapping (only for Connectivity line devices) */
+#define GPIO_Remap_SWJ_NoJTRST      ((uint32_t)0x00300100)  /*!< Full SWJ Enabled (JTAG-DP + SW-DP) but without JTRST */
+#define GPIO_Remap_SWJ_JTAGDisable  ((uint32_t)0x00300200)  /*!< JTAG-DP Disabled and SW-DP Enabled */
+#define GPIO_Remap_SWJ_Disable      ((uint32_t)0x00300400)  /*!< Full SWJ Disabled (JTAG-DP + SW-DP) */
+#define GPIO_Remap_SPI3             ((uint32_t)0x00201100)  /*!< SPI3/I2S3 Alternate Function mapping (only for Connectivity line devices) */
+#define GPIO_Remap_TIM2ITR1_PTP_SOF ((uint32_t)0x00202000)  /*!< Ethernet PTP output or USB OTG SOF (Start of Frame) connected
+                                                                 to TIM2 Internal Trigger 1 for calibration
+                                                                 (only for Connectivity line devices) */
+#define GPIO_Remap_PTP_PPS          ((uint32_t)0x00204000)  /*!< Ethernet MAC PPS_PTS output on PB05 (only for Connectivity line devices) */
+
+#define GPIO_Remap_TIM15            ((uint32_t)0x80000001)  /*!< TIM15 Alternate Function mapping (only for Value line devices) */
+#define GPIO_Remap_TIM16            ((uint32_t)0x80000002)  /*!< TIM16 Alternate Function mapping (only for Value line devices) */
+#define GPIO_Remap_TIM17            ((uint32_t)0x80000004)  /*!< TIM17 Alternate Function mapping (only for Value line devices) */
+#define GPIO_Remap_CEC              ((uint32_t)0x80000008)  /*!< CEC Alternate Function mapping (only for Value line devices) */
+#define GPIO_Remap_TIM1_DMA         ((uint32_t)0x80000010)  /*!< TIM1 DMA requests mapping (only for Value line devices) */
+
+#define GPIO_Remap_TIM9             ((uint32_t)0x80000020)  /*!< TIM9 Alternate Function mapping (only for XL-density devices) */
+#define GPIO_Remap_TIM10            ((uint32_t)0x80000040)  /*!< TIM10 Alternate Function mapping (only for XL-density devices) */
+#define GPIO_Remap_TIM11            ((uint32_t)0x80000080)  /*!< TIM11 Alternate Function mapping (only for XL-density devices) */
+#define GPIO_Remap_TIM13            ((uint32_t)0x80000100)  /*!< TIM13 Alternate Function mapping (only for High density Value line and XL-density devices) */
+#define GPIO_Remap_TIM14            ((uint32_t)0x80000200)  /*!< TIM14 Alternate Function mapping (only for High density Value line and XL-density devices) */
+#define GPIO_Remap_FSMC_NADV        ((uint32_t)0x80000400)  /*!< FSMC_NADV Alternate Function mapping (only for High density Value line and XL-density devices) */
+
+#define GPIO_Remap_TIM67_DAC_DMA    ((uint32_t)0x80000800)  /*!< TIM6/TIM7 and DAC DMA requests remapping (only for High density Value line devices) */
+#define GPIO_Remap_TIM12            ((uint32_t)0x80001000)  /*!< TIM12 Alternate Function mapping (only for High density Value line devices) */
+#define GPIO_Remap_MISC             ((uint32_t)0x80002000)  /*!< Miscellaneous Remap (DMA2 Channel5 Position and DAC Trigger remapping,
+                                                                 only for High density Value line devices) */
+
+#define IS_GPIO_REMAP(REMAP) (((REMAP) == GPIO_Remap_SPI1) || ((REMAP) == GPIO_Remap_I2C1) || \
+                              ((REMAP) == GPIO_Remap_USART1) || ((REMAP) == GPIO_Remap_USART2) || \
+                              ((REMAP) == GPIO_PartialRemap_USART3) || ((REMAP) == GPIO_FullRemap_USART3) || \
+                              ((REMAP) == GPIO_PartialRemap_TIM1) || ((REMAP) == GPIO_FullRemap_TIM1) || \
+                              ((REMAP) == GPIO_PartialRemap1_TIM2) || ((REMAP) == GPIO_PartialRemap2_TIM2) || \
+                              ((REMAP) == GPIO_FullRemap_TIM2) || ((REMAP) == GPIO_PartialRemap_TIM3) || \
+                              ((REMAP) == GPIO_FullRemap_TIM3) || ((REMAP) == GPIO_Remap_TIM4) || \
+                              ((REMAP) == GPIO_Remap1_CAN1) || ((REMAP) == GPIO_Remap2_CAN1) || \
+                              ((REMAP) == GPIO_Remap_PD01) || ((REMAP) == GPIO_Remap_TIM5CH4_LSI) || \
+                              ((REMAP) == GPIO_Remap_ADC1_ETRGINJ) ||((REMAP) == GPIO_Remap_ADC1_ETRGREG) || \
+                              ((REMAP) == GPIO_Remap_ADC2_ETRGINJ) ||((REMAP) == GPIO_Remap_ADC2_ETRGREG) || \
+                              ((REMAP) == GPIO_Remap_ETH) ||((REMAP) == GPIO_Remap_CAN2) || \
+                              ((REMAP) == GPIO_Remap_SWJ_NoJTRST) || ((REMAP) == GPIO_Remap_SWJ_JTAGDisable) || \
+                              ((REMAP) == GPIO_Remap_SWJ_Disable)|| ((REMAP) == GPIO_Remap_SPI3) || \
+                              ((REMAP) == GPIO_Remap_TIM2ITR1_PTP_SOF) || ((REMAP) == GPIO_Remap_PTP_PPS) || \
+                              ((REMAP) == GPIO_Remap_TIM15) || ((REMAP) == GPIO_Remap_TIM16) || \
+                              ((REMAP) == GPIO_Remap_TIM17) || ((REMAP) == GPIO_Remap_CEC) || \
+                              ((REMAP) == GPIO_Remap_TIM1_DMA) || ((REMAP) == GPIO_Remap_TIM9) || \
+                              ((REMAP) == GPIO_Remap_TIM10) || ((REMAP) == GPIO_Remap_TIM11) || \
+                              ((REMAP) == GPIO_Remap_TIM13) || ((REMAP) == GPIO_Remap_TIM14) || \
+                              ((REMAP) == GPIO_Remap_FSMC_NADV) || ((REMAP) == GPIO_Remap_TIM67_DAC_DMA) || \
+                              ((REMAP) == GPIO_Remap_TIM12) || ((REMAP) == GPIO_Remap_MISC))
+
+/**
+  * @}
+  */
+
+/** @defgroup GPIO_Port_Sources
+  * @{
+  */
+
+#define GPIO_PortSourceGPIOA       ((uint8_t)0x00)
+#define GPIO_PortSourceGPIOB       ((uint8_t)0x01)
+#define GPIO_PortSourceGPIOC       ((uint8_t)0x02)
+#define GPIO_PortSourceGPIOD       ((uint8_t)0x03)
+#define GPIO_PortSourceGPIOE       ((uint8_t)0x04)
+#define GPIO_PortSourceGPIOF       ((uint8_t)0x05)
+#define GPIO_PortSourceGPIOG       ((uint8_t)0x06)
+#define IS_GPIO_EVENTOUT_PORT_SOURCE(PORTSOURCE) (((PORTSOURCE) == GPIO_PortSourceGPIOA) || \
+                                                  ((PORTSOURCE) == GPIO_PortSourceGPIOB) || \
+                                                  ((PORTSOURCE) == GPIO_PortSourceGPIOC) || \
+                                                  ((PORTSOURCE) == GPIO_PortSourceGPIOD) || \
+                                                  ((PORTSOURCE) == GPIO_PortSourceGPIOE))
+
+#define IS_GPIO_EXTI_PORT_SOURCE(PORTSOURCE) (((PORTSOURCE) == GPIO_PortSourceGPIOA) || \
+                                              ((PORTSOURCE) == GPIO_PortSourceGPIOB) || \
+                                              ((PORTSOURCE) == GPIO_PortSourceGPIOC) || \
+                                              ((PORTSOURCE) == GPIO_PortSourceGPIOD) || \
+                                              ((PORTSOURCE) == GPIO_PortSourceGPIOE) || \
+                                              ((PORTSOURCE) == GPIO_PortSourceGPIOF) || \
+                                              ((PORTSOURCE) == GPIO_PortSourceGPIOG))
+
+/**
+  * @}
+  */
+
+/** @defgroup GPIO_Pin_sources
+  * @{
+  */
+
+#define GPIO_PinSource0            ((uint8_t)0x00)
+#define GPIO_PinSource1            ((uint8_t)0x01)
+#define GPIO_PinSource2            ((uint8_t)0x02)
+#define GPIO_PinSource3            ((uint8_t)0x03)
+#define GPIO_PinSource4            ((uint8_t)0x04)
+#define GPIO_PinSource5            ((uint8_t)0x05)
+#define GPIO_PinSource6            ((uint8_t)0x06)
+#define GPIO_PinSource7            ((uint8_t)0x07)
+#define GPIO_PinSource8            ((uint8_t)0x08)
+#define GPIO_PinSource9            ((uint8_t)0x09)
+#define GPIO_PinSource10           ((uint8_t)0x0A)
+#define GPIO_PinSource11           ((uint8_t)0x0B)
+#define GPIO_PinSource12           ((uint8_t)0x0C)
+#define GPIO_PinSource13           ((uint8_t)0x0D)
+#define GPIO_PinSource14           ((uint8_t)0x0E)
+#define GPIO_PinSource15           ((uint8_t)0x0F)
+
+#define IS_GPIO_PIN_SOURCE(PINSOURCE) (((PINSOURCE) == GPIO_PinSource0) || \
+                                       ((PINSOURCE) == GPIO_PinSource1) || \
+                                       ((PINSOURCE) == GPIO_PinSource2) || \
+                                       ((PINSOURCE) == GPIO_PinSource3) || \
+                                       ((PINSOURCE) == GPIO_PinSource4) || \
+                                       ((PINSOURCE) == GPIO_PinSource5) || \
+                                       ((PINSOURCE) == GPIO_PinSource6) || \
+                                       ((PINSOURCE) == GPIO_PinSource7) || \
+                                       ((PINSOURCE) == GPIO_PinSource8) || \
+                                       ((PINSOURCE) == GPIO_PinSource9) || \
+                                       ((PINSOURCE) == GPIO_PinSource10) || \
+                                       ((PINSOURCE) == GPIO_PinSource11) || \
+                                       ((PINSOURCE) == GPIO_PinSource12) || \
+                                       ((PINSOURCE) == GPIO_PinSource13) || \
+                                       ((PINSOURCE) == GPIO_PinSource14) || \
+                                       ((PINSOURCE) == GPIO_PinSource15))
+
+/**
+  * @}
+  */
+
+/** @defgroup Ethernet_Media_Interface
+  * @{
+  */
+#define GPIO_ETH_MediaInterface_MII    ((u32)0x00000000)
+#define GPIO_ETH_MediaInterface_RMII   ((u32)0x00000001)
+
+#define IS_GPIO_ETH_MEDIA_INTERFACE(INTERFACE) (((INTERFACE) == GPIO_ETH_MediaInterface_MII) || \
+                                                ((INTERFACE) == GPIO_ETH_MediaInterface_RMII))
+
+/**
+  * @}
+  */
+/**
+  * @}
+  */
+
+/** @defgroup GPIO_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup GPIO_Exported_Functions
+  * @{
+  */
+
+void GPIO_DeInit(GPIO_TypeDef* GPIOx);
+void GPIO_AFIODeInit(void);
+void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);
+void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct);
+uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
+uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx);
+uint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
+uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx);
+void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
+void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
+void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal);
+void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal);
+void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
+void GPIO_EventOutputConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource);
+void GPIO_EventOutputCmd(FunctionalState NewState);
+void GPIO_PinRemapConfig(uint32_t GPIO_Remap, FunctionalState NewState);
+void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource);
+void GPIO_ETH_MediaInterfaceConfig(uint32_t GPIO_ETH_MediaInterface);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F10x_GPIO_H */
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_i2c.h b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_i2c.h
new file mode 100644
index 0000000..2d42e5c
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_i2c.h
@@ -0,0 +1,684 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_i2c.h
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file contains all the functions prototypes for the I2C firmware
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F10x_I2C_H
+#define __STM32F10x_I2C_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup I2C
+  * @{
+  */
+
+/** @defgroup I2C_Exported_Types
+  * @{
+  */
+
+/**
+  * @brief  I2C Init structure definition
+  */
+
+typedef struct
+{
+  uint32_t I2C_ClockSpeed;          /*!< Specifies the clock frequency.
+                                         This parameter must be set to a value lower than 400kHz */
+
+  uint16_t I2C_Mode;                /*!< Specifies the I2C mode.
+                                         This parameter can be a value of @ref I2C_mode */
+
+  uint16_t I2C_DutyCycle;           /*!< Specifies the I2C fast mode duty cycle.
+                                         This parameter can be a value of @ref I2C_duty_cycle_in_fast_mode */
+
+  uint16_t I2C_OwnAddress1;         /*!< Specifies the first device own address.
+                                         This parameter can be a 7-bit or 10-bit address. */
+
+  uint16_t I2C_Ack;                 /*!< Enables or disables the acknowledgement.
+                                         This parameter can be a value of @ref I2C_acknowledgement */
+
+  uint16_t I2C_AcknowledgedAddress; /*!< Specifies if 7-bit or 10-bit address is acknowledged.
+                                         This parameter can be a value of @ref I2C_acknowledged_address */
+}I2C_InitTypeDef;
+
+/**
+  * @}
+  */
+
+
+/** @defgroup I2C_Exported_Constants
+  * @{
+  */
+
+#define IS_I2C_ALL_PERIPH(PERIPH) (((PERIPH) == I2C1) || \
+                                   ((PERIPH) == I2C2))
+/** @defgroup I2C_mode
+  * @{
+  */
+
+#define I2C_Mode_I2C                    ((uint16_t)0x0000)
+#define I2C_Mode_SMBusDevice            ((uint16_t)0x0002)
+#define I2C_Mode_SMBusHost              ((uint16_t)0x000A)
+#define IS_I2C_MODE(MODE) (((MODE) == I2C_Mode_I2C) || \
+                           ((MODE) == I2C_Mode_SMBusDevice) || \
+                           ((MODE) == I2C_Mode_SMBusHost))
+/**
+  * @}
+  */
+
+/** @defgroup I2C_duty_cycle_in_fast_mode
+  * @{
+  */
+
+#define I2C_DutyCycle_16_9              ((uint16_t)0x4000) /*!< I2C fast mode Tlow/Thigh = 16/9 */
+#define I2C_DutyCycle_2                 ((uint16_t)0xBFFF) /*!< I2C fast mode Tlow/Thigh = 2 */
+#define IS_I2C_DUTY_CYCLE(CYCLE) (((CYCLE) == I2C_DutyCycle_16_9) || \
+                                  ((CYCLE) == I2C_DutyCycle_2))
+/**
+  * @}
+  */
+
+/** @defgroup I2C_acknowledgement
+  * @{
+  */
+
+#define I2C_Ack_Enable                  ((uint16_t)0x0400)
+#define I2C_Ack_Disable                 ((uint16_t)0x0000)
+#define IS_I2C_ACK_STATE(STATE) (((STATE) == I2C_Ack_Enable) || \
+                                 ((STATE) == I2C_Ack_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup I2C_transfer_direction
+  * @{
+  */
+
+#define  I2C_Direction_Transmitter      ((uint8_t)0x00)
+#define  I2C_Direction_Receiver         ((uint8_t)0x01)
+#define IS_I2C_DIRECTION(DIRECTION) (((DIRECTION) == I2C_Direction_Transmitter) || \
+                                     ((DIRECTION) == I2C_Direction_Receiver))
+/**
+  * @}
+  */
+
+/** @defgroup I2C_acknowledged_address
+  * @{
+  */
+
+#define I2C_AcknowledgedAddress_7bit    ((uint16_t)0x4000)
+#define I2C_AcknowledgedAddress_10bit   ((uint16_t)0xC000)
+#define IS_I2C_ACKNOWLEDGE_ADDRESS(ADDRESS) (((ADDRESS) == I2C_AcknowledgedAddress_7bit) || \
+                                             ((ADDRESS) == I2C_AcknowledgedAddress_10bit))
+/**
+  * @}
+  */
+
+/** @defgroup I2C_registers
+  * @{
+  */
+
+#define I2C_Register_CR1                ((uint8_t)0x00)
+#define I2C_Register_CR2                ((uint8_t)0x04)
+#define I2C_Register_OAR1               ((uint8_t)0x08)
+#define I2C_Register_OAR2               ((uint8_t)0x0C)
+#define I2C_Register_DR                 ((uint8_t)0x10)
+#define I2C_Register_SR1                ((uint8_t)0x14)
+#define I2C_Register_SR2                ((uint8_t)0x18)
+#define I2C_Register_CCR                ((uint8_t)0x1C)
+#define I2C_Register_TRISE              ((uint8_t)0x20)
+#define IS_I2C_REGISTER(REGISTER) (((REGISTER) == I2C_Register_CR1) || \
+                                   ((REGISTER) == I2C_Register_CR2) || \
+                                   ((REGISTER) == I2C_Register_OAR1) || \
+                                   ((REGISTER) == I2C_Register_OAR2) || \
+                                   ((REGISTER) == I2C_Register_DR) || \
+                                   ((REGISTER) == I2C_Register_SR1) || \
+                                   ((REGISTER) == I2C_Register_SR2) || \
+                                   ((REGISTER) == I2C_Register_CCR) || \
+                                   ((REGISTER) == I2C_Register_TRISE))
+/**
+  * @}
+  */
+
+/** @defgroup I2C_SMBus_alert_pin_level
+  * @{
+  */
+
+#define I2C_SMBusAlert_Low              ((uint16_t)0x2000)
+#define I2C_SMBusAlert_High             ((uint16_t)0xDFFF)
+#define IS_I2C_SMBUS_ALERT(ALERT) (((ALERT) == I2C_SMBusAlert_Low) || \
+                                   ((ALERT) == I2C_SMBusAlert_High))
+/**
+  * @}
+  */
+
+/** @defgroup I2C_PEC_position
+  * @{
+  */
+
+#define I2C_PECPosition_Next            ((uint16_t)0x0800)
+#define I2C_PECPosition_Current         ((uint16_t)0xF7FF)
+#define IS_I2C_PEC_POSITION(POSITION) (((POSITION) == I2C_PECPosition_Next) || \
+                                       ((POSITION) == I2C_PECPosition_Current))
+/**
+  * @}
+  */
+
+/** @defgroup I2C_NCAK_position
+  * @{
+  */
+
+#define I2C_NACKPosition_Next           ((uint16_t)0x0800)
+#define I2C_NACKPosition_Current        ((uint16_t)0xF7FF)
+#define IS_I2C_NACK_POSITION(POSITION)  (((POSITION) == I2C_NACKPosition_Next) || \
+                                         ((POSITION) == I2C_NACKPosition_Current))
+/**
+  * @}
+  */
+
+/** @defgroup I2C_interrupts_definition
+  * @{
+  */
+
+#define I2C_IT_BUF                      ((uint16_t)0x0400)
+#define I2C_IT_EVT                      ((uint16_t)0x0200)
+#define I2C_IT_ERR                      ((uint16_t)0x0100)
+#define IS_I2C_CONFIG_IT(IT) ((((IT) & (uint16_t)0xF8FF) == 0x00) && ((IT) != 0x00))
+/**
+  * @}
+  */
+
+/** @defgroup I2C_interrupts_definition
+  * @{
+  */
+
+#define I2C_IT_SMBALERT                 ((uint32_t)0x01008000)
+#define I2C_IT_TIMEOUT                  ((uint32_t)0x01004000)
+#define I2C_IT_PECERR                   ((uint32_t)0x01001000)
+#define I2C_IT_OVR                      ((uint32_t)0x01000800)
+#define I2C_IT_AF                       ((uint32_t)0x01000400)
+#define I2C_IT_ARLO                     ((uint32_t)0x01000200)
+#define I2C_IT_BERR                     ((uint32_t)0x01000100)
+#define I2C_IT_TXE                      ((uint32_t)0x06000080)
+#define I2C_IT_RXNE                     ((uint32_t)0x06000040)
+#define I2C_IT_STOPF                    ((uint32_t)0x02000010)
+#define I2C_IT_ADD10                    ((uint32_t)0x02000008)
+#define I2C_IT_BTF                      ((uint32_t)0x02000004)
+#define I2C_IT_ADDR                     ((uint32_t)0x02000002)
+#define I2C_IT_SB                       ((uint32_t)0x02000001)
+
+#define IS_I2C_CLEAR_IT(IT) ((((IT) & (uint16_t)0x20FF) == 0x00) && ((IT) != (uint16_t)0x00))
+
+#define IS_I2C_GET_IT(IT) (((IT) == I2C_IT_SMBALERT) || ((IT) == I2C_IT_TIMEOUT) || \
+                           ((IT) == I2C_IT_PECERR) || ((IT) == I2C_IT_OVR) || \
+                           ((IT) == I2C_IT_AF) || ((IT) == I2C_IT_ARLO) || \
+                           ((IT) == I2C_IT_BERR) || ((IT) == I2C_IT_TXE) || \
+                           ((IT) == I2C_IT_RXNE) || ((IT) == I2C_IT_STOPF) || \
+                           ((IT) == I2C_IT_ADD10) || ((IT) == I2C_IT_BTF) || \
+                           ((IT) == I2C_IT_ADDR) || ((IT) == I2C_IT_SB))
+/**
+  * @}
+  */
+
+/** @defgroup I2C_flags_definition
+  * @{
+  */
+
+/**
+  * @brief  SR2 register flags
+  */
+
+#define I2C_FLAG_DUALF                  ((uint32_t)0x00800000)
+#define I2C_FLAG_SMBHOST                ((uint32_t)0x00400000)
+#define I2C_FLAG_SMBDEFAULT             ((uint32_t)0x00200000)
+#define I2C_FLAG_GENCALL                ((uint32_t)0x00100000)
+#define I2C_FLAG_TRA                    ((uint32_t)0x00040000)
+#define I2C_FLAG_BUSY                   ((uint32_t)0x00020000)
+#define I2C_FLAG_MSL                    ((uint32_t)0x00010000)
+
+/**
+  * @brief  SR1 register flags
+  */
+
+#define I2C_FLAG_SMBALERT               ((uint32_t)0x10008000)
+#define I2C_FLAG_TIMEOUT                ((uint32_t)0x10004000)
+#define I2C_FLAG_PECERR                 ((uint32_t)0x10001000)
+#define I2C_FLAG_OVR                    ((uint32_t)0x10000800)
+#define I2C_FLAG_AF                     ((uint32_t)0x10000400)
+#define I2C_FLAG_ARLO                   ((uint32_t)0x10000200)
+#define I2C_FLAG_BERR                   ((uint32_t)0x10000100)
+#define I2C_FLAG_TXE                    ((uint32_t)0x10000080)
+#define I2C_FLAG_RXNE                   ((uint32_t)0x10000040)
+#define I2C_FLAG_STOPF                  ((uint32_t)0x10000010)
+#define I2C_FLAG_ADD10                  ((uint32_t)0x10000008)
+#define I2C_FLAG_BTF                    ((uint32_t)0x10000004)
+#define I2C_FLAG_ADDR                   ((uint32_t)0x10000002)
+#define I2C_FLAG_SB                     ((uint32_t)0x10000001)
+
+#define IS_I2C_CLEAR_FLAG(FLAG) ((((FLAG) & (uint16_t)0x20FF) == 0x00) && ((FLAG) != (uint16_t)0x00))
+
+#define IS_I2C_GET_FLAG(FLAG) (((FLAG) == I2C_FLAG_DUALF) || ((FLAG) == I2C_FLAG_SMBHOST) || \
+                               ((FLAG) == I2C_FLAG_SMBDEFAULT) || ((FLAG) == I2C_FLAG_GENCALL) || \
+                               ((FLAG) == I2C_FLAG_TRA) || ((FLAG) == I2C_FLAG_BUSY) || \
+                               ((FLAG) == I2C_FLAG_MSL) || ((FLAG) == I2C_FLAG_SMBALERT) || \
+                               ((FLAG) == I2C_FLAG_TIMEOUT) || ((FLAG) == I2C_FLAG_PECERR) || \
+                               ((FLAG) == I2C_FLAG_OVR) || ((FLAG) == I2C_FLAG_AF) || \
+                               ((FLAG) == I2C_FLAG_ARLO) || ((FLAG) == I2C_FLAG_BERR) || \
+                               ((FLAG) == I2C_FLAG_TXE) || ((FLAG) == I2C_FLAG_RXNE) || \
+                               ((FLAG) == I2C_FLAG_STOPF) || ((FLAG) == I2C_FLAG_ADD10) || \
+                               ((FLAG) == I2C_FLAG_BTF) || ((FLAG) == I2C_FLAG_ADDR) || \
+                               ((FLAG) == I2C_FLAG_SB))
+/**
+  * @}
+  */
+
+/** @defgroup I2C_Events
+  * @{
+  */
+
+/*========================================
+
+                     I2C Master Events (Events grouped in order of communication)
+                                                        ==========================================*/
+/**
+  * @brief  Communication start
+  *
+  * After sending the START condition (I2C_GenerateSTART() function) the master
+  * has to wait for this event. It means that the Start condition has been correctly
+  * released on the I2C bus (the bus is free, no other devices is communicating).
+  *
+  */
+/* --EV5 */
+#define  I2C_EVENT_MASTER_MODE_SELECT                      ((uint32_t)0x00030001)  /* BUSY, MSL and SB flag */
+
+/**
+  * @brief  Address Acknowledge
+  *
+  * After checking on EV5 (start condition correctly released on the bus), the
+  * master sends the address of the slave(s) with which it will communicate
+  * (I2C_Send7bitAddress() function, it also determines the direction of the communication:
+  * Master transmitter or Receiver). Then the master has to wait that a slave acknowledges
+  * his address. If an acknowledge is sent on the bus, one of the following events will
+  * be set:
+  *
+  *  1) In case of Master Receiver (7-bit addressing): the I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED
+  *     event is set.
+  *
+  *  2) In case of Master Transmitter (7-bit addressing): the I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED
+  *     is set
+  *
+  *  3) In case of 10-Bit addressing mode, the master (just after generating the START
+  *  and checking on EV5) has to send the header of 10-bit addressing mode (I2C_SendData()
+  *  function). Then master should wait on EV9. It means that the 10-bit addressing
+  *  header has been correctly sent on the bus. Then master should send the second part of
+  *  the 10-bit address (LSB) using the function I2C_Send7bitAddress(). Then master
+  *  should wait for event EV6.
+  *
+  */
+
+/* --EV6 */
+#define  I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED        ((uint32_t)0x00070082)  /* BUSY, MSL, ADDR, TXE and TRA flags */
+#define  I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED           ((uint32_t)0x00030002)  /* BUSY, MSL and ADDR flags */
+/* --EV9 */
+#define  I2C_EVENT_MASTER_MODE_ADDRESS10                   ((uint32_t)0x00030008)  /* BUSY, MSL and ADD10 flags */
+
+/**
+  * @brief Communication events
+  *
+  * If a communication is established (START condition generated and slave address
+  * acknowledged) then the master has to check on one of the following events for
+  * communication procedures:
+  *
+  * 1) Master Receiver mode: The master has to wait on the event EV7 then to read
+  *    the data received from the slave (I2C_ReceiveData() function).
+  *
+  * 2) Master Transmitter mode: The master has to send data (I2C_SendData()
+  *    function) then to wait on event EV8 or EV8_2.
+  *    These two events are similar:
+  *     - EV8 means that the data has been written in the data register and is
+  *       being shifted out.
+  *     - EV8_2 means that the data has been physically shifted out and output
+  *       on the bus.
+  *     In most cases, using EV8 is sufficient for the application.
+  *     Using EV8_2 leads to a slower communication but ensure more reliable test.
+  *     EV8_2 is also more suitable than EV8 for testing on the last data transmission
+  *     (before Stop condition generation).
+  *
+  *  @note In case the  user software does not guarantee that this event EV7 is
+  *  managed before the current byte end of transfer, then user may check on EV7
+  *  and BTF flag at the same time (ie. (I2C_EVENT_MASTER_BYTE_RECEIVED | I2C_FLAG_BTF)).
+  *  In this case the communication may be slower.
+  *
+  */
+
+/* Master RECEIVER mode -----------------------------*/
+/* --EV7 */
+#define  I2C_EVENT_MASTER_BYTE_RECEIVED                    ((uint32_t)0x00030040)  /* BUSY, MSL and RXNE flags */
+
+/* Master TRANSMITTER mode --------------------------*/
+/* --EV8 */
+#define I2C_EVENT_MASTER_BYTE_TRANSMITTING                 ((uint32_t)0x00070080) /* TRA, BUSY, MSL, TXE flags */
+/* --EV8_2 */
+#define  I2C_EVENT_MASTER_BYTE_TRANSMITTED                 ((uint32_t)0x00070084)  /* TRA, BUSY, MSL, TXE and BTF flags */
+
+
+/*========================================
+
+                     I2C Slave Events (Events grouped in order of communication)
+                                                        ==========================================*/
+
+/**
+  * @brief  Communication start events
+  *
+  * Wait on one of these events at the start of the communication. It means that
+  * the I2C peripheral detected a Start condition on the bus (generated by master
+  * device) followed by the peripheral address. The peripheral generates an ACK
+  * condition on the bus (if the acknowledge feature is enabled through function
+  * I2C_AcknowledgeConfig()) and the events listed above are set :
+  *
+  * 1) In normal case (only one address managed by the slave), when the address
+  *   sent by the master matches the own address of the peripheral (configured by
+  *   I2C_OwnAddress1 field) the I2C_EVENT_SLAVE_XXX_ADDRESS_MATCHED event is set
+  *   (where XXX could be TRANSMITTER or RECEIVER).
+  *
+  * 2) In case the address sent by the master matches the second address of the
+  *   peripheral (configured by the function I2C_OwnAddress2Config() and enabled
+  *   by the function I2C_DualAddressCmd()) the events I2C_EVENT_SLAVE_XXX_SECONDADDRESS_MATCHED
+  *   (where XXX could be TRANSMITTER or RECEIVER) are set.
+  *
+  * 3) In case the address sent by the master is General Call (address 0x00) and
+  *   if the General Call is enabled for the peripheral (using function I2C_GeneralCallCmd())
+  *   the following event is set I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED.
+  *
+  */
+
+/* --EV1  (all the events below are variants of EV1) */
+/* 1) Case of One Single Address managed by the slave */
+#define  I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED          ((uint32_t)0x00020002) /* BUSY and ADDR flags */
+#define  I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED       ((uint32_t)0x00060082) /* TRA, BUSY, TXE and ADDR flags */
+
+/* 2) Case of Dual address managed by the slave */
+#define  I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED    ((uint32_t)0x00820000)  /* DUALF and BUSY flags */
+#define  I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED ((uint32_t)0x00860080)  /* DUALF, TRA, BUSY and TXE flags */
+
+/* 3) Case of General Call enabled for the slave */
+#define  I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED        ((uint32_t)0x00120000)  /* GENCALL and BUSY flags */
+
+/**
+  * @brief  Communication events
+  *
+  * Wait on one of these events when EV1 has already been checked and:
+  *
+  * - Slave RECEIVER mode:
+  *     - EV2: When the application is expecting a data byte to be received.
+  *     - EV4: When the application is expecting the end of the communication: master
+  *       sends a stop condition and data transmission is stopped.
+  *
+  * - Slave Transmitter mode:
+  *    - EV3: When a byte has been transmitted by the slave and the application is expecting
+  *      the end of the byte transmission. The two events I2C_EVENT_SLAVE_BYTE_TRANSMITTED and
+  *      I2C_EVENT_SLAVE_BYTE_TRANSMITTING are similar. The second one can optionally be
+  *      used when the user software doesn't guarantee the EV3 is managed before the
+  *      current byte end of transfer.
+  *    - EV3_2: When the master sends a NACK in order to tell slave that data transmission
+  *      shall end (before sending the STOP condition). In this case slave has to stop sending
+  *      data bytes and expect a Stop condition on the bus.
+  *
+  *  @note In case the  user software does not guarantee that the event EV2 is
+  *  managed before the current byte end of transfer, then user may check on EV2
+  *  and BTF flag at the same time (ie. (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_BTF)).
+  * In this case the communication may be slower.
+  *
+  */
+
+/* Slave RECEIVER mode --------------------------*/
+/* --EV2 */
+#define  I2C_EVENT_SLAVE_BYTE_RECEIVED                     ((uint32_t)0x00020040)  /* BUSY and RXNE flags */
+/* --EV4  */
+#define  I2C_EVENT_SLAVE_STOP_DETECTED                     ((uint32_t)0x00000010)  /* STOPF flag */
+
+/* Slave TRANSMITTER mode -----------------------*/
+/* --EV3 */
+#define  I2C_EVENT_SLAVE_BYTE_TRANSMITTED                  ((uint32_t)0x00060084)  /* TRA, BUSY, TXE and BTF flags */
+#define  I2C_EVENT_SLAVE_BYTE_TRANSMITTING                 ((uint32_t)0x00060080)  /* TRA, BUSY and TXE flags */
+/* --EV3_2 */
+#define  I2C_EVENT_SLAVE_ACK_FAILURE                       ((uint32_t)0x00000400)  /* AF flag */
+
+/*===========================      End of Events Description           ==========================================*/
+
+#define IS_I2C_EVENT(EVENT) (((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED) || \
+                             ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED) || \
+                             ((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED) || \
+                             ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED) || \
+                             ((EVENT) == I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED) || \
+                             ((EVENT) == I2C_EVENT_SLAVE_BYTE_RECEIVED) || \
+                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF)) || \
+                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)) || \
+                             ((EVENT) == I2C_EVENT_SLAVE_BYTE_TRANSMITTED) || \
+                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF)) || \
+                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL)) || \
+                             ((EVENT) == I2C_EVENT_SLAVE_STOP_DETECTED) || \
+                             ((EVENT) == I2C_EVENT_MASTER_MODE_SELECT) || \
+                             ((EVENT) == I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) || \
+                             ((EVENT) == I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) || \
+                             ((EVENT) == I2C_EVENT_MASTER_BYTE_RECEIVED) || \
+                             ((EVENT) == I2C_EVENT_MASTER_BYTE_TRANSMITTED) || \
+                             ((EVENT) == I2C_EVENT_MASTER_BYTE_TRANSMITTING) || \
+                             ((EVENT) == I2C_EVENT_MASTER_MODE_ADDRESS10) || \
+                             ((EVENT) == I2C_EVENT_SLAVE_ACK_FAILURE))
+/**
+  * @}
+  */
+
+/** @defgroup I2C_own_address1
+  * @{
+  */
+
+#define IS_I2C_OWN_ADDRESS1(ADDRESS1) ((ADDRESS1) <= 0x3FF)
+/**
+  * @}
+  */
+
+/** @defgroup I2C_clock_speed
+  * @{
+  */
+
+#define IS_I2C_CLOCK_SPEED(SPEED) (((SPEED) >= 0x1) && ((SPEED) <= 400000))
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup I2C_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup I2C_Exported_Functions
+  * @{
+  */
+
+void I2C_DeInit(I2C_TypeDef* I2Cx);
+void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct);
+void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct);
+void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
+void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
+void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
+void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState);
+void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState);
+void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState);
+void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address);
+void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
+void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
+void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState);
+void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data);
+uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx);
+void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction);
+uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register);
+void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
+void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition);
+void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert);
+void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState);
+void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition);
+void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState);
+uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx);
+void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
+void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
+void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle);
+
+/**
+ * @brief
+ ****************************************************************************************
+ *
+ *                         I2C State Monitoring Functions
+ *
+ ****************************************************************************************
+ * This I2C driver provides three different ways for I2C state monitoring
+ *  depending on the application requirements and constraints:
+ *
+ *
+ * 1) Basic state monitoring:
+ *    Using I2C_CheckEvent() function:
+ *    It compares the status registers (SR1 and SR2) content to a given event
+ *    (can be the combination of one or more flags).
+ *    It returns SUCCESS if the current status includes the given flags
+ *    and returns ERROR if one or more flags are missing in the current status.
+ *    - When to use:
+ *      - This function is suitable for most applications as well as for startup
+ *      activity since the events are fully described in the product reference manual
+ *      (RM0008).
+ *      - It is also suitable for users who need to define their own events.
+ *    - Limitations:
+ *      - If an error occurs (ie. error flags are set besides to the monitored flags),
+ *        the I2C_CheckEvent() function may return SUCCESS despite the communication
+ *        hold or corrupted real state.
+ *        In this case, it is advised to use error interrupts to monitor the error
+ *        events and handle them in the interrupt IRQ handler.
+ *
+ *        @note
+ *        For error management, it is advised to use the following functions:
+ *          - I2C_ITConfig() to configure and enable the error interrupts (I2C_IT_ERR).
+ *          - I2Cx_ER_IRQHandler() which is called when the error interrupt occurs.
+ *            Where x is the peripheral instance (I2C1, I2C2 ...)
+ *          - I2C_GetFlagStatus() or I2C_GetITStatus() to be called into I2Cx_ER_IRQHandler()
+ *            in order to determine which error occurred.
+ *          - I2C_ClearFlag() or I2C_ClearITPendingBit() and/or I2C_SoftwareResetCmd()
+ *            and/or I2C_GenerateStop() in order to clear the error flag and source,
+ *            and return to correct communication status.
+ *
+ *
+ *  2) Advanced state monitoring:
+ *     Using the function I2C_GetLastEvent() which returns the image of both status
+ *     registers in a single word (uint32_t) (Status Register 2 value is shifted left
+ *     by 16 bits and concatenated to Status Register 1).
+ *     - When to use:
+ *       - This function is suitable for the same applications above but it allows to
+ *         overcome the limitations of I2C_GetFlagStatus() function (see below).
+ *         The returned value could be compared to events already defined in the
+ *         library (stm32f10x_i2c.h) or to custom values defined by user.
+ *       - This function is suitable when multiple flags are monitored at the same time.
+ *       - At the opposite of I2C_CheckEvent() function, this function allows user to
+ *         choose when an event is accepted (when all events flags are set and no
+ *         other flags are set or just when the needed flags are set like
+ *         I2C_CheckEvent() function).
+ *     - Limitations:
+ *       - User may need to define his own events.
+ *       - Same remark concerning the error management is applicable for this
+ *         function if user decides to check only regular communication flags (and
+ *         ignores error flags).
+ *
+ *
+ *  3) Flag-based state monitoring:
+ *     Using the function I2C_GetFlagStatus() which simply returns the status of
+ *     one single flag (ie. I2C_FLAG_RXNE ...).
+ *     - When to use:
+ *        - This function could be used for specific applications or in debug phase.
+ *        - It is suitable when only one flag checking is needed (most I2C events
+ *          are monitored through multiple flags).
+ *     - Limitations:
+ *        - When calling this function, the Status register is accessed. Some flags are
+ *          cleared when the status register is accessed. So checking the status
+ *          of one Flag, may clear other ones.
+ *        - Function may need to be called twice or more in order to monitor one
+ *          single event.
+ *
+ */
+
+/**
+ *
+ *  1) Basic state monitoring
+ *******************************************************************************
+ */
+ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT);
+/**
+ *
+ *  2) Advanced state monitoring
+ *******************************************************************************
+ */
+uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx);
+/**
+ *
+ *  3) Flag-based state monitoring
+ *******************************************************************************
+ */
+FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);
+/**
+ *
+ *******************************************************************************
+ */
+
+void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);
+ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT);
+void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__STM32F10x_I2C_H */
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_iwdg.h b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_iwdg.h
new file mode 100644
index 0000000..7f5ab76
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_iwdg.h
@@ -0,0 +1,140 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_iwdg.h
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file contains all the functions prototypes for the IWDG
+  *          firmware library.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F10x_IWDG_H
+#define __STM32F10x_IWDG_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup IWDG
+  * @{
+  */
+
+/** @defgroup IWDG_Exported_Types
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup IWDG_Exported_Constants
+  * @{
+  */
+
+/** @defgroup IWDG_WriteAccess
+  * @{
+  */
+
+#define IWDG_WriteAccess_Enable     ((uint16_t)0x5555)
+#define IWDG_WriteAccess_Disable    ((uint16_t)0x0000)
+#define IS_IWDG_WRITE_ACCESS(ACCESS) (((ACCESS) == IWDG_WriteAccess_Enable) || \
+                                      ((ACCESS) == IWDG_WriteAccess_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup IWDG_prescaler
+  * @{
+  */
+
+#define IWDG_Prescaler_4            ((uint8_t)0x00)
+#define IWDG_Prescaler_8            ((uint8_t)0x01)
+#define IWDG_Prescaler_16           ((uint8_t)0x02)
+#define IWDG_Prescaler_32           ((uint8_t)0x03)
+#define IWDG_Prescaler_64           ((uint8_t)0x04)
+#define IWDG_Prescaler_128          ((uint8_t)0x05)
+#define IWDG_Prescaler_256          ((uint8_t)0x06)
+#define IS_IWDG_PRESCALER(PRESCALER) (((PRESCALER) == IWDG_Prescaler_4)  || \
+                                      ((PRESCALER) == IWDG_Prescaler_8)  || \
+                                      ((PRESCALER) == IWDG_Prescaler_16) || \
+                                      ((PRESCALER) == IWDG_Prescaler_32) || \
+                                      ((PRESCALER) == IWDG_Prescaler_64) || \
+                                      ((PRESCALER) == IWDG_Prescaler_128)|| \
+                                      ((PRESCALER) == IWDG_Prescaler_256))
+/**
+  * @}
+  */
+
+/** @defgroup IWDG_Flag
+  * @{
+  */
+
+#define IWDG_FLAG_PVU               ((uint16_t)0x0001)
+#define IWDG_FLAG_RVU               ((uint16_t)0x0002)
+#define IS_IWDG_FLAG(FLAG) (((FLAG) == IWDG_FLAG_PVU) || ((FLAG) == IWDG_FLAG_RVU))
+#define IS_IWDG_RELOAD(RELOAD) ((RELOAD) <= 0xFFF)
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup IWDG_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup IWDG_Exported_Functions
+  * @{
+  */
+
+void IWDG_WriteAccessCmd(uint16_t IWDG_WriteAccess);
+void IWDG_SetPrescaler(uint8_t IWDG_Prescaler);
+void IWDG_SetReload(uint16_t Reload);
+void IWDG_ReloadCounter(void);
+void IWDG_Enable(void);
+FlagStatus IWDG_GetFlagStatus(uint16_t IWDG_FLAG);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F10x_IWDG_H */
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_pwr.h b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_pwr.h
new file mode 100644
index 0000000..76e6ce9
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_pwr.h
@@ -0,0 +1,156 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_pwr.h
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file contains all the functions prototypes for the PWR firmware
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F10x_PWR_H
+#define __STM32F10x_PWR_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup PWR
+  * @{
+  */
+
+/** @defgroup PWR_Exported_Types
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup PWR_Exported_Constants
+  * @{
+  */
+
+/** @defgroup PVD_detection_level
+  * @{
+  */
+
+#define PWR_PVDLevel_2V2          ((uint32_t)0x00000000)
+#define PWR_PVDLevel_2V3          ((uint32_t)0x00000020)
+#define PWR_PVDLevel_2V4          ((uint32_t)0x00000040)
+#define PWR_PVDLevel_2V5          ((uint32_t)0x00000060)
+#define PWR_PVDLevel_2V6          ((uint32_t)0x00000080)
+#define PWR_PVDLevel_2V7          ((uint32_t)0x000000A0)
+#define PWR_PVDLevel_2V8          ((uint32_t)0x000000C0)
+#define PWR_PVDLevel_2V9          ((uint32_t)0x000000E0)
+#define IS_PWR_PVD_LEVEL(LEVEL) (((LEVEL) == PWR_PVDLevel_2V2) || ((LEVEL) == PWR_PVDLevel_2V3)|| \
+                                 ((LEVEL) == PWR_PVDLevel_2V4) || ((LEVEL) == PWR_PVDLevel_2V5)|| \
+                                 ((LEVEL) == PWR_PVDLevel_2V6) || ((LEVEL) == PWR_PVDLevel_2V7)|| \
+                                 ((LEVEL) == PWR_PVDLevel_2V8) || ((LEVEL) == PWR_PVDLevel_2V9))
+/**
+  * @}
+  */
+
+/** @defgroup Regulator_state_is_STOP_mode
+  * @{
+  */
+
+#define PWR_Regulator_ON          ((uint32_t)0x00000000)
+#define PWR_Regulator_LowPower    ((uint32_t)0x00000001)
+#define IS_PWR_REGULATOR(REGULATOR) (((REGULATOR) == PWR_Regulator_ON) || \
+                                     ((REGULATOR) == PWR_Regulator_LowPower))
+/**
+  * @}
+  */
+
+/** @defgroup STOP_mode_entry
+  * @{
+  */
+
+#define PWR_STOPEntry_WFI         ((uint8_t)0x01)
+#define PWR_STOPEntry_WFE         ((uint8_t)0x02)
+#define IS_PWR_STOP_ENTRY(ENTRY) (((ENTRY) == PWR_STOPEntry_WFI) || ((ENTRY) == PWR_STOPEntry_WFE))
+
+/**
+  * @}
+  */
+
+/** @defgroup PWR_Flag
+  * @{
+  */
+
+#define PWR_FLAG_WU               ((uint32_t)0x00000001)
+#define PWR_FLAG_SB               ((uint32_t)0x00000002)
+#define PWR_FLAG_PVDO             ((uint32_t)0x00000004)
+#define IS_PWR_GET_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB) || \
+                               ((FLAG) == PWR_FLAG_PVDO))
+
+#define IS_PWR_CLEAR_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB))
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup PWR_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup PWR_Exported_Functions
+  * @{
+  */
+
+void PWR_DeInit(void);
+void PWR_BackupAccessCmd(FunctionalState NewState);
+void PWR_PVDCmd(FunctionalState NewState);
+void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel);
+void PWR_WakeUpPinCmd(FunctionalState NewState);
+void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry);
+void PWR_EnterSTANDBYMode(void);
+FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG);
+void PWR_ClearFlag(uint32_t PWR_FLAG);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F10x_PWR_H */
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_rcc.h b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_rcc.h
new file mode 100644
index 0000000..b3b7d82
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_rcc.h
@@ -0,0 +1,727 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_rcc.h
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file contains all the functions prototypes for the RCC firmware
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F10x_RCC_H
+#define __STM32F10x_RCC_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup RCC
+  * @{
+  */
+
+/** @defgroup RCC_Exported_Types
+  * @{
+  */
+
+typedef struct
+{
+  uint32_t SYSCLK_Frequency;  /*!< returns SYSCLK clock frequency expressed in Hz */
+  uint32_t HCLK_Frequency;    /*!< returns HCLK clock frequency expressed in Hz */
+  uint32_t PCLK1_Frequency;   /*!< returns PCLK1 clock frequency expressed in Hz */
+  uint32_t PCLK2_Frequency;   /*!< returns PCLK2 clock frequency expressed in Hz */
+  uint32_t ADCCLK_Frequency;  /*!< returns ADCCLK clock frequency expressed in Hz */
+}RCC_ClocksTypeDef;
+
+/**
+  * @}
+  */
+
+/** @defgroup RCC_Exported_Constants
+  * @{
+  */
+
+/** @defgroup HSE_configuration
+  * @{
+  */
+
+#define RCC_HSE_OFF                      ((uint32_t)0x00000000)
+#define RCC_HSE_ON                       ((uint32_t)0x00010000)
+#define RCC_HSE_Bypass                   ((uint32_t)0x00040000)
+#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) || \
+                         ((HSE) == RCC_HSE_Bypass))
+
+/**
+  * @}
+  */
+
+/** @defgroup PLL_entry_clock_source
+  * @{
+  */
+
+#define RCC_PLLSource_HSI_Div2           ((uint32_t)0x00000000)
+
+#if !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD_VL) && !defined (STM32F10X_CL)
+ #define RCC_PLLSource_HSE_Div1           ((uint32_t)0x00010000)
+ #define RCC_PLLSource_HSE_Div2           ((uint32_t)0x00030000)
+ #define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) || \
+                                   ((SOURCE) == RCC_PLLSource_HSE_Div1) || \
+                                   ((SOURCE) == RCC_PLLSource_HSE_Div2))
+#else
+ #define RCC_PLLSource_PREDIV1            ((uint32_t)0x00010000)
+ #define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) || \
+                                   ((SOURCE) == RCC_PLLSource_PREDIV1))
+#endif /* STM32F10X_CL */
+
+/**
+  * @}
+  */
+
+/** @defgroup PLL_multiplication_factor
+  * @{
+  */
+#ifndef STM32F10X_CL
+ #define RCC_PLLMul_2                    ((uint32_t)0x00000000)
+ #define RCC_PLLMul_3                    ((uint32_t)0x00040000)
+ #define RCC_PLLMul_4                    ((uint32_t)0x00080000)
+ #define RCC_PLLMul_5                    ((uint32_t)0x000C0000)
+ #define RCC_PLLMul_6                    ((uint32_t)0x00100000)
+ #define RCC_PLLMul_7                    ((uint32_t)0x00140000)
+ #define RCC_PLLMul_8                    ((uint32_t)0x00180000)
+ #define RCC_PLLMul_9                    ((uint32_t)0x001C0000)
+ #define RCC_PLLMul_10                   ((uint32_t)0x00200000)
+ #define RCC_PLLMul_11                   ((uint32_t)0x00240000)
+ #define RCC_PLLMul_12                   ((uint32_t)0x00280000)
+ #define RCC_PLLMul_13                   ((uint32_t)0x002C0000)
+ #define RCC_PLLMul_14                   ((uint32_t)0x00300000)
+ #define RCC_PLLMul_15                   ((uint32_t)0x00340000)
+ #define RCC_PLLMul_16                   ((uint32_t)0x00380000)
+ #define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_2) || ((MUL) == RCC_PLLMul_3)   || \
+                              ((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5)   || \
+                              ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7)   || \
+                              ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9)   || \
+                              ((MUL) == RCC_PLLMul_10) || ((MUL) == RCC_PLLMul_11) || \
+                              ((MUL) == RCC_PLLMul_12) || ((MUL) == RCC_PLLMul_13) || \
+                              ((MUL) == RCC_PLLMul_14) || ((MUL) == RCC_PLLMul_15) || \
+                              ((MUL) == RCC_PLLMul_16))
+
+#else
+ #define RCC_PLLMul_4                    ((uint32_t)0x00080000)
+ #define RCC_PLLMul_5                    ((uint32_t)0x000C0000)
+ #define RCC_PLLMul_6                    ((uint32_t)0x00100000)
+ #define RCC_PLLMul_7                    ((uint32_t)0x00140000)
+ #define RCC_PLLMul_8                    ((uint32_t)0x00180000)
+ #define RCC_PLLMul_9                    ((uint32_t)0x001C0000)
+ #define RCC_PLLMul_6_5                  ((uint32_t)0x00340000)
+
+ #define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5) || \
+                              ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7) || \
+                              ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9) || \
+                              ((MUL) == RCC_PLLMul_6_5))
+#endif /* STM32F10X_CL */
+/**
+  * @}
+  */
+
+/** @defgroup PREDIV1_division_factor
+  * @{
+  */
+#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL) || defined (STM32F10X_CL)
+ #define  RCC_PREDIV1_Div1               ((uint32_t)0x00000000)
+ #define  RCC_PREDIV1_Div2               ((uint32_t)0x00000001)
+ #define  RCC_PREDIV1_Div3               ((uint32_t)0x00000002)
+ #define  RCC_PREDIV1_Div4               ((uint32_t)0x00000003)
+ #define  RCC_PREDIV1_Div5               ((uint32_t)0x00000004)
+ #define  RCC_PREDIV1_Div6               ((uint32_t)0x00000005)
+ #define  RCC_PREDIV1_Div7               ((uint32_t)0x00000006)
+ #define  RCC_PREDIV1_Div8               ((uint32_t)0x00000007)
+ #define  RCC_PREDIV1_Div9               ((uint32_t)0x00000008)
+ #define  RCC_PREDIV1_Div10              ((uint32_t)0x00000009)
+ #define  RCC_PREDIV1_Div11              ((uint32_t)0x0000000A)
+ #define  RCC_PREDIV1_Div12              ((uint32_t)0x0000000B)
+ #define  RCC_PREDIV1_Div13              ((uint32_t)0x0000000C)
+ #define  RCC_PREDIV1_Div14              ((uint32_t)0x0000000D)
+ #define  RCC_PREDIV1_Div15              ((uint32_t)0x0000000E)
+ #define  RCC_PREDIV1_Div16              ((uint32_t)0x0000000F)
+
+ #define IS_RCC_PREDIV1(PREDIV1) (((PREDIV1) == RCC_PREDIV1_Div1) || ((PREDIV1) == RCC_PREDIV1_Div2) || \
+                                  ((PREDIV1) == RCC_PREDIV1_Div3) || ((PREDIV1) == RCC_PREDIV1_Div4) || \
+                                  ((PREDIV1) == RCC_PREDIV1_Div5) || ((PREDIV1) == RCC_PREDIV1_Div6) || \
+                                  ((PREDIV1) == RCC_PREDIV1_Div7) || ((PREDIV1) == RCC_PREDIV1_Div8) || \
+                                  ((PREDIV1) == RCC_PREDIV1_Div9) || ((PREDIV1) == RCC_PREDIV1_Div10) || \
+                                  ((PREDIV1) == RCC_PREDIV1_Div11) || ((PREDIV1) == RCC_PREDIV1_Div12) || \
+                                  ((PREDIV1) == RCC_PREDIV1_Div13) || ((PREDIV1) == RCC_PREDIV1_Div14) || \
+                                  ((PREDIV1) == RCC_PREDIV1_Div15) || ((PREDIV1) == RCC_PREDIV1_Div16))
+#endif
+/**
+  * @}
+  */
+
+
+/** @defgroup PREDIV1_clock_source
+  * @{
+  */
+#ifdef STM32F10X_CL
+/* PREDIV1 clock source (for STM32 connectivity line devices) */
+ #define  RCC_PREDIV1_Source_HSE         ((uint32_t)0x00000000)
+ #define  RCC_PREDIV1_Source_PLL2        ((uint32_t)0x00010000)
+
+ #define IS_RCC_PREDIV1_SOURCE(SOURCE) (((SOURCE) == RCC_PREDIV1_Source_HSE) || \
+                                        ((SOURCE) == RCC_PREDIV1_Source_PLL2))
+#elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
+/* PREDIV1 clock source (for STM32 Value line devices) */
+ #define  RCC_PREDIV1_Source_HSE         ((uint32_t)0x00000000)
+
+ #define IS_RCC_PREDIV1_SOURCE(SOURCE) (((SOURCE) == RCC_PREDIV1_Source_HSE))
+#endif
+/**
+  * @}
+  */
+
+#ifdef STM32F10X_CL
+/** @defgroup PREDIV2_division_factor
+  * @{
+  */
+
+ #define  RCC_PREDIV2_Div1               ((uint32_t)0x00000000)
+ #define  RCC_PREDIV2_Div2               ((uint32_t)0x00000010)
+ #define  RCC_PREDIV2_Div3               ((uint32_t)0x00000020)
+ #define  RCC_PREDIV2_Div4               ((uint32_t)0x00000030)
+ #define  RCC_PREDIV2_Div5               ((uint32_t)0x00000040)
+ #define  RCC_PREDIV2_Div6               ((uint32_t)0x00000050)
+ #define  RCC_PREDIV2_Div7               ((uint32_t)0x00000060)
+ #define  RCC_PREDIV2_Div8               ((uint32_t)0x00000070)
+ #define  RCC_PREDIV2_Div9               ((uint32_t)0x00000080)
+ #define  RCC_PREDIV2_Div10              ((uint32_t)0x00000090)
+ #define  RCC_PREDIV2_Div11              ((uint32_t)0x000000A0)
+ #define  RCC_PREDIV2_Div12              ((uint32_t)0x000000B0)
+ #define  RCC_PREDIV2_Div13              ((uint32_t)0x000000C0)
+ #define  RCC_PREDIV2_Div14              ((uint32_t)0x000000D0)
+ #define  RCC_PREDIV2_Div15              ((uint32_t)0x000000E0)
+ #define  RCC_PREDIV2_Div16              ((uint32_t)0x000000F0)
+
+ #define IS_RCC_PREDIV2(PREDIV2) (((PREDIV2) == RCC_PREDIV2_Div1) || ((PREDIV2) == RCC_PREDIV2_Div2) || \
+                                  ((PREDIV2) == RCC_PREDIV2_Div3) || ((PREDIV2) == RCC_PREDIV2_Div4) || \
+                                  ((PREDIV2) == RCC_PREDIV2_Div5) || ((PREDIV2) == RCC_PREDIV2_Div6) || \
+                                  ((PREDIV2) == RCC_PREDIV2_Div7) || ((PREDIV2) == RCC_PREDIV2_Div8) || \
+                                  ((PREDIV2) == RCC_PREDIV2_Div9) || ((PREDIV2) == RCC_PREDIV2_Div10) || \
+                                  ((PREDIV2) == RCC_PREDIV2_Div11) || ((PREDIV2) == RCC_PREDIV2_Div12) || \
+                                  ((PREDIV2) == RCC_PREDIV2_Div13) || ((PREDIV2) == RCC_PREDIV2_Div14) || \
+                                  ((PREDIV2) == RCC_PREDIV2_Div15) || ((PREDIV2) == RCC_PREDIV2_Div16))
+/**
+  * @}
+  */
+
+
+/** @defgroup PLL2_multiplication_factor
+  * @{
+  */
+
+ #define  RCC_PLL2Mul_8                  ((uint32_t)0x00000600)
+ #define  RCC_PLL2Mul_9                  ((uint32_t)0x00000700)
+ #define  RCC_PLL2Mul_10                 ((uint32_t)0x00000800)
+ #define  RCC_PLL2Mul_11                 ((uint32_t)0x00000900)
+ #define  RCC_PLL2Mul_12                 ((uint32_t)0x00000A00)
+ #define  RCC_PLL2Mul_13                 ((uint32_t)0x00000B00)
+ #define  RCC_PLL2Mul_14                 ((uint32_t)0x00000C00)
+ #define  RCC_PLL2Mul_16                 ((uint32_t)0x00000E00)
+ #define  RCC_PLL2Mul_20                 ((uint32_t)0x00000F00)
+
+ #define IS_RCC_PLL2_MUL(MUL) (((MUL) == RCC_PLL2Mul_8) || ((MUL) == RCC_PLL2Mul_9)  || \
+                               ((MUL) == RCC_PLL2Mul_10) || ((MUL) == RCC_PLL2Mul_11) || \
+                               ((MUL) == RCC_PLL2Mul_12) || ((MUL) == RCC_PLL2Mul_13) || \
+                               ((MUL) == RCC_PLL2Mul_14) || ((MUL) == RCC_PLL2Mul_16) || \
+                               ((MUL) == RCC_PLL2Mul_20))
+/**
+  * @}
+  */
+
+
+/** @defgroup PLL3_multiplication_factor
+  * @{
+  */
+
+ #define  RCC_PLL3Mul_8                  ((uint32_t)0x00006000)
+ #define  RCC_PLL3Mul_9                  ((uint32_t)0x00007000)
+ #define  RCC_PLL3Mul_10                 ((uint32_t)0x00008000)
+ #define  RCC_PLL3Mul_11                 ((uint32_t)0x00009000)
+ #define  RCC_PLL3Mul_12                 ((uint32_t)0x0000A000)
+ #define  RCC_PLL3Mul_13                 ((uint32_t)0x0000B000)
+ #define  RCC_PLL3Mul_14                 ((uint32_t)0x0000C000)
+ #define  RCC_PLL3Mul_16                 ((uint32_t)0x0000E000)
+ #define  RCC_PLL3Mul_20                 ((uint32_t)0x0000F000)
+
+ #define IS_RCC_PLL3_MUL(MUL) (((MUL) == RCC_PLL3Mul_8) || ((MUL) == RCC_PLL3Mul_9)  || \
+                               ((MUL) == RCC_PLL3Mul_10) || ((MUL) == RCC_PLL3Mul_11) || \
+                               ((MUL) == RCC_PLL3Mul_12) || ((MUL) == RCC_PLL3Mul_13) || \
+                               ((MUL) == RCC_PLL3Mul_14) || ((MUL) == RCC_PLL3Mul_16) || \
+                               ((MUL) == RCC_PLL3Mul_20))
+/**
+  * @}
+  */
+
+#endif /* STM32F10X_CL */
+
+
+/** @defgroup System_clock_source
+  * @{
+  */
+
+#define RCC_SYSCLKSource_HSI             ((uint32_t)0x00000000)
+#define RCC_SYSCLKSource_HSE             ((uint32_t)0x00000001)
+#define RCC_SYSCLKSource_PLLCLK          ((uint32_t)0x00000002)
+#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HSI) || \
+                                      ((SOURCE) == RCC_SYSCLKSource_HSE) || \
+                                      ((SOURCE) == RCC_SYSCLKSource_PLLCLK))
+/**
+  * @}
+  */
+
+/** @defgroup AHB_clock_source
+  * @{
+  */
+
+#define RCC_SYSCLK_Div1                  ((uint32_t)0x00000000)
+#define RCC_SYSCLK_Div2                  ((uint32_t)0x00000080)
+#define RCC_SYSCLK_Div4                  ((uint32_t)0x00000090)
+#define RCC_SYSCLK_Div8                  ((uint32_t)0x000000A0)
+#define RCC_SYSCLK_Div16                 ((uint32_t)0x000000B0)
+#define RCC_SYSCLK_Div64                 ((uint32_t)0x000000C0)
+#define RCC_SYSCLK_Div128                ((uint32_t)0x000000D0)
+#define RCC_SYSCLK_Div256                ((uint32_t)0x000000E0)
+#define RCC_SYSCLK_Div512                ((uint32_t)0x000000F0)
+#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) || \
+                           ((HCLK) == RCC_SYSCLK_Div4) || ((HCLK) == RCC_SYSCLK_Div8) || \
+                           ((HCLK) == RCC_SYSCLK_Div16) || ((HCLK) == RCC_SYSCLK_Div64) || \
+                           ((HCLK) == RCC_SYSCLK_Div128) || ((HCLK) == RCC_SYSCLK_Div256) || \
+                           ((HCLK) == RCC_SYSCLK_Div512))
+/**
+  * @}
+  */
+
+/** @defgroup APB1_APB2_clock_source
+  * @{
+  */
+
+#define RCC_HCLK_Div1                    ((uint32_t)0x00000000)
+#define RCC_HCLK_Div2                    ((uint32_t)0x00000400)
+#define RCC_HCLK_Div4                    ((uint32_t)0x00000500)
+#define RCC_HCLK_Div8                    ((uint32_t)0x00000600)
+#define RCC_HCLK_Div16                   ((uint32_t)0x00000700)
+#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) || \
+                           ((PCLK) == RCC_HCLK_Div4) || ((PCLK) == RCC_HCLK_Div8) || \
+                           ((PCLK) == RCC_HCLK_Div16))
+/**
+  * @}
+  */
+
+/** @defgroup RCC_Interrupt_source
+  * @{
+  */
+
+#define RCC_IT_LSIRDY                    ((uint8_t)0x01)
+#define RCC_IT_LSERDY                    ((uint8_t)0x02)
+#define RCC_IT_HSIRDY                    ((uint8_t)0x04)
+#define RCC_IT_HSERDY                    ((uint8_t)0x08)
+#define RCC_IT_PLLRDY                    ((uint8_t)0x10)
+#define RCC_IT_CSS                       ((uint8_t)0x80)
+
+#ifndef STM32F10X_CL
+ #define IS_RCC_IT(IT) ((((IT) & (uint8_t)0xE0) == 0x00) && ((IT) != 0x00))
+ #define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) || \
+                            ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) || \
+                            ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS))
+ #define IS_RCC_CLEAR_IT(IT) ((((IT) & (uint8_t)0x60) == 0x00) && ((IT) != 0x00))
+#else
+ #define RCC_IT_PLL2RDY                  ((uint8_t)0x20)
+ #define RCC_IT_PLL3RDY                  ((uint8_t)0x40)
+ #define IS_RCC_IT(IT) ((((IT) & (uint8_t)0x80) == 0x00) && ((IT) != 0x00))
+ #define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) || \
+                            ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) || \
+                            ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS) || \
+                            ((IT) == RCC_IT_PLL2RDY) || ((IT) == RCC_IT_PLL3RDY))
+ #define IS_RCC_CLEAR_IT(IT) ((IT) != 0x00)
+#endif /* STM32F10X_CL */
+
+
+/**
+  * @}
+  */
+
+#ifndef STM32F10X_CL
+/** @defgroup USB_Device_clock_source
+  * @{
+  */
+
+ #define RCC_USBCLKSource_PLLCLK_1Div5   ((uint8_t)0x00)
+ #define RCC_USBCLKSource_PLLCLK_Div1    ((uint8_t)0x01)
+
+ #define IS_RCC_USBCLK_SOURCE(SOURCE) (((SOURCE) == RCC_USBCLKSource_PLLCLK_1Div5) || \
+                                      ((SOURCE) == RCC_USBCLKSource_PLLCLK_Div1))
+/**
+  * @}
+  */
+#else
+/** @defgroup USB_OTG_FS_clock_source
+  * @{
+  */
+ #define RCC_OTGFSCLKSource_PLLVCO_Div3    ((uint8_t)0x00)
+ #define RCC_OTGFSCLKSource_PLLVCO_Div2    ((uint8_t)0x01)
+
+ #define IS_RCC_OTGFSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_OTGFSCLKSource_PLLVCO_Div3) || \
+                                         ((SOURCE) == RCC_OTGFSCLKSource_PLLVCO_Div2))
+/**
+  * @}
+  */
+#endif /* STM32F10X_CL */
+
+
+#ifdef STM32F10X_CL
+/** @defgroup I2S2_clock_source
+  * @{
+  */
+ #define RCC_I2S2CLKSource_SYSCLK        ((uint8_t)0x00)
+ #define RCC_I2S2CLKSource_PLL3_VCO      ((uint8_t)0x01)
+
+ #define IS_RCC_I2S2CLK_SOURCE(SOURCE) (((SOURCE) == RCC_I2S2CLKSource_SYSCLK) || \
+                                        ((SOURCE) == RCC_I2S2CLKSource_PLL3_VCO))
+/**
+  * @}
+  */
+
+/** @defgroup I2S3_clock_source
+  * @{
+  */
+ #define RCC_I2S3CLKSource_SYSCLK        ((uint8_t)0x00)
+ #define RCC_I2S3CLKSource_PLL3_VCO      ((uint8_t)0x01)
+
+ #define IS_RCC_I2S3CLK_SOURCE(SOURCE) (((SOURCE) == RCC_I2S3CLKSource_SYSCLK) || \
+                                        ((SOURCE) == RCC_I2S3CLKSource_PLL3_VCO))
+/**
+  * @}
+  */
+#endif /* STM32F10X_CL */
+
+
+/** @defgroup ADC_clock_source
+  * @{
+  */
+
+#define RCC_PCLK2_Div2                   ((uint32_t)0x00000000)
+#define RCC_PCLK2_Div4                   ((uint32_t)0x00004000)
+#define RCC_PCLK2_Div6                   ((uint32_t)0x00008000)
+#define RCC_PCLK2_Div8                   ((uint32_t)0x0000C000)
+#define IS_RCC_ADCCLK(ADCCLK) (((ADCCLK) == RCC_PCLK2_Div2) || ((ADCCLK) == RCC_PCLK2_Div4) || \
+                               ((ADCCLK) == RCC_PCLK2_Div6) || ((ADCCLK) == RCC_PCLK2_Div8))
+/**
+  * @}
+  */
+
+/** @defgroup LSE_configuration
+  * @{
+  */
+
+#define RCC_LSE_OFF                      ((uint8_t)0x00)
+#define RCC_LSE_ON                       ((uint8_t)0x01)
+#define RCC_LSE_Bypass                   ((uint8_t)0x04)
+#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) || \
+                         ((LSE) == RCC_LSE_Bypass))
+/**
+  * @}
+  */
+
+/** @defgroup RTC_clock_source
+  * @{
+  */
+
+#define RCC_RTCCLKSource_LSE             ((uint32_t)0x00000100)
+#define RCC_RTCCLKSource_LSI             ((uint32_t)0x00000200)
+#define RCC_RTCCLKSource_HSE_Div128      ((uint32_t)0x00000300)
+#define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_LSI) || \
+                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div128))
+/**
+  * @}
+  */
+
+/** @defgroup AHB_peripheral
+  * @{
+  */
+
+#define RCC_AHBPeriph_DMA1               ((uint32_t)0x00000001)
+#define RCC_AHBPeriph_DMA2               ((uint32_t)0x00000002)
+#define RCC_AHBPeriph_SRAM               ((uint32_t)0x00000004)
+#define RCC_AHBPeriph_FLITF              ((uint32_t)0x00000010)
+#define RCC_AHBPeriph_CRC                ((uint32_t)0x00000040)
+
+#ifndef STM32F10X_CL
+ #define RCC_AHBPeriph_FSMC              ((uint32_t)0x00000100)
+ #define RCC_AHBPeriph_SDIO              ((uint32_t)0x00000400)
+ #define IS_RCC_AHB_PERIPH(PERIPH) ((((PERIPH) & 0xFFFFFAA8) == 0x00) && ((PERIPH) != 0x00))
+#else
+ #define RCC_AHBPeriph_OTG_FS            ((uint32_t)0x00001000)
+ #define RCC_AHBPeriph_ETH_MAC           ((uint32_t)0x00004000)
+ #define RCC_AHBPeriph_ETH_MAC_Tx        ((uint32_t)0x00008000)
+ #define RCC_AHBPeriph_ETH_MAC_Rx        ((uint32_t)0x00010000)
+
+ #define IS_RCC_AHB_PERIPH(PERIPH) ((((PERIPH) & 0xFFFE2FA8) == 0x00) && ((PERIPH) != 0x00))
+ #define IS_RCC_AHB_PERIPH_RESET(PERIPH) ((((PERIPH) & 0xFFFFAFFF) == 0x00) && ((PERIPH) != 0x00))
+#endif /* STM32F10X_CL */
+/**
+  * @}
+  */
+
+/** @defgroup APB2_peripheral
+  * @{
+  */
+
+#define RCC_APB2Periph_AFIO              ((uint32_t)0x00000001)
+#define RCC_APB2Periph_GPIOA             ((uint32_t)0x00000004)
+#define RCC_APB2Periph_GPIOB             ((uint32_t)0x00000008)
+#define RCC_APB2Periph_GPIOC             ((uint32_t)0x00000010)
+#define RCC_APB2Periph_GPIOD             ((uint32_t)0x00000020)
+#define RCC_APB2Periph_GPIOE             ((uint32_t)0x00000040)
+#define RCC_APB2Periph_GPIOF             ((uint32_t)0x00000080)
+#define RCC_APB2Periph_GPIOG             ((uint32_t)0x00000100)
+#define RCC_APB2Periph_ADC1              ((uint32_t)0x00000200)
+#define RCC_APB2Periph_ADC2              ((uint32_t)0x00000400)
+#define RCC_APB2Periph_TIM1              ((uint32_t)0x00000800)
+#define RCC_APB2Periph_SPI1              ((uint32_t)0x00001000)
+#define RCC_APB2Periph_TIM8              ((uint32_t)0x00002000)
+#define RCC_APB2Periph_USART1            ((uint32_t)0x00004000)
+#define RCC_APB2Periph_ADC3              ((uint32_t)0x00008000)
+#define RCC_APB2Periph_TIM15             ((uint32_t)0x00010000)
+#define RCC_APB2Periph_TIM16             ((uint32_t)0x00020000)
+#define RCC_APB2Periph_TIM17             ((uint32_t)0x00040000)
+#define RCC_APB2Periph_TIM9              ((uint32_t)0x00080000)
+#define RCC_APB2Periph_TIM10             ((uint32_t)0x00100000)
+#define RCC_APB2Periph_TIM11             ((uint32_t)0x00200000)
+
+#define IS_RCC_APB2_PERIPH(PERIPH) ((((PERIPH) & 0xFFC00002) == 0x00) && ((PERIPH) != 0x00))
+/**
+  * @}
+  */
+
+/** @defgroup APB1_peripheral
+  * @{
+  */
+
+#define RCC_APB1Periph_TIM2              ((uint32_t)0x00000001)
+#define RCC_APB1Periph_TIM3              ((uint32_t)0x00000002)
+#define RCC_APB1Periph_TIM4              ((uint32_t)0x00000004)
+#define RCC_APB1Periph_TIM5              ((uint32_t)0x00000008)
+#define RCC_APB1Periph_TIM6              ((uint32_t)0x00000010)
+#define RCC_APB1Periph_TIM7              ((uint32_t)0x00000020)
+#define RCC_APB1Periph_TIM12             ((uint32_t)0x00000040)
+#define RCC_APB1Periph_TIM13             ((uint32_t)0x00000080)
+#define RCC_APB1Periph_TIM14             ((uint32_t)0x00000100)
+#define RCC_APB1Periph_WWDG              ((uint32_t)0x00000800)
+#define RCC_APB1Periph_SPI2              ((uint32_t)0x00004000)
+#define RCC_APB1Periph_SPI3              ((uint32_t)0x00008000)
+#define RCC_APB1Periph_USART2            ((uint32_t)0x00020000)
+#define RCC_APB1Periph_USART3            ((uint32_t)0x00040000)
+#define RCC_APB1Periph_UART4             ((uint32_t)0x00080000)
+#define RCC_APB1Periph_UART5             ((uint32_t)0x00100000)
+#define RCC_APB1Periph_I2C1              ((uint32_t)0x00200000)
+#define RCC_APB1Periph_I2C2              ((uint32_t)0x00400000)
+#define RCC_APB1Periph_USB               ((uint32_t)0x00800000)
+#define RCC_APB1Periph_CAN1              ((uint32_t)0x02000000)
+#define RCC_APB1Periph_CAN2              ((uint32_t)0x04000000)
+#define RCC_APB1Periph_BKP               ((uint32_t)0x08000000)
+#define RCC_APB1Periph_PWR               ((uint32_t)0x10000000)
+#define RCC_APB1Periph_DAC               ((uint32_t)0x20000000)
+#define RCC_APB1Periph_CEC               ((uint32_t)0x40000000)
+
+#define IS_RCC_APB1_PERIPH(PERIPH) ((((PERIPH) & 0x81013600) == 0x00) && ((PERIPH) != 0x00))
+
+/**
+  * @}
+  */
+
+/** @defgroup Clock_source_to_output_on_MCO_pin
+  * @{
+  */
+
+#define RCC_MCO_NoClock                  ((uint8_t)0x00)
+#define RCC_MCO_SYSCLK                   ((uint8_t)0x04)
+#define RCC_MCO_HSI                      ((uint8_t)0x05)
+#define RCC_MCO_HSE                      ((uint8_t)0x06)
+#define RCC_MCO_PLLCLK_Div2              ((uint8_t)0x07)
+
+#ifndef STM32F10X_CL
+ #define IS_RCC_MCO(MCO) (((MCO) == RCC_MCO_NoClock) || ((MCO) == RCC_MCO_HSI) || \
+                          ((MCO) == RCC_MCO_SYSCLK)  || ((MCO) == RCC_MCO_HSE) || \
+                          ((MCO) == RCC_MCO_PLLCLK_Div2))
+#else
+ #define RCC_MCO_PLL2CLK                 ((uint8_t)0x08)
+ #define RCC_MCO_PLL3CLK_Div2            ((uint8_t)0x09)
+ #define RCC_MCO_XT1                     ((uint8_t)0x0A)
+ #define RCC_MCO_PLL3CLK                 ((uint8_t)0x0B)
+
+ #define IS_RCC_MCO(MCO) (((MCO) == RCC_MCO_NoClock) || ((MCO) == RCC_MCO_HSI) || \
+                          ((MCO) == RCC_MCO_SYSCLK)  || ((MCO) == RCC_MCO_HSE) || \
+                          ((MCO) == RCC_MCO_PLLCLK_Div2) || ((MCO) == RCC_MCO_PLL2CLK) || \
+                          ((MCO) == RCC_MCO_PLL3CLK_Div2) || ((MCO) == RCC_MCO_XT1) || \
+                          ((MCO) == RCC_MCO_PLL3CLK))
+#endif /* STM32F10X_CL */
+
+/**
+  * @}
+  */
+
+/** @defgroup RCC_Flag
+  * @{
+  */
+
+#define RCC_FLAG_HSIRDY                  ((uint8_t)0x21)
+#define RCC_FLAG_HSERDY                  ((uint8_t)0x31)
+#define RCC_FLAG_PLLRDY                  ((uint8_t)0x39)
+#define RCC_FLAG_LSERDY                  ((uint8_t)0x41)
+#define RCC_FLAG_LSIRDY                  ((uint8_t)0x61)
+#define RCC_FLAG_PINRST                  ((uint8_t)0x7A)
+#define RCC_FLAG_PORRST                  ((uint8_t)0x7B)
+#define RCC_FLAG_SFTRST                  ((uint8_t)0x7C)
+#define RCC_FLAG_IWDGRST                 ((uint8_t)0x7D)
+#define RCC_FLAG_WWDGRST                 ((uint8_t)0x7E)
+#define RCC_FLAG_LPWRRST                 ((uint8_t)0x7F)
+
+#ifndef STM32F10X_CL
+ #define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY) || ((FLAG) == RCC_FLAG_HSERDY) || \
+                            ((FLAG) == RCC_FLAG_PLLRDY) || ((FLAG) == RCC_FLAG_LSERDY) || \
+                            ((FLAG) == RCC_FLAG_LSIRDY) || ((FLAG) == RCC_FLAG_PINRST) || \
+                            ((FLAG) == RCC_FLAG_PORRST) || ((FLAG) == RCC_FLAG_SFTRST) || \
+                            ((FLAG) == RCC_FLAG_IWDGRST)|| ((FLAG) == RCC_FLAG_WWDGRST)|| \
+                            ((FLAG) == RCC_FLAG_LPWRRST))
+#else
+ #define RCC_FLAG_PLL2RDY                ((uint8_t)0x3B)
+ #define RCC_FLAG_PLL3RDY                ((uint8_t)0x3D)
+ #define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY) || ((FLAG) == RCC_FLAG_HSERDY) || \
+                            ((FLAG) == RCC_FLAG_PLLRDY) || ((FLAG) == RCC_FLAG_LSERDY) || \
+                            ((FLAG) == RCC_FLAG_PLL2RDY) || ((FLAG) == RCC_FLAG_PLL3RDY) || \
+                            ((FLAG) == RCC_FLAG_LSIRDY) || ((FLAG) == RCC_FLAG_PINRST) || \
+                            ((FLAG) == RCC_FLAG_PORRST) || ((FLAG) == RCC_FLAG_SFTRST) || \
+                            ((FLAG) == RCC_FLAG_IWDGRST)|| ((FLAG) == RCC_FLAG_WWDGRST)|| \
+                            ((FLAG) == RCC_FLAG_LPWRRST))
+#endif /* STM32F10X_CL */
+
+#define IS_RCC_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x1F)
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup RCC_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup RCC_Exported_Functions
+  * @{
+  */
+
+void RCC_DeInit(void);
+void RCC_HSEConfig(uint32_t RCC_HSE);
+ErrorStatus RCC_WaitForHSEStartUp(void);
+void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue);
+void RCC_HSICmd(FunctionalState NewState);
+void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul);
+void RCC_PLLCmd(FunctionalState NewState);
+
+#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL) || defined (STM32F10X_CL)
+ void RCC_PREDIV1Config(uint32_t RCC_PREDIV1_Source, uint32_t RCC_PREDIV1_Div);
+#endif
+
+#ifdef  STM32F10X_CL
+ void RCC_PREDIV2Config(uint32_t RCC_PREDIV2_Div);
+ void RCC_PLL2Config(uint32_t RCC_PLL2Mul);
+ void RCC_PLL2Cmd(FunctionalState NewState);
+ void RCC_PLL3Config(uint32_t RCC_PLL3Mul);
+ void RCC_PLL3Cmd(FunctionalState NewState);
+#endif /* STM32F10X_CL */
+
+void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource);
+uint8_t RCC_GetSYSCLKSource(void);
+void RCC_HCLKConfig(uint32_t RCC_SYSCLK);
+void RCC_PCLK1Config(uint32_t RCC_HCLK);
+void RCC_PCLK2Config(uint32_t RCC_HCLK);
+void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState);
+
+#ifndef STM32F10X_CL
+ void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource);
+#else
+ void RCC_OTGFSCLKConfig(uint32_t RCC_OTGFSCLKSource);
+#endif /* STM32F10X_CL */
+
+void RCC_ADCCLKConfig(uint32_t RCC_PCLK2);
+
+#ifdef STM32F10X_CL
+ void RCC_I2S2CLKConfig(uint32_t RCC_I2S2CLKSource);
+ void RCC_I2S3CLKConfig(uint32_t RCC_I2S3CLKSource);
+#endif /* STM32F10X_CL */
+
+void RCC_LSEConfig(uint8_t RCC_LSE);
+void RCC_LSICmd(FunctionalState NewState);
+void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource);
+void RCC_RTCCLKCmd(FunctionalState NewState);
+void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks);
+void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState);
+void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
+void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);
+
+#ifdef STM32F10X_CL
+void RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState);
+#endif /* STM32F10X_CL */
+
+void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
+void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);
+void RCC_BackupResetCmd(FunctionalState NewState);
+void RCC_ClockSecuritySystemCmd(FunctionalState NewState);
+void RCC_MCOConfig(uint8_t RCC_MCO);
+FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG);
+void RCC_ClearFlag(void);
+ITStatus RCC_GetITStatus(uint8_t RCC_IT);
+void RCC_ClearITPendingBit(uint8_t RCC_IT);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F10x_RCC_H */
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_rtc.h b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_rtc.h
new file mode 100644
index 0000000..214a589
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_rtc.h
@@ -0,0 +1,135 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_rtc.h
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file contains all the functions prototypes for the RTC firmware
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F10x_RTC_H
+#define __STM32F10x_RTC_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup RTC
+  * @{
+  */
+
+/** @defgroup RTC_Exported_Types
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Exported_Constants
+  * @{
+  */
+
+/** @defgroup RTC_interrupts_define
+  * @{
+  */
+
+#define RTC_IT_OW            ((uint16_t)0x0004)  /*!< Overflow interrupt */
+#define RTC_IT_ALR           ((uint16_t)0x0002)  /*!< Alarm interrupt */
+#define RTC_IT_SEC           ((uint16_t)0x0001)  /*!< Second interrupt */
+#define IS_RTC_IT(IT) ((((IT) & (uint16_t)0xFFF8) == 0x00) && ((IT) != 0x00))
+#define IS_RTC_GET_IT(IT) (((IT) == RTC_IT_OW) || ((IT) == RTC_IT_ALR) || \
+                           ((IT) == RTC_IT_SEC))
+/**
+  * @}
+  */
+
+/** @defgroup RTC_interrupts_flags
+  * @{
+  */
+
+#define RTC_FLAG_RTOFF       ((uint16_t)0x0020)  /*!< RTC Operation OFF flag */
+#define RTC_FLAG_RSF         ((uint16_t)0x0008)  /*!< Registers Synchronized flag */
+#define RTC_FLAG_OW          ((uint16_t)0x0004)  /*!< Overflow flag */
+#define RTC_FLAG_ALR         ((uint16_t)0x0002)  /*!< Alarm flag */
+#define RTC_FLAG_SEC         ((uint16_t)0x0001)  /*!< Second flag */
+#define IS_RTC_CLEAR_FLAG(FLAG) ((((FLAG) & (uint16_t)0xFFF0) == 0x00) && ((FLAG) != 0x00))
+#define IS_RTC_GET_FLAG(FLAG) (((FLAG) == RTC_FLAG_RTOFF) || ((FLAG) == RTC_FLAG_RSF) || \
+                               ((FLAG) == RTC_FLAG_OW) || ((FLAG) == RTC_FLAG_ALR) || \
+                               ((FLAG) == RTC_FLAG_SEC))
+#define IS_RTC_PRESCALER(PRESCALER) ((PRESCALER) <= 0xFFFFF)
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Exported_Functions
+  * @{
+  */
+
+void RTC_ITConfig(uint16_t RTC_IT, FunctionalState NewState);
+void RTC_EnterConfigMode(void);
+void RTC_ExitConfigMode(void);
+uint32_t  RTC_GetCounter(void);
+void RTC_SetCounter(uint32_t CounterValue);
+void RTC_SetPrescaler(uint32_t PrescalerValue);
+void RTC_SetAlarm(uint32_t AlarmValue);
+uint32_t  RTC_GetDivider(void);
+void RTC_WaitForLastTask(void);
+void RTC_WaitForSynchro(void);
+FlagStatus RTC_GetFlagStatus(uint16_t RTC_FLAG);
+void RTC_ClearFlag(uint16_t RTC_FLAG);
+ITStatus RTC_GetITStatus(uint16_t RTC_IT);
+void RTC_ClearITPendingBit(uint16_t RTC_IT);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F10x_RTC_H */
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_sdio.h b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_sdio.h
new file mode 100644
index 0000000..40cfded
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_sdio.h
@@ -0,0 +1,531 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_sdio.h
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file contains all the functions prototypes for the SDIO firmware
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F10x_SDIO_H
+#define __STM32F10x_SDIO_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup SDIO
+  * @{
+  */
+
+/** @defgroup SDIO_Exported_Types
+  * @{
+  */
+
+typedef struct
+{
+  uint32_t SDIO_ClockEdge;            /*!< Specifies the clock transition on which the bit capture is made.
+                                           This parameter can be a value of @ref SDIO_Clock_Edge */
+
+  uint32_t SDIO_ClockBypass;          /*!< Specifies whether the SDIO Clock divider bypass is
+                                           enabled or disabled.
+                                           This parameter can be a value of @ref SDIO_Clock_Bypass */
+
+  uint32_t SDIO_ClockPowerSave;       /*!< Specifies whether SDIO Clock output is enabled or
+                                           disabled when the bus is idle.
+                                           This parameter can be a value of @ref SDIO_Clock_Power_Save */
+
+  uint32_t SDIO_BusWide;              /*!< Specifies the SDIO bus width.
+                                           This parameter can be a value of @ref SDIO_Bus_Wide */
+
+  uint32_t SDIO_HardwareFlowControl;  /*!< Specifies whether the SDIO hardware flow control is enabled or disabled.
+                                           This parameter can be a value of @ref SDIO_Hardware_Flow_Control */
+
+  uint8_t SDIO_ClockDiv;              /*!< Specifies the clock frequency of the SDIO controller.
+                                           This parameter can be a value between 0x00 and 0xFF. */
+
+} SDIO_InitTypeDef;
+
+typedef struct
+{
+  uint32_t SDIO_Argument;  /*!< Specifies the SDIO command argument which is sent
+                                to a card as part of a command message. If a command
+                                contains an argument, it must be loaded into this register
+                                before writing the command to the command register */
+
+  uint32_t SDIO_CmdIndex;  /*!< Specifies the SDIO command index. It must be lower than 0x40. */
+
+  uint32_t SDIO_Response;  /*!< Specifies the SDIO response type.
+                                This parameter can be a value of @ref SDIO_Response_Type */
+
+  uint32_t SDIO_Wait;      /*!< Specifies whether SDIO wait-for-interrupt request is enabled or disabled.
+                                This parameter can be a value of @ref SDIO_Wait_Interrupt_State */
+
+  uint32_t SDIO_CPSM;      /*!< Specifies whether SDIO Command path state machine (CPSM)
+                                is enabled or disabled.
+                                This parameter can be a value of @ref SDIO_CPSM_State */
+} SDIO_CmdInitTypeDef;
+
+typedef struct
+{
+  uint32_t SDIO_DataTimeOut;    /*!< Specifies the data timeout period in card bus clock periods. */
+
+  uint32_t SDIO_DataLength;     /*!< Specifies the number of data bytes to be transferred. */
+
+  uint32_t SDIO_DataBlockSize;  /*!< Specifies the data block size for block transfer.
+                                     This parameter can be a value of @ref SDIO_Data_Block_Size */
+
+  uint32_t SDIO_TransferDir;    /*!< Specifies the data transfer direction, whether the transfer
+                                     is a read or write.
+                                     This parameter can be a value of @ref SDIO_Transfer_Direction */
+
+  uint32_t SDIO_TransferMode;   /*!< Specifies whether data transfer is in stream or block mode.
+                                     This parameter can be a value of @ref SDIO_Transfer_Type */
+
+  uint32_t SDIO_DPSM;           /*!< Specifies whether SDIO Data path state machine (DPSM)
+                                     is enabled or disabled.
+                                     This parameter can be a value of @ref SDIO_DPSM_State */
+} SDIO_DataInitTypeDef;
+
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Exported_Constants
+  * @{
+  */
+
+/** @defgroup SDIO_Clock_Edge
+  * @{
+  */
+
+#define SDIO_ClockEdge_Rising               ((uint32_t)0x00000000)
+#define SDIO_ClockEdge_Falling              ((uint32_t)0x00002000)
+#define IS_SDIO_CLOCK_EDGE(EDGE) (((EDGE) == SDIO_ClockEdge_Rising) || \
+                                  ((EDGE) == SDIO_ClockEdge_Falling))
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Clock_Bypass
+  * @{
+  */
+
+#define SDIO_ClockBypass_Disable             ((uint32_t)0x00000000)
+#define SDIO_ClockBypass_Enable              ((uint32_t)0x00000400)
+#define IS_SDIO_CLOCK_BYPASS(BYPASS) (((BYPASS) == SDIO_ClockBypass_Disable) || \
+                                     ((BYPASS) == SDIO_ClockBypass_Enable))
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Clock_Power_Save
+  * @{
+  */
+
+#define SDIO_ClockPowerSave_Disable         ((uint32_t)0x00000000)
+#define SDIO_ClockPowerSave_Enable          ((uint32_t)0x00000200)
+#define IS_SDIO_CLOCK_POWER_SAVE(SAVE) (((SAVE) == SDIO_ClockPowerSave_Disable) || \
+                                        ((SAVE) == SDIO_ClockPowerSave_Enable))
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Bus_Wide
+  * @{
+  */
+
+#define SDIO_BusWide_1b                     ((uint32_t)0x00000000)
+#define SDIO_BusWide_4b                     ((uint32_t)0x00000800)
+#define SDIO_BusWide_8b                     ((uint32_t)0x00001000)
+#define IS_SDIO_BUS_WIDE(WIDE) (((WIDE) == SDIO_BusWide_1b) || ((WIDE) == SDIO_BusWide_4b) || \
+                                ((WIDE) == SDIO_BusWide_8b))
+
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Hardware_Flow_Control
+  * @{
+  */
+
+#define SDIO_HardwareFlowControl_Disable    ((uint32_t)0x00000000)
+#define SDIO_HardwareFlowControl_Enable     ((uint32_t)0x00004000)
+#define IS_SDIO_HARDWARE_FLOW_CONTROL(CONTROL) (((CONTROL) == SDIO_HardwareFlowControl_Disable) || \
+                                                ((CONTROL) == SDIO_HardwareFlowControl_Enable))
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Power_State
+  * @{
+  */
+
+#define SDIO_PowerState_OFF                 ((uint32_t)0x00000000)
+#define SDIO_PowerState_ON                  ((uint32_t)0x00000003)
+#define IS_SDIO_POWER_STATE(STATE) (((STATE) == SDIO_PowerState_OFF) || ((STATE) == SDIO_PowerState_ON))
+/**
+  * @}
+  */
+
+
+/** @defgroup SDIO_Interrupt_sources
+  * @{
+  */
+
+#define SDIO_IT_CCRCFAIL                    ((uint32_t)0x00000001)
+#define SDIO_IT_DCRCFAIL                    ((uint32_t)0x00000002)
+#define SDIO_IT_CTIMEOUT                    ((uint32_t)0x00000004)
+#define SDIO_IT_DTIMEOUT                    ((uint32_t)0x00000008)
+#define SDIO_IT_TXUNDERR                    ((uint32_t)0x00000010)
+#define SDIO_IT_RXOVERR                     ((uint32_t)0x00000020)
+#define SDIO_IT_CMDREND                     ((uint32_t)0x00000040)
+#define SDIO_IT_CMDSENT                     ((uint32_t)0x00000080)
+#define SDIO_IT_DATAEND                     ((uint32_t)0x00000100)
+#define SDIO_IT_STBITERR                    ((uint32_t)0x00000200)
+#define SDIO_IT_DBCKEND                     ((uint32_t)0x00000400)
+#define SDIO_IT_CMDACT                      ((uint32_t)0x00000800)
+#define SDIO_IT_TXACT                       ((uint32_t)0x00001000)
+#define SDIO_IT_RXACT                       ((uint32_t)0x00002000)
+#define SDIO_IT_TXFIFOHE                    ((uint32_t)0x00004000)
+#define SDIO_IT_RXFIFOHF                    ((uint32_t)0x00008000)
+#define SDIO_IT_TXFIFOF                     ((uint32_t)0x00010000)
+#define SDIO_IT_RXFIFOF                     ((uint32_t)0x00020000)
+#define SDIO_IT_TXFIFOE                     ((uint32_t)0x00040000)
+#define SDIO_IT_RXFIFOE                     ((uint32_t)0x00080000)
+#define SDIO_IT_TXDAVL                      ((uint32_t)0x00100000)
+#define SDIO_IT_RXDAVL                      ((uint32_t)0x00200000)
+#define SDIO_IT_SDIOIT                      ((uint32_t)0x00400000)
+#define SDIO_IT_CEATAEND                    ((uint32_t)0x00800000)
+#define IS_SDIO_IT(IT) ((((IT) & (uint32_t)0xFF000000) == 0x00) && ((IT) != (uint32_t)0x00))
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Command_Index
+  * @{
+  */
+
+#define IS_SDIO_CMD_INDEX(INDEX)            ((INDEX) < 0x40)
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Response_Type
+  * @{
+  */
+
+#define SDIO_Response_No                    ((uint32_t)0x00000000)
+#define SDIO_Response_Short                 ((uint32_t)0x00000040)
+#define SDIO_Response_Long                  ((uint32_t)0x000000C0)
+#define IS_SDIO_RESPONSE(RESPONSE) (((RESPONSE) == SDIO_Response_No) || \
+                                    ((RESPONSE) == SDIO_Response_Short) || \
+                                    ((RESPONSE) == SDIO_Response_Long))
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Wait_Interrupt_State
+  * @{
+  */
+
+#define SDIO_Wait_No                        ((uint32_t)0x00000000) /*!< SDIO No Wait, TimeOut is enabled */
+#define SDIO_Wait_IT                        ((uint32_t)0x00000100) /*!< SDIO Wait Interrupt Request */
+#define SDIO_Wait_Pend                      ((uint32_t)0x00000200) /*!< SDIO Wait End of transfer */
+#define IS_SDIO_WAIT(WAIT) (((WAIT) == SDIO_Wait_No) || ((WAIT) == SDIO_Wait_IT) || \
+                            ((WAIT) == SDIO_Wait_Pend))
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_CPSM_State
+  * @{
+  */
+
+#define SDIO_CPSM_Disable                    ((uint32_t)0x00000000)
+#define SDIO_CPSM_Enable                     ((uint32_t)0x00000400)
+#define IS_SDIO_CPSM(CPSM) (((CPSM) == SDIO_CPSM_Enable) || ((CPSM) == SDIO_CPSM_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Response_Registers
+  * @{
+  */
+
+#define SDIO_RESP1                          ((uint32_t)0x00000000)
+#define SDIO_RESP2                          ((uint32_t)0x00000004)
+#define SDIO_RESP3                          ((uint32_t)0x00000008)
+#define SDIO_RESP4                          ((uint32_t)0x0000000C)
+#define IS_SDIO_RESP(RESP) (((RESP) == SDIO_RESP1) || ((RESP) == SDIO_RESP2) || \
+                            ((RESP) == SDIO_RESP3) || ((RESP) == SDIO_RESP4))
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Data_Length
+  * @{
+  */
+
+#define IS_SDIO_DATA_LENGTH(LENGTH) ((LENGTH) <= 0x01FFFFFF)
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Data_Block_Size
+  * @{
+  */
+
+#define SDIO_DataBlockSize_1b               ((uint32_t)0x00000000)
+#define SDIO_DataBlockSize_2b               ((uint32_t)0x00000010)
+#define SDIO_DataBlockSize_4b               ((uint32_t)0x00000020)
+#define SDIO_DataBlockSize_8b               ((uint32_t)0x00000030)
+#define SDIO_DataBlockSize_16b              ((uint32_t)0x00000040)
+#define SDIO_DataBlockSize_32b              ((uint32_t)0x00000050)
+#define SDIO_DataBlockSize_64b              ((uint32_t)0x00000060)
+#define SDIO_DataBlockSize_128b             ((uint32_t)0x00000070)
+#define SDIO_DataBlockSize_256b             ((uint32_t)0x00000080)
+#define SDIO_DataBlockSize_512b             ((uint32_t)0x00000090)
+#define SDIO_DataBlockSize_1024b            ((uint32_t)0x000000A0)
+#define SDIO_DataBlockSize_2048b            ((uint32_t)0x000000B0)
+#define SDIO_DataBlockSize_4096b            ((uint32_t)0x000000C0)
+#define SDIO_DataBlockSize_8192b            ((uint32_t)0x000000D0)
+#define SDIO_DataBlockSize_16384b           ((uint32_t)0x000000E0)
+#define IS_SDIO_BLOCK_SIZE(SIZE) (((SIZE) == SDIO_DataBlockSize_1b) || \
+                                  ((SIZE) == SDIO_DataBlockSize_2b) || \
+                                  ((SIZE) == SDIO_DataBlockSize_4b) || \
+                                  ((SIZE) == SDIO_DataBlockSize_8b) || \
+                                  ((SIZE) == SDIO_DataBlockSize_16b) || \
+                                  ((SIZE) == SDIO_DataBlockSize_32b) || \
+                                  ((SIZE) == SDIO_DataBlockSize_64b) || \
+                                  ((SIZE) == SDIO_DataBlockSize_128b) || \
+                                  ((SIZE) == SDIO_DataBlockSize_256b) || \
+                                  ((SIZE) == SDIO_DataBlockSize_512b) || \
+                                  ((SIZE) == SDIO_DataBlockSize_1024b) || \
+                                  ((SIZE) == SDIO_DataBlockSize_2048b) || \
+                                  ((SIZE) == SDIO_DataBlockSize_4096b) || \
+                                  ((SIZE) == SDIO_DataBlockSize_8192b) || \
+                                  ((SIZE) == SDIO_DataBlockSize_16384b))
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Transfer_Direction
+  * @{
+  */
+
+#define SDIO_TransferDir_ToCard             ((uint32_t)0x00000000)
+#define SDIO_TransferDir_ToSDIO             ((uint32_t)0x00000002)
+#define IS_SDIO_TRANSFER_DIR(DIR) (((DIR) == SDIO_TransferDir_ToCard) || \
+                                   ((DIR) == SDIO_TransferDir_ToSDIO))
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Transfer_Type
+  * @{
+  */
+
+#define SDIO_TransferMode_Block             ((uint32_t)0x00000000)
+#define SDIO_TransferMode_Stream            ((uint32_t)0x00000004)
+#define IS_SDIO_TRANSFER_MODE(MODE) (((MODE) == SDIO_TransferMode_Stream) || \
+                                     ((MODE) == SDIO_TransferMode_Block))
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_DPSM_State
+  * @{
+  */
+
+#define SDIO_DPSM_Disable                    ((uint32_t)0x00000000)
+#define SDIO_DPSM_Enable                     ((uint32_t)0x00000001)
+#define IS_SDIO_DPSM(DPSM) (((DPSM) == SDIO_DPSM_Enable) || ((DPSM) == SDIO_DPSM_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Flags
+  * @{
+  */
+
+#define SDIO_FLAG_CCRCFAIL                  ((uint32_t)0x00000001)
+#define SDIO_FLAG_DCRCFAIL                  ((uint32_t)0x00000002)
+#define SDIO_FLAG_CTIMEOUT                  ((uint32_t)0x00000004)
+#define SDIO_FLAG_DTIMEOUT                  ((uint32_t)0x00000008)
+#define SDIO_FLAG_TXUNDERR                  ((uint32_t)0x00000010)
+#define SDIO_FLAG_RXOVERR                   ((uint32_t)0x00000020)
+#define SDIO_FLAG_CMDREND                   ((uint32_t)0x00000040)
+#define SDIO_FLAG_CMDSENT                   ((uint32_t)0x00000080)
+#define SDIO_FLAG_DATAEND                   ((uint32_t)0x00000100)
+#define SDIO_FLAG_STBITERR                  ((uint32_t)0x00000200)
+#define SDIO_FLAG_DBCKEND                   ((uint32_t)0x00000400)
+#define SDIO_FLAG_CMDACT                    ((uint32_t)0x00000800)
+#define SDIO_FLAG_TXACT                     ((uint32_t)0x00001000)
+#define SDIO_FLAG_RXACT                     ((uint32_t)0x00002000)
+#define SDIO_FLAG_TXFIFOHE                  ((uint32_t)0x00004000)
+#define SDIO_FLAG_RXFIFOHF                  ((uint32_t)0x00008000)
+#define SDIO_FLAG_TXFIFOF                   ((uint32_t)0x00010000)
+#define SDIO_FLAG_RXFIFOF                   ((uint32_t)0x00020000)
+#define SDIO_FLAG_TXFIFOE                   ((uint32_t)0x00040000)
+#define SDIO_FLAG_RXFIFOE                   ((uint32_t)0x00080000)
+#define SDIO_FLAG_TXDAVL                    ((uint32_t)0x00100000)
+#define SDIO_FLAG_RXDAVL                    ((uint32_t)0x00200000)
+#define SDIO_FLAG_SDIOIT                    ((uint32_t)0x00400000)
+#define SDIO_FLAG_CEATAEND                  ((uint32_t)0x00800000)
+#define IS_SDIO_FLAG(FLAG) (((FLAG)  == SDIO_FLAG_CCRCFAIL) || \
+                            ((FLAG)  == SDIO_FLAG_DCRCFAIL) || \
+                            ((FLAG)  == SDIO_FLAG_CTIMEOUT) || \
+                            ((FLAG)  == SDIO_FLAG_DTIMEOUT) || \
+                            ((FLAG)  == SDIO_FLAG_TXUNDERR) || \
+                            ((FLAG)  == SDIO_FLAG_RXOVERR) || \
+                            ((FLAG)  == SDIO_FLAG_CMDREND) || \
+                            ((FLAG)  == SDIO_FLAG_CMDSENT) || \
+                            ((FLAG)  == SDIO_FLAG_DATAEND) || \
+                            ((FLAG)  == SDIO_FLAG_STBITERR) || \
+                            ((FLAG)  == SDIO_FLAG_DBCKEND) || \
+                            ((FLAG)  == SDIO_FLAG_CMDACT) || \
+                            ((FLAG)  == SDIO_FLAG_TXACT) || \
+                            ((FLAG)  == SDIO_FLAG_RXACT) || \
+                            ((FLAG)  == SDIO_FLAG_TXFIFOHE) || \
+                            ((FLAG)  == SDIO_FLAG_RXFIFOHF) || \
+                            ((FLAG)  == SDIO_FLAG_TXFIFOF) || \
+                            ((FLAG)  == SDIO_FLAG_RXFIFOF) || \
+                            ((FLAG)  == SDIO_FLAG_TXFIFOE) || \
+                            ((FLAG)  == SDIO_FLAG_RXFIFOE) || \
+                            ((FLAG)  == SDIO_FLAG_TXDAVL) || \
+                            ((FLAG)  == SDIO_FLAG_RXDAVL) || \
+                            ((FLAG)  == SDIO_FLAG_SDIOIT) || \
+                            ((FLAG)  == SDIO_FLAG_CEATAEND))
+
+#define IS_SDIO_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFF3FF800) == 0x00) && ((FLAG) != (uint32_t)0x00))
+
+#define IS_SDIO_GET_IT(IT) (((IT)  == SDIO_IT_CCRCFAIL) || \
+                            ((IT)  == SDIO_IT_DCRCFAIL) || \
+                            ((IT)  == SDIO_IT_CTIMEOUT) || \
+                            ((IT)  == SDIO_IT_DTIMEOUT) || \
+                            ((IT)  == SDIO_IT_TXUNDERR) || \
+                            ((IT)  == SDIO_IT_RXOVERR) || \
+                            ((IT)  == SDIO_IT_CMDREND) || \
+                            ((IT)  == SDIO_IT_CMDSENT) || \
+                            ((IT)  == SDIO_IT_DATAEND) || \
+                            ((IT)  == SDIO_IT_STBITERR) || \
+                            ((IT)  == SDIO_IT_DBCKEND) || \
+                            ((IT)  == SDIO_IT_CMDACT) || \
+                            ((IT)  == SDIO_IT_TXACT) || \
+                            ((IT)  == SDIO_IT_RXACT) || \
+                            ((IT)  == SDIO_IT_TXFIFOHE) || \
+                            ((IT)  == SDIO_IT_RXFIFOHF) || \
+                            ((IT)  == SDIO_IT_TXFIFOF) || \
+                            ((IT)  == SDIO_IT_RXFIFOF) || \
+                            ((IT)  == SDIO_IT_TXFIFOE) || \
+                            ((IT)  == SDIO_IT_RXFIFOE) || \
+                            ((IT)  == SDIO_IT_TXDAVL) || \
+                            ((IT)  == SDIO_IT_RXDAVL) || \
+                            ((IT)  == SDIO_IT_SDIOIT) || \
+                            ((IT)  == SDIO_IT_CEATAEND))
+
+#define IS_SDIO_CLEAR_IT(IT) ((((IT) & (uint32_t)0xFF3FF800) == 0x00) && ((IT) != (uint32_t)0x00))
+
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Read_Wait_Mode
+  * @{
+  */
+
+#define SDIO_ReadWaitMode_CLK               ((uint32_t)0x00000001)
+#define SDIO_ReadWaitMode_DATA2             ((uint32_t)0x00000000)
+#define IS_SDIO_READWAIT_MODE(MODE) (((MODE) == SDIO_ReadWaitMode_CLK) || \
+                                     ((MODE) == SDIO_ReadWaitMode_DATA2))
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Exported_Functions
+  * @{
+  */
+
+void SDIO_DeInit(void);
+void SDIO_Init(SDIO_InitTypeDef* SDIO_InitStruct);
+void SDIO_StructInit(SDIO_InitTypeDef* SDIO_InitStruct);
+void SDIO_ClockCmd(FunctionalState NewState);
+void SDIO_SetPowerState(uint32_t SDIO_PowerState);
+uint32_t SDIO_GetPowerState(void);
+void SDIO_ITConfig(uint32_t SDIO_IT, FunctionalState NewState);
+void SDIO_DMACmd(FunctionalState NewState);
+void SDIO_SendCommand(SDIO_CmdInitTypeDef *SDIO_CmdInitStruct);
+void SDIO_CmdStructInit(SDIO_CmdInitTypeDef* SDIO_CmdInitStruct);
+uint8_t SDIO_GetCommandResponse(void);
+uint32_t SDIO_GetResponse(uint32_t SDIO_RESP);
+void SDIO_DataConfig(SDIO_DataInitTypeDef* SDIO_DataInitStruct);
+void SDIO_DataStructInit(SDIO_DataInitTypeDef* SDIO_DataInitStruct);
+uint32_t SDIO_GetDataCounter(void);
+uint32_t SDIO_ReadData(void);
+void SDIO_WriteData(uint32_t Data);
+uint32_t SDIO_GetFIFOCount(void);
+void SDIO_StartSDIOReadWait(FunctionalState NewState);
+void SDIO_StopSDIOReadWait(FunctionalState NewState);
+void SDIO_SetSDIOReadWaitMode(uint32_t SDIO_ReadWaitMode);
+void SDIO_SetSDIOOperation(FunctionalState NewState);
+void SDIO_SendSDIOSuspendCmd(FunctionalState NewState);
+void SDIO_CommandCompletionCmd(FunctionalState NewState);
+void SDIO_CEATAITCmd(FunctionalState NewState);
+void SDIO_SendCEATACmd(FunctionalState NewState);
+FlagStatus SDIO_GetFlagStatus(uint32_t SDIO_FLAG);
+void SDIO_ClearFlag(uint32_t SDIO_FLAG);
+ITStatus SDIO_GetITStatus(uint32_t SDIO_IT);
+void SDIO_ClearITPendingBit(uint32_t SDIO_IT);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F10x_SDIO_H */
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_spi.h b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_spi.h
new file mode 100644
index 0000000..6056c4c
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_spi.h
@@ -0,0 +1,487 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_spi.h
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file contains all the functions prototypes for the SPI firmware
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F10x_SPI_H
+#define __STM32F10x_SPI_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup SPI
+  * @{
+  */
+
+/** @defgroup SPI_Exported_Types
+  * @{
+  */
+
+/**
+  * @brief  SPI Init structure definition
+  */
+
+typedef struct
+{
+  uint16_t SPI_Direction;           /*!< Specifies the SPI unidirectional or bidirectional data mode.
+                                         This parameter can be a value of @ref SPI_data_direction */
+
+  uint16_t SPI_Mode;                /*!< Specifies the SPI operating mode.
+                                         This parameter can be a value of @ref SPI_mode */
+
+  uint16_t SPI_DataSize;            /*!< Specifies the SPI data size.
+                                         This parameter can be a value of @ref SPI_data_size */
+
+  uint16_t SPI_CPOL;                /*!< Specifies the serial clock steady state.
+                                         This parameter can be a value of @ref SPI_Clock_Polarity */
+
+  uint16_t SPI_CPHA;                /*!< Specifies the clock active edge for the bit capture.
+                                         This parameter can be a value of @ref SPI_Clock_Phase */
+
+  uint16_t SPI_NSS;                 /*!< Specifies whether the NSS signal is managed by
+                                         hardware (NSS pin) or by software using the SSI bit.
+                                         This parameter can be a value of @ref SPI_Slave_Select_management */
+
+  uint16_t SPI_BaudRatePrescaler;   /*!< Specifies the Baud Rate prescaler value which will be
+                                         used to configure the transmit and receive SCK clock.
+                                         This parameter can be a value of @ref SPI_BaudRate_Prescaler.
+                                         @note The communication clock is derived from the master
+                                               clock. The slave clock does not need to be set. */
+
+  uint16_t SPI_FirstBit;            /*!< Specifies whether data transfers start from MSB or LSB bit.
+                                         This parameter can be a value of @ref SPI_MSB_LSB_transmission */
+
+  uint16_t SPI_CRCPolynomial;       /*!< Specifies the polynomial used for the CRC calculation. */
+}SPI_InitTypeDef;
+
+/**
+  * @brief  I2S Init structure definition
+  */
+
+typedef struct
+{
+
+  uint16_t I2S_Mode;         /*!< Specifies the I2S operating mode.
+                                  This parameter can be a value of @ref I2S_Mode */
+
+  uint16_t I2S_Standard;     /*!< Specifies the standard used for the I2S communication.
+                                  This parameter can be a value of @ref I2S_Standard */
+
+  uint16_t I2S_DataFormat;   /*!< Specifies the data format for the I2S communication.
+                                  This parameter can be a value of @ref I2S_Data_Format */
+
+  uint16_t I2S_MCLKOutput;   /*!< Specifies whether the I2S MCLK output is enabled or not.
+                                  This parameter can be a value of @ref I2S_MCLK_Output */
+
+  uint32_t I2S_AudioFreq;    /*!< Specifies the frequency selected for the I2S communication.
+                                  This parameter can be a value of @ref I2S_Audio_Frequency */
+
+  uint16_t I2S_CPOL;         /*!< Specifies the idle state of the I2S clock.
+                                  This parameter can be a value of @ref I2S_Clock_Polarity */
+}I2S_InitTypeDef;
+
+/**
+  * @}
+  */
+
+/** @defgroup SPI_Exported_Constants
+  * @{
+  */
+
+#define IS_SPI_ALL_PERIPH(PERIPH) (((PERIPH) == SPI1) || \
+                                   ((PERIPH) == SPI2) || \
+                                   ((PERIPH) == SPI3))
+
+#define IS_SPI_23_PERIPH(PERIPH) (((PERIPH) == SPI2) || \
+                                  ((PERIPH) == SPI3))
+
+/** @defgroup SPI_data_direction
+  * @{
+  */
+
+#define SPI_Direction_2Lines_FullDuplex ((uint16_t)0x0000)
+#define SPI_Direction_2Lines_RxOnly     ((uint16_t)0x0400)
+#define SPI_Direction_1Line_Rx          ((uint16_t)0x8000)
+#define SPI_Direction_1Line_Tx          ((uint16_t)0xC000)
+#define IS_SPI_DIRECTION_MODE(MODE) (((MODE) == SPI_Direction_2Lines_FullDuplex) || \
+                                     ((MODE) == SPI_Direction_2Lines_RxOnly) || \
+                                     ((MODE) == SPI_Direction_1Line_Rx) || \
+                                     ((MODE) == SPI_Direction_1Line_Tx))
+/**
+  * @}
+  */
+
+/** @defgroup SPI_mode
+  * @{
+  */
+
+#define SPI_Mode_Master                 ((uint16_t)0x0104)
+#define SPI_Mode_Slave                  ((uint16_t)0x0000)
+#define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) || \
+                           ((MODE) == SPI_Mode_Slave))
+/**
+  * @}
+  */
+
+/** @defgroup SPI_data_size
+  * @{
+  */
+
+#define SPI_DataSize_16b                ((uint16_t)0x0800)
+#define SPI_DataSize_8b                 ((uint16_t)0x0000)
+#define IS_SPI_DATASIZE(DATASIZE) (((DATASIZE) == SPI_DataSize_16b) || \
+                                   ((DATASIZE) == SPI_DataSize_8b))
+/**
+  * @}
+  */
+
+/** @defgroup SPI_Clock_Polarity
+  * @{
+  */
+
+#define SPI_CPOL_Low                    ((uint16_t)0x0000)
+#define SPI_CPOL_High                   ((uint16_t)0x0002)
+#define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) || \
+                           ((CPOL) == SPI_CPOL_High))
+/**
+  * @}
+  */
+
+/** @defgroup SPI_Clock_Phase
+  * @{
+  */
+
+#define SPI_CPHA_1Edge                  ((uint16_t)0x0000)
+#define SPI_CPHA_2Edge                  ((uint16_t)0x0001)
+#define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) || \
+                           ((CPHA) == SPI_CPHA_2Edge))
+/**
+  * @}
+  */
+
+/** @defgroup SPI_Slave_Select_management
+  * @{
+  */
+
+#define SPI_NSS_Soft                    ((uint16_t)0x0200)
+#define SPI_NSS_Hard                    ((uint16_t)0x0000)
+#define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) || \
+                         ((NSS) == SPI_NSS_Hard))
+/**
+  * @}
+  */
+
+/** @defgroup SPI_BaudRate_Prescaler
+  * @{
+  */
+
+#define SPI_BaudRatePrescaler_2         ((uint16_t)0x0000)
+#define SPI_BaudRatePrescaler_4         ((uint16_t)0x0008)
+#define SPI_BaudRatePrescaler_8         ((uint16_t)0x0010)
+#define SPI_BaudRatePrescaler_16        ((uint16_t)0x0018)
+#define SPI_BaudRatePrescaler_32        ((uint16_t)0x0020)
+#define SPI_BaudRatePrescaler_64        ((uint16_t)0x0028)
+#define SPI_BaudRatePrescaler_128       ((uint16_t)0x0030)
+#define SPI_BaudRatePrescaler_256       ((uint16_t)0x0038)
+#define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) || \
+                                              ((PRESCALER) == SPI_BaudRatePrescaler_4) || \
+                                              ((PRESCALER) == SPI_BaudRatePrescaler_8) || \
+                                              ((PRESCALER) == SPI_BaudRatePrescaler_16) || \
+                                              ((PRESCALER) == SPI_BaudRatePrescaler_32) || \
+                                              ((PRESCALER) == SPI_BaudRatePrescaler_64) || \
+                                              ((PRESCALER) == SPI_BaudRatePrescaler_128) || \
+                                              ((PRESCALER) == SPI_BaudRatePrescaler_256))
+/**
+  * @}
+  */
+
+/** @defgroup SPI_MSB_LSB_transmission
+  * @{
+  */
+
+#define SPI_FirstBit_MSB                ((uint16_t)0x0000)
+#define SPI_FirstBit_LSB                ((uint16_t)0x0080)
+#define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) || \
+                               ((BIT) == SPI_FirstBit_LSB))
+/**
+  * @}
+  */
+
+/** @defgroup I2S_Mode
+  * @{
+  */
+
+#define I2S_Mode_SlaveTx                ((uint16_t)0x0000)
+#define I2S_Mode_SlaveRx                ((uint16_t)0x0100)
+#define I2S_Mode_MasterTx               ((uint16_t)0x0200)
+#define I2S_Mode_MasterRx               ((uint16_t)0x0300)
+#define IS_I2S_MODE(MODE) (((MODE) == I2S_Mode_SlaveTx) || \
+                           ((MODE) == I2S_Mode_SlaveRx) || \
+                           ((MODE) == I2S_Mode_MasterTx) || \
+                           ((MODE) == I2S_Mode_MasterRx) )
+/**
+  * @}
+  */
+
+/** @defgroup I2S_Standard
+  * @{
+  */
+
+#define I2S_Standard_Phillips           ((uint16_t)0x0000)
+#define I2S_Standard_MSB                ((uint16_t)0x0010)
+#define I2S_Standard_LSB                ((uint16_t)0x0020)
+#define I2S_Standard_PCMShort           ((uint16_t)0x0030)
+#define I2S_Standard_PCMLong            ((uint16_t)0x00B0)
+#define IS_I2S_STANDARD(STANDARD) (((STANDARD) == I2S_Standard_Phillips) || \
+                                   ((STANDARD) == I2S_Standard_MSB) || \
+                                   ((STANDARD) == I2S_Standard_LSB) || \
+                                   ((STANDARD) == I2S_Standard_PCMShort) || \
+                                   ((STANDARD) == I2S_Standard_PCMLong))
+/**
+  * @}
+  */
+
+/** @defgroup I2S_Data_Format
+  * @{
+  */
+
+#define I2S_DataFormat_16b              ((uint16_t)0x0000)
+#define I2S_DataFormat_16bextended      ((uint16_t)0x0001)
+#define I2S_DataFormat_24b              ((uint16_t)0x0003)
+#define I2S_DataFormat_32b              ((uint16_t)0x0005)
+#define IS_I2S_DATA_FORMAT(FORMAT) (((FORMAT) == I2S_DataFormat_16b) || \
+                                    ((FORMAT) == I2S_DataFormat_16bextended) || \
+                                    ((FORMAT) == I2S_DataFormat_24b) || \
+                                    ((FORMAT) == I2S_DataFormat_32b))
+/**
+  * @}
+  */
+
+/** @defgroup I2S_MCLK_Output
+  * @{
+  */
+
+#define I2S_MCLKOutput_Enable           ((uint16_t)0x0200)
+#define I2S_MCLKOutput_Disable          ((uint16_t)0x0000)
+#define IS_I2S_MCLK_OUTPUT(OUTPUT) (((OUTPUT) == I2S_MCLKOutput_Enable) || \
+                                    ((OUTPUT) == I2S_MCLKOutput_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup I2S_Audio_Frequency
+  * @{
+  */
+
+#define I2S_AudioFreq_192k               ((uint32_t)192000)
+#define I2S_AudioFreq_96k                ((uint32_t)96000)
+#define I2S_AudioFreq_48k                ((uint32_t)48000)
+#define I2S_AudioFreq_44k                ((uint32_t)44100)
+#define I2S_AudioFreq_32k                ((uint32_t)32000)
+#define I2S_AudioFreq_22k                ((uint32_t)22050)
+#define I2S_AudioFreq_16k                ((uint32_t)16000)
+#define I2S_AudioFreq_11k                ((uint32_t)11025)
+#define I2S_AudioFreq_8k                 ((uint32_t)8000)
+#define I2S_AudioFreq_Default            ((uint32_t)2)
+
+#define IS_I2S_AUDIO_FREQ(FREQ) ((((FREQ) >= I2S_AudioFreq_8k) && \
+                                  ((FREQ) <= I2S_AudioFreq_192k)) || \
+                                 ((FREQ) == I2S_AudioFreq_Default))
+/**
+  * @}
+  */
+
+/** @defgroup I2S_Clock_Polarity
+  * @{
+  */
+
+#define I2S_CPOL_Low                    ((uint16_t)0x0000)
+#define I2S_CPOL_High                   ((uint16_t)0x0008)
+#define IS_I2S_CPOL(CPOL) (((CPOL) == I2S_CPOL_Low) || \
+                           ((CPOL) == I2S_CPOL_High))
+/**
+  * @}
+  */
+
+/** @defgroup SPI_I2S_DMA_transfer_requests
+  * @{
+  */
+
+#define SPI_I2S_DMAReq_Tx               ((uint16_t)0x0002)
+#define SPI_I2S_DMAReq_Rx               ((uint16_t)0x0001)
+#define IS_SPI_I2S_DMAREQ(DMAREQ) ((((DMAREQ) & (uint16_t)0xFFFC) == 0x00) && ((DMAREQ) != 0x00))
+/**
+  * @}
+  */
+
+/** @defgroup SPI_NSS_internal_software_management
+  * @{
+  */
+
+#define SPI_NSSInternalSoft_Set         ((uint16_t)0x0100)
+#define SPI_NSSInternalSoft_Reset       ((uint16_t)0xFEFF)
+#define IS_SPI_NSS_INTERNAL(INTERNAL) (((INTERNAL) == SPI_NSSInternalSoft_Set) || \
+                                       ((INTERNAL) == SPI_NSSInternalSoft_Reset))
+/**
+  * @}
+  */
+
+/** @defgroup SPI_CRC_Transmit_Receive
+  * @{
+  */
+
+#define SPI_CRC_Tx                      ((uint8_t)0x00)
+#define SPI_CRC_Rx                      ((uint8_t)0x01)
+#define IS_SPI_CRC(CRC) (((CRC) == SPI_CRC_Tx) || ((CRC) == SPI_CRC_Rx))
+/**
+  * @}
+  */
+
+/** @defgroup SPI_direction_transmit_receive
+  * @{
+  */
+
+#define SPI_Direction_Rx                ((uint16_t)0xBFFF)
+#define SPI_Direction_Tx                ((uint16_t)0x4000)
+#define IS_SPI_DIRECTION(DIRECTION) (((DIRECTION) == SPI_Direction_Rx) || \
+                                     ((DIRECTION) == SPI_Direction_Tx))
+/**
+  * @}
+  */
+
+/** @defgroup SPI_I2S_interrupts_definition
+  * @{
+  */
+
+#define SPI_I2S_IT_TXE                  ((uint8_t)0x71)
+#define SPI_I2S_IT_RXNE                 ((uint8_t)0x60)
+#define SPI_I2S_IT_ERR                  ((uint8_t)0x50)
+#define IS_SPI_I2S_CONFIG_IT(IT) (((IT) == SPI_I2S_IT_TXE) || \
+                                 ((IT) == SPI_I2S_IT_RXNE) || \
+                                 ((IT) == SPI_I2S_IT_ERR))
+#define SPI_I2S_IT_OVR                  ((uint8_t)0x56)
+#define SPI_IT_MODF                     ((uint8_t)0x55)
+#define SPI_IT_CRCERR                   ((uint8_t)0x54)
+#define I2S_IT_UDR                      ((uint8_t)0x53)
+#define IS_SPI_I2S_CLEAR_IT(IT) (((IT) == SPI_IT_CRCERR))
+#define IS_SPI_I2S_GET_IT(IT) (((IT) == SPI_I2S_IT_RXNE) || ((IT) == SPI_I2S_IT_TXE) || \
+                               ((IT) == I2S_IT_UDR) || ((IT) == SPI_IT_CRCERR) || \
+                               ((IT) == SPI_IT_MODF) || ((IT) == SPI_I2S_IT_OVR))
+/**
+  * @}
+  */
+
+/** @defgroup SPI_I2S_flags_definition
+  * @{
+  */
+
+#define SPI_I2S_FLAG_RXNE               ((uint16_t)0x0001)
+#define SPI_I2S_FLAG_TXE                ((uint16_t)0x0002)
+#define I2S_FLAG_CHSIDE                 ((uint16_t)0x0004)
+#define I2S_FLAG_UDR                    ((uint16_t)0x0008)
+#define SPI_FLAG_CRCERR                 ((uint16_t)0x0010)
+#define SPI_FLAG_MODF                   ((uint16_t)0x0020)
+#define SPI_I2S_FLAG_OVR                ((uint16_t)0x0040)
+#define SPI_I2S_FLAG_BSY                ((uint16_t)0x0080)
+#define IS_SPI_I2S_CLEAR_FLAG(FLAG) (((FLAG) == SPI_FLAG_CRCERR))
+#define IS_SPI_I2S_GET_FLAG(FLAG) (((FLAG) == SPI_I2S_FLAG_BSY) || ((FLAG) == SPI_I2S_FLAG_OVR) || \
+                                   ((FLAG) == SPI_FLAG_MODF) || ((FLAG) == SPI_FLAG_CRCERR) || \
+                                   ((FLAG) == I2S_FLAG_UDR) || ((FLAG) == I2S_FLAG_CHSIDE) || \
+                                   ((FLAG) == SPI_I2S_FLAG_TXE) || ((FLAG) == SPI_I2S_FLAG_RXNE))
+/**
+  * @}
+  */
+
+/** @defgroup SPI_CRC_polynomial
+  * @{
+  */
+
+#define IS_SPI_CRC_POLYNOMIAL(POLYNOMIAL) ((POLYNOMIAL) >= 0x1)
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup SPI_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup SPI_Exported_Functions
+  * @{
+  */
+
+void SPI_I2S_DeInit(SPI_TypeDef* SPIx);
+void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct);
+void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct);
+void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct);
+void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct);
+void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState);
+void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState);
+void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState);
+void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState);
+void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data);
+uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx);
+void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft);
+void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState);
+void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize);
+void SPI_TransmitCRC(SPI_TypeDef* SPIx);
+void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState);
+uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC);
+uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx);
+void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction);
+FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
+void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
+ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
+void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__STM32F10x_SPI_H */
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_tim.h b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_tim.h
new file mode 100644
index 0000000..cd7ac3e
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_tim.h
@@ -0,0 +1,1164 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_tim.h
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file contains all the functions prototypes for the TIM firmware
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F10x_TIM_H
+#define __STM32F10x_TIM_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup TIM
+  * @{
+  */
+
+/** @defgroup TIM_Exported_Types
+  * @{
+  */
+
+/**
+  * @brief  TIM Time Base Init structure definition
+  * @note   This structure is used with all TIMx except for TIM6 and TIM7.
+  */
+
+typedef struct
+{
+  uint16_t TIM_Prescaler;         /*!< Specifies the prescaler value used to divide the TIM clock.
+                                       This parameter can be a number between 0x0000 and 0xFFFF */
+
+  uint16_t TIM_CounterMode;       /*!< Specifies the counter mode.
+                                       This parameter can be a value of @ref TIM_Counter_Mode */
+
+  uint16_t TIM_Period;            /*!< Specifies the period value to be loaded into the active
+                                       Auto-Reload Register at the next update event.
+                                       This parameter must be a number between 0x0000 and 0xFFFF.  */
+
+  uint16_t TIM_ClockDivision;     /*!< Specifies the clock division.
+                                      This parameter can be a value of @ref TIM_Clock_Division_CKD */
+
+  uint8_t TIM_RepetitionCounter;  /*!< Specifies the repetition counter value. Each time the RCR downcounter
+                                       reaches zero, an update event is generated and counting restarts
+                                       from the RCR value (N).
+                                       This means in PWM mode that (N+1) corresponds to:
+                                          - the number of PWM periods in edge-aligned mode
+                                          - the number of half PWM period in center-aligned mode
+                                       This parameter must be a number between 0x00 and 0xFF.
+                                       @note This parameter is valid only for TIM1 and TIM8. */
+} TIM_TimeBaseInitTypeDef;
+
+/**
+  * @brief  TIM Output Compare Init structure definition
+  */
+
+typedef struct
+{
+  uint16_t TIM_OCMode;        /*!< Specifies the TIM mode.
+                                   This parameter can be a value of @ref TIM_Output_Compare_and_PWM_modes */
+
+  uint16_t TIM_OutputState;   /*!< Specifies the TIM Output Compare state.
+                                   This parameter can be a value of @ref TIM_Output_Compare_state */
+
+  uint16_t TIM_OutputNState;  /*!< Specifies the TIM complementary Output Compare state.
+                                   This parameter can be a value of @ref TIM_Output_Compare_N_state
+                                   @note This parameter is valid only for TIM1 and TIM8. */
+
+  uint16_t TIM_Pulse;         /*!< Specifies the pulse value to be loaded into the Capture Compare Register.
+                                   This parameter can be a number between 0x0000 and 0xFFFF */
+
+  uint16_t TIM_OCPolarity;    /*!< Specifies the output polarity.
+                                   This parameter can be a value of @ref TIM_Output_Compare_Polarity */
+
+  uint16_t TIM_OCNPolarity;   /*!< Specifies the complementary output polarity.
+                                   This parameter can be a value of @ref TIM_Output_Compare_N_Polarity
+                                   @note This parameter is valid only for TIM1 and TIM8. */
+
+  uint16_t TIM_OCIdleState;   /*!< Specifies the TIM Output Compare pin state during Idle state.
+                                   This parameter can be a value of @ref TIM_Output_Compare_Idle_State
+                                   @note This parameter is valid only for TIM1 and TIM8. */
+
+  uint16_t TIM_OCNIdleState;  /*!< Specifies the TIM Output Compare pin state during Idle state.
+                                   This parameter can be a value of @ref TIM_Output_Compare_N_Idle_State
+                                   @note This parameter is valid only for TIM1 and TIM8. */
+} TIM_OCInitTypeDef;
+
+/**
+  * @brief  TIM Input Capture Init structure definition
+  */
+
+typedef struct
+{
+
+  uint16_t TIM_Channel;      /*!< Specifies the TIM channel.
+                                  This parameter can be a value of @ref TIM_Channel */
+
+  uint16_t TIM_ICPolarity;   /*!< Specifies the active edge of the input signal.
+                                  This parameter can be a value of @ref TIM_Input_Capture_Polarity */
+
+  uint16_t TIM_ICSelection;  /*!< Specifies the input.
+                                  This parameter can be a value of @ref TIM_Input_Capture_Selection */
+
+  uint16_t TIM_ICPrescaler;  /*!< Specifies the Input Capture Prescaler.
+                                  This parameter can be a value of @ref TIM_Input_Capture_Prescaler */
+
+  uint16_t TIM_ICFilter;     /*!< Specifies the input capture filter.
+                                  This parameter can be a number between 0x0 and 0xF */
+} TIM_ICInitTypeDef;
+
+/**
+  * @brief  BDTR structure definition
+  * @note   This structure is used only with TIM1 and TIM8.
+  */
+
+typedef struct
+{
+
+  uint16_t TIM_OSSRState;        /*!< Specifies the Off-State selection used in Run mode.
+                                      This parameter can be a value of @ref OSSR_Off_State_Selection_for_Run_mode_state */
+
+  uint16_t TIM_OSSIState;        /*!< Specifies the Off-State used in Idle state.
+                                      This parameter can be a value of @ref OSSI_Off_State_Selection_for_Idle_mode_state */
+
+  uint16_t TIM_LOCKLevel;        /*!< Specifies the LOCK level parameters.
+                                      This parameter can be a value of @ref Lock_level */
+
+  uint16_t TIM_DeadTime;         /*!< Specifies the delay time between the switching-off and the
+                                      switching-on of the outputs.
+                                      This parameter can be a number between 0x00 and 0xFF  */
+
+  uint16_t TIM_Break;            /*!< Specifies whether the TIM Break input is enabled or not.
+                                      This parameter can be a value of @ref Break_Input_enable_disable */
+
+  uint16_t TIM_BreakPolarity;    /*!< Specifies the TIM Break Input pin polarity.
+                                      This parameter can be a value of @ref Break_Polarity */
+
+  uint16_t TIM_AutomaticOutput;  /*!< Specifies whether the TIM Automatic Output feature is enabled or not.
+                                      This parameter can be a value of @ref TIM_AOE_Bit_Set_Reset */
+} TIM_BDTRInitTypeDef;
+
+/** @defgroup TIM_Exported_constants
+  * @{
+  */
+
+#define IS_TIM_ALL_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
+                                   ((PERIPH) == TIM2) || \
+                                   ((PERIPH) == TIM3) || \
+                                   ((PERIPH) == TIM4) || \
+                                   ((PERIPH) == TIM5) || \
+                                   ((PERIPH) == TIM6) || \
+                                   ((PERIPH) == TIM7) || \
+                                   ((PERIPH) == TIM8) || \
+                                   ((PERIPH) == TIM9) || \
+                                   ((PERIPH) == TIM10)|| \
+                                   ((PERIPH) == TIM11)|| \
+                                   ((PERIPH) == TIM12)|| \
+                                   ((PERIPH) == TIM13)|| \
+                                   ((PERIPH) == TIM14)|| \
+                                   ((PERIPH) == TIM15)|| \
+                                   ((PERIPH) == TIM16)|| \
+                                   ((PERIPH) == TIM17))
+
+/* LIST1: TIM 1 and 8 */
+#define IS_TIM_LIST1_PERIPH(PERIPH)  (((PERIPH) == TIM1) || \
+                                      ((PERIPH) == TIM8))
+
+/* LIST2: TIM 1, 8, 15 16 and 17 */
+#define IS_TIM_LIST2_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
+                                     ((PERIPH) == TIM8) || \
+                                     ((PERIPH) == TIM15)|| \
+                                     ((PERIPH) == TIM16)|| \
+                                     ((PERIPH) == TIM17))
+
+/* LIST3: TIM 1, 2, 3, 4, 5 and 8 */
+#define IS_TIM_LIST3_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
+                                     ((PERIPH) == TIM2) || \
+                                     ((PERIPH) == TIM3) || \
+                                     ((PERIPH) == TIM4) || \
+                                     ((PERIPH) == TIM5) || \
+                                     ((PERIPH) == TIM8))
+
+/* LIST4: TIM 1, 2, 3, 4, 5, 8, 15, 16 and 17 */
+#define IS_TIM_LIST4_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
+                                     ((PERIPH) == TIM2) || \
+                                     ((PERIPH) == TIM3) || \
+                                     ((PERIPH) == TIM4) || \
+                                     ((PERIPH) == TIM5) || \
+                                     ((PERIPH) == TIM8) || \
+                                     ((PERIPH) == TIM15)|| \
+                                     ((PERIPH) == TIM16)|| \
+                                     ((PERIPH) == TIM17))
+
+/* LIST5: TIM 1, 2, 3, 4, 5, 8 and 15 */
+#define IS_TIM_LIST5_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
+                                     ((PERIPH) == TIM2) || \
+                                     ((PERIPH) == TIM3) || \
+                                     ((PERIPH) == TIM4) || \
+                                     ((PERIPH) == TIM5) || \
+                                     ((PERIPH) == TIM8) || \
+                                     ((PERIPH) == TIM15))
+
+/* LIST6: TIM 1, 2, 3, 4, 5, 8, 9, 12 and 15 */
+#define IS_TIM_LIST6_PERIPH(PERIPH)  (((PERIPH) == TIM1) || \
+                                      ((PERIPH) == TIM2) || \
+                                      ((PERIPH) == TIM3) || \
+                                      ((PERIPH) == TIM4) || \
+                                      ((PERIPH) == TIM5) || \
+                                      ((PERIPH) == TIM8) || \
+                                      ((PERIPH) == TIM9) || \
+									  ((PERIPH) == TIM12)|| \
+                                      ((PERIPH) == TIM15))
+
+/* LIST7: TIM 1, 2, 3, 4, 5, 6, 7, 8, 9, 12 and 15 */
+#define IS_TIM_LIST7_PERIPH(PERIPH)  (((PERIPH) == TIM1) || \
+                                      ((PERIPH) == TIM2) || \
+                                      ((PERIPH) == TIM3) || \
+                                      ((PERIPH) == TIM4) || \
+                                      ((PERIPH) == TIM5) || \
+                                      ((PERIPH) == TIM6) || \
+                                      ((PERIPH) == TIM7) || \
+                                      ((PERIPH) == TIM8) || \
+                                      ((PERIPH) == TIM9) || \
+                                      ((PERIPH) == TIM12)|| \
+                                      ((PERIPH) == TIM15))
+
+/* LIST8: TIM 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16 and 17 */
+#define IS_TIM_LIST8_PERIPH(PERIPH)  (((PERIPH) == TIM1) || \
+                                      ((PERIPH) == TIM2) || \
+                                      ((PERIPH) == TIM3) || \
+                                      ((PERIPH) == TIM4) || \
+                                      ((PERIPH) == TIM5) || \
+                                      ((PERIPH) == TIM8) || \
+                                      ((PERIPH) == TIM9) || \
+                                      ((PERIPH) == TIM10)|| \
+                                      ((PERIPH) == TIM11)|| \
+                                      ((PERIPH) == TIM12)|| \
+                                      ((PERIPH) == TIM13)|| \
+                                      ((PERIPH) == TIM14)|| \
+                                      ((PERIPH) == TIM15)|| \
+                                      ((PERIPH) == TIM16)|| \
+                                      ((PERIPH) == TIM17))
+
+/* LIST9: TIM 1, 2, 3, 4, 5, 6, 7, 8, 15, 16, and 17 */
+#define IS_TIM_LIST9_PERIPH(PERIPH)  (((PERIPH) == TIM1) || \
+                                      ((PERIPH) == TIM2) || \
+                                      ((PERIPH) == TIM3) || \
+                                      ((PERIPH) == TIM4) || \
+                                      ((PERIPH) == TIM5) || \
+                                      ((PERIPH) == TIM6) || \
+                                      ((PERIPH) == TIM7) || \
+                                      ((PERIPH) == TIM8) || \
+                                      ((PERIPH) == TIM15)|| \
+                                      ((PERIPH) == TIM16)|| \
+                                      ((PERIPH) == TIM17))
+
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Output_Compare_and_PWM_modes
+  * @{
+  */
+
+#define TIM_OCMode_Timing                  ((uint16_t)0x0000)
+#define TIM_OCMode_Active                  ((uint16_t)0x0010)
+#define TIM_OCMode_Inactive                ((uint16_t)0x0020)
+#define TIM_OCMode_Toggle                  ((uint16_t)0x0030)
+#define TIM_OCMode_PWM1                    ((uint16_t)0x0060)
+#define TIM_OCMode_PWM2                    ((uint16_t)0x0070)
+#define IS_TIM_OC_MODE(MODE) (((MODE) == TIM_OCMode_Timing) || \
+                              ((MODE) == TIM_OCMode_Active) || \
+                              ((MODE) == TIM_OCMode_Inactive) || \
+                              ((MODE) == TIM_OCMode_Toggle)|| \
+                              ((MODE) == TIM_OCMode_PWM1) || \
+                              ((MODE) == TIM_OCMode_PWM2))
+#define IS_TIM_OCM(MODE) (((MODE) == TIM_OCMode_Timing) || \
+                          ((MODE) == TIM_OCMode_Active) || \
+                          ((MODE) == TIM_OCMode_Inactive) || \
+                          ((MODE) == TIM_OCMode_Toggle)|| \
+                          ((MODE) == TIM_OCMode_PWM1) || \
+                          ((MODE) == TIM_OCMode_PWM2) ||	\
+                          ((MODE) == TIM_ForcedAction_Active) || \
+                          ((MODE) == TIM_ForcedAction_InActive))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_One_Pulse_Mode
+  * @{
+  */
+
+#define TIM_OPMode_Single                  ((uint16_t)0x0008)
+#define TIM_OPMode_Repetitive              ((uint16_t)0x0000)
+#define IS_TIM_OPM_MODE(MODE) (((MODE) == TIM_OPMode_Single) || \
+                               ((MODE) == TIM_OPMode_Repetitive))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Channel
+  * @{
+  */
+
+#define TIM_Channel_1                      ((uint16_t)0x0000)
+#define TIM_Channel_2                      ((uint16_t)0x0004)
+#define TIM_Channel_3                      ((uint16_t)0x0008)
+#define TIM_Channel_4                      ((uint16_t)0x000C)
+#define IS_TIM_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
+                                 ((CHANNEL) == TIM_Channel_2) || \
+                                 ((CHANNEL) == TIM_Channel_3) || \
+                                 ((CHANNEL) == TIM_Channel_4))
+#define IS_TIM_PWMI_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
+                                      ((CHANNEL) == TIM_Channel_2))
+#define IS_TIM_COMPLEMENTARY_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
+                                               ((CHANNEL) == TIM_Channel_2) || \
+                                               ((CHANNEL) == TIM_Channel_3))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Clock_Division_CKD
+  * @{
+  */
+
+#define TIM_CKD_DIV1                       ((uint16_t)0x0000)
+#define TIM_CKD_DIV2                       ((uint16_t)0x0100)
+#define TIM_CKD_DIV4                       ((uint16_t)0x0200)
+#define IS_TIM_CKD_DIV(DIV) (((DIV) == TIM_CKD_DIV1) || \
+                             ((DIV) == TIM_CKD_DIV2) || \
+                             ((DIV) == TIM_CKD_DIV4))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Counter_Mode
+  * @{
+  */
+
+#define TIM_CounterMode_Up                 ((uint16_t)0x0000)
+#define TIM_CounterMode_Down               ((uint16_t)0x0010)
+#define TIM_CounterMode_CenterAligned1     ((uint16_t)0x0020)
+#define TIM_CounterMode_CenterAligned2     ((uint16_t)0x0040)
+#define TIM_CounterMode_CenterAligned3     ((uint16_t)0x0060)
+#define IS_TIM_COUNTER_MODE(MODE) (((MODE) == TIM_CounterMode_Up) ||  \
+                                   ((MODE) == TIM_CounterMode_Down) || \
+                                   ((MODE) == TIM_CounterMode_CenterAligned1) || \
+                                   ((MODE) == TIM_CounterMode_CenterAligned2) || \
+                                   ((MODE) == TIM_CounterMode_CenterAligned3))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Output_Compare_Polarity
+  * @{
+  */
+
+#define TIM_OCPolarity_High                ((uint16_t)0x0000)
+#define TIM_OCPolarity_Low                 ((uint16_t)0x0002)
+#define IS_TIM_OC_POLARITY(POLARITY) (((POLARITY) == TIM_OCPolarity_High) || \
+                                      ((POLARITY) == TIM_OCPolarity_Low))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Output_Compare_N_Polarity
+  * @{
+  */
+
+#define TIM_OCNPolarity_High               ((uint16_t)0x0000)
+#define TIM_OCNPolarity_Low                ((uint16_t)0x0008)
+#define IS_TIM_OCN_POLARITY(POLARITY) (((POLARITY) == TIM_OCNPolarity_High) || \
+                                       ((POLARITY) == TIM_OCNPolarity_Low))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Output_Compare_state
+  * @{
+  */
+
+#define TIM_OutputState_Disable            ((uint16_t)0x0000)
+#define TIM_OutputState_Enable             ((uint16_t)0x0001)
+#define IS_TIM_OUTPUT_STATE(STATE) (((STATE) == TIM_OutputState_Disable) || \
+                                    ((STATE) == TIM_OutputState_Enable))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Output_Compare_N_state
+  * @{
+  */
+
+#define TIM_OutputNState_Disable           ((uint16_t)0x0000)
+#define TIM_OutputNState_Enable            ((uint16_t)0x0004)
+#define IS_TIM_OUTPUTN_STATE(STATE) (((STATE) == TIM_OutputNState_Disable) || \
+                                     ((STATE) == TIM_OutputNState_Enable))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Capture_Compare_state
+  * @{
+  */
+
+#define TIM_CCx_Enable                      ((uint16_t)0x0001)
+#define TIM_CCx_Disable                     ((uint16_t)0x0000)
+#define IS_TIM_CCX(CCX) (((CCX) == TIM_CCx_Enable) || \
+                         ((CCX) == TIM_CCx_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Capture_Compare_N_state
+  * @{
+  */
+
+#define TIM_CCxN_Enable                     ((uint16_t)0x0004)
+#define TIM_CCxN_Disable                    ((uint16_t)0x0000)
+#define IS_TIM_CCXN(CCXN) (((CCXN) == TIM_CCxN_Enable) || \
+                           ((CCXN) == TIM_CCxN_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup Break_Input_enable_disable
+  * @{
+  */
+
+#define TIM_Break_Enable                   ((uint16_t)0x1000)
+#define TIM_Break_Disable                  ((uint16_t)0x0000)
+#define IS_TIM_BREAK_STATE(STATE) (((STATE) == TIM_Break_Enable) || \
+                                   ((STATE) == TIM_Break_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup Break_Polarity
+  * @{
+  */
+
+#define TIM_BreakPolarity_Low              ((uint16_t)0x0000)
+#define TIM_BreakPolarity_High             ((uint16_t)0x2000)
+#define IS_TIM_BREAK_POLARITY(POLARITY) (((POLARITY) == TIM_BreakPolarity_Low) || \
+                                         ((POLARITY) == TIM_BreakPolarity_High))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_AOE_Bit_Set_Reset
+  * @{
+  */
+
+#define TIM_AutomaticOutput_Enable         ((uint16_t)0x4000)
+#define TIM_AutomaticOutput_Disable        ((uint16_t)0x0000)
+#define IS_TIM_AUTOMATIC_OUTPUT_STATE(STATE) (((STATE) == TIM_AutomaticOutput_Enable) || \
+                                              ((STATE) == TIM_AutomaticOutput_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup Lock_level
+  * @{
+  */
+
+#define TIM_LOCKLevel_OFF                  ((uint16_t)0x0000)
+#define TIM_LOCKLevel_1                    ((uint16_t)0x0100)
+#define TIM_LOCKLevel_2                    ((uint16_t)0x0200)
+#define TIM_LOCKLevel_3                    ((uint16_t)0x0300)
+#define IS_TIM_LOCK_LEVEL(LEVEL) (((LEVEL) == TIM_LOCKLevel_OFF) || \
+                                  ((LEVEL) == TIM_LOCKLevel_1) || \
+                                  ((LEVEL) == TIM_LOCKLevel_2) || \
+                                  ((LEVEL) == TIM_LOCKLevel_3))
+/**
+  * @}
+  */
+
+/** @defgroup OSSI_Off_State_Selection_for_Idle_mode_state
+  * @{
+  */
+
+#define TIM_OSSIState_Enable               ((uint16_t)0x0400)
+#define TIM_OSSIState_Disable              ((uint16_t)0x0000)
+#define IS_TIM_OSSI_STATE(STATE) (((STATE) == TIM_OSSIState_Enable) || \
+                                  ((STATE) == TIM_OSSIState_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup OSSR_Off_State_Selection_for_Run_mode_state
+  * @{
+  */
+
+#define TIM_OSSRState_Enable               ((uint16_t)0x0800)
+#define TIM_OSSRState_Disable              ((uint16_t)0x0000)
+#define IS_TIM_OSSR_STATE(STATE) (((STATE) == TIM_OSSRState_Enable) || \
+                                  ((STATE) == TIM_OSSRState_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Output_Compare_Idle_State
+  * @{
+  */
+
+#define TIM_OCIdleState_Set                ((uint16_t)0x0100)
+#define TIM_OCIdleState_Reset              ((uint16_t)0x0000)
+#define IS_TIM_OCIDLE_STATE(STATE) (((STATE) == TIM_OCIdleState_Set) || \
+                                    ((STATE) == TIM_OCIdleState_Reset))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Output_Compare_N_Idle_State
+  * @{
+  */
+
+#define TIM_OCNIdleState_Set               ((uint16_t)0x0200)
+#define TIM_OCNIdleState_Reset             ((uint16_t)0x0000)
+#define IS_TIM_OCNIDLE_STATE(STATE) (((STATE) == TIM_OCNIdleState_Set) || \
+                                     ((STATE) == TIM_OCNIdleState_Reset))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Input_Capture_Polarity
+  * @{
+  */
+
+#define  TIM_ICPolarity_Rising             ((uint16_t)0x0000)
+#define  TIM_ICPolarity_Falling            ((uint16_t)0x0002)
+#define  TIM_ICPolarity_BothEdge           ((uint16_t)0x000A)
+#define IS_TIM_IC_POLARITY(POLARITY) (((POLARITY) == TIM_ICPolarity_Rising) || \
+                                      ((POLARITY) == TIM_ICPolarity_Falling))
+#define IS_TIM_IC_POLARITY_LITE(POLARITY) (((POLARITY) == TIM_ICPolarity_Rising) || \
+                                           ((POLARITY) == TIM_ICPolarity_Falling)|| \
+                                           ((POLARITY) == TIM_ICPolarity_BothEdge))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Input_Capture_Selection
+  * @{
+  */
+
+#define TIM_ICSelection_DirectTI           ((uint16_t)0x0001) /*!< TIM Input 1, 2, 3 or 4 is selected to be
+                                                                   connected to IC1, IC2, IC3 or IC4, respectively */
+#define TIM_ICSelection_IndirectTI         ((uint16_t)0x0002) /*!< TIM Input 1, 2, 3 or 4 is selected to be
+                                                                   connected to IC2, IC1, IC4 or IC3, respectively. */
+#define TIM_ICSelection_TRC                ((uint16_t)0x0003) /*!< TIM Input 1, 2, 3 or 4 is selected to be connected to TRC. */
+#define IS_TIM_IC_SELECTION(SELECTION) (((SELECTION) == TIM_ICSelection_DirectTI) || \
+                                        ((SELECTION) == TIM_ICSelection_IndirectTI) || \
+                                        ((SELECTION) == TIM_ICSelection_TRC))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Input_Capture_Prescaler
+  * @{
+  */
+
+#define TIM_ICPSC_DIV1                     ((uint16_t)0x0000) /*!< Capture performed each time an edge is detected on the capture input. */
+#define TIM_ICPSC_DIV2                     ((uint16_t)0x0004) /*!< Capture performed once every 2 events. */
+#define TIM_ICPSC_DIV4                     ((uint16_t)0x0008) /*!< Capture performed once every 4 events. */
+#define TIM_ICPSC_DIV8                     ((uint16_t)0x000C) /*!< Capture performed once every 8 events. */
+#define IS_TIM_IC_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ICPSC_DIV1) || \
+                                        ((PRESCALER) == TIM_ICPSC_DIV2) || \
+                                        ((PRESCALER) == TIM_ICPSC_DIV4) || \
+                                        ((PRESCALER) == TIM_ICPSC_DIV8))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_interrupt_sources
+  * @{
+  */
+
+#define TIM_IT_Update                      ((uint16_t)0x0001)
+#define TIM_IT_CC1                         ((uint16_t)0x0002)
+#define TIM_IT_CC2                         ((uint16_t)0x0004)
+#define TIM_IT_CC3                         ((uint16_t)0x0008)
+#define TIM_IT_CC4                         ((uint16_t)0x0010)
+#define TIM_IT_COM                         ((uint16_t)0x0020)
+#define TIM_IT_Trigger                     ((uint16_t)0x0040)
+#define TIM_IT_Break                       ((uint16_t)0x0080)
+#define IS_TIM_IT(IT) ((((IT) & (uint16_t)0xFF00) == 0x0000) && ((IT) != 0x0000))
+
+#define IS_TIM_GET_IT(IT) (((IT) == TIM_IT_Update) || \
+                           ((IT) == TIM_IT_CC1) || \
+                           ((IT) == TIM_IT_CC2) || \
+                           ((IT) == TIM_IT_CC3) || \
+                           ((IT) == TIM_IT_CC4) || \
+                           ((IT) == TIM_IT_COM) || \
+                           ((IT) == TIM_IT_Trigger) || \
+                           ((IT) == TIM_IT_Break))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_DMA_Base_address
+  * @{
+  */
+
+#define TIM_DMABase_CR1                    ((uint16_t)0x0000)
+#define TIM_DMABase_CR2                    ((uint16_t)0x0001)
+#define TIM_DMABase_SMCR                   ((uint16_t)0x0002)
+#define TIM_DMABase_DIER                   ((uint16_t)0x0003)
+#define TIM_DMABase_SR                     ((uint16_t)0x0004)
+#define TIM_DMABase_EGR                    ((uint16_t)0x0005)
+#define TIM_DMABase_CCMR1                  ((uint16_t)0x0006)
+#define TIM_DMABase_CCMR2                  ((uint16_t)0x0007)
+#define TIM_DMABase_CCER                   ((uint16_t)0x0008)
+#define TIM_DMABase_CNT                    ((uint16_t)0x0009)
+#define TIM_DMABase_PSC                    ((uint16_t)0x000A)
+#define TIM_DMABase_ARR                    ((uint16_t)0x000B)
+#define TIM_DMABase_RCR                    ((uint16_t)0x000C)
+#define TIM_DMABase_CCR1                   ((uint16_t)0x000D)
+#define TIM_DMABase_CCR2                   ((uint16_t)0x000E)
+#define TIM_DMABase_CCR3                   ((uint16_t)0x000F)
+#define TIM_DMABase_CCR4                   ((uint16_t)0x0010)
+#define TIM_DMABase_BDTR                   ((uint16_t)0x0011)
+#define TIM_DMABase_DCR                    ((uint16_t)0x0012)
+#define IS_TIM_DMA_BASE(BASE) (((BASE) == TIM_DMABase_CR1) || \
+                               ((BASE) == TIM_DMABase_CR2) || \
+                               ((BASE) == TIM_DMABase_SMCR) || \
+                               ((BASE) == TIM_DMABase_DIER) || \
+                               ((BASE) == TIM_DMABase_SR) || \
+                               ((BASE) == TIM_DMABase_EGR) || \
+                               ((BASE) == TIM_DMABase_CCMR1) || \
+                               ((BASE) == TIM_DMABase_CCMR2) || \
+                               ((BASE) == TIM_DMABase_CCER) || \
+                               ((BASE) == TIM_DMABase_CNT) || \
+                               ((BASE) == TIM_DMABase_PSC) || \
+                               ((BASE) == TIM_DMABase_ARR) || \
+                               ((BASE) == TIM_DMABase_RCR) || \
+                               ((BASE) == TIM_DMABase_CCR1) || \
+                               ((BASE) == TIM_DMABase_CCR2) || \
+                               ((BASE) == TIM_DMABase_CCR3) || \
+                               ((BASE) == TIM_DMABase_CCR4) || \
+                               ((BASE) == TIM_DMABase_BDTR) || \
+                               ((BASE) == TIM_DMABase_DCR))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_DMA_Burst_Length
+  * @{
+  */
+
+#define TIM_DMABurstLength_1Transfer           ((uint16_t)0x0000)
+#define TIM_DMABurstLength_2Transfers          ((uint16_t)0x0100)
+#define TIM_DMABurstLength_3Transfers          ((uint16_t)0x0200)
+#define TIM_DMABurstLength_4Transfers          ((uint16_t)0x0300)
+#define TIM_DMABurstLength_5Transfers          ((uint16_t)0x0400)
+#define TIM_DMABurstLength_6Transfers          ((uint16_t)0x0500)
+#define TIM_DMABurstLength_7Transfers          ((uint16_t)0x0600)
+#define TIM_DMABurstLength_8Transfers          ((uint16_t)0x0700)
+#define TIM_DMABurstLength_9Transfers          ((uint16_t)0x0800)
+#define TIM_DMABurstLength_10Transfers         ((uint16_t)0x0900)
+#define TIM_DMABurstLength_11Transfers         ((uint16_t)0x0A00)
+#define TIM_DMABurstLength_12Transfers         ((uint16_t)0x0B00)
+#define TIM_DMABurstLength_13Transfers         ((uint16_t)0x0C00)
+#define TIM_DMABurstLength_14Transfers         ((uint16_t)0x0D00)
+#define TIM_DMABurstLength_15Transfers         ((uint16_t)0x0E00)
+#define TIM_DMABurstLength_16Transfers         ((uint16_t)0x0F00)
+#define TIM_DMABurstLength_17Transfers         ((uint16_t)0x1000)
+#define TIM_DMABurstLength_18Transfers         ((uint16_t)0x1100)
+#define IS_TIM_DMA_LENGTH(LENGTH) (((LENGTH) == TIM_DMABurstLength_1Transfer) || \
+                                   ((LENGTH) == TIM_DMABurstLength_2Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_3Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_4Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_5Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_6Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_7Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_8Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_9Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_10Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_11Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_12Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_13Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_14Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_15Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_16Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_17Transfers) || \
+                                   ((LENGTH) == TIM_DMABurstLength_18Transfers))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_DMA_sources
+  * @{
+  */
+
+#define TIM_DMA_Update                     ((uint16_t)0x0100)
+#define TIM_DMA_CC1                        ((uint16_t)0x0200)
+#define TIM_DMA_CC2                        ((uint16_t)0x0400)
+#define TIM_DMA_CC3                        ((uint16_t)0x0800)
+#define TIM_DMA_CC4                        ((uint16_t)0x1000)
+#define TIM_DMA_COM                        ((uint16_t)0x2000)
+#define TIM_DMA_Trigger                    ((uint16_t)0x4000)
+#define IS_TIM_DMA_SOURCE(SOURCE) ((((SOURCE) & (uint16_t)0x80FF) == 0x0000) && ((SOURCE) != 0x0000))
+
+/**
+  * @}
+  */
+
+/** @defgroup TIM_External_Trigger_Prescaler
+  * @{
+  */
+
+#define TIM_ExtTRGPSC_OFF                  ((uint16_t)0x0000)
+#define TIM_ExtTRGPSC_DIV2                 ((uint16_t)0x1000)
+#define TIM_ExtTRGPSC_DIV4                 ((uint16_t)0x2000)
+#define TIM_ExtTRGPSC_DIV8                 ((uint16_t)0x3000)
+#define IS_TIM_EXT_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ExtTRGPSC_OFF) || \
+                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV2) || \
+                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV4) || \
+                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV8))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Internal_Trigger_Selection
+  * @{
+  */
+
+#define TIM_TS_ITR0                        ((uint16_t)0x0000)
+#define TIM_TS_ITR1                        ((uint16_t)0x0010)
+#define TIM_TS_ITR2                        ((uint16_t)0x0020)
+#define TIM_TS_ITR3                        ((uint16_t)0x0030)
+#define TIM_TS_TI1F_ED                     ((uint16_t)0x0040)
+#define TIM_TS_TI1FP1                      ((uint16_t)0x0050)
+#define TIM_TS_TI2FP2                      ((uint16_t)0x0060)
+#define TIM_TS_ETRF                        ((uint16_t)0x0070)
+#define IS_TIM_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) || \
+                                             ((SELECTION) == TIM_TS_ITR1) || \
+                                             ((SELECTION) == TIM_TS_ITR2) || \
+                                             ((SELECTION) == TIM_TS_ITR3) || \
+                                             ((SELECTION) == TIM_TS_TI1F_ED) || \
+                                             ((SELECTION) == TIM_TS_TI1FP1) || \
+                                             ((SELECTION) == TIM_TS_TI2FP2) || \
+                                             ((SELECTION) == TIM_TS_ETRF))
+#define IS_TIM_INTERNAL_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) || \
+                                                      ((SELECTION) == TIM_TS_ITR1) || \
+                                                      ((SELECTION) == TIM_TS_ITR2) || \
+                                                      ((SELECTION) == TIM_TS_ITR3))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_TIx_External_Clock_Source
+  * @{
+  */
+
+#define TIM_TIxExternalCLK1Source_TI1      ((uint16_t)0x0050)
+#define TIM_TIxExternalCLK1Source_TI2      ((uint16_t)0x0060)
+#define TIM_TIxExternalCLK1Source_TI1ED    ((uint16_t)0x0040)
+#define IS_TIM_TIXCLK_SOURCE(SOURCE) (((SOURCE) == TIM_TIxExternalCLK1Source_TI1) || \
+                                      ((SOURCE) == TIM_TIxExternalCLK1Source_TI2) || \
+                                      ((SOURCE) == TIM_TIxExternalCLK1Source_TI1ED))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_External_Trigger_Polarity
+  * @{
+  */
+#define TIM_ExtTRGPolarity_Inverted        ((uint16_t)0x8000)
+#define TIM_ExtTRGPolarity_NonInverted     ((uint16_t)0x0000)
+#define IS_TIM_EXT_POLARITY(POLARITY) (((POLARITY) == TIM_ExtTRGPolarity_Inverted) || \
+                                       ((POLARITY) == TIM_ExtTRGPolarity_NonInverted))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Prescaler_Reload_Mode
+  * @{
+  */
+
+#define TIM_PSCReloadMode_Update           ((uint16_t)0x0000)
+#define TIM_PSCReloadMode_Immediate        ((uint16_t)0x0001)
+#define IS_TIM_PRESCALER_RELOAD(RELOAD) (((RELOAD) == TIM_PSCReloadMode_Update) || \
+                                         ((RELOAD) == TIM_PSCReloadMode_Immediate))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Forced_Action
+  * @{
+  */
+
+#define TIM_ForcedAction_Active            ((uint16_t)0x0050)
+#define TIM_ForcedAction_InActive          ((uint16_t)0x0040)
+#define IS_TIM_FORCED_ACTION(ACTION) (((ACTION) == TIM_ForcedAction_Active) || \
+                                      ((ACTION) == TIM_ForcedAction_InActive))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Encoder_Mode
+  * @{
+  */
+
+#define TIM_EncoderMode_TI1                ((uint16_t)0x0001)
+#define TIM_EncoderMode_TI2                ((uint16_t)0x0002)
+#define TIM_EncoderMode_TI12               ((uint16_t)0x0003)
+#define IS_TIM_ENCODER_MODE(MODE) (((MODE) == TIM_EncoderMode_TI1) || \
+                                   ((MODE) == TIM_EncoderMode_TI2) || \
+                                   ((MODE) == TIM_EncoderMode_TI12))
+/**
+  * @}
+  */
+
+
+/** @defgroup TIM_Event_Source
+  * @{
+  */
+
+#define TIM_EventSource_Update             ((uint16_t)0x0001)
+#define TIM_EventSource_CC1                ((uint16_t)0x0002)
+#define TIM_EventSource_CC2                ((uint16_t)0x0004)
+#define TIM_EventSource_CC3                ((uint16_t)0x0008)
+#define TIM_EventSource_CC4                ((uint16_t)0x0010)
+#define TIM_EventSource_COM                ((uint16_t)0x0020)
+#define TIM_EventSource_Trigger            ((uint16_t)0x0040)
+#define TIM_EventSource_Break              ((uint16_t)0x0080)
+#define IS_TIM_EVENT_SOURCE(SOURCE) ((((SOURCE) & (uint16_t)0xFF00) == 0x0000) && ((SOURCE) != 0x0000))
+
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Update_Source
+  * @{
+  */
+
+#define TIM_UpdateSource_Global            ((uint16_t)0x0000) /*!< Source of update is the counter overflow/underflow
+                                                                   or the setting of UG bit, or an update generation
+                                                                   through the slave mode controller. */
+#define TIM_UpdateSource_Regular           ((uint16_t)0x0001) /*!< Source of update is counter overflow/underflow. */
+#define IS_TIM_UPDATE_SOURCE(SOURCE) (((SOURCE) == TIM_UpdateSource_Global) || \
+                                      ((SOURCE) == TIM_UpdateSource_Regular))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Output_Compare_Preload_State
+  * @{
+  */
+
+#define TIM_OCPreload_Enable               ((uint16_t)0x0008)
+#define TIM_OCPreload_Disable              ((uint16_t)0x0000)
+#define IS_TIM_OCPRELOAD_STATE(STATE) (((STATE) == TIM_OCPreload_Enable) || \
+                                       ((STATE) == TIM_OCPreload_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Output_Compare_Fast_State
+  * @{
+  */
+
+#define TIM_OCFast_Enable                  ((uint16_t)0x0004)
+#define TIM_OCFast_Disable                 ((uint16_t)0x0000)
+#define IS_TIM_OCFAST_STATE(STATE) (((STATE) == TIM_OCFast_Enable) || \
+                                    ((STATE) == TIM_OCFast_Disable))
+
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Output_Compare_Clear_State
+  * @{
+  */
+
+#define TIM_OCClear_Enable                 ((uint16_t)0x0080)
+#define TIM_OCClear_Disable                ((uint16_t)0x0000)
+#define IS_TIM_OCCLEAR_STATE(STATE) (((STATE) == TIM_OCClear_Enable) || \
+                                     ((STATE) == TIM_OCClear_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Trigger_Output_Source
+  * @{
+  */
+
+#define TIM_TRGOSource_Reset               ((uint16_t)0x0000)
+#define TIM_TRGOSource_Enable              ((uint16_t)0x0010)
+#define TIM_TRGOSource_Update              ((uint16_t)0x0020)
+#define TIM_TRGOSource_OC1                 ((uint16_t)0x0030)
+#define TIM_TRGOSource_OC1Ref              ((uint16_t)0x0040)
+#define TIM_TRGOSource_OC2Ref              ((uint16_t)0x0050)
+#define TIM_TRGOSource_OC3Ref              ((uint16_t)0x0060)
+#define TIM_TRGOSource_OC4Ref              ((uint16_t)0x0070)
+#define IS_TIM_TRGO_SOURCE(SOURCE) (((SOURCE) == TIM_TRGOSource_Reset) || \
+                                    ((SOURCE) == TIM_TRGOSource_Enable) || \
+                                    ((SOURCE) == TIM_TRGOSource_Update) || \
+                                    ((SOURCE) == TIM_TRGOSource_OC1) || \
+                                    ((SOURCE) == TIM_TRGOSource_OC1Ref) || \
+                                    ((SOURCE) == TIM_TRGOSource_OC2Ref) || \
+                                    ((SOURCE) == TIM_TRGOSource_OC3Ref) || \
+                                    ((SOURCE) == TIM_TRGOSource_OC4Ref))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Slave_Mode
+  * @{
+  */
+
+#define TIM_SlaveMode_Reset                ((uint16_t)0x0004)
+#define TIM_SlaveMode_Gated                ((uint16_t)0x0005)
+#define TIM_SlaveMode_Trigger              ((uint16_t)0x0006)
+#define TIM_SlaveMode_External1            ((uint16_t)0x0007)
+#define IS_TIM_SLAVE_MODE(MODE) (((MODE) == TIM_SlaveMode_Reset) || \
+                                 ((MODE) == TIM_SlaveMode_Gated) || \
+                                 ((MODE) == TIM_SlaveMode_Trigger) || \
+                                 ((MODE) == TIM_SlaveMode_External1))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Master_Slave_Mode
+  * @{
+  */
+
+#define TIM_MasterSlaveMode_Enable         ((uint16_t)0x0080)
+#define TIM_MasterSlaveMode_Disable        ((uint16_t)0x0000)
+#define IS_TIM_MSM_STATE(STATE) (((STATE) == TIM_MasterSlaveMode_Enable) || \
+                                 ((STATE) == TIM_MasterSlaveMode_Disable))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Flags
+  * @{
+  */
+
+#define TIM_FLAG_Update                    ((uint16_t)0x0001)
+#define TIM_FLAG_CC1                       ((uint16_t)0x0002)
+#define TIM_FLAG_CC2                       ((uint16_t)0x0004)
+#define TIM_FLAG_CC3                       ((uint16_t)0x0008)
+#define TIM_FLAG_CC4                       ((uint16_t)0x0010)
+#define TIM_FLAG_COM                       ((uint16_t)0x0020)
+#define TIM_FLAG_Trigger                   ((uint16_t)0x0040)
+#define TIM_FLAG_Break                     ((uint16_t)0x0080)
+#define TIM_FLAG_CC1OF                     ((uint16_t)0x0200)
+#define TIM_FLAG_CC2OF                     ((uint16_t)0x0400)
+#define TIM_FLAG_CC3OF                     ((uint16_t)0x0800)
+#define TIM_FLAG_CC4OF                     ((uint16_t)0x1000)
+#define IS_TIM_GET_FLAG(FLAG) (((FLAG) == TIM_FLAG_Update) || \
+                               ((FLAG) == TIM_FLAG_CC1) || \
+                               ((FLAG) == TIM_FLAG_CC2) || \
+                               ((FLAG) == TIM_FLAG_CC3) || \
+                               ((FLAG) == TIM_FLAG_CC4) || \
+                               ((FLAG) == TIM_FLAG_COM) || \
+                               ((FLAG) == TIM_FLAG_Trigger) || \
+                               ((FLAG) == TIM_FLAG_Break) || \
+                               ((FLAG) == TIM_FLAG_CC1OF) || \
+                               ((FLAG) == TIM_FLAG_CC2OF) || \
+                               ((FLAG) == TIM_FLAG_CC3OF) || \
+                               ((FLAG) == TIM_FLAG_CC4OF))
+
+
+#define IS_TIM_CLEAR_FLAG(TIM_FLAG) ((((TIM_FLAG) & (uint16_t)0xE100) == 0x0000) && ((TIM_FLAG) != 0x0000))
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Input_Capture_Filer_Value
+  * @{
+  */
+
+#define IS_TIM_IC_FILTER(ICFILTER) ((ICFILTER) <= 0xF)
+/**
+  * @}
+  */
+
+/** @defgroup TIM_External_Trigger_Filter
+  * @{
+  */
+
+#define IS_TIM_EXT_FILTER(EXTFILTER) ((EXTFILTER) <= 0xF)
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Legacy
+  * @{
+  */
+
+#define TIM_DMABurstLength_1Byte           TIM_DMABurstLength_1Transfer
+#define TIM_DMABurstLength_2Bytes          TIM_DMABurstLength_2Transfers
+#define TIM_DMABurstLength_3Bytes          TIM_DMABurstLength_3Transfers
+#define TIM_DMABurstLength_4Bytes          TIM_DMABurstLength_4Transfers
+#define TIM_DMABurstLength_5Bytes          TIM_DMABurstLength_5Transfers
+#define TIM_DMABurstLength_6Bytes          TIM_DMABurstLength_6Transfers
+#define TIM_DMABurstLength_7Bytes          TIM_DMABurstLength_7Transfers
+#define TIM_DMABurstLength_8Bytes          TIM_DMABurstLength_8Transfers
+#define TIM_DMABurstLength_9Bytes          TIM_DMABurstLength_9Transfers
+#define TIM_DMABurstLength_10Bytes         TIM_DMABurstLength_10Transfers
+#define TIM_DMABurstLength_11Bytes         TIM_DMABurstLength_11Transfers
+#define TIM_DMABurstLength_12Bytes         TIM_DMABurstLength_12Transfers
+#define TIM_DMABurstLength_13Bytes         TIM_DMABurstLength_13Transfers
+#define TIM_DMABurstLength_14Bytes         TIM_DMABurstLength_14Transfers
+#define TIM_DMABurstLength_15Bytes         TIM_DMABurstLength_15Transfers
+#define TIM_DMABurstLength_16Bytes         TIM_DMABurstLength_16Transfers
+#define TIM_DMABurstLength_17Bytes         TIM_DMABurstLength_17Transfers
+#define TIM_DMABurstLength_18Bytes         TIM_DMABurstLength_18Transfers
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Exported_Functions
+  * @{
+  */
+
+void TIM_DeInit(TIM_TypeDef* TIMx);
+void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);
+void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
+void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
+void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
+void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
+void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);
+void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);
+void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct);
+void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);
+void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct);
+void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct);
+void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct);
+void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState);
+void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState);
+void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState);
+void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource);
+void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength);
+void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState);
+void TIM_InternalClockConfig(TIM_TypeDef* TIMx);
+void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);
+void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
+                                uint16_t TIM_ICPolarity, uint16_t ICFilter);
+void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
+                             uint16_t ExtTRGFilter);
+void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
+                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter);
+void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
+                   uint16_t ExtTRGFilter);
+void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode);
+void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode);
+void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);
+void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
+                                uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity);
+void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
+void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
+void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
+void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
+void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState);
+void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState);
+void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState);
+void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState);
+void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
+void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
+void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
+void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
+void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
+void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
+void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
+void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
+void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
+void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
+void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
+void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
+void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
+void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
+void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
+void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
+void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
+void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
+void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
+void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx);
+void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN);
+void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode);
+void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState);
+void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource);
+void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState);
+void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode);
+void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource);
+void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode);
+void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode);
+void TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter);
+void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload);
+void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1);
+void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2);
+void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3);
+void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4);
+void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
+void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
+void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
+void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
+void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD);
+uint16_t TIM_GetCapture1(TIM_TypeDef* TIMx);
+uint16_t TIM_GetCapture2(TIM_TypeDef* TIMx);
+uint16_t TIM_GetCapture3(TIM_TypeDef* TIMx);
+uint16_t TIM_GetCapture4(TIM_TypeDef* TIMx);
+uint16_t TIM_GetCounter(TIM_TypeDef* TIMx);
+uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx);
+FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);
+void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);
+ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT);
+void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__STM32F10x_TIM_H */
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_usart.h b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_usart.h
new file mode 100644
index 0000000..61ae249
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_usart.h
@@ -0,0 +1,412 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_usart.h
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file contains all the functions prototypes for the USART
+  *          firmware library.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F10x_USART_H
+#define __STM32F10x_USART_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup USART
+  * @{
+  */
+
+/** @defgroup USART_Exported_Types
+  * @{
+  */
+
+/**
+  * @brief  USART Init Structure definition
+  */
+
+typedef struct
+{
+  uint32_t USART_BaudRate;            /*!< This member configures the USART communication baud rate.
+                                           The baud rate is computed using the following formula:
+                                            - IntegerDivider = ((PCLKx) / (16 * (USART_InitStruct->USART_BaudRate)))
+                                            - FractionalDivider = ((IntegerDivider - ((u32) IntegerDivider)) * 16) + 0.5 */
+
+  uint16_t USART_WordLength;          /*!< Specifies the number of data bits transmitted or received in a frame.
+                                           This parameter can be a value of @ref USART_Word_Length */
+
+  uint16_t USART_StopBits;            /*!< Specifies the number of stop bits transmitted.
+                                           This parameter can be a value of @ref USART_Stop_Bits */
+
+  uint16_t USART_Parity;              /*!< Specifies the parity mode.
+                                           This parameter can be a value of @ref USART_Parity
+                                           @note When parity is enabled, the computed parity is inserted
+                                                 at the MSB position of the transmitted data (9th bit when
+                                                 the word length is set to 9 data bits; 8th bit when the
+                                                 word length is set to 8 data bits). */
+
+  uint16_t USART_Mode;                /*!< Specifies wether the Receive or Transmit mode is enabled or disabled.
+                                           This parameter can be a value of @ref USART_Mode */
+
+  uint16_t USART_HardwareFlowControl; /*!< Specifies wether the hardware flow control mode is enabled
+                                           or disabled.
+                                           This parameter can be a value of @ref USART_Hardware_Flow_Control */
+} USART_InitTypeDef;
+
+/**
+  * @brief  USART Clock Init Structure definition
+  */
+
+typedef struct
+{
+
+  uint16_t USART_Clock;   /*!< Specifies whether the USART clock is enabled or disabled.
+                               This parameter can be a value of @ref USART_Clock */
+
+  uint16_t USART_CPOL;    /*!< Specifies the steady state value of the serial clock.
+                               This parameter can be a value of @ref USART_Clock_Polarity */
+
+  uint16_t USART_CPHA;    /*!< Specifies the clock transition on which the bit capture is made.
+                               This parameter can be a value of @ref USART_Clock_Phase */
+
+  uint16_t USART_LastBit; /*!< Specifies whether the clock pulse corresponding to the last transmitted
+                               data bit (MSB) has to be output on the SCLK pin in synchronous mode.
+                               This parameter can be a value of @ref USART_Last_Bit */
+} USART_ClockInitTypeDef;
+
+/**
+  * @}
+  */
+
+/** @defgroup USART_Exported_Constants
+  * @{
+  */
+
+#define IS_USART_ALL_PERIPH(PERIPH) (((PERIPH) == USART1) || \
+                                     ((PERIPH) == USART2) || \
+                                     ((PERIPH) == USART3) || \
+                                     ((PERIPH) == UART4) || \
+                                     ((PERIPH) == UART5))
+
+#define IS_USART_123_PERIPH(PERIPH) (((PERIPH) == USART1) || \
+                                     ((PERIPH) == USART2) || \
+                                     ((PERIPH) == USART3))
+
+#define IS_USART_1234_PERIPH(PERIPH) (((PERIPH) == USART1) || \
+                                      ((PERIPH) == USART2) || \
+                                      ((PERIPH) == USART3) || \
+                                      ((PERIPH) == UART4))
+/** @defgroup USART_Word_Length
+  * @{
+  */
+
+#define USART_WordLength_8b                  ((uint16_t)0x0000)
+#define USART_WordLength_9b                  ((uint16_t)0x1000)
+
+#define IS_USART_WORD_LENGTH(LENGTH) (((LENGTH) == USART_WordLength_8b) || \
+                                      ((LENGTH) == USART_WordLength_9b))
+/**
+  * @}
+  */
+
+/** @defgroup USART_Stop_Bits
+  * @{
+  */
+
+#define USART_StopBits_1                     ((uint16_t)0x0000)
+#define USART_StopBits_0_5                   ((uint16_t)0x1000)
+#define USART_StopBits_2                     ((uint16_t)0x2000)
+#define USART_StopBits_1_5                   ((uint16_t)0x3000)
+#define IS_USART_STOPBITS(STOPBITS) (((STOPBITS) == USART_StopBits_1) || \
+                                     ((STOPBITS) == USART_StopBits_0_5) || \
+                                     ((STOPBITS) == USART_StopBits_2) || \
+                                     ((STOPBITS) == USART_StopBits_1_5))
+/**
+  * @}
+  */
+
+/** @defgroup USART_Parity
+  * @{
+  */
+
+#define USART_Parity_No                      ((uint16_t)0x0000)
+#define USART_Parity_Even                    ((uint16_t)0x0400)
+#define USART_Parity_Odd                     ((uint16_t)0x0600)
+#define IS_USART_PARITY(PARITY) (((PARITY) == USART_Parity_No) || \
+                                 ((PARITY) == USART_Parity_Even) || \
+                                 ((PARITY) == USART_Parity_Odd))
+/**
+  * @}
+  */
+
+/** @defgroup USART_Mode
+  * @{
+  */
+
+#define USART_Mode_Rx                        ((uint16_t)0x0004)
+#define USART_Mode_Tx                        ((uint16_t)0x0008)
+#define IS_USART_MODE(MODE) ((((MODE) & (uint16_t)0xFFF3) == 0x00) && ((MODE) != (uint16_t)0x00))
+/**
+  * @}
+  */
+
+/** @defgroup USART_Hardware_Flow_Control
+  * @{
+  */
+#define USART_HardwareFlowControl_None       ((uint16_t)0x0000)
+#define USART_HardwareFlowControl_RTS        ((uint16_t)0x0100)
+#define USART_HardwareFlowControl_CTS        ((uint16_t)0x0200)
+#define USART_HardwareFlowControl_RTS_CTS    ((uint16_t)0x0300)
+#define IS_USART_HARDWARE_FLOW_CONTROL(CONTROL)\
+                              (((CONTROL) == USART_HardwareFlowControl_None) || \
+                               ((CONTROL) == USART_HardwareFlowControl_RTS) || \
+                               ((CONTROL) == USART_HardwareFlowControl_CTS) || \
+                               ((CONTROL) == USART_HardwareFlowControl_RTS_CTS))
+/**
+  * @}
+  */
+
+/** @defgroup USART_Clock
+  * @{
+  */
+#define USART_Clock_Disable                  ((uint16_t)0x0000)
+#define USART_Clock_Enable                   ((uint16_t)0x0800)
+#define IS_USART_CLOCK(CLOCK) (((CLOCK) == USART_Clock_Disable) || \
+                               ((CLOCK) == USART_Clock_Enable))
+/**
+  * @}
+  */
+
+/** @defgroup USART_Clock_Polarity
+  * @{
+  */
+
+#define USART_CPOL_Low                       ((uint16_t)0x0000)
+#define USART_CPOL_High                      ((uint16_t)0x0400)
+#define IS_USART_CPOL(CPOL) (((CPOL) == USART_CPOL_Low) || ((CPOL) == USART_CPOL_High))
+
+/**
+  * @}
+  */
+
+/** @defgroup USART_Clock_Phase
+  * @{
+  */
+
+#define USART_CPHA_1Edge                     ((uint16_t)0x0000)
+#define USART_CPHA_2Edge                     ((uint16_t)0x0200)
+#define IS_USART_CPHA(CPHA) (((CPHA) == USART_CPHA_1Edge) || ((CPHA) == USART_CPHA_2Edge))
+
+/**
+  * @}
+  */
+
+/** @defgroup USART_Last_Bit
+  * @{
+  */
+
+#define USART_LastBit_Disable                ((uint16_t)0x0000)
+#define USART_LastBit_Enable                 ((uint16_t)0x0100)
+#define IS_USART_LASTBIT(LASTBIT) (((LASTBIT) == USART_LastBit_Disable) || \
+                                   ((LASTBIT) == USART_LastBit_Enable))
+/**
+  * @}
+  */
+
+/** @defgroup USART_Interrupt_definition
+  * @{
+  */
+
+#define USART_IT_PE                          ((uint16_t)0x0028)
+#define USART_IT_TXE                         ((uint16_t)0x0727)
+#define USART_IT_TC                          ((uint16_t)0x0626)
+#define USART_IT_RXNE                        ((uint16_t)0x0525)
+#define USART_IT_IDLE                        ((uint16_t)0x0424)
+#define USART_IT_LBD                         ((uint16_t)0x0846)
+#define USART_IT_CTS                         ((uint16_t)0x096A)
+#define USART_IT_ERR                         ((uint16_t)0x0060)
+#define USART_IT_ORE                         ((uint16_t)0x0360)
+#define USART_IT_NE                          ((uint16_t)0x0260)
+#define USART_IT_FE                          ((uint16_t)0x0160)
+#define IS_USART_CONFIG_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) || \
+                               ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
+                               ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) || \
+                               ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ERR))
+#define IS_USART_GET_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) || \
+                            ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
+                            ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) || \
+                            ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ORE) || \
+                            ((IT) == USART_IT_NE) || ((IT) == USART_IT_FE))
+#define IS_USART_CLEAR_IT(IT) (((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
+                               ((IT) == USART_IT_LBD) || ((IT) == USART_IT_CTS))
+/**
+  * @}
+  */
+
+/** @defgroup USART_DMA_Requests
+  * @{
+  */
+
+#define USART_DMAReq_Tx                      ((uint16_t)0x0080)
+#define USART_DMAReq_Rx                      ((uint16_t)0x0040)
+#define IS_USART_DMAREQ(DMAREQ) ((((DMAREQ) & (uint16_t)0xFF3F) == 0x00) && ((DMAREQ) != (uint16_t)0x00))
+
+/**
+  * @}
+  */
+
+/** @defgroup USART_WakeUp_methods
+  * @{
+  */
+
+#define USART_WakeUp_IdleLine                ((uint16_t)0x0000)
+#define USART_WakeUp_AddressMark             ((uint16_t)0x0800)
+#define IS_USART_WAKEUP(WAKEUP) (((WAKEUP) == USART_WakeUp_IdleLine) || \
+                                 ((WAKEUP) == USART_WakeUp_AddressMark))
+/**
+  * @}
+  */
+
+/** @defgroup USART_LIN_Break_Detection_Length
+  * @{
+  */
+
+#define USART_LINBreakDetectLength_10b      ((uint16_t)0x0000)
+#define USART_LINBreakDetectLength_11b      ((uint16_t)0x0020)
+#define IS_USART_LIN_BREAK_DETECT_LENGTH(LENGTH) \
+                               (((LENGTH) == USART_LINBreakDetectLength_10b) || \
+                                ((LENGTH) == USART_LINBreakDetectLength_11b))
+/**
+  * @}
+  */
+
+/** @defgroup USART_IrDA_Low_Power
+  * @{
+  */
+
+#define USART_IrDAMode_LowPower              ((uint16_t)0x0004)
+#define USART_IrDAMode_Normal                ((uint16_t)0x0000)
+#define IS_USART_IRDA_MODE(MODE) (((MODE) == USART_IrDAMode_LowPower) || \
+                                  ((MODE) == USART_IrDAMode_Normal))
+/**
+  * @}
+  */
+
+/** @defgroup USART_Flags
+  * @{
+  */
+
+#define USART_FLAG_CTS                       ((uint16_t)0x0200)
+#define USART_FLAG_LBD                       ((uint16_t)0x0100)
+#define USART_FLAG_TXE                       ((uint16_t)0x0080)
+#define USART_FLAG_TC                        ((uint16_t)0x0040)
+#define USART_FLAG_RXNE                      ((uint16_t)0x0020)
+#define USART_FLAG_IDLE                      ((uint16_t)0x0010)
+#define USART_FLAG_ORE                       ((uint16_t)0x0008)
+#define USART_FLAG_NE                        ((uint16_t)0x0004)
+#define USART_FLAG_FE                        ((uint16_t)0x0002)
+#define USART_FLAG_PE                        ((uint16_t)0x0001)
+#define IS_USART_FLAG(FLAG) (((FLAG) == USART_FLAG_PE) || ((FLAG) == USART_FLAG_TXE) || \
+                             ((FLAG) == USART_FLAG_TC) || ((FLAG) == USART_FLAG_RXNE) || \
+                             ((FLAG) == USART_FLAG_IDLE) || ((FLAG) == USART_FLAG_LBD) || \
+                             ((FLAG) == USART_FLAG_CTS) || ((FLAG) == USART_FLAG_ORE) || \
+                             ((FLAG) == USART_FLAG_NE) || ((FLAG) == USART_FLAG_FE))
+
+#define IS_USART_CLEAR_FLAG(FLAG) ((((FLAG) & (uint16_t)0xFC9F) == 0x00) && ((FLAG) != (uint16_t)0x00))
+#define IS_USART_PERIPH_FLAG(PERIPH, USART_FLAG) ((((*(uint32_t*)&(PERIPH)) != UART4_BASE) &&\
+                                                  ((*(uint32_t*)&(PERIPH)) != UART5_BASE)) \
+                                                  || ((USART_FLAG) != USART_FLAG_CTS))
+#define IS_USART_BAUDRATE(BAUDRATE) (((BAUDRATE) > 0) && ((BAUDRATE) < 0x0044AA21))
+#define IS_USART_ADDRESS(ADDRESS) ((ADDRESS) <= 0xF)
+#define IS_USART_DATA(DATA) ((DATA) <= 0x1FF)
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup USART_Exported_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup USART_Exported_Functions
+  * @{
+  */
+
+void USART_DeInit(USART_TypeDef* USARTx);
+void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct);
+void USART_StructInit(USART_InitTypeDef* USART_InitStruct);
+void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct);
+void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct);
+void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState);
+void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);
+void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState);
+void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address);
+void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp);
+void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState);
+void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength);
+void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState);
+void USART_SendData(USART_TypeDef* USARTx, uint16_t Data);
+uint16_t USART_ReceiveData(USART_TypeDef* USARTx);
+void USART_SendBreak(USART_TypeDef* USARTx);
+void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime);
+void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler);
+void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState);
+void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState);
+void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState);
+void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState);
+void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState);
+void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode);
+void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState);
+FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);
+void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG);
+ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);
+void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F10x_USART_H */
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_wwdg.h b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_wwdg.h
new file mode 100644
index 0000000..cd573da
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_wwdg.h
@@ -0,0 +1,115 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_wwdg.h
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file contains all the functions prototypes for the WWDG firmware
+  *          library.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32F10x_WWDG_H
+#define __STM32F10x_WWDG_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @addtogroup WWDG
+  * @{
+  */
+
+/** @defgroup WWDG_Exported_Types
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup WWDG_Exported_Constants
+  * @{
+  */
+
+/** @defgroup WWDG_Prescaler
+  * @{
+  */
+
+#define WWDG_Prescaler_1    ((uint32_t)0x00000000)
+#define WWDG_Prescaler_2    ((uint32_t)0x00000080)
+#define WWDG_Prescaler_4    ((uint32_t)0x00000100)
+#define WWDG_Prescaler_8    ((uint32_t)0x00000180)
+#define IS_WWDG_PRESCALER(PRESCALER) (((PRESCALER) == WWDG_Prescaler_1) || \
+                                      ((PRESCALER) == WWDG_Prescaler_2) || \
+                                      ((PRESCALER) == WWDG_Prescaler_4) || \
+                                      ((PRESCALER) == WWDG_Prescaler_8))
+#define IS_WWDG_WINDOW_VALUE(VALUE) ((VALUE) <= 0x7F)
+#define IS_WWDG_COUNTER(COUNTER) (((COUNTER) >= 0x40) && ((COUNTER) <= 0x7F))
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup WWDG_Exported_Macros
+  * @{
+  */
+/**
+  * @}
+  */
+
+/** @defgroup WWDG_Exported_Functions
+  * @{
+  */
+
+void WWDG_DeInit(void);
+void WWDG_SetPrescaler(uint32_t WWDG_Prescaler);
+void WWDG_SetWindowValue(uint8_t WindowValue);
+void WWDG_EnableIT(void);
+void WWDG_SetCounter(uint8_t Counter);
+void WWDG_Enable(uint8_t Counter);
+FlagStatus WWDG_GetFlagStatus(void);
+void WWDG_ClearFlag(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STM32F10x_WWDG_H */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/misc.c b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/misc.c
new file mode 100644
index 0000000..ec9165f
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/misc.c
@@ -0,0 +1,225 @@
+/**
+  ******************************************************************************
+  * @file    misc.c
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file provides all the miscellaneous firmware functions (add-on
+  *          to CMSIS functions).
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "misc.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup MISC
+  * @brief MISC driver modules
+  * @{
+  */
+
+/** @defgroup MISC_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup MISC_Private_Defines
+  * @{
+  */
+
+#define AIRCR_VECTKEY_MASK    ((uint32_t)0x05FA0000)
+/**
+  * @}
+  */
+
+/** @defgroup MISC_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup MISC_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup MISC_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup MISC_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Configures the priority grouping: pre-emption priority and subpriority.
+  * @param  NVIC_PriorityGroup: specifies the priority grouping bits length.
+  *   This parameter can be one of the following values:
+  *     @arg NVIC_PriorityGroup_0: 0 bits for pre-emption priority
+  *                                4 bits for subpriority
+  *     @arg NVIC_PriorityGroup_1: 1 bits for pre-emption priority
+  *                                3 bits for subpriority
+  *     @arg NVIC_PriorityGroup_2: 2 bits for pre-emption priority
+  *                                2 bits for subpriority
+  *     @arg NVIC_PriorityGroup_3: 3 bits for pre-emption priority
+  *                                1 bits for subpriority
+  *     @arg NVIC_PriorityGroup_4: 4 bits for pre-emption priority
+  *                                0 bits for subpriority
+  * @retval None
+  */
+void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)
+{
+  /* Check the parameters */
+  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
+
+  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
+  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
+}
+
+/**
+  * @brief  Initializes the NVIC peripheral according to the specified
+  *         parameters in the NVIC_InitStruct.
+  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
+  *         the configuration information for the specified NVIC peripheral.
+  * @retval None
+  */
+void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
+{
+  uint32_t tmppriority = 0x00, tmppre = 0x00, tmpsub = 0x0F;
+
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
+  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));
+  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
+
+  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
+  {
+    /* Compute the Corresponding IRQ Priority --------------------------------*/
+    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
+    tmppre = (0x4 - tmppriority);
+    tmpsub = tmpsub >> tmppriority;
+
+    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
+    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
+    tmppriority = tmppriority << 0x04;
+
+    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
+
+    /* Enable the Selected IRQ Channels --------------------------------------*/
+    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
+      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
+  }
+  else
+  {
+    /* Disable the Selected IRQ Channels -------------------------------------*/
+    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
+      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
+  }
+}
+
+/**
+  * @brief  Sets the vector table location and Offset.
+  * @param  NVIC_VectTab: specifies if the vector table is in RAM or FLASH memory.
+  *   This parameter can be one of the following values:
+  *     @arg NVIC_VectTab_RAM
+  *     @arg NVIC_VectTab_FLASH
+  * @param  Offset: Vector Table base offset field. This value must be a multiple
+  *         of 0x200.
+  * @retval None
+  */
+void NVIC_SetVectorTable(uint32_t NVIC_VectTab, uint32_t Offset)
+{
+  /* Check the parameters */
+  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
+  assert_param(IS_NVIC_OFFSET(Offset));
+
+  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);
+}
+
+/**
+  * @brief  Selects the condition for the system to enter low power mode.
+  * @param  LowPowerMode: Specifies the new mode for the system to enter low power mode.
+  *   This parameter can be one of the following values:
+  *     @arg NVIC_LP_SEVONPEND
+  *     @arg NVIC_LP_SLEEPDEEP
+  *     @arg NVIC_LP_SLEEPONEXIT
+  * @param  NewState: new state of LP condition. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void NVIC_SystemLPConfig(uint8_t LowPowerMode, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_NVIC_LP(LowPowerMode));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    SCB->SCR |= LowPowerMode;
+  }
+  else
+  {
+    SCB->SCR &= (uint32_t)(~(uint32_t)LowPowerMode);
+  }
+}
+
+/**
+  * @brief  Configures the SysTick clock source.
+  * @param  SysTick_CLKSource: specifies the SysTick clock source.
+  *   This parameter can be one of the following values:
+  *     @arg SysTick_CLKSource_HCLK_Div8: AHB clock divided by 8 selected as SysTick clock source.
+  *     @arg SysTick_CLKSource_HCLK: AHB clock selected as SysTick clock source.
+  * @retval None
+  */
+void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)
+{
+  /* Check the parameters */
+  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
+  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
+  {
+    SysTick->CTRL |= SysTick_CLKSource_HCLK;
+  }
+  else
+  {
+    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
+  }
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_adc.c b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_adc.c
new file mode 100644
index 0000000..916a096
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_adc.c
@@ -0,0 +1,1307 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_adc.c
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file provides all the ADC firmware functions.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x_adc.h"
+#include "stm32f10x_rcc.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup ADC
+  * @brief ADC driver modules
+  * @{
+  */
+
+/** @defgroup ADC_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup ADC_Private_Defines
+  * @{
+  */
+
+/* ADC DISCNUM mask */
+#define CR1_DISCNUM_Reset           ((uint32_t)0xFFFF1FFF)
+
+/* ADC DISCEN mask */
+#define CR1_DISCEN_Set              ((uint32_t)0x00000800)
+#define CR1_DISCEN_Reset            ((uint32_t)0xFFFFF7FF)
+
+/* ADC JAUTO mask */
+#define CR1_JAUTO_Set               ((uint32_t)0x00000400)
+#define CR1_JAUTO_Reset             ((uint32_t)0xFFFFFBFF)
+
+/* ADC JDISCEN mask */
+#define CR1_JDISCEN_Set             ((uint32_t)0x00001000)
+#define CR1_JDISCEN_Reset           ((uint32_t)0xFFFFEFFF)
+
+/* ADC AWDCH mask */
+#define CR1_AWDCH_Reset             ((uint32_t)0xFFFFFFE0)
+
+/* ADC Analog watchdog enable mode mask */
+#define CR1_AWDMode_Reset           ((uint32_t)0xFF3FFDFF)
+
+/* CR1 register Mask */
+#define CR1_CLEAR_Mask              ((uint32_t)0xFFF0FEFF)
+
+/* ADC ADON mask */
+#define CR2_ADON_Set                ((uint32_t)0x00000001)
+#define CR2_ADON_Reset              ((uint32_t)0xFFFFFFFE)
+
+/* ADC DMA mask */
+#define CR2_DMA_Set                 ((uint32_t)0x00000100)
+#define CR2_DMA_Reset               ((uint32_t)0xFFFFFEFF)
+
+/* ADC RSTCAL mask */
+#define CR2_RSTCAL_Set              ((uint32_t)0x00000008)
+
+/* ADC CAL mask */
+#define CR2_CAL_Set                 ((uint32_t)0x00000004)
+
+/* ADC SWSTART mask */
+#define CR2_SWSTART_Set             ((uint32_t)0x00400000)
+
+/* ADC EXTTRIG mask */
+#define CR2_EXTTRIG_Set             ((uint32_t)0x00100000)
+#define CR2_EXTTRIG_Reset           ((uint32_t)0xFFEFFFFF)
+
+/* ADC Software start mask */
+#define CR2_EXTTRIG_SWSTART_Set     ((uint32_t)0x00500000)
+#define CR2_EXTTRIG_SWSTART_Reset   ((uint32_t)0xFFAFFFFF)
+
+/* ADC JEXTSEL mask */
+#define CR2_JEXTSEL_Reset           ((uint32_t)0xFFFF8FFF)
+
+/* ADC JEXTTRIG mask */
+#define CR2_JEXTTRIG_Set            ((uint32_t)0x00008000)
+#define CR2_JEXTTRIG_Reset          ((uint32_t)0xFFFF7FFF)
+
+/* ADC JSWSTART mask */
+#define CR2_JSWSTART_Set            ((uint32_t)0x00200000)
+
+/* ADC injected software start mask */
+#define CR2_JEXTTRIG_JSWSTART_Set   ((uint32_t)0x00208000)
+#define CR2_JEXTTRIG_JSWSTART_Reset ((uint32_t)0xFFDF7FFF)
+
+/* ADC TSPD mask */
+#define CR2_TSVREFE_Set             ((uint32_t)0x00800000)
+#define CR2_TSVREFE_Reset           ((uint32_t)0xFF7FFFFF)
+
+/* CR2 register Mask */
+#define CR2_CLEAR_Mask              ((uint32_t)0xFFF1F7FD)
+
+/* ADC SQx mask */
+#define SQR3_SQ_Set                 ((uint32_t)0x0000001F)
+#define SQR2_SQ_Set                 ((uint32_t)0x0000001F)
+#define SQR1_SQ_Set                 ((uint32_t)0x0000001F)
+
+/* SQR1 register Mask */
+#define SQR1_CLEAR_Mask             ((uint32_t)0xFF0FFFFF)
+
+/* ADC JSQx mask */
+#define JSQR_JSQ_Set                ((uint32_t)0x0000001F)
+
+/* ADC JL mask */
+#define JSQR_JL_Set                 ((uint32_t)0x00300000)
+#define JSQR_JL_Reset               ((uint32_t)0xFFCFFFFF)
+
+/* ADC SMPx mask */
+#define SMPR1_SMP_Set               ((uint32_t)0x00000007)
+#define SMPR2_SMP_Set               ((uint32_t)0x00000007)
+
+/* ADC JDRx registers offset */
+#define JDR_Offset                  ((uint8_t)0x28)
+
+/* ADC1 DR register base address */
+#define DR_ADDRESS                  ((uint32_t)0x4001244C)
+
+/**
+  * @}
+  */
+
+/** @defgroup ADC_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup ADC_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup ADC_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup ADC_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the ADCx peripheral registers to their default reset values.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @retval None
+  */
+void ADC_DeInit(ADC_TypeDef* ADCx)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+
+  if (ADCx == ADC1)
+  {
+    /* Enable ADC1 reset state */
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
+    /* Release ADC1 from reset state */
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
+  }
+  else if (ADCx == ADC2)
+  {
+    /* Enable ADC2 reset state */
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, ENABLE);
+    /* Release ADC2 from reset state */
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, DISABLE);
+  }
+  else
+  {
+    if (ADCx == ADC3)
+    {
+      /* Enable ADC3 reset state */
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, ENABLE);
+      /* Release ADC3 from reset state */
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, DISABLE);
+    }
+  }
+}
+
+/**
+  * @brief  Initializes the ADCx peripheral according to the specified parameters
+  *         in the ADC_InitStruct.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
+  *         the configuration information for the specified ADC peripheral.
+  * @retval None
+  */
+void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
+{
+  uint32_t tmpreg1 = 0;
+  uint8_t tmpreg2 = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_MODE(ADC_InitStruct->ADC_Mode));
+  assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
+  assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode));
+  assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));
+  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign));
+  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfChannel));
+
+  /*---------------------------- ADCx CR1 Configuration -----------------*/
+  /* Get the ADCx CR1 value */
+  tmpreg1 = ADCx->CR1;
+  /* Clear DUALMOD and SCAN bits */
+  tmpreg1 &= CR1_CLEAR_Mask;
+  /* Configure ADCx: Dual mode and scan conversion mode */
+  /* Set DUALMOD bits according to ADC_Mode value */
+  /* Set SCAN bit according to ADC_ScanConvMode value */
+  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_Mode | ((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8));
+  /* Write to ADCx CR1 */
+  ADCx->CR1 = tmpreg1;
+
+  /*---------------------------- ADCx CR2 Configuration -----------------*/
+  /* Get the ADCx CR2 value */
+  tmpreg1 = ADCx->CR2;
+  /* Clear CONT, ALIGN and EXTSEL bits */
+  tmpreg1 &= CR2_CLEAR_Mask;
+  /* Configure ADCx: external trigger event and continuous conversion mode */
+  /* Set ALIGN bit according to ADC_DataAlign value */
+  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
+  /* Set CONT bit according to ADC_ContinuousConvMode value */
+  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
+            ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
+  /* Write to ADCx CR2 */
+  ADCx->CR2 = tmpreg1;
+
+  /*---------------------------- ADCx SQR1 Configuration -----------------*/
+  /* Get the ADCx SQR1 value */
+  tmpreg1 = ADCx->SQR1;
+  /* Clear L bits */
+  tmpreg1 &= SQR1_CLEAR_Mask;
+  /* Configure ADCx: regular channel sequence length */
+  /* Set L bits according to ADC_NbrOfChannel value */
+  tmpreg2 |= (uint8_t) (ADC_InitStruct->ADC_NbrOfChannel - (uint8_t)1);
+  tmpreg1 |= (uint32_t)tmpreg2 << 20;
+  /* Write to ADCx SQR1 */
+  ADCx->SQR1 = tmpreg1;
+}
+
+/**
+  * @brief  Fills each ADC_InitStruct member with its default value.
+  * @param  ADC_InitStruct : pointer to an ADC_InitTypeDef structure which will be initialized.
+  * @retval None
+  */
+void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
+{
+  /* Reset ADC init structure parameters values */
+  /* Initialize the ADC_Mode member */
+  ADC_InitStruct->ADC_Mode = ADC_Mode_Independent;
+  /* initialize the ADC_ScanConvMode member */
+  ADC_InitStruct->ADC_ScanConvMode = DISABLE;
+  /* Initialize the ADC_ContinuousConvMode member */
+  ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
+  /* Initialize the ADC_ExternalTrigConv member */
+  ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
+  /* Initialize the ADC_DataAlign member */
+  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
+  /* Initialize the ADC_NbrOfChannel member */
+  ADC_InitStruct->ADC_NbrOfChannel = 1;
+}
+
+/**
+  * @brief  Enables or disables the specified ADC peripheral.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  NewState: new state of the ADCx peripheral.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Set the ADON bit to wake up the ADC from power down mode */
+    ADCx->CR2 |= CR2_ADON_Set;
+  }
+  else
+  {
+    /* Disable the selected ADC peripheral */
+    ADCx->CR2 &= CR2_ADON_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified ADC DMA request.
+  * @param  ADCx: where x can be 1 or 3 to select the ADC peripheral.
+  *   Note: ADC2 hasn't a DMA capability.
+  * @param  NewState: new state of the selected ADC DMA transfer.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_DMA_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC DMA request */
+    ADCx->CR2 |= CR2_DMA_Set;
+  }
+  else
+  {
+    /* Disable the selected ADC DMA request */
+    ADCx->CR2 &= CR2_DMA_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified ADC interrupts.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_IT: specifies the ADC interrupt sources to be enabled or disabled.
+  *   This parameter can be any combination of the following values:
+  *     @arg ADC_IT_EOC: End of conversion interrupt mask
+  *     @arg ADC_IT_AWD: Analog watchdog interrupt mask
+  *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask
+  * @param  NewState: new state of the specified ADC interrupts.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)
+{
+  uint8_t itmask = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  assert_param(IS_ADC_IT(ADC_IT));
+  /* Get the ADC IT index */
+  itmask = (uint8_t)ADC_IT;
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC interrupts */
+    ADCx->CR1 |= itmask;
+  }
+  else
+  {
+    /* Disable the selected ADC interrupts */
+    ADCx->CR1 &= (~(uint32_t)itmask);
+  }
+}
+
+/**
+  * @brief  Resets the selected ADC calibration registers.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @retval None
+  */
+void ADC_ResetCalibration(ADC_TypeDef* ADCx)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  /* Resets the selected ADC calibration registers */
+  ADCx->CR2 |= CR2_RSTCAL_Set;
+}
+
+/**
+  * @brief  Gets the selected ADC reset calibration registers status.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @retval The new state of ADC reset calibration registers (SET or RESET).
+  */
+FlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  /* Check the status of RSTCAL bit */
+  if ((ADCx->CR2 & CR2_RSTCAL_Set) != (uint32_t)RESET)
+  {
+    /* RSTCAL bit is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* RSTCAL bit is reset */
+    bitstatus = RESET;
+  }
+  /* Return the RSTCAL bit status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Starts the selected ADC calibration process.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @retval None
+  */
+void ADC_StartCalibration(ADC_TypeDef* ADCx)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  /* Enable the selected ADC calibration process */
+  ADCx->CR2 |= CR2_CAL_Set;
+}
+
+/**
+  * @brief  Gets the selected ADC calibration status.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @retval The new state of ADC calibration (SET or RESET).
+  */
+FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  /* Check the status of CAL bit */
+  if ((ADCx->CR2 & CR2_CAL_Set) != (uint32_t)RESET)
+  {
+    /* CAL bit is set: calibration on going */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* CAL bit is reset: end of calibration */
+    bitstatus = RESET;
+  }
+  /* Return the CAL bit status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Enables or disables the selected ADC software start conversion .
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  NewState: new state of the selected ADC software start conversion.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC conversion on external event and start the selected
+       ADC conversion */
+    ADCx->CR2 |= CR2_EXTTRIG_SWSTART_Set;
+  }
+  else
+  {
+    /* Disable the selected ADC conversion on external event and stop the selected
+       ADC conversion */
+    ADCx->CR2 &= CR2_EXTTRIG_SWSTART_Reset;
+  }
+}
+
+/**
+  * @brief  Gets the selected ADC Software start conversion Status.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @retval The new state of ADC software start conversion (SET or RESET).
+  */
+FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  /* Check the status of SWSTART bit */
+  if ((ADCx->CR2 & CR2_SWSTART_Set) != (uint32_t)RESET)
+  {
+    /* SWSTART bit is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* SWSTART bit is reset */
+    bitstatus = RESET;
+  }
+  /* Return the SWSTART bit status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Configures the discontinuous mode for the selected ADC regular
+  *         group channel.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  Number: specifies the discontinuous mode regular channel
+  *         count value. This number must be between 1 and 8.
+  * @retval None
+  */
+void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)
+{
+  uint32_t tmpreg1 = 0;
+  uint32_t tmpreg2 = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
+  /* Get the old register value */
+  tmpreg1 = ADCx->CR1;
+  /* Clear the old discontinuous mode channel count */
+  tmpreg1 &= CR1_DISCNUM_Reset;
+  /* Set the discontinuous mode channel count */
+  tmpreg2 = Number - 1;
+  tmpreg1 |= tmpreg2 << 13;
+  /* Store the new register value */
+  ADCx->CR1 = tmpreg1;
+}
+
+/**
+  * @brief  Enables or disables the discontinuous mode on regular group
+  *         channel for the specified ADC
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  NewState: new state of the selected ADC discontinuous mode
+  *         on regular group channel.
+  *         This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC regular discontinuous mode */
+    ADCx->CR1 |= CR1_DISCEN_Set;
+  }
+  else
+  {
+    /* Disable the selected ADC regular discontinuous mode */
+    ADCx->CR1 &= CR1_DISCEN_Reset;
+  }
+}
+
+/**
+  * @brief  Configures for the selected ADC regular channel its corresponding
+  *         rank in the sequencer and its sample time.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_Channel: the ADC channel to configure.
+  *   This parameter can be one of the following values:
+  *     @arg ADC_Channel_0: ADC Channel0 selected
+  *     @arg ADC_Channel_1: ADC Channel1 selected
+  *     @arg ADC_Channel_2: ADC Channel2 selected
+  *     @arg ADC_Channel_3: ADC Channel3 selected
+  *     @arg ADC_Channel_4: ADC Channel4 selected
+  *     @arg ADC_Channel_5: ADC Channel5 selected
+  *     @arg ADC_Channel_6: ADC Channel6 selected
+  *     @arg ADC_Channel_7: ADC Channel7 selected
+  *     @arg ADC_Channel_8: ADC Channel8 selected
+  *     @arg ADC_Channel_9: ADC Channel9 selected
+  *     @arg ADC_Channel_10: ADC Channel10 selected
+  *     @arg ADC_Channel_11: ADC Channel11 selected
+  *     @arg ADC_Channel_12: ADC Channel12 selected
+  *     @arg ADC_Channel_13: ADC Channel13 selected
+  *     @arg ADC_Channel_14: ADC Channel14 selected
+  *     @arg ADC_Channel_15: ADC Channel15 selected
+  *     @arg ADC_Channel_16: ADC Channel16 selected
+  *     @arg ADC_Channel_17: ADC Channel17 selected
+  * @param  Rank: The rank in the regular group sequencer. This parameter must be between 1 to 16.
+  * @param  ADC_SampleTime: The sample time value to be set for the selected channel.
+  *   This parameter can be one of the following values:
+  *     @arg ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles
+  *     @arg ADC_SampleTime_7Cycles5: Sample time equal to 7.5 cycles
+  *     @arg ADC_SampleTime_13Cycles5: Sample time equal to 13.5 cycles
+  *     @arg ADC_SampleTime_28Cycles5: Sample time equal to 28.5 cycles
+  *     @arg ADC_SampleTime_41Cycles5: Sample time equal to 41.5 cycles
+  *     @arg ADC_SampleTime_55Cycles5: Sample time equal to 55.5 cycles
+  *     @arg ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles
+  *     @arg ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles
+  * @retval None
+  */
+void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
+{
+  uint32_t tmpreg1 = 0, tmpreg2 = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_CHANNEL(ADC_Channel));
+  assert_param(IS_ADC_REGULAR_RANK(Rank));
+  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
+  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
+  if (ADC_Channel > ADC_Channel_9)
+  {
+    /* Get the old register value */
+    tmpreg1 = ADCx->SMPR1;
+    /* Calculate the mask to clear */
+    tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
+    /* Clear the old channel sample time */
+    tmpreg1 &= ~tmpreg2;
+    /* Calculate the mask to set */
+    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
+    /* Set the new channel sample time */
+    tmpreg1 |= tmpreg2;
+    /* Store the new register value */
+    ADCx->SMPR1 = tmpreg1;
+  }
+  else /* ADC_Channel include in ADC_Channel_[0..9] */
+  {
+    /* Get the old register value */
+    tmpreg1 = ADCx->SMPR2;
+    /* Calculate the mask to clear */
+    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
+    /* Clear the old channel sample time */
+    tmpreg1 &= ~tmpreg2;
+    /* Calculate the mask to set */
+    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
+    /* Set the new channel sample time */
+    tmpreg1 |= tmpreg2;
+    /* Store the new register value */
+    ADCx->SMPR2 = tmpreg1;
+  }
+  /* For Rank 1 to 6 */
+  if (Rank < 7)
+  {
+    /* Get the old register value */
+    tmpreg1 = ADCx->SQR3;
+    /* Calculate the mask to clear */
+    tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
+    /* Clear the old SQx bits for the selected rank */
+    tmpreg1 &= ~tmpreg2;
+    /* Calculate the mask to set */
+    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
+    /* Set the SQx bits for the selected rank */
+    tmpreg1 |= tmpreg2;
+    /* Store the new register value */
+    ADCx->SQR3 = tmpreg1;
+  }
+  /* For Rank 7 to 12 */
+  else if (Rank < 13)
+  {
+    /* Get the old register value */
+    tmpreg1 = ADCx->SQR2;
+    /* Calculate the mask to clear */
+    tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
+    /* Clear the old SQx bits for the selected rank */
+    tmpreg1 &= ~tmpreg2;
+    /* Calculate the mask to set */
+    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
+    /* Set the SQx bits for the selected rank */
+    tmpreg1 |= tmpreg2;
+    /* Store the new register value */
+    ADCx->SQR2 = tmpreg1;
+  }
+  /* For Rank 13 to 16 */
+  else
+  {
+    /* Get the old register value */
+    tmpreg1 = ADCx->SQR1;
+    /* Calculate the mask to clear */
+    tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
+    /* Clear the old SQx bits for the selected rank */
+    tmpreg1 &= ~tmpreg2;
+    /* Calculate the mask to set */
+    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
+    /* Set the SQx bits for the selected rank */
+    tmpreg1 |= tmpreg2;
+    /* Store the new register value */
+    ADCx->SQR1 = tmpreg1;
+  }
+}
+
+/**
+  * @brief  Enables or disables the ADCx conversion through external trigger.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  NewState: new state of the selected ADC external trigger start of conversion.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC conversion on external event */
+    ADCx->CR2 |= CR2_EXTTRIG_Set;
+  }
+  else
+  {
+    /* Disable the selected ADC conversion on external event */
+    ADCx->CR2 &= CR2_EXTTRIG_Reset;
+  }
+}
+
+/**
+  * @brief  Returns the last ADCx conversion result data for regular channel.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @retval The Data conversion value.
+  */
+uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  /* Return the selected ADC conversion value */
+  return (uint16_t) ADCx->DR;
+}
+
+/**
+  * @brief  Returns the last ADC1 and ADC2 conversion result data in dual mode.
+  * @retval The Data conversion value.
+  */
+uint32_t ADC_GetDualModeConversionValue(void)
+{
+  /* Return the dual mode conversion value */
+  return (*(__IO uint32_t *) DR_ADDRESS);
+}
+
+/**
+  * @brief  Enables or disables the selected ADC automatic injected group
+  *         conversion after regular one.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  NewState: new state of the selected ADC auto injected conversion
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC automatic injected group conversion */
+    ADCx->CR1 |= CR1_JAUTO_Set;
+  }
+  else
+  {
+    /* Disable the selected ADC automatic injected group conversion */
+    ADCx->CR1 &= CR1_JAUTO_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the discontinuous mode for injected group
+  *         channel for the specified ADC
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  NewState: new state of the selected ADC discontinuous mode
+  *         on injected group channel.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC injected discontinuous mode */
+    ADCx->CR1 |= CR1_JDISCEN_Set;
+  }
+  else
+  {
+    /* Disable the selected ADC injected discontinuous mode */
+    ADCx->CR1 &= CR1_JDISCEN_Reset;
+  }
+}
+
+/**
+  * @brief  Configures the ADCx external trigger for injected channels conversion.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_ExternalTrigInjecConv: specifies the ADC trigger to start injected conversion.
+  *   This parameter can be one of the following values:
+  *     @arg ADC_ExternalTrigInjecConv_T1_TRGO: Timer1 TRGO event selected (for ADC1, ADC2 and ADC3)
+  *     @arg ADC_ExternalTrigInjecConv_T1_CC4: Timer1 capture compare4 selected (for ADC1, ADC2 and ADC3)
+  *     @arg ADC_ExternalTrigInjecConv_T2_TRGO: Timer2 TRGO event selected (for ADC1 and ADC2)
+  *     @arg ADC_ExternalTrigInjecConv_T2_CC1: Timer2 capture compare1 selected (for ADC1 and ADC2)
+  *     @arg ADC_ExternalTrigInjecConv_T3_CC4: Timer3 capture compare4 selected (for ADC1 and ADC2)
+  *     @arg ADC_ExternalTrigInjecConv_T4_TRGO: Timer4 TRGO event selected (for ADC1 and ADC2)
+  *     @arg ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4: External interrupt line 15 or Timer8
+  *                                                       capture compare4 event selected (for ADC1 and ADC2)
+  *     @arg ADC_ExternalTrigInjecConv_T4_CC3: Timer4 capture compare3 selected (for ADC3 only)
+  *     @arg ADC_ExternalTrigInjecConv_T8_CC2: Timer8 capture compare2 selected (for ADC3 only)
+  *     @arg ADC_ExternalTrigInjecConv_T8_CC4: Timer8 capture compare4 selected (for ADC3 only)
+  *     @arg ADC_ExternalTrigInjecConv_T5_TRGO: Timer5 TRGO event selected (for ADC3 only)
+  *     @arg ADC_ExternalTrigInjecConv_T5_CC4: Timer5 capture compare4 selected (for ADC3 only)
+  *     @arg ADC_ExternalTrigInjecConv_None: Injected conversion started by software and not
+  *                                          by external trigger (for ADC1, ADC2 and ADC3)
+  * @retval None
+  */
+void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv)
+{
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
+  /* Get the old register value */
+  tmpreg = ADCx->CR2;
+  /* Clear the old external event selection for injected group */
+  tmpreg &= CR2_JEXTSEL_Reset;
+  /* Set the external event selection for injected group */
+  tmpreg |= ADC_ExternalTrigInjecConv;
+  /* Store the new register value */
+  ADCx->CR2 = tmpreg;
+}
+
+/**
+  * @brief  Enables or disables the ADCx injected channels conversion through
+  *         external trigger
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  NewState: new state of the selected ADC external trigger start of
+  *         injected conversion.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC external event selection for injected group */
+    ADCx->CR2 |= CR2_JEXTTRIG_Set;
+  }
+  else
+  {
+    /* Disable the selected ADC external event selection for injected group */
+    ADCx->CR2 &= CR2_JEXTTRIG_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the selected ADC start of the injected
+  *         channels conversion.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  NewState: new state of the selected ADC software start injected conversion.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC conversion for injected group on external event and start the selected
+       ADC injected conversion */
+    ADCx->CR2 |= CR2_JEXTTRIG_JSWSTART_Set;
+  }
+  else
+  {
+    /* Disable the selected ADC conversion on external event for injected group and stop the selected
+       ADC injected conversion */
+    ADCx->CR2 &= CR2_JEXTTRIG_JSWSTART_Reset;
+  }
+}
+
+/**
+  * @brief  Gets the selected ADC Software start injected conversion Status.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @retval The new state of ADC software start injected conversion (SET or RESET).
+  */
+FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  /* Check the status of JSWSTART bit */
+  if ((ADCx->CR2 & CR2_JSWSTART_Set) != (uint32_t)RESET)
+  {
+    /* JSWSTART bit is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* JSWSTART bit is reset */
+    bitstatus = RESET;
+  }
+  /* Return the JSWSTART bit status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Configures for the selected ADC injected channel its corresponding
+  *         rank in the sequencer and its sample time.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_Channel: the ADC channel to configure.
+  *   This parameter can be one of the following values:
+  *     @arg ADC_Channel_0: ADC Channel0 selected
+  *     @arg ADC_Channel_1: ADC Channel1 selected
+  *     @arg ADC_Channel_2: ADC Channel2 selected
+  *     @arg ADC_Channel_3: ADC Channel3 selected
+  *     @arg ADC_Channel_4: ADC Channel4 selected
+  *     @arg ADC_Channel_5: ADC Channel5 selected
+  *     @arg ADC_Channel_6: ADC Channel6 selected
+  *     @arg ADC_Channel_7: ADC Channel7 selected
+  *     @arg ADC_Channel_8: ADC Channel8 selected
+  *     @arg ADC_Channel_9: ADC Channel9 selected
+  *     @arg ADC_Channel_10: ADC Channel10 selected
+  *     @arg ADC_Channel_11: ADC Channel11 selected
+  *     @arg ADC_Channel_12: ADC Channel12 selected
+  *     @arg ADC_Channel_13: ADC Channel13 selected
+  *     @arg ADC_Channel_14: ADC Channel14 selected
+  *     @arg ADC_Channel_15: ADC Channel15 selected
+  *     @arg ADC_Channel_16: ADC Channel16 selected
+  *     @arg ADC_Channel_17: ADC Channel17 selected
+  * @param  Rank: The rank in the injected group sequencer. This parameter must be between 1 and 4.
+  * @param  ADC_SampleTime: The sample time value to be set for the selected channel.
+  *   This parameter can be one of the following values:
+  *     @arg ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles
+  *     @arg ADC_SampleTime_7Cycles5: Sample time equal to 7.5 cycles
+  *     @arg ADC_SampleTime_13Cycles5: Sample time equal to 13.5 cycles
+  *     @arg ADC_SampleTime_28Cycles5: Sample time equal to 28.5 cycles
+  *     @arg ADC_SampleTime_41Cycles5: Sample time equal to 41.5 cycles
+  *     @arg ADC_SampleTime_55Cycles5: Sample time equal to 55.5 cycles
+  *     @arg ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles
+  *     @arg ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles
+  * @retval None
+  */
+void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
+{
+  uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_CHANNEL(ADC_Channel));
+  assert_param(IS_ADC_INJECTED_RANK(Rank));
+  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
+  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
+  if (ADC_Channel > ADC_Channel_9)
+  {
+    /* Get the old register value */
+    tmpreg1 = ADCx->SMPR1;
+    /* Calculate the mask to clear */
+    tmpreg2 = SMPR1_SMP_Set << (3*(ADC_Channel - 10));
+    /* Clear the old channel sample time */
+    tmpreg1 &= ~tmpreg2;
+    /* Calculate the mask to set */
+    tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
+    /* Set the new channel sample time */
+    tmpreg1 |= tmpreg2;
+    /* Store the new register value */
+    ADCx->SMPR1 = tmpreg1;
+  }
+  else /* ADC_Channel include in ADC_Channel_[0..9] */
+  {
+    /* Get the old register value */
+    tmpreg1 = ADCx->SMPR2;
+    /* Calculate the mask to clear */
+    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
+    /* Clear the old channel sample time */
+    tmpreg1 &= ~tmpreg2;
+    /* Calculate the mask to set */
+    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
+    /* Set the new channel sample time */
+    tmpreg1 |= tmpreg2;
+    /* Store the new register value */
+    ADCx->SMPR2 = tmpreg1;
+  }
+  /* Rank configuration */
+  /* Get the old register value */
+  tmpreg1 = ADCx->JSQR;
+  /* Get JL value: Number = JL+1 */
+  tmpreg3 =  (tmpreg1 & JSQR_JL_Set)>> 20;
+  /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
+  tmpreg2 = JSQR_JSQ_Set << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
+  /* Clear the old JSQx bits for the selected rank */
+  tmpreg1 &= ~tmpreg2;
+  /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
+  tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
+  /* Set the JSQx bits for the selected rank */
+  tmpreg1 |= tmpreg2;
+  /* Store the new register value */
+  ADCx->JSQR = tmpreg1;
+}
+
+/**
+  * @brief  Configures the sequencer length for injected channels
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  Length: The sequencer length.
+  *   This parameter must be a number between 1 to 4.
+  * @retval None
+  */
+void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)
+{
+  uint32_t tmpreg1 = 0;
+  uint32_t tmpreg2 = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_INJECTED_LENGTH(Length));
+
+  /* Get the old register value */
+  tmpreg1 = ADCx->JSQR;
+  /* Clear the old injected sequnence lenght JL bits */
+  tmpreg1 &= JSQR_JL_Reset;
+  /* Set the injected sequnence lenght JL bits */
+  tmpreg2 = Length - 1;
+  tmpreg1 |= tmpreg2 << 20;
+  /* Store the new register value */
+  ADCx->JSQR = tmpreg1;
+}
+
+/**
+  * @brief  Set the injected channels conversion value offset
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_InjectedChannel: the ADC injected channel to set its offset.
+  *   This parameter can be one of the following values:
+  *     @arg ADC_InjectedChannel_1: Injected Channel1 selected
+  *     @arg ADC_InjectedChannel_2: Injected Channel2 selected
+  *     @arg ADC_InjectedChannel_3: Injected Channel3 selected
+  *     @arg ADC_InjectedChannel_4: Injected Channel4 selected
+  * @param  Offset: the offset value for the selected ADC injected channel
+  *   This parameter must be a 12bit value.
+  * @retval None
+  */
+void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
+{
+  __IO uint32_t tmp = 0;
+
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
+  assert_param(IS_ADC_OFFSET(Offset));
+
+  tmp = (uint32_t)ADCx;
+  tmp += ADC_InjectedChannel;
+
+  /* Set the selected injected channel data offset */
+  *(__IO uint32_t *) tmp = (uint32_t)Offset;
+}
+
+/**
+  * @brief  Returns the ADC injected channel conversion result
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_InjectedChannel: the converted ADC injected channel.
+  *   This parameter can be one of the following values:
+  *     @arg ADC_InjectedChannel_1: Injected Channel1 selected
+  *     @arg ADC_InjectedChannel_2: Injected Channel2 selected
+  *     @arg ADC_InjectedChannel_3: Injected Channel3 selected
+  *     @arg ADC_InjectedChannel_4: Injected Channel4 selected
+  * @retval The Data conversion value.
+  */
+uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
+{
+  __IO uint32_t tmp = 0;
+
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
+
+  tmp = (uint32_t)ADCx;
+  tmp += ADC_InjectedChannel + JDR_Offset;
+
+  /* Returns the selected injected channel conversion data value */
+  return (uint16_t) (*(__IO uint32_t*)  tmp);
+}
+
+/**
+  * @brief  Enables or disables the analog watchdog on single/all regular
+  *         or injected channels
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_AnalogWatchdog: the ADC analog watchdog configuration.
+  *   This parameter can be one of the following values:
+  *     @arg ADC_AnalogWatchdog_SingleRegEnable: Analog watchdog on a single regular channel
+  *     @arg ADC_AnalogWatchdog_SingleInjecEnable: Analog watchdog on a single injected channel
+  *     @arg ADC_AnalogWatchdog_SingleRegOrInjecEnable: Analog watchdog on a single regular or injected channel
+  *     @arg ADC_AnalogWatchdog_AllRegEnable: Analog watchdog on  all regular channel
+  *     @arg ADC_AnalogWatchdog_AllInjecEnable: Analog watchdog on  all injected channel
+  *     @arg ADC_AnalogWatchdog_AllRegAllInjecEnable: Analog watchdog on all regular and injected channels
+  *     @arg ADC_AnalogWatchdog_None: No channel guarded by the analog watchdog
+  * @retval None
+  */
+void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
+{
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
+  /* Get the old register value */
+  tmpreg = ADCx->CR1;
+  /* Clear AWDEN, AWDENJ and AWDSGL bits */
+  tmpreg &= CR1_AWDMode_Reset;
+  /* Set the analog watchdog enable mode */
+  tmpreg |= ADC_AnalogWatchdog;
+  /* Store the new register value */
+  ADCx->CR1 = tmpreg;
+}
+
+/**
+  * @brief  Configures the high and low thresholds of the analog watchdog.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  HighThreshold: the ADC analog watchdog High threshold value.
+  *   This parameter must be a 12bit value.
+  * @param  LowThreshold: the ADC analog watchdog Low threshold value.
+  *   This parameter must be a 12bit value.
+  * @retval None
+  */
+void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
+                                        uint16_t LowThreshold)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_THRESHOLD(HighThreshold));
+  assert_param(IS_ADC_THRESHOLD(LowThreshold));
+  /* Set the ADCx high threshold */
+  ADCx->HTR = HighThreshold;
+  /* Set the ADCx low threshold */
+  ADCx->LTR = LowThreshold;
+}
+
+/**
+  * @brief  Configures the analog watchdog guarded single channel
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_Channel: the ADC channel to configure for the analog watchdog.
+  *   This parameter can be one of the following values:
+  *     @arg ADC_Channel_0: ADC Channel0 selected
+  *     @arg ADC_Channel_1: ADC Channel1 selected
+  *     @arg ADC_Channel_2: ADC Channel2 selected
+  *     @arg ADC_Channel_3: ADC Channel3 selected
+  *     @arg ADC_Channel_4: ADC Channel4 selected
+  *     @arg ADC_Channel_5: ADC Channel5 selected
+  *     @arg ADC_Channel_6: ADC Channel6 selected
+  *     @arg ADC_Channel_7: ADC Channel7 selected
+  *     @arg ADC_Channel_8: ADC Channel8 selected
+  *     @arg ADC_Channel_9: ADC Channel9 selected
+  *     @arg ADC_Channel_10: ADC Channel10 selected
+  *     @arg ADC_Channel_11: ADC Channel11 selected
+  *     @arg ADC_Channel_12: ADC Channel12 selected
+  *     @arg ADC_Channel_13: ADC Channel13 selected
+  *     @arg ADC_Channel_14: ADC Channel14 selected
+  *     @arg ADC_Channel_15: ADC Channel15 selected
+  *     @arg ADC_Channel_16: ADC Channel16 selected
+  *     @arg ADC_Channel_17: ADC Channel17 selected
+  * @retval None
+  */
+void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
+{
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_CHANNEL(ADC_Channel));
+  /* Get the old register value */
+  tmpreg = ADCx->CR1;
+  /* Clear the Analog watchdog channel select bits */
+  tmpreg &= CR1_AWDCH_Reset;
+  /* Set the Analog watchdog channel */
+  tmpreg |= ADC_Channel;
+  /* Store the new register value */
+  ADCx->CR1 = tmpreg;
+}
+
+/**
+  * @brief  Enables or disables the temperature sensor and Vrefint channel.
+  * @param  NewState: new state of the temperature sensor.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void ADC_TempSensorVrefintCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the temperature sensor and Vrefint channel*/
+    ADC1->CR2 |= CR2_TSVREFE_Set;
+  }
+  else
+  {
+    /* Disable the temperature sensor and Vrefint channel*/
+    ADC1->CR2 &= CR2_TSVREFE_Reset;
+  }
+}
+
+/**
+  * @brief  Checks whether the specified ADC flag is set or not.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_FLAG: specifies the flag to check.
+  *   This parameter can be one of the following values:
+  *     @arg ADC_FLAG_AWD: Analog watchdog flag
+  *     @arg ADC_FLAG_EOC: End of conversion flag
+  *     @arg ADC_FLAG_JEOC: End of injected group conversion flag
+  *     @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
+  *     @arg ADC_FLAG_STRT: Start of regular group conversion flag
+  * @retval The new state of ADC_FLAG (SET or RESET).
+  */
+FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
+  /* Check the status of the specified ADC flag */
+  if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
+  {
+    /* ADC_FLAG is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* ADC_FLAG is reset */
+    bitstatus = RESET;
+  }
+  /* Return the ADC_FLAG status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the ADCx's pending flags.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_FLAG: specifies the flag to clear.
+  *   This parameter can be any combination of the following values:
+  *     @arg ADC_FLAG_AWD: Analog watchdog flag
+  *     @arg ADC_FLAG_EOC: End of conversion flag
+  *     @arg ADC_FLAG_JEOC: End of injected group conversion flag
+  *     @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
+  *     @arg ADC_FLAG_STRT: Start of regular group conversion flag
+  * @retval None
+  */
+void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
+  /* Clear the selected ADC flags */
+  ADCx->SR = ~(uint32_t)ADC_FLAG;
+}
+
+/**
+  * @brief  Checks whether the specified ADC interrupt has occurred or not.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_IT: specifies the ADC interrupt source to check.
+  *   This parameter can be one of the following values:
+  *     @arg ADC_IT_EOC: End of conversion interrupt mask
+  *     @arg ADC_IT_AWD: Analog watchdog interrupt mask
+  *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask
+  * @retval The new state of ADC_IT (SET or RESET).
+  */
+ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
+{
+  ITStatus bitstatus = RESET;
+  uint32_t itmask = 0, enablestatus = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_GET_IT(ADC_IT));
+  /* Get the ADC IT index */
+  itmask = ADC_IT >> 8;
+  /* Get the ADC_IT enable bit status */
+  enablestatus = (ADCx->CR1 & (uint8_t)ADC_IT) ;
+  /* Check the status of the specified ADC interrupt */
+  if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
+  {
+    /* ADC_IT is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* ADC_IT is reset */
+    bitstatus = RESET;
+  }
+  /* Return the ADC_IT status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the ADCx's interrupt pending bits.
+  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+  * @param  ADC_IT: specifies the ADC interrupt pending bit to clear.
+  *   This parameter can be any combination of the following values:
+  *     @arg ADC_IT_EOC: End of conversion interrupt mask
+  *     @arg ADC_IT_AWD: Analog watchdog interrupt mask
+  *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask
+  * @retval None
+  */
+void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)
+{
+  uint8_t itmask = 0;
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_IT(ADC_IT));
+  /* Get the ADC IT index */
+  itmask = (uint8_t)(ADC_IT >> 8);
+  /* Clear the selected ADC interrupt pending bits */
+  ADCx->SR = ~(uint32_t)itmask;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_bkp.c b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_bkp.c
new file mode 100644
index 0000000..3004b9e
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_bkp.c
@@ -0,0 +1,308 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_bkp.c
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file provides all the BKP firmware functions.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x_bkp.h"
+#include "stm32f10x_rcc.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup BKP
+  * @brief BKP driver modules
+  * @{
+  */
+
+/** @defgroup BKP_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup BKP_Private_Defines
+  * @{
+  */
+
+/* ------------ BKP registers bit address in the alias region --------------- */
+#define BKP_OFFSET        (BKP_BASE - PERIPH_BASE)
+
+/* --- CR Register ----*/
+
+/* Alias word address of TPAL bit */
+#define CR_OFFSET         (BKP_OFFSET + 0x30)
+#define TPAL_BitNumber    0x01
+#define CR_TPAL_BB        (PERIPH_BB_BASE + (CR_OFFSET * 32) + (TPAL_BitNumber * 4))
+
+/* Alias word address of TPE bit */
+#define TPE_BitNumber     0x00
+#define CR_TPE_BB         (PERIPH_BB_BASE + (CR_OFFSET * 32) + (TPE_BitNumber * 4))
+
+/* --- CSR Register ---*/
+
+/* Alias word address of TPIE bit */
+#define CSR_OFFSET        (BKP_OFFSET + 0x34)
+#define TPIE_BitNumber    0x02
+#define CSR_TPIE_BB       (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (TPIE_BitNumber * 4))
+
+/* Alias word address of TIF bit */
+#define TIF_BitNumber     0x09
+#define CSR_TIF_BB        (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (TIF_BitNumber * 4))
+
+/* Alias word address of TEF bit */
+#define TEF_BitNumber     0x08
+#define CSR_TEF_BB        (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (TEF_BitNumber * 4))
+
+/* ---------------------- BKP registers bit mask ------------------------ */
+
+/* RTCCR register bit mask */
+#define RTCCR_CAL_MASK    ((uint16_t)0xFF80)
+#define RTCCR_MASK        ((uint16_t)0xFC7F)
+
+/**
+  * @}
+  */
+
+
+/** @defgroup BKP_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup BKP_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup BKP_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup BKP_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the BKP peripheral registers to their default reset values.
+  * @param  None
+  * @retval None
+  */
+void BKP_DeInit(void)
+{
+  RCC_BackupResetCmd(ENABLE);
+  RCC_BackupResetCmd(DISABLE);
+}
+
+/**
+  * @brief  Configures the Tamper Pin active level.
+  * @param  BKP_TamperPinLevel: specifies the Tamper Pin active level.
+  *   This parameter can be one of the following values:
+  *     @arg BKP_TamperPinLevel_High: Tamper pin active on high level
+  *     @arg BKP_TamperPinLevel_Low: Tamper pin active on low level
+  * @retval None
+  */
+void BKP_TamperPinLevelConfig(uint16_t BKP_TamperPinLevel)
+{
+  /* Check the parameters */
+  assert_param(IS_BKP_TAMPER_PIN_LEVEL(BKP_TamperPinLevel));
+  *(__IO uint32_t *) CR_TPAL_BB = BKP_TamperPinLevel;
+}
+
+/**
+  * @brief  Enables or disables the Tamper Pin activation.
+  * @param  NewState: new state of the Tamper Pin activation.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void BKP_TamperPinCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  *(__IO uint32_t *) CR_TPE_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Enables or disables the Tamper Pin Interrupt.
+  * @param  NewState: new state of the Tamper Pin Interrupt.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void BKP_ITConfig(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  *(__IO uint32_t *) CSR_TPIE_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Select the RTC output source to output on the Tamper pin.
+  * @param  BKP_RTCOutputSource: specifies the RTC output source.
+  *   This parameter can be one of the following values:
+  *     @arg BKP_RTCOutputSource_None: no RTC output on the Tamper pin.
+  *     @arg BKP_RTCOutputSource_CalibClock: output the RTC clock with frequency
+  *                                          divided by 64 on the Tamper pin.
+  *     @arg BKP_RTCOutputSource_Alarm: output the RTC Alarm pulse signal on
+  *                                     the Tamper pin.
+  *     @arg BKP_RTCOutputSource_Second: output the RTC Second pulse signal on
+  *                                      the Tamper pin.
+  * @retval None
+  */
+void BKP_RTCOutputConfig(uint16_t BKP_RTCOutputSource)
+{
+  uint16_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_BKP_RTC_OUTPUT_SOURCE(BKP_RTCOutputSource));
+  tmpreg = BKP->RTCCR;
+  /* Clear CCO, ASOE and ASOS bits */
+  tmpreg &= RTCCR_MASK;
+
+  /* Set CCO, ASOE and ASOS bits according to BKP_RTCOutputSource value */
+  tmpreg |= BKP_RTCOutputSource;
+  /* Store the new value */
+  BKP->RTCCR = tmpreg;
+}
+
+/**
+  * @brief  Sets RTC Clock Calibration value.
+  * @param  CalibrationValue: specifies the RTC Clock Calibration value.
+  *   This parameter must be a number between 0 and 0x7F.
+  * @retval None
+  */
+void BKP_SetRTCCalibrationValue(uint8_t CalibrationValue)
+{
+  uint16_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_BKP_CALIBRATION_VALUE(CalibrationValue));
+  tmpreg = BKP->RTCCR;
+  /* Clear CAL[6:0] bits */
+  tmpreg &= RTCCR_CAL_MASK;
+  /* Set CAL[6:0] bits according to CalibrationValue value */
+  tmpreg |= CalibrationValue;
+  /* Store the new value */
+  BKP->RTCCR = tmpreg;
+}
+
+/**
+  * @brief  Writes user data to the specified Data Backup Register.
+  * @param  BKP_DR: specifies the Data Backup Register.
+  *   This parameter can be BKP_DRx where x:[1, 42]
+  * @param  Data: data to write
+  * @retval None
+  */
+void BKP_WriteBackupRegister(uint16_t BKP_DR, uint16_t Data)
+{
+  __IO uint32_t tmp = 0;
+
+  /* Check the parameters */
+  assert_param(IS_BKP_DR(BKP_DR));
+
+  tmp = (uint32_t)BKP_BASE;
+  tmp += BKP_DR;
+
+  *(__IO uint32_t *) tmp = Data;
+}
+
+/**
+  * @brief  Reads data from the specified Data Backup Register.
+  * @param  BKP_DR: specifies the Data Backup Register.
+  *   This parameter can be BKP_DRx where x:[1, 42]
+  * @retval The content of the specified Data Backup Register
+  */
+uint16_t BKP_ReadBackupRegister(uint16_t BKP_DR)
+{
+  __IO uint32_t tmp = 0;
+
+  /* Check the parameters */
+  assert_param(IS_BKP_DR(BKP_DR));
+
+  tmp = (uint32_t)BKP_BASE;
+  tmp += BKP_DR;
+
+  return (*(__IO uint16_t *) tmp);
+}
+
+/**
+  * @brief  Checks whether the Tamper Pin Event flag is set or not.
+  * @param  None
+  * @retval The new state of the Tamper Pin Event flag (SET or RESET).
+  */
+FlagStatus BKP_GetFlagStatus(void)
+{
+  return (FlagStatus)(*(__IO uint32_t *) CSR_TEF_BB);
+}
+
+/**
+  * @brief  Clears Tamper Pin Event pending flag.
+  * @param  None
+  * @retval None
+  */
+void BKP_ClearFlag(void)
+{
+  /* Set CTE bit to clear Tamper Pin Event flag */
+  BKP->CSR |= BKP_CSR_CTE;
+}
+
+/**
+  * @brief  Checks whether the Tamper Pin Interrupt has occurred or not.
+  * @param  None
+  * @retval The new state of the Tamper Pin Interrupt (SET or RESET).
+  */
+ITStatus BKP_GetITStatus(void)
+{
+  return (ITStatus)(*(__IO uint32_t *) CSR_TIF_BB);
+}
+
+/**
+  * @brief  Clears Tamper Pin Interrupt pending bit.
+  * @param  None
+  * @retval None
+  */
+void BKP_ClearITPendingBit(void)
+{
+  /* Set CTI bit to clear Tamper Pin Interrupt pending bit */
+  BKP->CSR |= BKP_CSR_CTI;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_can.c b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_can.c
new file mode 100644
index 0000000..607d692
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_can.c
@@ -0,0 +1,1415 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_can.c
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file provides all the CAN firmware functions.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x_can.h"
+#include "stm32f10x_rcc.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup CAN
+  * @brief CAN driver modules
+  * @{
+  */
+
+/** @defgroup CAN_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup CAN_Private_Defines
+  * @{
+  */
+
+/* CAN Master Control Register bits */
+
+#define MCR_DBF      ((uint32_t)0x00010000) /* software master reset */
+
+/* CAN Mailbox Transmit Request */
+#define TMIDxR_TXRQ  ((uint32_t)0x00000001) /* Transmit mailbox request */
+
+/* CAN Filter Master Register bits */
+#define FMR_FINIT    ((uint32_t)0x00000001) /* Filter init mode */
+
+/* Time out for INAK bit */
+#define INAK_TIMEOUT        ((uint32_t)0x0000FFFF)
+/* Time out for SLAK bit */
+#define SLAK_TIMEOUT        ((uint32_t)0x0000FFFF)
+
+
+
+/* Flags in TSR register */
+#define CAN_FLAGS_TSR              ((uint32_t)0x08000000)
+/* Flags in RF1R register */
+#define CAN_FLAGS_RF1R             ((uint32_t)0x04000000)
+/* Flags in RF0R register */
+#define CAN_FLAGS_RF0R             ((uint32_t)0x02000000)
+/* Flags in MSR register */
+#define CAN_FLAGS_MSR              ((uint32_t)0x01000000)
+/* Flags in ESR register */
+#define CAN_FLAGS_ESR              ((uint32_t)0x00F00000)
+
+/* Mailboxes definition */
+#define CAN_TXMAILBOX_0                   ((uint8_t)0x00)
+#define CAN_TXMAILBOX_1                   ((uint8_t)0x01)
+#define CAN_TXMAILBOX_2                   ((uint8_t)0x02)
+
+
+
+#define CAN_MODE_MASK              ((uint32_t) 0x00000003)
+/**
+  * @}
+  */
+
+/** @defgroup CAN_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup CAN_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup CAN_Private_FunctionPrototypes
+  * @{
+  */
+
+static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit);
+
+/**
+  * @}
+  */
+
+/** @defgroup CAN_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the CAN peripheral registers to their default reset values.
+  * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
+  * @retval None.
+  */
+void CAN_DeInit(CAN_TypeDef* CANx)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+
+  if (CANx == CAN1)
+  {
+    /* Enable CAN1 reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
+    /* Release CAN1 from reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
+  }
+  else
+  {
+    /* Enable CAN2 reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
+    /* Release CAN2 from reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
+  }
+}
+
+/**
+  * @brief  Initializes the CAN peripheral according to the specified
+  *         parameters in the CAN_InitStruct.
+  * @param  CANx:           where x can be 1 or 2 to to select the CAN
+  *                         peripheral.
+  * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure that
+  *                         contains the configuration information for the
+  *                         CAN peripheral.
+  * @retval Constant indicates initialization succeed which will be
+  *         CAN_InitStatus_Failed or CAN_InitStatus_Success.
+  */
+uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
+{
+  uint8_t InitStatus = CAN_InitStatus_Failed;
+  uint32_t wait_ack = 0x00000000;
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
+  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
+  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
+  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
+  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
+  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
+  assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
+  assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
+  assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
+  assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
+  assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
+
+  /* Exit from sleep mode */
+  CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
+
+  /* Request initialisation */
+  CANx->MCR |= CAN_MCR_INRQ ;
+
+  /* Wait the acknowledge */
+  while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
+  {
+    wait_ack++;
+  }
+
+  /* Check acknowledge */
+  if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
+  {
+    InitStatus = CAN_InitStatus_Failed;
+  }
+  else
+  {
+    /* Set the time triggered communication mode */
+    if (CAN_InitStruct->CAN_TTCM == ENABLE)
+    {
+      CANx->MCR |= CAN_MCR_TTCM;
+    }
+    else
+    {
+      CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
+    }
+
+    /* Set the automatic bus-off management */
+    if (CAN_InitStruct->CAN_ABOM == ENABLE)
+    {
+      CANx->MCR |= CAN_MCR_ABOM;
+    }
+    else
+    {
+      CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
+    }
+
+    /* Set the automatic wake-up mode */
+    if (CAN_InitStruct->CAN_AWUM == ENABLE)
+    {
+      CANx->MCR |= CAN_MCR_AWUM;
+    }
+    else
+    {
+      CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
+    }
+
+    /* Set the no automatic retransmission */
+    if (CAN_InitStruct->CAN_NART == ENABLE)
+    {
+      CANx->MCR |= CAN_MCR_NART;
+    }
+    else
+    {
+      CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
+    }
+
+    /* Set the receive FIFO locked mode */
+    if (CAN_InitStruct->CAN_RFLM == ENABLE)
+    {
+      CANx->MCR |= CAN_MCR_RFLM;
+    }
+    else
+    {
+      CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
+    }
+
+    /* Set the transmit FIFO priority */
+    if (CAN_InitStruct->CAN_TXFP == ENABLE)
+    {
+      CANx->MCR |= CAN_MCR_TXFP;
+    }
+    else
+    {
+      CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
+    }
+
+    /* Set the bit timing register */
+    CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
+                ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
+                ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
+                ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
+               ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
+
+    /* Request leave initialisation */
+    CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
+
+   /* Wait the acknowledge */
+   wait_ack = 0;
+
+   while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
+   {
+     wait_ack++;
+   }
+
+    /* ...and check acknowledged */
+    if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
+    {
+      InitStatus = CAN_InitStatus_Failed;
+    }
+    else
+    {
+      InitStatus = CAN_InitStatus_Success ;
+    }
+  }
+
+  /* At this step, return the status of initialization */
+  return InitStatus;
+}
+
+/**
+  * @brief  Initializes the CAN peripheral according to the specified
+  *         parameters in the CAN_FilterInitStruct.
+  * @param  CAN_FilterInitStruct: pointer to a CAN_FilterInitTypeDef
+  *                               structure that contains the configuration
+  *                               information.
+  * @retval None.
+  */
+void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
+{
+  uint32_t filter_number_bit_pos = 0;
+  /* Check the parameters */
+  assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
+  assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
+  assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
+  assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
+  assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
+
+  filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
+
+  /* Initialisation mode for the filter */
+  CAN1->FMR |= FMR_FINIT;
+
+  /* Filter Deactivation */
+  CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
+
+  /* Filter Scale */
+  if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
+  {
+    /* 16-bit scale for the filter */
+    CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
+
+    /* First 16-bit identifier and First 16-bit mask */
+    /* Or First 16-bit identifier and Second 16-bit identifier */
+    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 =
+    ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
+        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
+
+    /* Second 16-bit identifier and Second 16-bit mask */
+    /* Or Third 16-bit identifier and Fourth 16-bit identifier */
+    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 =
+    ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
+        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
+  }
+
+  if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
+  {
+    /* 32-bit scale for the filter */
+    CAN1->FS1R |= filter_number_bit_pos;
+    /* 32-bit identifier or First 32-bit identifier */
+    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 =
+    ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
+        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
+    /* 32-bit mask or Second 32-bit identifier */
+    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 =
+    ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
+        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
+  }
+
+  /* Filter Mode */
+  if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
+  {
+    /*Id/Mask mode for the filter*/
+    CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
+  }
+  else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
+  {
+    /*Identifier list mode for the filter*/
+    CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
+  }
+
+  /* Filter FIFO assignment */
+  if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
+  {
+    /* FIFO 0 assignation for the filter */
+    CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
+  }
+
+  if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)
+  {
+    /* FIFO 1 assignation for the filter */
+    CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
+  }
+
+  /* Filter activation */
+  if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
+  {
+    CAN1->FA1R |= filter_number_bit_pos;
+  }
+
+  /* Leave the initialisation mode for the filter */
+  CAN1->FMR &= ~FMR_FINIT;
+}
+
+/**
+  * @brief  Fills each CAN_InitStruct member with its default value.
+  * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure which
+  *                         will be initialized.
+  * @retval None.
+  */
+void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
+{
+  /* Reset CAN init structure parameters values */
+
+  /* Initialize the time triggered communication mode */
+  CAN_InitStruct->CAN_TTCM = DISABLE;
+
+  /* Initialize the automatic bus-off management */
+  CAN_InitStruct->CAN_ABOM = DISABLE;
+
+  /* Initialize the automatic wake-up mode */
+  CAN_InitStruct->CAN_AWUM = DISABLE;
+
+  /* Initialize the no automatic retransmission */
+  CAN_InitStruct->CAN_NART = DISABLE;
+
+  /* Initialize the receive FIFO locked mode */
+  CAN_InitStruct->CAN_RFLM = DISABLE;
+
+  /* Initialize the transmit FIFO priority */
+  CAN_InitStruct->CAN_TXFP = DISABLE;
+
+  /* Initialize the CAN_Mode member */
+  CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
+
+  /* Initialize the CAN_SJW member */
+  CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
+
+  /* Initialize the CAN_BS1 member */
+  CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
+
+  /* Initialize the CAN_BS2 member */
+  CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
+
+  /* Initialize the CAN_Prescaler member */
+  CAN_InitStruct->CAN_Prescaler = 1;
+}
+
+/**
+  * @brief  Select the start bank filter for slave CAN.
+  * @note   This function applies only to STM32 Connectivity line devices.
+  * @param  CAN_BankNumber: Select the start slave bank filter from 1..27.
+  * @retval None.
+  */
+void CAN_SlaveStartBank(uint8_t CAN_BankNumber)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
+
+  /* Enter Initialisation mode for the filter */
+  CAN1->FMR |= FMR_FINIT;
+
+  /* Select the start slave bank */
+  CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;
+  CAN1->FMR |= (uint32_t)(CAN_BankNumber)<<8;
+
+  /* Leave Initialisation mode for the filter */
+  CAN1->FMR &= ~FMR_FINIT;
+}
+
+/**
+  * @brief  Enables or disables the DBG Freeze for CAN.
+  * @param  CANx:     where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  NewState: new state of the CAN peripheral. This parameter can
+  *                   be: ENABLE or DISABLE.
+  * @retval None.
+  */
+void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable Debug Freeze  */
+    CANx->MCR |= MCR_DBF;
+  }
+  else
+  {
+    /* Disable Debug Freeze */
+    CANx->MCR &= ~MCR_DBF;
+  }
+}
+
+
+/**
+  * @brief  Enables or disabes the CAN Time TriggerOperation communication mode.
+  * @param  CANx:      where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  NewState : Mode new state , can be one of @ref FunctionalState.
+  * @note   when enabled, Time stamp (TIME[15:0]) value is sent in the last
+  *         two data bytes of the 8-byte message: TIME[7:0] in data byte 6
+  *         and TIME[15:8] in data byte 7
+  * @note   DLC must be programmed as 8 in order Time Stamp (2 bytes) to be
+  *         sent over the CAN bus.
+  * @retval None
+  */
+void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the TTCM mode */
+    CANx->MCR |= CAN_MCR_TTCM;
+
+    /* Set TGT bits */
+    CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);
+    CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
+    CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);
+  }
+  else
+  {
+    /* Disable the TTCM mode */
+    CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);
+
+    /* Reset TGT bits */
+    CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
+    CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
+    CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
+  }
+}
+/**
+  * @brief  Initiates the transmission of a message.
+  * @param  CANx:      where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  TxMessage: pointer to a structure which contains CAN Id, CAN
+  *                    DLC and CAN data.
+  * @retval The number of the mailbox that is used for transmission
+  *                    or CAN_TxStatus_NoMailBox if there is no empty mailbox.
+  */
+uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
+{
+  uint8_t transmit_mailbox = 0;
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
+  assert_param(IS_CAN_RTR(TxMessage->RTR));
+  assert_param(IS_CAN_DLC(TxMessage->DLC));
+
+  /* Select one empty transmit mailbox */
+  if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
+  {
+    transmit_mailbox = 0;
+  }
+  else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
+  {
+    transmit_mailbox = 1;
+  }
+  else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
+  {
+    transmit_mailbox = 2;
+  }
+  else
+  {
+    transmit_mailbox = CAN_TxStatus_NoMailBox;
+  }
+
+  if (transmit_mailbox != CAN_TxStatus_NoMailBox)
+  {
+    /* Set up the Id */
+    CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
+    if (TxMessage->IDE == CAN_Id_Standard)
+    {
+      assert_param(IS_CAN_STDID(TxMessage->StdId));
+      CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
+                                                  TxMessage->RTR);
+    }
+    else
+    {
+      assert_param(IS_CAN_EXTID(TxMessage->ExtId));
+      CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
+                                                  TxMessage->IDE | \
+                                                  TxMessage->RTR);
+    }
+
+    /* Set up the DLC */
+    TxMessage->DLC &= (uint8_t)0x0000000F;
+    CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
+    CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
+
+    /* Set up the data field */
+    CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) |
+                                             ((uint32_t)TxMessage->Data[2] << 16) |
+                                             ((uint32_t)TxMessage->Data[1] << 8) |
+                                             ((uint32_t)TxMessage->Data[0]));
+    CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) |
+                                             ((uint32_t)TxMessage->Data[6] << 16) |
+                                             ((uint32_t)TxMessage->Data[5] << 8) |
+                                             ((uint32_t)TxMessage->Data[4]));
+    /* Request transmission */
+    CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
+  }
+  return transmit_mailbox;
+}
+
+/**
+  * @brief  Checks the transmission of a message.
+  * @param  CANx:            where x can be 1 or 2 to to select the
+  *                          CAN peripheral.
+  * @param  TransmitMailbox: the number of the mailbox that is used for
+  *                          transmission.
+  * @retval CAN_TxStatus_Ok if the CAN driver transmits the message, CAN_TxStatus_Failed
+  *         in an other case.
+  */
+uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
+{
+  uint32_t state = 0;
+
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
+
+  switch (TransmitMailbox)
+  {
+    case (CAN_TXMAILBOX_0):
+      state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
+      break;
+    case (CAN_TXMAILBOX_1):
+      state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
+      break;
+    case (CAN_TXMAILBOX_2):
+      state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
+      break;
+    default:
+      state = CAN_TxStatus_Failed;
+      break;
+  }
+  switch (state)
+  {
+      /* transmit pending  */
+    case (0x0): state = CAN_TxStatus_Pending;
+      break;
+      /* transmit failed  */
+     case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;
+      break;
+     case (CAN_TSR_RQCP1 | CAN_TSR_TME1): state = CAN_TxStatus_Failed;
+      break;
+     case (CAN_TSR_RQCP2 | CAN_TSR_TME2): state = CAN_TxStatus_Failed;
+      break;
+      /* transmit succeeded  */
+    case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;
+      break;
+    case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;
+      break;
+    case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;
+      break;
+    default: state = CAN_TxStatus_Failed;
+      break;
+  }
+  return (uint8_t) state;
+}
+
+/**
+  * @brief  Cancels a transmit request.
+  * @param  CANx:     where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  Mailbox:  Mailbox number.
+  * @retval None.
+  */
+void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
+  /* abort transmission */
+  switch (Mailbox)
+  {
+    case (CAN_TXMAILBOX_0): CANx->TSR |= CAN_TSR_ABRQ0;
+      break;
+    case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;
+      break;
+    case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;
+      break;
+    default:
+      break;
+  }
+}
+
+
+/**
+  * @brief  Receives a message.
+  * @param  CANx:       where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
+  * @param  RxMessage:  pointer to a structure receive message which contains
+  *                     CAN Id, CAN DLC, CAN datas and FMI number.
+  * @retval None.
+  */
+void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_FIFO(FIFONumber));
+  /* Get the Id */
+  RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
+  if (RxMessage->IDE == CAN_Id_Standard)
+  {
+    RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
+  }
+  else
+  {
+    RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
+  }
+
+  RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
+  /* Get the DLC */
+  RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
+  /* Get the FMI */
+  RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
+  /* Get the data field */
+  RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
+  RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
+  RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
+  RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
+  RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
+  RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
+  RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
+  RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
+  /* Release the FIFO */
+  /* Release FIFO0 */
+  if (FIFONumber == CAN_FIFO0)
+  {
+    CANx->RF0R |= CAN_RF0R_RFOM0;
+  }
+  /* Release FIFO1 */
+  else /* FIFONumber == CAN_FIFO1 */
+  {
+    CANx->RF1R |= CAN_RF1R_RFOM1;
+  }
+}
+
+/**
+  * @brief  Releases the specified FIFO.
+  * @param  CANx:       where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  FIFONumber: FIFO to release, CAN_FIFO0 or CAN_FIFO1.
+  * @retval None.
+  */
+void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_FIFO(FIFONumber));
+  /* Release FIFO0 */
+  if (FIFONumber == CAN_FIFO0)
+  {
+    CANx->RF0R |= CAN_RF0R_RFOM0;
+  }
+  /* Release FIFO1 */
+  else /* FIFONumber == CAN_FIFO1 */
+  {
+    CANx->RF1R |= CAN_RF1R_RFOM1;
+  }
+}
+
+/**
+  * @brief  Returns the number of pending messages.
+  * @param  CANx:       where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
+  * @retval NbMessage : which is the number of pending message.
+  */
+uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
+{
+  uint8_t message_pending=0;
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_FIFO(FIFONumber));
+  if (FIFONumber == CAN_FIFO0)
+  {
+    message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
+  }
+  else if (FIFONumber == CAN_FIFO1)
+  {
+    message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
+  }
+  else
+  {
+    message_pending = 0;
+  }
+  return message_pending;
+}
+
+
+/**
+  * @brief   Select the CAN Operation mode.
+  * @param CAN_OperatingMode : CAN Operating Mode. This parameter can be one
+  *                            of @ref CAN_OperatingMode_TypeDef enumeration.
+  * @retval status of the requested mode which can be
+  *         - CAN_ModeStatus_Failed    CAN failed entering the specific mode
+  *         - CAN_ModeStatus_Success   CAN Succeed entering the specific mode
+
+  */
+uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode)
+{
+  uint8_t status = CAN_ModeStatus_Failed;
+
+  /* Timeout for INAK or also for SLAK bits*/
+  uint32_t timeout = INAK_TIMEOUT;
+
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_OPERATING_MODE(CAN_OperatingMode));
+
+  if (CAN_OperatingMode == CAN_OperatingMode_Initialization)
+  {
+    /* Request initialisation */
+    CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);
+
+    /* Wait the acknowledge */
+    while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
+    {
+      timeout--;
+    }
+    if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)
+    {
+      status = CAN_ModeStatus_Failed;
+    }
+    else
+    {
+      status = CAN_ModeStatus_Success;
+    }
+  }
+  else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)
+  {
+    /* Request leave initialisation and sleep mode  and enter Normal mode */
+    CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP|CAN_MCR_INRQ));
+
+    /* Wait the acknowledge */
+    while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
+    {
+      timeout--;
+    }
+    if ((CANx->MSR & CAN_MODE_MASK) != 0)
+    {
+      status = CAN_ModeStatus_Failed;
+    }
+    else
+    {
+      status = CAN_ModeStatus_Success;
+    }
+  }
+  else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)
+  {
+    /* Request Sleep mode */
+    CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
+
+    /* Wait the acknowledge */
+    while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
+    {
+      timeout--;
+    }
+    if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)
+    {
+      status = CAN_ModeStatus_Failed;
+    }
+    else
+    {
+      status = CAN_ModeStatus_Success;
+    }
+  }
+  else
+  {
+    status = CAN_ModeStatus_Failed;
+  }
+
+  return  (uint8_t) status;
+}
+
+/**
+  * @brief  Enters the low power mode.
+  * @param  CANx:   where x can be 1 or 2 to to select the CAN peripheral.
+  * @retval status: CAN_Sleep_Ok if sleep entered, CAN_Sleep_Failed in an
+  *                 other case.
+  */
+uint8_t CAN_Sleep(CAN_TypeDef* CANx)
+{
+  uint8_t sleepstatus = CAN_Sleep_Failed;
+
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+
+  /* Request Sleep mode */
+   CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
+
+  /* Sleep mode status */
+  if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
+  {
+    /* Sleep mode not entered */
+    sleepstatus =  CAN_Sleep_Ok;
+  }
+  /* return sleep mode status */
+   return (uint8_t)sleepstatus;
+}
+
+/**
+  * @brief  Wakes the CAN up.
+  * @param  CANx:    where x can be 1 or 2 to to select the CAN peripheral.
+  * @retval status:  CAN_WakeUp_Ok if sleep mode left, CAN_WakeUp_Failed in an
+  *                  other case.
+  */
+uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
+{
+  uint32_t wait_slak = SLAK_TIMEOUT;
+  uint8_t wakeupstatus = CAN_WakeUp_Failed;
+
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+
+  /* Wake up request */
+  CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
+
+  /* Sleep mode status */
+  while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
+  {
+   wait_slak--;
+  }
+  if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
+  {
+   /* wake up done : Sleep mode exited */
+    wakeupstatus = CAN_WakeUp_Ok;
+  }
+  /* return wakeup status */
+  return (uint8_t)wakeupstatus;
+}
+
+
+/**
+  * @brief  Returns the CANx's last error code (LEC).
+  * @param  CANx:          where x can be 1 or 2 to to select the CAN peripheral.
+  * @retval CAN_ErrorCode: specifies the Error code :
+  *                        - CAN_ERRORCODE_NoErr            No Error
+  *                        - CAN_ERRORCODE_StuffErr         Stuff Error
+  *                        - CAN_ERRORCODE_FormErr          Form Error
+  *                        - CAN_ERRORCODE_ACKErr           Acknowledgment Error
+  *                        - CAN_ERRORCODE_BitRecessiveErr  Bit Recessive Error
+  *                        - CAN_ERRORCODE_BitDominantErr   Bit Dominant Error
+  *                        - CAN_ERRORCODE_CRCErr           CRC Error
+  *                        - CAN_ERRORCODE_SoftwareSetErr   Software Set Error
+  */
+
+uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx)
+{
+  uint8_t errorcode=0;
+
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+
+  /* Get the error code*/
+  errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);
+
+  /* Return the error code*/
+  return errorcode;
+}
+/**
+  * @brief  Returns the CANx Receive Error Counter (REC).
+  * @note   In case of an error during reception, this counter is incremented
+  *         by 1 or by 8 depending on the error condition as defined by the CAN
+  *         standard. After every successful reception, the counter is
+  *         decremented by 1 or reset to 120 if its value was higher than 128.
+  *         When the counter value exceeds 127, the CAN controller enters the
+  *         error passive state.
+  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
+  * @retval CAN Receive Error Counter.
+  */
+uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx)
+{
+  uint8_t counter=0;
+
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+
+  /* Get the Receive Error Counter*/
+  counter = (uint8_t)((CANx->ESR & CAN_ESR_REC)>> 24);
+
+  /* Return the Receive Error Counter*/
+  return counter;
+}
+
+
+/**
+  * @brief  Returns the LSB of the 9-bit CANx Transmit Error Counter(TEC).
+  * @param  CANx:   where x can be 1 or 2 to to select the CAN peripheral.
+  * @retval LSB of the 9-bit CAN Transmit Error Counter.
+  */
+uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx)
+{
+  uint8_t counter=0;
+
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+
+  /* Get the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
+  counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC)>> 16);
+
+  /* Return the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
+  return counter;
+}
+
+
+/**
+  * @brief  Enables or disables the specified CANx interrupts.
+  * @param  CANx:   where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  CAN_IT: specifies the CAN interrupt sources to be enabled or disabled.
+  *                 This parameter can be:
+  *                 - CAN_IT_TME,
+  *                 - CAN_IT_FMP0,
+  *                 - CAN_IT_FF0,
+  *                 - CAN_IT_FOV0,
+  *                 - CAN_IT_FMP1,
+  *                 - CAN_IT_FF1,
+  *                 - CAN_IT_FOV1,
+  *                 - CAN_IT_EWG,
+  *                 - CAN_IT_EPV,
+  *                 - CAN_IT_LEC,
+  *                 - CAN_IT_ERR,
+  *                 - CAN_IT_WKU or
+  *                 - CAN_IT_SLK.
+  * @param  NewState: new state of the CAN interrupts.
+  *                   This parameter can be: ENABLE or DISABLE.
+  * @retval None.
+  */
+void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_IT(CAN_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected CANx interrupt */
+    CANx->IER |= CAN_IT;
+  }
+  else
+  {
+    /* Disable the selected CANx interrupt */
+    CANx->IER &= ~CAN_IT;
+  }
+}
+/**
+  * @brief  Checks whether the specified CAN flag is set or not.
+  * @param  CANx:     where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  CAN_FLAG: specifies the flag to check.
+  *                   This parameter can be one of the following flags:
+  *                  - CAN_FLAG_EWG
+  *                  - CAN_FLAG_EPV
+  *                  - CAN_FLAG_BOF
+  *                  - CAN_FLAG_RQCP0
+  *                  - CAN_FLAG_RQCP1
+  *                  - CAN_FLAG_RQCP2
+  *                  - CAN_FLAG_FMP1
+  *                  - CAN_FLAG_FF1
+  *                  - CAN_FLAG_FOV1
+  *                  - CAN_FLAG_FMP0
+  *                  - CAN_FLAG_FF0
+  *                  - CAN_FLAG_FOV0
+  *                  - CAN_FLAG_WKU
+  *                  - CAN_FLAG_SLAK
+  *                  - CAN_FLAG_LEC
+  * @retval The new state of CAN_FLAG (SET or RESET).
+  */
+FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
+
+
+  if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
+  {
+    /* Check the status of the specified CAN flag */
+    if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
+    {
+      /* CAN_FLAG is set */
+      bitstatus = SET;
+    }
+    else
+    {
+      /* CAN_FLAG is reset */
+      bitstatus = RESET;
+    }
+  }
+  else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
+  {
+    /* Check the status of the specified CAN flag */
+    if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
+    {
+      /* CAN_FLAG is set */
+      bitstatus = SET;
+    }
+    else
+    {
+      /* CAN_FLAG is reset */
+      bitstatus = RESET;
+    }
+  }
+  else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
+  {
+    /* Check the status of the specified CAN flag */
+    if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
+    {
+      /* CAN_FLAG is set */
+      bitstatus = SET;
+    }
+    else
+    {
+      /* CAN_FLAG is reset */
+      bitstatus = RESET;
+    }
+  }
+  else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
+  {
+    /* Check the status of the specified CAN flag */
+    if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
+    {
+      /* CAN_FLAG is set */
+      bitstatus = SET;
+    }
+    else
+    {
+      /* CAN_FLAG is reset */
+      bitstatus = RESET;
+    }
+  }
+  else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
+  {
+    /* Check the status of the specified CAN flag */
+    if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
+    {
+      /* CAN_FLAG is set */
+      bitstatus = SET;
+    }
+    else
+    {
+      /* CAN_FLAG is reset */
+      bitstatus = RESET;
+    }
+  }
+  /* Return the CAN_FLAG status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the CAN's pending flags.
+  * @param  CANx:     where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  CAN_FLAG: specifies the flag to clear.
+  *                   This parameter can be one of the following flags:
+  *                    - CAN_FLAG_RQCP0
+  *                    - CAN_FLAG_RQCP1
+  *                    - CAN_FLAG_RQCP2
+  *                    - CAN_FLAG_FF1
+  *                    - CAN_FLAG_FOV1
+  *                    - CAN_FLAG_FF0
+  *                    - CAN_FLAG_FOV0
+  *                    - CAN_FLAG_WKU
+  *                    - CAN_FLAG_SLAK
+  *                    - CAN_FLAG_LEC
+  * @retval None.
+  */
+void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
+{
+  uint32_t flagtmp=0;
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
+
+  if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
+  {
+    /* Clear the selected CAN flags */
+    CANx->ESR = (uint32_t)RESET;
+  }
+  else /* MSR or TSR or RF0R or RF1R */
+  {
+    flagtmp = CAN_FLAG & 0x000FFFFF;
+
+    if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
+    {
+      /* Receive Flags */
+      CANx->RF0R = (uint32_t)(flagtmp);
+    }
+    else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
+    {
+      /* Receive Flags */
+      CANx->RF1R = (uint32_t)(flagtmp);
+    }
+    else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
+    {
+      /* Transmit Flags */
+      CANx->TSR = (uint32_t)(flagtmp);
+    }
+    else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */
+    {
+      /* Operating mode Flags */
+      CANx->MSR = (uint32_t)(flagtmp);
+    }
+  }
+}
+
+/**
+  * @brief  Checks whether the specified CANx interrupt has occurred or not.
+  * @param  CANx:    where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  CAN_IT:  specifies the CAN interrupt source to check.
+  *                  This parameter can be one of the following flags:
+  *                 -  CAN_IT_TME
+  *                 -  CAN_IT_FMP0
+  *                 -  CAN_IT_FF0
+  *                 -  CAN_IT_FOV0
+  *                 -  CAN_IT_FMP1
+  *                 -  CAN_IT_FF1
+  *                 -  CAN_IT_FOV1
+  *                 -  CAN_IT_WKU
+  *                 -  CAN_IT_SLK
+  *                 -  CAN_IT_EWG
+  *                 -  CAN_IT_EPV
+  *                 -  CAN_IT_BOF
+  *                 -  CAN_IT_LEC
+  *                 -  CAN_IT_ERR
+  * @retval The current state of CAN_IT (SET or RESET).
+  */
+ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
+{
+  ITStatus itstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_IT(CAN_IT));
+
+  /* check the enable interrupt bit */
+ if((CANx->IER & CAN_IT) != RESET)
+ {
+   /* in case the Interrupt is enabled, .... */
+    switch (CAN_IT)
+    {
+      case CAN_IT_TME:
+               /* Check CAN_TSR_RQCPx bits */
+	             itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);
+	      break;
+      case CAN_IT_FMP0:
+               /* Check CAN_RF0R_FMP0 bit */
+	             itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);
+	      break;
+      case CAN_IT_FF0:
+               /* Check CAN_RF0R_FULL0 bit */
+               itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);
+	      break;
+      case CAN_IT_FOV0:
+               /* Check CAN_RF0R_FOVR0 bit */
+               itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);
+	      break;
+      case CAN_IT_FMP1:
+               /* Check CAN_RF1R_FMP1 bit */
+               itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);
+	      break;
+      case CAN_IT_FF1:
+               /* Check CAN_RF1R_FULL1 bit */
+	             itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);
+	      break;
+      case CAN_IT_FOV1:
+               /* Check CAN_RF1R_FOVR1 bit */
+	             itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);
+	      break;
+      case CAN_IT_WKU:
+               /* Check CAN_MSR_WKUI bit */
+               itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);
+	      break;
+      case CAN_IT_SLK:
+               /* Check CAN_MSR_SLAKI bit */
+	             itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);
+	      break;
+      case CAN_IT_EWG:
+               /* Check CAN_ESR_EWGF bit */
+	             itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);
+	      break;
+      case CAN_IT_EPV:
+               /* Check CAN_ESR_EPVF bit */
+	             itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);
+	      break;
+      case CAN_IT_BOF:
+               /* Check CAN_ESR_BOFF bit */
+	             itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);
+	      break;
+      case CAN_IT_LEC:
+               /* Check CAN_ESR_LEC bit */
+	             itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);
+	      break;
+      case CAN_IT_ERR:
+               /* Check CAN_MSR_ERRI bit */
+               itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI);
+	      break;
+      default :
+               /* in case of error, return RESET */
+              itstatus = RESET;
+              break;
+    }
+  }
+  else
+  {
+   /* in case the Interrupt is not enabled, return RESET */
+    itstatus  = RESET;
+  }
+
+  /* Return the CAN_IT status */
+  return  itstatus;
+}
+
+/**
+  * @brief  Clears the CANx's interrupt pending bits.
+  * @param  CANx:    where x can be 1 or 2 to to select the CAN peripheral.
+  * @param  CAN_IT: specifies the interrupt pending bit to clear.
+  *                  -  CAN_IT_TME
+  *                  -  CAN_IT_FF0
+  *                  -  CAN_IT_FOV0
+  *                  -  CAN_IT_FF1
+  *                  -  CAN_IT_FOV1
+  *                  -  CAN_IT_WKU
+  *                  -  CAN_IT_SLK
+  *                  -  CAN_IT_EWG
+  *                  -  CAN_IT_EPV
+  *                  -  CAN_IT_BOF
+  *                  -  CAN_IT_LEC
+  *                  -  CAN_IT_ERR
+  * @retval None.
+  */
+void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_ALL_PERIPH(CANx));
+  assert_param(IS_CAN_CLEAR_IT(CAN_IT));
+
+  switch (CAN_IT)
+  {
+      case CAN_IT_TME:
+              /* Clear CAN_TSR_RQCPx (rc_w1)*/
+	      CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;
+	      break;
+      case CAN_IT_FF0:
+              /* Clear CAN_RF0R_FULL0 (rc_w1)*/
+	      CANx->RF0R = CAN_RF0R_FULL0;
+	      break;
+      case CAN_IT_FOV0:
+              /* Clear CAN_RF0R_FOVR0 (rc_w1)*/
+	      CANx->RF0R = CAN_RF0R_FOVR0;
+	      break;
+      case CAN_IT_FF1:
+              /* Clear CAN_RF1R_FULL1 (rc_w1)*/
+	      CANx->RF1R = CAN_RF1R_FULL1;
+	      break;
+      case CAN_IT_FOV1:
+              /* Clear CAN_RF1R_FOVR1 (rc_w1)*/
+	      CANx->RF1R = CAN_RF1R_FOVR1;
+	      break;
+      case CAN_IT_WKU:
+              /* Clear CAN_MSR_WKUI (rc_w1)*/
+	      CANx->MSR = CAN_MSR_WKUI;
+	      break;
+      case CAN_IT_SLK:
+              /* Clear CAN_MSR_SLAKI (rc_w1)*/
+	      CANx->MSR = CAN_MSR_SLAKI;
+	      break;
+      case CAN_IT_EWG:
+              /* Clear CAN_MSR_ERRI (rc_w1) */
+	      CANx->MSR = CAN_MSR_ERRI;
+              /* Note : the corresponding Flag is cleared by hardware depending
+                        of the CAN Bus status*/
+	      break;
+      case CAN_IT_EPV:
+              /* Clear CAN_MSR_ERRI (rc_w1) */
+	      CANx->MSR = CAN_MSR_ERRI;
+              /* Note : the corresponding Flag is cleared by hardware depending
+                        of the CAN Bus status*/
+	      break;
+      case CAN_IT_BOF:
+              /* Clear CAN_MSR_ERRI (rc_w1) */
+	      CANx->MSR = CAN_MSR_ERRI;
+              /* Note : the corresponding Flag is cleared by hardware depending
+                        of the CAN Bus status*/
+	      break;
+      case CAN_IT_LEC:
+              /*  Clear LEC bits */
+	      CANx->ESR = RESET;
+              /* Clear CAN_MSR_ERRI (rc_w1) */
+	      CANx->MSR = CAN_MSR_ERRI;
+	      break;
+      case CAN_IT_ERR:
+              /*Clear LEC bits */
+	      CANx->ESR = RESET;
+              /* Clear CAN_MSR_ERRI (rc_w1) */
+	      CANx->MSR = CAN_MSR_ERRI;
+	      /* Note : BOFF, EPVF and EWGF Flags are cleared by hardware depending
+                  of the CAN Bus status*/
+	      break;
+      default :
+	      break;
+   }
+}
+
+/**
+  * @brief  Checks whether the CAN interrupt has occurred or not.
+  * @param  CAN_Reg: specifies the CAN interrupt register to check.
+  * @param  It_Bit:  specifies the interrupt source bit to check.
+  * @retval The new state of the CAN Interrupt (SET or RESET).
+  */
+static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
+{
+  ITStatus pendingbitstatus = RESET;
+
+  if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
+  {
+    /* CAN_IT is set */
+    pendingbitstatus = SET;
+  }
+  else
+  {
+    /* CAN_IT is reset */
+    pendingbitstatus = RESET;
+  }
+  return pendingbitstatus;
+}
+
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_cec.c b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_cec.c
new file mode 100644
index 0000000..08b501a
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_cec.c
@@ -0,0 +1,433 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_cec.c
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file provides all the CEC firmware functions.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x_cec.h"
+#include "stm32f10x_rcc.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup CEC
+  * @brief CEC driver modules
+  * @{
+  */
+
+/** @defgroup CEC_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+
+/** @defgroup CEC_Private_Defines
+  * @{
+  */
+
+/* ------------ CEC registers bit address in the alias region ----------- */
+#define CEC_OFFSET                (CEC_BASE - PERIPH_BASE)
+
+/* --- CFGR Register ---*/
+
+/* Alias word address of PE bit */
+#define CFGR_OFFSET                 (CEC_OFFSET + 0x00)
+#define PE_BitNumber                0x00
+#define CFGR_PE_BB                  (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (PE_BitNumber * 4))
+
+/* Alias word address of IE bit */
+#define IE_BitNumber                0x01
+#define CFGR_IE_BB                  (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (IE_BitNumber * 4))
+
+/* --- CSR Register ---*/
+
+/* Alias word address of TSOM bit */
+#define CSR_OFFSET                  (CEC_OFFSET + 0x10)
+#define TSOM_BitNumber              0x00
+#define CSR_TSOM_BB                 (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (TSOM_BitNumber * 4))
+
+/* Alias word address of TEOM bit */
+#define TEOM_BitNumber              0x01
+#define CSR_TEOM_BB                 (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (TEOM_BitNumber * 4))
+
+#define CFGR_CLEAR_Mask            (uint8_t)(0xF3)        /* CFGR register Mask */
+#define FLAG_Mask                  ((uint32_t)0x00FFFFFF) /* CEC FLAG mask */
+
+/**
+  * @}
+  */
+
+
+/** @defgroup CEC_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+
+/** @defgroup CEC_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+
+/** @defgroup CEC_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+
+/** @defgroup CEC_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the CEC peripheral registers to their default reset
+  *         values.
+  * @param  None
+  * @retval None
+  */
+void CEC_DeInit(void)
+{
+  /* Enable CEC reset state */
+  RCC_APB1PeriphResetCmd(RCC_APB1Periph_CEC, ENABLE);
+  /* Release CEC from reset state */
+  RCC_APB1PeriphResetCmd(RCC_APB1Periph_CEC, DISABLE);
+}
+
+
+/**
+  * @brief  Initializes the CEC peripheral according to the specified
+  *         parameters in the CEC_InitStruct.
+  * @param  CEC_InitStruct: pointer to an CEC_InitTypeDef structure that
+  *         contains the configuration information for the specified
+  *         CEC peripheral.
+  * @retval None
+  */
+void CEC_Init(CEC_InitTypeDef* CEC_InitStruct)
+{
+  uint16_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_CEC_BIT_TIMING_ERROR_MODE(CEC_InitStruct->CEC_BitTimingMode));
+  assert_param(IS_CEC_BIT_PERIOD_ERROR_MODE(CEC_InitStruct->CEC_BitPeriodMode));
+
+  /*---------------------------- CEC CFGR Configuration -----------------*/
+  /* Get the CEC CFGR value */
+  tmpreg = CEC->CFGR;
+
+  /* Clear BTEM and BPEM bits */
+  tmpreg &= CFGR_CLEAR_Mask;
+
+  /* Configure CEC: Bit Timing Error and Bit Period Error */
+  tmpreg |= (uint16_t)(CEC_InitStruct->CEC_BitTimingMode | CEC_InitStruct->CEC_BitPeriodMode);
+
+  /* Write to CEC CFGR  register*/
+  CEC->CFGR = tmpreg;
+
+}
+
+/**
+  * @brief  Enables or disables the specified CEC peripheral.
+  * @param  NewState: new state of the CEC peripheral.
+  *     This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void CEC_Cmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(__IO uint32_t *) CFGR_PE_BB = (uint32_t)NewState;
+
+  if(NewState == DISABLE)
+  {
+    /* Wait until the PE bit is cleared by hardware (Idle Line detected) */
+    while((CEC->CFGR & CEC_CFGR_PE) != (uint32_t)RESET)
+    {
+    }
+  }
+}
+
+/**
+  * @brief  Enables or disables the CEC interrupt.
+  * @param  NewState: new state of the CEC interrupt.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void CEC_ITConfig(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(__IO uint32_t *) CFGR_IE_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Defines the Own Address of the CEC device.
+  * @param  CEC_OwnAddress: The CEC own address
+  * @retval None
+  */
+void CEC_OwnAddressConfig(uint8_t CEC_OwnAddress)
+{
+  /* Check the parameters */
+  assert_param(IS_CEC_ADDRESS(CEC_OwnAddress));
+
+  /* Set the CEC own address */
+  CEC->OAR = CEC_OwnAddress;
+}
+
+/**
+  * @brief  Sets the CEC prescaler value.
+  * @param  CEC_Prescaler: CEC prescaler new value
+  * @retval None
+  */
+void CEC_SetPrescaler(uint16_t CEC_Prescaler)
+{
+  /* Check the parameters */
+  assert_param(IS_CEC_PRESCALER(CEC_Prescaler));
+
+  /* Set the  Prescaler value*/
+  CEC->PRES = CEC_Prescaler;
+}
+
+/**
+  * @brief  Transmits single data through the CEC peripheral.
+  * @param  Data: the data to transmit.
+  * @retval None
+  */
+void CEC_SendDataByte(uint8_t Data)
+{
+  /* Transmit Data */
+  CEC->TXD = Data ;
+}
+
+
+/**
+  * @brief  Returns the most recent received data by the CEC peripheral.
+  * @param  None
+  * @retval The received data.
+  */
+uint8_t CEC_ReceiveDataByte(void)
+{
+  /* Receive Data */
+  return (uint8_t)(CEC->RXD);
+}
+
+/**
+  * @brief  Starts a new message.
+  * @param  None
+  * @retval None
+  */
+void CEC_StartOfMessage(void)
+{
+  /* Starts of new message */
+  *(__IO uint32_t *) CSR_TSOM_BB = (uint32_t)0x1;
+}
+
+/**
+  * @brief  Transmits message with or without an EOM bit.
+  * @param  NewState: new state of the CEC Tx End Of Message.
+  *     This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void CEC_EndOfMessageCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  /* The data byte will be transmitted with or without an EOM bit*/
+  *(__IO uint32_t *) CSR_TEOM_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Gets the CEC flag status
+  * @param  CEC_FLAG: specifies the CEC flag to check.
+  *   This parameter can be one of the following values:
+  *     @arg CEC_FLAG_BTE: Bit Timing Error
+  *     @arg CEC_FLAG_BPE: Bit Period Error
+  *     @arg CEC_FLAG_RBTFE: Rx Block Transfer Finished Error
+  *     @arg CEC_FLAG_SBE: Start Bit Error
+  *     @arg CEC_FLAG_ACKE: Block Acknowledge Error
+  *     @arg CEC_FLAG_LINE: Line Error
+  *     @arg CEC_FLAG_TBTFE: Tx Block Transfer Finished Error
+  *     @arg CEC_FLAG_TEOM: Tx End Of Message
+  *     @arg CEC_FLAG_TERR: Tx Error
+  *     @arg CEC_FLAG_TBTRF: Tx Byte Transfer Request or Block Transfer Finished
+  *     @arg CEC_FLAG_RSOM: Rx Start Of Message
+  *     @arg CEC_FLAG_REOM: Rx End Of Message
+  *     @arg CEC_FLAG_RERR: Rx Error
+  *     @arg CEC_FLAG_RBTF: Rx Byte/Block Transfer Finished
+  * @retval The new state of CEC_FLAG (SET or RESET)
+  */
+FlagStatus CEC_GetFlagStatus(uint32_t CEC_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  uint32_t cecreg = 0, cecbase = 0;
+
+  /* Check the parameters */
+  assert_param(IS_CEC_GET_FLAG(CEC_FLAG));
+
+  /* Get the CEC peripheral base address */
+  cecbase = (uint32_t)(CEC_BASE);
+
+  /* Read flag register index */
+  cecreg = CEC_FLAG >> 28;
+
+  /* Get bit[23:0] of the flag */
+  CEC_FLAG &= FLAG_Mask;
+
+  if(cecreg != 0)
+  {
+    /* Flag in CEC ESR Register */
+    CEC_FLAG = (uint32_t)(CEC_FLAG >> 16);
+
+    /* Get the CEC ESR register address */
+    cecbase += 0xC;
+  }
+  else
+  {
+    /* Get the CEC CSR register address */
+    cecbase += 0x10;
+  }
+
+  if(((*(__IO uint32_t *)cecbase) & CEC_FLAG) != (uint32_t)RESET)
+  {
+    /* CEC_FLAG is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* CEC_FLAG is reset */
+    bitstatus = RESET;
+  }
+
+  /* Return the CEC_FLAG status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the CEC's pending flags.
+  * @param  CEC_FLAG: specifies the flag to clear.
+  *   This parameter can be any combination of the following values:
+  *     @arg CEC_FLAG_TERR: Tx Error
+  *     @arg CEC_FLAG_TBTRF: Tx Byte Transfer Request or Block Transfer Finished
+  *     @arg CEC_FLAG_RSOM: Rx Start Of Message
+  *     @arg CEC_FLAG_REOM: Rx End Of Message
+  *     @arg CEC_FLAG_RERR: Rx Error
+  *     @arg CEC_FLAG_RBTF: Rx Byte/Block Transfer Finished
+  * @retval None
+  */
+void CEC_ClearFlag(uint32_t CEC_FLAG)
+{
+  uint32_t tmp = 0x0;
+
+  /* Check the parameters */
+  assert_param(IS_CEC_CLEAR_FLAG(CEC_FLAG));
+
+  tmp = CEC->CSR & 0x2;
+
+  /* Clear the selected CEC flags */
+  CEC->CSR &= (uint32_t)(((~(uint32_t)CEC_FLAG) & 0xFFFFFFFC) | tmp);
+}
+
+/**
+  * @brief  Checks whether the specified CEC interrupt has occurred or not.
+  * @param  CEC_IT: specifies the CEC interrupt source to check.
+  *   This parameter can be one of the following values:
+  *     @arg CEC_IT_TERR: Tx Error
+  *     @arg CEC_IT_TBTF: Tx Block Transfer Finished
+  *     @arg CEC_IT_RERR: Rx Error
+  *     @arg CEC_IT_RBTF: Rx Block Transfer Finished
+  * @retval The new state of CEC_IT (SET or RESET).
+  */
+ITStatus CEC_GetITStatus(uint8_t CEC_IT)
+{
+  ITStatus bitstatus = RESET;
+  uint32_t enablestatus = 0;
+
+  /* Check the parameters */
+   assert_param(IS_CEC_GET_IT(CEC_IT));
+
+  /* Get the CEC IT enable bit status */
+  enablestatus = (CEC->CFGR & (uint8_t)CEC_CFGR_IE) ;
+
+  /* Check the status of the specified CEC interrupt */
+  if (((CEC->CSR & CEC_IT) != (uint32_t)RESET) && enablestatus)
+  {
+    /* CEC_IT is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* CEC_IT is reset */
+    bitstatus = RESET;
+  }
+  /* Return the CEC_IT status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the CEC's interrupt pending bits.
+  * @param  CEC_IT: specifies the CEC interrupt pending bit to clear.
+  *   This parameter can be any combination of the following values:
+  *     @arg CEC_IT_TERR: Tx Error
+  *     @arg CEC_IT_TBTF: Tx Block Transfer Finished
+  *     @arg CEC_IT_RERR: Rx Error
+  *     @arg CEC_IT_RBTF: Rx Block Transfer Finished
+  * @retval None
+  */
+void CEC_ClearITPendingBit(uint16_t CEC_IT)
+{
+  uint32_t tmp = 0x0;
+
+  /* Check the parameters */
+  assert_param(IS_CEC_GET_IT(CEC_IT));
+
+  tmp = CEC->CSR & 0x2;
+
+  /* Clear the selected CEC interrupt pending bits */
+  CEC->CSR &= (uint32_t)(((~(uint32_t)CEC_IT) & 0xFFFFFFFC) | tmp);
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_crc.c b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_crc.c
new file mode 100644
index 0000000..ef0c047
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_crc.c
@@ -0,0 +1,160 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_crc.c
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file provides all the CRC firmware functions.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x_crc.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup CRC
+  * @brief CRC driver modules
+  * @{
+  */
+
+/** @defgroup CRC_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup CRC_Private_Defines
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup CRC_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup CRC_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup CRC_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup CRC_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Resets the CRC Data register (DR).
+  * @param  None
+  * @retval None
+  */
+void CRC_ResetDR(void)
+{
+  /* Reset CRC generator */
+  CRC->CR = CRC_CR_RESET;
+}
+
+/**
+  * @brief  Computes the 32-bit CRC of a given data word(32-bit).
+  * @param  Data: data word(32-bit) to compute its CRC
+  * @retval 32-bit CRC
+  */
+uint32_t CRC_CalcCRC(uint32_t Data)
+{
+  CRC->DR = Data;
+
+  return (CRC->DR);
+}
+
+/**
+  * @brief  Computes the 32-bit CRC of a given buffer of data word(32-bit).
+  * @param  pBuffer: pointer to the buffer containing the data to be computed
+  * @param  BufferLength: length of the buffer to be computed
+  * @retval 32-bit CRC
+  */
+uint32_t CRC_CalcBlockCRC(uint32_t pBuffer[], uint32_t BufferLength)
+{
+  uint32_t index = 0;
+
+  for(index = 0; index < BufferLength; index++)
+  {
+    CRC->DR = pBuffer[index];
+  }
+  return (CRC->DR);
+}
+
+/**
+  * @brief  Returns the current CRC value.
+  * @param  None
+  * @retval 32-bit CRC
+  */
+uint32_t CRC_GetCRC(void)
+{
+  return (CRC->DR);
+}
+
+/**
+  * @brief  Stores a 8-bit data in the Independent Data(ID) register.
+  * @param  IDValue: 8-bit value to be stored in the ID register
+  * @retval None
+  */
+void CRC_SetIDRegister(uint8_t IDValue)
+{
+  CRC->IDR = IDValue;
+}
+
+/**
+  * @brief  Returns the 8-bit data stored in the Independent Data(ID) register
+  * @param  None
+  * @retval 8-bit value of the ID register
+  */
+uint8_t CRC_GetIDRegister(void)
+{
+  return (CRC->IDR);
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_dac.c b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_dac.c
new file mode 100644
index 0000000..025b8e2
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_dac.c
@@ -0,0 +1,571 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_dac.c
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file provides all the DAC firmware functions.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x_dac.h"
+#include "stm32f10x_rcc.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup DAC
+  * @brief DAC driver modules
+  * @{
+  */
+
+/** @defgroup DAC_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DAC_Private_Defines
+  * @{
+  */
+
+/* CR register Mask */
+#define CR_CLEAR_MASK              ((uint32_t)0x00000FFE)
+
+/* DAC Dual Channels SWTRIG masks */
+#define DUAL_SWTRIG_SET            ((uint32_t)0x00000003)
+#define DUAL_SWTRIG_RESET          ((uint32_t)0xFFFFFFFC)
+
+/* DHR registers offsets */
+#define DHR12R1_OFFSET             ((uint32_t)0x00000008)
+#define DHR12R2_OFFSET             ((uint32_t)0x00000014)
+#define DHR12RD_OFFSET             ((uint32_t)0x00000020)
+
+/* DOR register offset */
+#define DOR_OFFSET                 ((uint32_t)0x0000002C)
+/**
+  * @}
+  */
+
+/** @defgroup DAC_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DAC_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DAC_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DAC_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the DAC peripheral registers to their default reset values.
+  * @param  None
+  * @retval None
+  */
+void DAC_DeInit(void)
+{
+  /* Enable DAC reset state */
+  RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);
+  /* Release DAC from reset state */
+  RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);
+}
+
+/**
+  * @brief  Initializes the DAC peripheral according to the specified
+  *         parameters in the DAC_InitStruct.
+  * @param  DAC_Channel: the selected DAC channel.
+  *   This parameter can be one of the following values:
+  *     @arg DAC_Channel_1: DAC Channel1 selected
+  *     @arg DAC_Channel_2: DAC Channel2 selected
+  * @param  DAC_InitStruct: pointer to a DAC_InitTypeDef structure that
+  *        contains the configuration information for the specified DAC channel.
+  * @retval None
+  */
+void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)
+{
+  uint32_t tmpreg1 = 0, tmpreg2 = 0;
+  /* Check the DAC parameters */
+  assert_param(IS_DAC_TRIGGER(DAC_InitStruct->DAC_Trigger));
+  assert_param(IS_DAC_GENERATE_WAVE(DAC_InitStruct->DAC_WaveGeneration));
+  assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude));
+  assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct->DAC_OutputBuffer));
+/*---------------------------- DAC CR Configuration --------------------------*/
+  /* Get the DAC CR value */
+  tmpreg1 = DAC->CR;
+  /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
+  tmpreg1 &= ~(CR_CLEAR_MASK << DAC_Channel);
+  /* Configure for the selected DAC channel: buffer output, trigger, wave generation,
+     mask/amplitude for wave generation */
+  /* Set TSELx and TENx bits according to DAC_Trigger value */
+  /* Set WAVEx bits according to DAC_WaveGeneration value */
+  /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */
+  /* Set BOFFx bit according to DAC_OutputBuffer value */
+  tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
+             DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude | DAC_InitStruct->DAC_OutputBuffer);
+  /* Calculate CR register value depending on DAC_Channel */
+  tmpreg1 |= tmpreg2 << DAC_Channel;
+  /* Write to DAC CR */
+  DAC->CR = tmpreg1;
+}
+
+/**
+  * @brief  Fills each DAC_InitStruct member with its default value.
+  * @param  DAC_InitStruct : pointer to a DAC_InitTypeDef structure which will
+  *         be initialized.
+  * @retval None
+  */
+void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)
+{
+/*--------------- Reset DAC init structure parameters values -----------------*/
+  /* Initialize the DAC_Trigger member */
+  DAC_InitStruct->DAC_Trigger = DAC_Trigger_None;
+  /* Initialize the DAC_WaveGeneration member */
+  DAC_InitStruct->DAC_WaveGeneration = DAC_WaveGeneration_None;
+  /* Initialize the DAC_LFSRUnmask_TriangleAmplitude member */
+  DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;
+  /* Initialize the DAC_OutputBuffer member */
+  DAC_InitStruct->DAC_OutputBuffer = DAC_OutputBuffer_Enable;
+}
+
+/**
+  * @brief  Enables or disables the specified DAC channel.
+  * @param  DAC_Channel: the selected DAC channel.
+  *   This parameter can be one of the following values:
+  *     @arg DAC_Channel_1: DAC Channel1 selected
+  *     @arg DAC_Channel_2: DAC Channel2 selected
+  * @param  NewState: new state of the DAC channel.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DAC_CHANNEL(DAC_Channel));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected DAC channel */
+    DAC->CR |= (DAC_CR_EN1 << DAC_Channel);
+  }
+  else
+  {
+    /* Disable the selected DAC channel */
+    DAC->CR &= ~(DAC_CR_EN1 << DAC_Channel);
+  }
+}
+#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
+/**
+  * @brief  Enables or disables the specified DAC interrupts.
+  * @param  DAC_Channel: the selected DAC channel.
+  *   This parameter can be one of the following values:
+  *     @arg DAC_Channel_1: DAC Channel1 selected
+  *     @arg DAC_Channel_2: DAC Channel2 selected
+  * @param  DAC_IT: specifies the DAC interrupt sources to be enabled or disabled.
+  *   This parameter can be the following values:
+  *     @arg DAC_IT_DMAUDR: DMA underrun interrupt mask
+  * @param  NewState: new state of the specified DAC interrupts.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void DAC_ITConfig(uint32_t DAC_Channel, uint32_t DAC_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DAC_CHANNEL(DAC_Channel));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  assert_param(IS_DAC_IT(DAC_IT));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected DAC interrupts */
+    DAC->CR |=  (DAC_IT << DAC_Channel);
+  }
+  else
+  {
+    /* Disable the selected DAC interrupts */
+    DAC->CR &= (~(uint32_t)(DAC_IT << DAC_Channel));
+  }
+}
+#endif
+
+/**
+  * @brief  Enables or disables the specified DAC channel DMA request.
+  * @param  DAC_Channel: the selected DAC channel.
+  *   This parameter can be one of the following values:
+  *     @arg DAC_Channel_1: DAC Channel1 selected
+  *     @arg DAC_Channel_2: DAC Channel2 selected
+  * @param  NewState: new state of the selected DAC channel DMA request.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DAC_CHANNEL(DAC_Channel));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected DAC channel DMA request */
+    DAC->CR |= (DAC_CR_DMAEN1 << DAC_Channel);
+  }
+  else
+  {
+    /* Disable the selected DAC channel DMA request */
+    DAC->CR &= ~(DAC_CR_DMAEN1 << DAC_Channel);
+  }
+}
+
+/**
+  * @brief  Enables or disables the selected DAC channel software trigger.
+  * @param  DAC_Channel: the selected DAC channel.
+  *   This parameter can be one of the following values:
+  *     @arg DAC_Channel_1: DAC Channel1 selected
+  *     @arg DAC_Channel_2: DAC Channel2 selected
+  * @param  NewState: new state of the selected DAC channel software trigger.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DAC_CHANNEL(DAC_Channel));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable software trigger for the selected DAC channel */
+    DAC->SWTRIGR |= (uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4);
+  }
+  else
+  {
+    /* Disable software trigger for the selected DAC channel */
+    DAC->SWTRIGR &= ~((uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4));
+  }
+}
+
+/**
+  * @brief  Enables or disables simultaneously the two DAC channels software
+  *   triggers.
+  * @param  NewState: new state of the DAC channels software triggers.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable software trigger for both DAC channels */
+    DAC->SWTRIGR |= DUAL_SWTRIG_SET ;
+  }
+  else
+  {
+    /* Disable software trigger for both DAC channels */
+    DAC->SWTRIGR &= DUAL_SWTRIG_RESET;
+  }
+}
+
+/**
+  * @brief  Enables or disables the selected DAC channel wave generation.
+  * @param  DAC_Channel: the selected DAC channel.
+  *   This parameter can be one of the following values:
+  *     @arg DAC_Channel_1: DAC Channel1 selected
+  *     @arg DAC_Channel_2: DAC Channel2 selected
+  * @param  DAC_Wave: Specifies the wave type to enable or disable.
+  *   This parameter can be one of the following values:
+  *     @arg DAC_Wave_Noise: noise wave generation
+  *     @arg DAC_Wave_Triangle: triangle wave generation
+  * @param  NewState: new state of the selected DAC channel wave generation.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DAC_CHANNEL(DAC_Channel));
+  assert_param(IS_DAC_WAVE(DAC_Wave));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected wave generation for the selected DAC channel */
+    DAC->CR |= DAC_Wave << DAC_Channel;
+  }
+  else
+  {
+    /* Disable the selected wave generation for the selected DAC channel */
+    DAC->CR &= ~(DAC_Wave << DAC_Channel);
+  }
+}
+
+/**
+  * @brief  Set the specified data holding register value for DAC channel1.
+  * @param  DAC_Align: Specifies the data alignment for DAC channel1.
+  *   This parameter can be one of the following values:
+  *     @arg DAC_Align_8b_R: 8bit right data alignment selected
+  *     @arg DAC_Align_12b_L: 12bit left data alignment selected
+  *     @arg DAC_Align_12b_R: 12bit right data alignment selected
+  * @param  Data : Data to be loaded in the selected data holding register.
+  * @retval None
+  */
+void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data)
+{
+  __IO uint32_t tmp = 0;
+
+  /* Check the parameters */
+  assert_param(IS_DAC_ALIGN(DAC_Align));
+  assert_param(IS_DAC_DATA(Data));
+
+  tmp = (uint32_t)DAC_BASE;
+  tmp += DHR12R1_OFFSET + DAC_Align;
+
+  /* Set the DAC channel1 selected data holding register */
+  *(__IO uint32_t *) tmp = Data;
+}
+
+/**
+  * @brief  Set the specified data holding register value for DAC channel2.
+  * @param  DAC_Align: Specifies the data alignment for DAC channel2.
+  *   This parameter can be one of the following values:
+  *     @arg DAC_Align_8b_R: 8bit right data alignment selected
+  *     @arg DAC_Align_12b_L: 12bit left data alignment selected
+  *     @arg DAC_Align_12b_R: 12bit right data alignment selected
+  * @param  Data : Data to be loaded in the selected data holding register.
+  * @retval None
+  */
+void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data)
+{
+  __IO uint32_t tmp = 0;
+
+  /* Check the parameters */
+  assert_param(IS_DAC_ALIGN(DAC_Align));
+  assert_param(IS_DAC_DATA(Data));
+
+  tmp = (uint32_t)DAC_BASE;
+  tmp += DHR12R2_OFFSET + DAC_Align;
+
+  /* Set the DAC channel2 selected data holding register */
+  *(__IO uint32_t *)tmp = Data;
+}
+
+/**
+  * @brief  Set the specified data holding register value for dual channel
+  *   DAC.
+  * @param  DAC_Align: Specifies the data alignment for dual channel DAC.
+  *   This parameter can be one of the following values:
+  *     @arg DAC_Align_8b_R: 8bit right data alignment selected
+  *     @arg DAC_Align_12b_L: 12bit left data alignment selected
+  *     @arg DAC_Align_12b_R: 12bit right data alignment selected
+  * @param  Data2: Data for DAC Channel2 to be loaded in the selected data
+  *   holding register.
+  * @param  Data1: Data for DAC Channel1 to be loaded in the selected data
+  *   holding register.
+  * @retval None
+  */
+void DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1)
+{
+  uint32_t data = 0, tmp = 0;
+
+  /* Check the parameters */
+  assert_param(IS_DAC_ALIGN(DAC_Align));
+  assert_param(IS_DAC_DATA(Data1));
+  assert_param(IS_DAC_DATA(Data2));
+
+  /* Calculate and set dual DAC data holding register value */
+  if (DAC_Align == DAC_Align_8b_R)
+  {
+    data = ((uint32_t)Data2 << 8) | Data1;
+  }
+  else
+  {
+    data = ((uint32_t)Data2 << 16) | Data1;
+  }
+
+  tmp = (uint32_t)DAC_BASE;
+  tmp += DHR12RD_OFFSET + DAC_Align;
+
+  /* Set the dual DAC selected data holding register */
+  *(__IO uint32_t *)tmp = data;
+}
+
+/**
+  * @brief  Returns the last data output value of the selected DAC channel.
+  * @param  DAC_Channel: the selected DAC channel.
+  *   This parameter can be one of the following values:
+  *     @arg DAC_Channel_1: DAC Channel1 selected
+  *     @arg DAC_Channel_2: DAC Channel2 selected
+  * @retval The selected DAC channel data output value.
+  */
+uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel)
+{
+  __IO uint32_t tmp = 0;
+
+  /* Check the parameters */
+  assert_param(IS_DAC_CHANNEL(DAC_Channel));
+
+  tmp = (uint32_t) DAC_BASE ;
+  tmp += DOR_OFFSET + ((uint32_t)DAC_Channel >> 2);
+
+  /* Returns the DAC channel data output register value */
+  return (uint16_t) (*(__IO uint32_t*) tmp);
+}
+
+#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
+/**
+  * @brief  Checks whether the specified DAC flag is set or not.
+  * @param  DAC_Channel: thee selected DAC channel.
+  *   This parameter can be one of the following values:
+  *     @arg DAC_Channel_1: DAC Channel1 selected
+  *     @arg DAC_Channel_2: DAC Channel2 selected
+  * @param  DAC_FLAG: specifies the flag to check.
+  *   This parameter can be only of the following value:
+  *     @arg DAC_FLAG_DMAUDR: DMA underrun flag
+  * @retval The new state of DAC_FLAG (SET or RESET).
+  */
+FlagStatus DAC_GetFlagStatus(uint32_t DAC_Channel, uint32_t DAC_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_DAC_CHANNEL(DAC_Channel));
+  assert_param(IS_DAC_FLAG(DAC_FLAG));
+
+  /* Check the status of the specified DAC flag */
+  if ((DAC->SR & (DAC_FLAG << DAC_Channel)) != (uint8_t)RESET)
+  {
+    /* DAC_FLAG is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* DAC_FLAG is reset */
+    bitstatus = RESET;
+  }
+  /* Return the DAC_FLAG status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the DAC channelx's pending flags.
+  * @param  DAC_Channel: the selected DAC channel.
+  *   This parameter can be one of the following values:
+  *     @arg DAC_Channel_1: DAC Channel1 selected
+  *     @arg DAC_Channel_2: DAC Channel2 selected
+  * @param  DAC_FLAG: specifies the flag to clear.
+  *   This parameter can be of the following value:
+  *     @arg DAC_FLAG_DMAUDR: DMA underrun flag
+  * @retval None
+  */
+void DAC_ClearFlag(uint32_t DAC_Channel, uint32_t DAC_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_DAC_CHANNEL(DAC_Channel));
+  assert_param(IS_DAC_FLAG(DAC_FLAG));
+
+  /* Clear the selected DAC flags */
+  DAC->SR = (DAC_FLAG << DAC_Channel);
+}
+
+/**
+  * @brief  Checks whether the specified DAC interrupt has occurred or not.
+  * @param  DAC_Channel: the selected DAC channel.
+  *   This parameter can be one of the following values:
+  *     @arg DAC_Channel_1: DAC Channel1 selected
+  *     @arg DAC_Channel_2: DAC Channel2 selected
+  * @param  DAC_IT: specifies the DAC interrupt source to check.
+  *   This parameter can be the following values:
+  *     @arg DAC_IT_DMAUDR: DMA underrun interrupt mask
+  * @retval The new state of DAC_IT (SET or RESET).
+  */
+ITStatus DAC_GetITStatus(uint32_t DAC_Channel, uint32_t DAC_IT)
+{
+  ITStatus bitstatus = RESET;
+  uint32_t enablestatus = 0;
+
+  /* Check the parameters */
+  assert_param(IS_DAC_CHANNEL(DAC_Channel));
+  assert_param(IS_DAC_IT(DAC_IT));
+
+  /* Get the DAC_IT enable bit status */
+  enablestatus = (DAC->CR & (DAC_IT << DAC_Channel)) ;
+
+  /* Check the status of the specified DAC interrupt */
+  if (((DAC->SR & (DAC_IT << DAC_Channel)) != (uint32_t)RESET) && enablestatus)
+  {
+    /* DAC_IT is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* DAC_IT is reset */
+    bitstatus = RESET;
+  }
+  /* Return the DAC_IT status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the DAC channelx's interrupt pending bits.
+  * @param  DAC_Channel: the selected DAC channel.
+  *   This parameter can be one of the following values:
+  *     @arg DAC_Channel_1: DAC Channel1 selected
+  *     @arg DAC_Channel_2: DAC Channel2 selected
+  * @param  DAC_IT: specifies the DAC interrupt pending bit to clear.
+  *   This parameter can be the following values:
+  *     @arg DAC_IT_DMAUDR: DMA underrun interrupt mask
+  * @retval None
+  */
+void DAC_ClearITPendingBit(uint32_t DAC_Channel, uint32_t DAC_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_DAC_CHANNEL(DAC_Channel));
+  assert_param(IS_DAC_IT(DAC_IT));
+
+  /* Clear the selected DAC interrupt pending bits */
+  DAC->SR = (DAC_IT << DAC_Channel);
+}
+#endif
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_dbgmcu.c b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_dbgmcu.c
new file mode 100644
index 0000000..d34307b
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_dbgmcu.c
@@ -0,0 +1,162 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_dbgmcu.c
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file provides all the DBGMCU firmware functions.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x_dbgmcu.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup DBGMCU
+  * @brief DBGMCU driver modules
+  * @{
+  */
+
+/** @defgroup DBGMCU_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DBGMCU_Private_Defines
+  * @{
+  */
+
+#define IDCODE_DEVID_MASK    ((uint32_t)0x00000FFF)
+/**
+  * @}
+  */
+
+/** @defgroup DBGMCU_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DBGMCU_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DBGMCU_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DBGMCU_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Returns the device revision identifier.
+  * @param  None
+  * @retval Device revision identifier
+  */
+uint32_t DBGMCU_GetREVID(void)
+{
+   return(DBGMCU->IDCODE >> 16);
+}
+
+/**
+  * @brief  Returns the device identifier.
+  * @param  None
+  * @retval Device identifier
+  */
+uint32_t DBGMCU_GetDEVID(void)
+{
+   return(DBGMCU->IDCODE & IDCODE_DEVID_MASK);
+}
+
+/**
+  * @brief  Configures the specified peripheral and low power mode behavior
+  *   when the MCU under Debug mode.
+  * @param  DBGMCU_Periph: specifies the peripheral and low power mode.
+  *   This parameter can be any combination of the following values:
+  *     @arg DBGMCU_SLEEP: Keep debugger connection during SLEEP mode
+  *     @arg DBGMCU_STOP: Keep debugger connection during STOP mode
+  *     @arg DBGMCU_STANDBY: Keep debugger connection during STANDBY mode
+  *     @arg DBGMCU_IWDG_STOP: Debug IWDG stopped when Core is halted
+  *     @arg DBGMCU_WWDG_STOP: Debug WWDG stopped when Core is halted
+  *     @arg DBGMCU_TIM1_STOP: TIM1 counter stopped when Core is halted
+  *     @arg DBGMCU_TIM2_STOP: TIM2 counter stopped when Core is halted
+  *     @arg DBGMCU_TIM3_STOP: TIM3 counter stopped when Core is halted
+  *     @arg DBGMCU_TIM4_STOP: TIM4 counter stopped when Core is halted
+  *     @arg DBGMCU_CAN1_STOP: Debug CAN2 stopped when Core is halted
+  *     @arg DBGMCU_I2C1_SMBUS_TIMEOUT: I2C1 SMBUS timeout mode stopped when Core is halted
+  *     @arg DBGMCU_I2C2_SMBUS_TIMEOUT: I2C2 SMBUS timeout mode stopped when Core is halted
+  *     @arg DBGMCU_TIM5_STOP: TIM5 counter stopped when Core is halted
+  *     @arg DBGMCU_TIM6_STOP: TIM6 counter stopped when Core is halted
+  *     @arg DBGMCU_TIM7_STOP: TIM7 counter stopped when Core is halted
+  *     @arg DBGMCU_TIM8_STOP: TIM8 counter stopped when Core is halted
+  *     @arg DBGMCU_CAN2_STOP: Debug CAN2 stopped when Core is halted
+  *     @arg DBGMCU_TIM15_STOP: TIM15 counter stopped when Core is halted
+  *     @arg DBGMCU_TIM16_STOP: TIM16 counter stopped when Core is halted
+  *     @arg DBGMCU_TIM17_STOP: TIM17 counter stopped when Core is halted
+  *     @arg DBGMCU_TIM9_STOP: TIM9 counter stopped when Core is halted
+  *     @arg DBGMCU_TIM10_STOP: TIM10 counter stopped when Core is halted
+  *     @arg DBGMCU_TIM11_STOP: TIM11 counter stopped when Core is halted
+  *     @arg DBGMCU_TIM12_STOP: TIM12 counter stopped when Core is halted
+  *     @arg DBGMCU_TIM13_STOP: TIM13 counter stopped when Core is halted
+  *     @arg DBGMCU_TIM14_STOP: TIM14 counter stopped when Core is halted
+  * @param  NewState: new state of the specified peripheral in Debug mode.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void DBGMCU_Config(uint32_t DBGMCU_Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DBGMCU_PERIPH(DBGMCU_Periph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    DBGMCU->CR |= DBGMCU_Periph;
+  }
+  else
+  {
+    DBGMCU->CR &= ~DBGMCU_Periph;
+  }
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_dma.c b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_dma.c
new file mode 100644
index 0000000..0c86f90
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_dma.c
@@ -0,0 +1,714 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_dma.c
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file provides all the DMA firmware functions.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x_dma.h"
+#include "stm32f10x_rcc.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup DMA
+  * @brief DMA driver modules
+  * @{
+  */
+
+/** @defgroup DMA_Private_TypesDefinitions
+  * @{
+  */
+/**
+  * @}
+  */
+
+/** @defgroup DMA_Private_Defines
+  * @{
+  */
+
+
+/* DMA1 Channelx interrupt pending bit masks */
+#define DMA1_Channel1_IT_Mask    ((uint32_t)(DMA_ISR_GIF1 | DMA_ISR_TCIF1 | DMA_ISR_HTIF1 | DMA_ISR_TEIF1))
+#define DMA1_Channel2_IT_Mask    ((uint32_t)(DMA_ISR_GIF2 | DMA_ISR_TCIF2 | DMA_ISR_HTIF2 | DMA_ISR_TEIF2))
+#define DMA1_Channel3_IT_Mask    ((uint32_t)(DMA_ISR_GIF3 | DMA_ISR_TCIF3 | DMA_ISR_HTIF3 | DMA_ISR_TEIF3))
+#define DMA1_Channel4_IT_Mask    ((uint32_t)(DMA_ISR_GIF4 | DMA_ISR_TCIF4 | DMA_ISR_HTIF4 | DMA_ISR_TEIF4))
+#define DMA1_Channel5_IT_Mask    ((uint32_t)(DMA_ISR_GIF5 | DMA_ISR_TCIF5 | DMA_ISR_HTIF5 | DMA_ISR_TEIF5))
+#define DMA1_Channel6_IT_Mask    ((uint32_t)(DMA_ISR_GIF6 | DMA_ISR_TCIF6 | DMA_ISR_HTIF6 | DMA_ISR_TEIF6))
+#define DMA1_Channel7_IT_Mask    ((uint32_t)(DMA_ISR_GIF7 | DMA_ISR_TCIF7 | DMA_ISR_HTIF7 | DMA_ISR_TEIF7))
+
+/* DMA2 Channelx interrupt pending bit masks */
+#define DMA2_Channel1_IT_Mask    ((uint32_t)(DMA_ISR_GIF1 | DMA_ISR_TCIF1 | DMA_ISR_HTIF1 | DMA_ISR_TEIF1))
+#define DMA2_Channel2_IT_Mask    ((uint32_t)(DMA_ISR_GIF2 | DMA_ISR_TCIF2 | DMA_ISR_HTIF2 | DMA_ISR_TEIF2))
+#define DMA2_Channel3_IT_Mask    ((uint32_t)(DMA_ISR_GIF3 | DMA_ISR_TCIF3 | DMA_ISR_HTIF3 | DMA_ISR_TEIF3))
+#define DMA2_Channel4_IT_Mask    ((uint32_t)(DMA_ISR_GIF4 | DMA_ISR_TCIF4 | DMA_ISR_HTIF4 | DMA_ISR_TEIF4))
+#define DMA2_Channel5_IT_Mask    ((uint32_t)(DMA_ISR_GIF5 | DMA_ISR_TCIF5 | DMA_ISR_HTIF5 | DMA_ISR_TEIF5))
+
+/* DMA2 FLAG mask */
+#define FLAG_Mask                ((uint32_t)0x10000000)
+
+/* DMA registers Masks */
+#define CCR_CLEAR_Mask           ((uint32_t)0xFFFF800F)
+
+/**
+  * @}
+  */
+
+/** @defgroup DMA_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DMA_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DMA_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup DMA_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the DMAy Channelx registers to their default reset
+  *         values.
+  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and
+  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
+  * @retval None
+  */
+void DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
+
+  /* Disable the selected DMAy Channelx */
+  DMAy_Channelx->CCR &= (uint16_t)(~DMA_CCR1_EN);
+
+  /* Reset DMAy Channelx control register */
+  DMAy_Channelx->CCR  = 0;
+
+  /* Reset DMAy Channelx remaining bytes register */
+  DMAy_Channelx->CNDTR = 0;
+
+  /* Reset DMAy Channelx peripheral address register */
+  DMAy_Channelx->CPAR  = 0;
+
+  /* Reset DMAy Channelx memory address register */
+  DMAy_Channelx->CMAR = 0;
+
+  if (DMAy_Channelx == DMA1_Channel1)
+  {
+    /* Reset interrupt pending bits for DMA1 Channel1 */
+    DMA1->IFCR |= DMA1_Channel1_IT_Mask;
+  }
+  else if (DMAy_Channelx == DMA1_Channel2)
+  {
+    /* Reset interrupt pending bits for DMA1 Channel2 */
+    DMA1->IFCR |= DMA1_Channel2_IT_Mask;
+  }
+  else if (DMAy_Channelx == DMA1_Channel3)
+  {
+    /* Reset interrupt pending bits for DMA1 Channel3 */
+    DMA1->IFCR |= DMA1_Channel3_IT_Mask;
+  }
+  else if (DMAy_Channelx == DMA1_Channel4)
+  {
+    /* Reset interrupt pending bits for DMA1 Channel4 */
+    DMA1->IFCR |= DMA1_Channel4_IT_Mask;
+  }
+  else if (DMAy_Channelx == DMA1_Channel5)
+  {
+    /* Reset interrupt pending bits for DMA1 Channel5 */
+    DMA1->IFCR |= DMA1_Channel5_IT_Mask;
+  }
+  else if (DMAy_Channelx == DMA1_Channel6)
+  {
+    /* Reset interrupt pending bits for DMA1 Channel6 */
+    DMA1->IFCR |= DMA1_Channel6_IT_Mask;
+  }
+  else if (DMAy_Channelx == DMA1_Channel7)
+  {
+    /* Reset interrupt pending bits for DMA1 Channel7 */
+    DMA1->IFCR |= DMA1_Channel7_IT_Mask;
+  }
+  else if (DMAy_Channelx == DMA2_Channel1)
+  {
+    /* Reset interrupt pending bits for DMA2 Channel1 */
+    DMA2->IFCR |= DMA2_Channel1_IT_Mask;
+  }
+  else if (DMAy_Channelx == DMA2_Channel2)
+  {
+    /* Reset interrupt pending bits for DMA2 Channel2 */
+    DMA2->IFCR |= DMA2_Channel2_IT_Mask;
+  }
+  else if (DMAy_Channelx == DMA2_Channel3)
+  {
+    /* Reset interrupt pending bits for DMA2 Channel3 */
+    DMA2->IFCR |= DMA2_Channel3_IT_Mask;
+  }
+  else if (DMAy_Channelx == DMA2_Channel4)
+  {
+    /* Reset interrupt pending bits for DMA2 Channel4 */
+    DMA2->IFCR |= DMA2_Channel4_IT_Mask;
+  }
+  else
+  {
+    if (DMAy_Channelx == DMA2_Channel5)
+    {
+      /* Reset interrupt pending bits for DMA2 Channel5 */
+      DMA2->IFCR |= DMA2_Channel5_IT_Mask;
+    }
+  }
+}
+
+/**
+  * @brief  Initializes the DMAy Channelx according to the specified
+  *         parameters in the DMA_InitStruct.
+  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and
+  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
+  * @param  DMA_InitStruct: pointer to a DMA_InitTypeDef structure that
+  *         contains the configuration information for the specified DMA Channel.
+  * @retval None
+  */
+void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)
+{
+  uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
+  assert_param(IS_DMA_DIR(DMA_InitStruct->DMA_DIR));
+  assert_param(IS_DMA_BUFFER_SIZE(DMA_InitStruct->DMA_BufferSize));
+  assert_param(IS_DMA_PERIPHERAL_INC_STATE(DMA_InitStruct->DMA_PeripheralInc));
+  assert_param(IS_DMA_MEMORY_INC_STATE(DMA_InitStruct->DMA_MemoryInc));
+  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(DMA_InitStruct->DMA_PeripheralDataSize));
+  assert_param(IS_DMA_MEMORY_DATA_SIZE(DMA_InitStruct->DMA_MemoryDataSize));
+  assert_param(IS_DMA_MODE(DMA_InitStruct->DMA_Mode));
+  assert_param(IS_DMA_PRIORITY(DMA_InitStruct->DMA_Priority));
+  assert_param(IS_DMA_M2M_STATE(DMA_InitStruct->DMA_M2M));
+
+/*--------------------------- DMAy Channelx CCR Configuration -----------------*/
+  /* Get the DMAy_Channelx CCR value */
+  tmpreg = DMAy_Channelx->CCR;
+  /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
+  tmpreg &= CCR_CLEAR_Mask;
+  /* Configure DMAy Channelx: data transfer, data size, priority level and mode */
+  /* Set DIR bit according to DMA_DIR value */
+  /* Set CIRC bit according to DMA_Mode value */
+  /* Set PINC bit according to DMA_PeripheralInc value */
+  /* Set MINC bit according to DMA_MemoryInc value */
+  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
+  /* Set MSIZE bits according to DMA_MemoryDataSize value */
+  /* Set PL bits according to DMA_Priority value */
+  /* Set the MEM2MEM bit according to DMA_M2M value */
+  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
+            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
+            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
+            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;
+
+  /* Write to DMAy Channelx CCR */
+  DMAy_Channelx->CCR = tmpreg;
+
+/*--------------------------- DMAy Channelx CNDTR Configuration ---------------*/
+  /* Write to DMAy Channelx CNDTR */
+  DMAy_Channelx->CNDTR = DMA_InitStruct->DMA_BufferSize;
+
+/*--------------------------- DMAy Channelx CPAR Configuration ----------------*/
+  /* Write to DMAy Channelx CPAR */
+  DMAy_Channelx->CPAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
+
+/*--------------------------- DMAy Channelx CMAR Configuration ----------------*/
+  /* Write to DMAy Channelx CMAR */
+  DMAy_Channelx->CMAR = DMA_InitStruct->DMA_MemoryBaseAddr;
+}
+
+/**
+  * @brief  Fills each DMA_InitStruct member with its default value.
+  * @param  DMA_InitStruct : pointer to a DMA_InitTypeDef structure which will
+  *         be initialized.
+  * @retval None
+  */
+void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
+{
+/*-------------- Reset DMA init structure parameters values ------------------*/
+  /* Initialize the DMA_PeripheralBaseAddr member */
+  DMA_InitStruct->DMA_PeripheralBaseAddr = 0;
+  /* Initialize the DMA_MemoryBaseAddr member */
+  DMA_InitStruct->DMA_MemoryBaseAddr = 0;
+  /* Initialize the DMA_DIR member */
+  DMA_InitStruct->DMA_DIR = DMA_DIR_PeripheralSRC;
+  /* Initialize the DMA_BufferSize member */
+  DMA_InitStruct->DMA_BufferSize = 0;
+  /* Initialize the DMA_PeripheralInc member */
+  DMA_InitStruct->DMA_PeripheralInc = DMA_PeripheralInc_Disable;
+  /* Initialize the DMA_MemoryInc member */
+  DMA_InitStruct->DMA_MemoryInc = DMA_MemoryInc_Disable;
+  /* Initialize the DMA_PeripheralDataSize member */
+  DMA_InitStruct->DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
+  /* Initialize the DMA_MemoryDataSize member */
+  DMA_InitStruct->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
+  /* Initialize the DMA_Mode member */
+  DMA_InitStruct->DMA_Mode = DMA_Mode_Normal;
+  /* Initialize the DMA_Priority member */
+  DMA_InitStruct->DMA_Priority = DMA_Priority_Low;
+  /* Initialize the DMA_M2M member */
+  DMA_InitStruct->DMA_M2M = DMA_M2M_Disable;
+}
+
+/**
+  * @brief  Enables or disables the specified DMAy Channelx.
+  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and
+  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
+  * @param  NewState: new state of the DMAy Channelx.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected DMAy Channelx */
+    DMAy_Channelx->CCR |= DMA_CCR1_EN;
+  }
+  else
+  {
+    /* Disable the selected DMAy Channelx */
+    DMAy_Channelx->CCR &= (uint16_t)(~DMA_CCR1_EN);
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified DMAy Channelx interrupts.
+  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and
+  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
+  * @param  DMA_IT: specifies the DMA interrupts sources to be enabled
+  *   or disabled.
+  *   This parameter can be any combination of the following values:
+  *     @arg DMA_IT_TC:  Transfer complete interrupt mask
+  *     @arg DMA_IT_HT:  Half transfer interrupt mask
+  *     @arg DMA_IT_TE:  Transfer error interrupt mask
+  * @param  NewState: new state of the specified DMA interrupts.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, uint32_t DMA_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
+  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected DMA interrupts */
+    DMAy_Channelx->CCR |= DMA_IT;
+  }
+  else
+  {
+    /* Disable the selected DMA interrupts */
+    DMAy_Channelx->CCR &= ~DMA_IT;
+  }
+}
+
+/**
+  * @brief  Sets the number of data units in the current DMAy Channelx transfer.
+  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and
+  *         x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
+  * @param  DataNumber: The number of data units in the current DMAy Channelx
+  *         transfer.
+  * @note   This function can only be used when the DMAy_Channelx is disabled.
+  * @retval None.
+  */
+void DMA_SetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx, uint16_t DataNumber)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
+
+/*--------------------------- DMAy Channelx CNDTR Configuration ---------------*/
+  /* Write to DMAy Channelx CNDTR */
+  DMAy_Channelx->CNDTR = DataNumber;
+}
+
+/**
+  * @brief  Returns the number of remaining data units in the current
+  *         DMAy Channelx transfer.
+  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and
+  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
+  * @retval The number of remaining data units in the current DMAy Channelx
+  *         transfer.
+  */
+uint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
+  /* Return the number of remaining data units for DMAy Channelx */
+  return ((uint16_t)(DMAy_Channelx->CNDTR));
+}
+
+/**
+  * @brief  Checks whether the specified DMAy Channelx flag is set or not.
+  * @param  DMAy_FLAG: specifies the flag to check.
+  *   This parameter can be one of the following values:
+  *     @arg DMA1_FLAG_GL1: DMA1 Channel1 global flag.
+  *     @arg DMA1_FLAG_TC1: DMA1 Channel1 transfer complete flag.
+  *     @arg DMA1_FLAG_HT1: DMA1 Channel1 half transfer flag.
+  *     @arg DMA1_FLAG_TE1: DMA1 Channel1 transfer error flag.
+  *     @arg DMA1_FLAG_GL2: DMA1 Channel2 global flag.
+  *     @arg DMA1_FLAG_TC2: DMA1 Channel2 transfer complete flag.
+  *     @arg DMA1_FLAG_HT2: DMA1 Channel2 half transfer flag.
+  *     @arg DMA1_FLAG_TE2: DMA1 Channel2 transfer error flag.
+  *     @arg DMA1_FLAG_GL3: DMA1 Channel3 global flag.
+  *     @arg DMA1_FLAG_TC3: DMA1 Channel3 transfer complete flag.
+  *     @arg DMA1_FLAG_HT3: DMA1 Channel3 half transfer flag.
+  *     @arg DMA1_FLAG_TE3: DMA1 Channel3 transfer error flag.
+  *     @arg DMA1_FLAG_GL4: DMA1 Channel4 global flag.
+  *     @arg DMA1_FLAG_TC4: DMA1 Channel4 transfer complete flag.
+  *     @arg DMA1_FLAG_HT4: DMA1 Channel4 half transfer flag.
+  *     @arg DMA1_FLAG_TE4: DMA1 Channel4 transfer error flag.
+  *     @arg DMA1_FLAG_GL5: DMA1 Channel5 global flag.
+  *     @arg DMA1_FLAG_TC5: DMA1 Channel5 transfer complete flag.
+  *     @arg DMA1_FLAG_HT5: DMA1 Channel5 half transfer flag.
+  *     @arg DMA1_FLAG_TE5: DMA1 Channel5 transfer error flag.
+  *     @arg DMA1_FLAG_GL6: DMA1 Channel6 global flag.
+  *     @arg DMA1_FLAG_TC6: DMA1 Channel6 transfer complete flag.
+  *     @arg DMA1_FLAG_HT6: DMA1 Channel6 half transfer flag.
+  *     @arg DMA1_FLAG_TE6: DMA1 Channel6 transfer error flag.
+  *     @arg DMA1_FLAG_GL7: DMA1 Channel7 global flag.
+  *     @arg DMA1_FLAG_TC7: DMA1 Channel7 transfer complete flag.
+  *     @arg DMA1_FLAG_HT7: DMA1 Channel7 half transfer flag.
+  *     @arg DMA1_FLAG_TE7: DMA1 Channel7 transfer error flag.
+  *     @arg DMA2_FLAG_GL1: DMA2 Channel1 global flag.
+  *     @arg DMA2_FLAG_TC1: DMA2 Channel1 transfer complete flag.
+  *     @arg DMA2_FLAG_HT1: DMA2 Channel1 half transfer flag.
+  *     @arg DMA2_FLAG_TE1: DMA2 Channel1 transfer error flag.
+  *     @arg DMA2_FLAG_GL2: DMA2 Channel2 global flag.
+  *     @arg DMA2_FLAG_TC2: DMA2 Channel2 transfer complete flag.
+  *     @arg DMA2_FLAG_HT2: DMA2 Channel2 half transfer flag.
+  *     @arg DMA2_FLAG_TE2: DMA2 Channel2 transfer error flag.
+  *     @arg DMA2_FLAG_GL3: DMA2 Channel3 global flag.
+  *     @arg DMA2_FLAG_TC3: DMA2 Channel3 transfer complete flag.
+  *     @arg DMA2_FLAG_HT3: DMA2 Channel3 half transfer flag.
+  *     @arg DMA2_FLAG_TE3: DMA2 Channel3 transfer error flag.
+  *     @arg DMA2_FLAG_GL4: DMA2 Channel4 global flag.
+  *     @arg DMA2_FLAG_TC4: DMA2 Channel4 transfer complete flag.
+  *     @arg DMA2_FLAG_HT4: DMA2 Channel4 half transfer flag.
+  *     @arg DMA2_FLAG_TE4: DMA2 Channel4 transfer error flag.
+  *     @arg DMA2_FLAG_GL5: DMA2 Channel5 global flag.
+  *     @arg DMA2_FLAG_TC5: DMA2 Channel5 transfer complete flag.
+  *     @arg DMA2_FLAG_HT5: DMA2 Channel5 half transfer flag.
+  *     @arg DMA2_FLAG_TE5: DMA2 Channel5 transfer error flag.
+  * @retval The new state of DMAy_FLAG (SET or RESET).
+  */
+FlagStatus DMA_GetFlagStatus(uint32_t DMAy_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_DMA_GET_FLAG(DMAy_FLAG));
+
+  /* Calculate the used DMAy */
+  if ((DMAy_FLAG & FLAG_Mask) != (uint32_t)RESET)
+  {
+    /* Get DMA2 ISR register value */
+    tmpreg = DMA2->ISR ;
+  }
+  else
+  {
+    /* Get DMA1 ISR register value */
+    tmpreg = DMA1->ISR ;
+  }
+
+  /* Check the status of the specified DMAy flag */
+  if ((tmpreg & DMAy_FLAG) != (uint32_t)RESET)
+  {
+    /* DMAy_FLAG is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* DMAy_FLAG is reset */
+    bitstatus = RESET;
+  }
+
+  /* Return the DMAy_FLAG status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the DMAy Channelx's pending flags.
+  * @param  DMAy_FLAG: specifies the flag to clear.
+  *   This parameter can be any combination (for the same DMA) of the following values:
+  *     @arg DMA1_FLAG_GL1: DMA1 Channel1 global flag.
+  *     @arg DMA1_FLAG_TC1: DMA1 Channel1 transfer complete flag.
+  *     @arg DMA1_FLAG_HT1: DMA1 Channel1 half transfer flag.
+  *     @arg DMA1_FLAG_TE1: DMA1 Channel1 transfer error flag.
+  *     @arg DMA1_FLAG_GL2: DMA1 Channel2 global flag.
+  *     @arg DMA1_FLAG_TC2: DMA1 Channel2 transfer complete flag.
+  *     @arg DMA1_FLAG_HT2: DMA1 Channel2 half transfer flag.
+  *     @arg DMA1_FLAG_TE2: DMA1 Channel2 transfer error flag.
+  *     @arg DMA1_FLAG_GL3: DMA1 Channel3 global flag.
+  *     @arg DMA1_FLAG_TC3: DMA1 Channel3 transfer complete flag.
+  *     @arg DMA1_FLAG_HT3: DMA1 Channel3 half transfer flag.
+  *     @arg DMA1_FLAG_TE3: DMA1 Channel3 transfer error flag.
+  *     @arg DMA1_FLAG_GL4: DMA1 Channel4 global flag.
+  *     @arg DMA1_FLAG_TC4: DMA1 Channel4 transfer complete flag.
+  *     @arg DMA1_FLAG_HT4: DMA1 Channel4 half transfer flag.
+  *     @arg DMA1_FLAG_TE4: DMA1 Channel4 transfer error flag.
+  *     @arg DMA1_FLAG_GL5: DMA1 Channel5 global flag.
+  *     @arg DMA1_FLAG_TC5: DMA1 Channel5 transfer complete flag.
+  *     @arg DMA1_FLAG_HT5: DMA1 Channel5 half transfer flag.
+  *     @arg DMA1_FLAG_TE5: DMA1 Channel5 transfer error flag.
+  *     @arg DMA1_FLAG_GL6: DMA1 Channel6 global flag.
+  *     @arg DMA1_FLAG_TC6: DMA1 Channel6 transfer complete flag.
+  *     @arg DMA1_FLAG_HT6: DMA1 Channel6 half transfer flag.
+  *     @arg DMA1_FLAG_TE6: DMA1 Channel6 transfer error flag.
+  *     @arg DMA1_FLAG_GL7: DMA1 Channel7 global flag.
+  *     @arg DMA1_FLAG_TC7: DMA1 Channel7 transfer complete flag.
+  *     @arg DMA1_FLAG_HT7: DMA1 Channel7 half transfer flag.
+  *     @arg DMA1_FLAG_TE7: DMA1 Channel7 transfer error flag.
+  *     @arg DMA2_FLAG_GL1: DMA2 Channel1 global flag.
+  *     @arg DMA2_FLAG_TC1: DMA2 Channel1 transfer complete flag.
+  *     @arg DMA2_FLAG_HT1: DMA2 Channel1 half transfer flag.
+  *     @arg DMA2_FLAG_TE1: DMA2 Channel1 transfer error flag.
+  *     @arg DMA2_FLAG_GL2: DMA2 Channel2 global flag.
+  *     @arg DMA2_FLAG_TC2: DMA2 Channel2 transfer complete flag.
+  *     @arg DMA2_FLAG_HT2: DMA2 Channel2 half transfer flag.
+  *     @arg DMA2_FLAG_TE2: DMA2 Channel2 transfer error flag.
+  *     @arg DMA2_FLAG_GL3: DMA2 Channel3 global flag.
+  *     @arg DMA2_FLAG_TC3: DMA2 Channel3 transfer complete flag.
+  *     @arg DMA2_FLAG_HT3: DMA2 Channel3 half transfer flag.
+  *     @arg DMA2_FLAG_TE3: DMA2 Channel3 transfer error flag.
+  *     @arg DMA2_FLAG_GL4: DMA2 Channel4 global flag.
+  *     @arg DMA2_FLAG_TC4: DMA2 Channel4 transfer complete flag.
+  *     @arg DMA2_FLAG_HT4: DMA2 Channel4 half transfer flag.
+  *     @arg DMA2_FLAG_TE4: DMA2 Channel4 transfer error flag.
+  *     @arg DMA2_FLAG_GL5: DMA2 Channel5 global flag.
+  *     @arg DMA2_FLAG_TC5: DMA2 Channel5 transfer complete flag.
+  *     @arg DMA2_FLAG_HT5: DMA2 Channel5 half transfer flag.
+  *     @arg DMA2_FLAG_TE5: DMA2 Channel5 transfer error flag.
+  * @retval None
+  */
+void DMA_ClearFlag(uint32_t DMAy_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA_CLEAR_FLAG(DMAy_FLAG));
+
+  /* Calculate the used DMAy */
+  if ((DMAy_FLAG & FLAG_Mask) != (uint32_t)RESET)
+  {
+    /* Clear the selected DMAy flags */
+    DMA2->IFCR = DMAy_FLAG;
+  }
+  else
+  {
+    /* Clear the selected DMAy flags */
+    DMA1->IFCR = DMAy_FLAG;
+  }
+}
+
+/**
+  * @brief  Checks whether the specified DMAy Channelx interrupt has occurred or not.
+  * @param  DMAy_IT: specifies the DMAy interrupt source to check.
+  *   This parameter can be one of the following values:
+  *     @arg DMA1_IT_GL1: DMA1 Channel1 global interrupt.
+  *     @arg DMA1_IT_TC1: DMA1 Channel1 transfer complete interrupt.
+  *     @arg DMA1_IT_HT1: DMA1 Channel1 half transfer interrupt.
+  *     @arg DMA1_IT_TE1: DMA1 Channel1 transfer error interrupt.
+  *     @arg DMA1_IT_GL2: DMA1 Channel2 global interrupt.
+  *     @arg DMA1_IT_TC2: DMA1 Channel2 transfer complete interrupt.
+  *     @arg DMA1_IT_HT2: DMA1 Channel2 half transfer interrupt.
+  *     @arg DMA1_IT_TE2: DMA1 Channel2 transfer error interrupt.
+  *     @arg DMA1_IT_GL3: DMA1 Channel3 global interrupt.
+  *     @arg DMA1_IT_TC3: DMA1 Channel3 transfer complete interrupt.
+  *     @arg DMA1_IT_HT3: DMA1 Channel3 half transfer interrupt.
+  *     @arg DMA1_IT_TE3: DMA1 Channel3 transfer error interrupt.
+  *     @arg DMA1_IT_GL4: DMA1 Channel4 global interrupt.
+  *     @arg DMA1_IT_TC4: DMA1 Channel4 transfer complete interrupt.
+  *     @arg DMA1_IT_HT4: DMA1 Channel4 half transfer interrupt.
+  *     @arg DMA1_IT_TE4: DMA1 Channel4 transfer error interrupt.
+  *     @arg DMA1_IT_GL5: DMA1 Channel5 global interrupt.
+  *     @arg DMA1_IT_TC5: DMA1 Channel5 transfer complete interrupt.
+  *     @arg DMA1_IT_HT5: DMA1 Channel5 half transfer interrupt.
+  *     @arg DMA1_IT_TE5: DMA1 Channel5 transfer error interrupt.
+  *     @arg DMA1_IT_GL6: DMA1 Channel6 global interrupt.
+  *     @arg DMA1_IT_TC6: DMA1 Channel6 transfer complete interrupt.
+  *     @arg DMA1_IT_HT6: DMA1 Channel6 half transfer interrupt.
+  *     @arg DMA1_IT_TE6: DMA1 Channel6 transfer error interrupt.
+  *     @arg DMA1_IT_GL7: DMA1 Channel7 global interrupt.
+  *     @arg DMA1_IT_TC7: DMA1 Channel7 transfer complete interrupt.
+  *     @arg DMA1_IT_HT7: DMA1 Channel7 half transfer interrupt.
+  *     @arg DMA1_IT_TE7: DMA1 Channel7 transfer error interrupt.
+  *     @arg DMA2_IT_GL1: DMA2 Channel1 global interrupt.
+  *     @arg DMA2_IT_TC1: DMA2 Channel1 transfer complete interrupt.
+  *     @arg DMA2_IT_HT1: DMA2 Channel1 half transfer interrupt.
+  *     @arg DMA2_IT_TE1: DMA2 Channel1 transfer error interrupt.
+  *     @arg DMA2_IT_GL2: DMA2 Channel2 global interrupt.
+  *     @arg DMA2_IT_TC2: DMA2 Channel2 transfer complete interrupt.
+  *     @arg DMA2_IT_HT2: DMA2 Channel2 half transfer interrupt.
+  *     @arg DMA2_IT_TE2: DMA2 Channel2 transfer error interrupt.
+  *     @arg DMA2_IT_GL3: DMA2 Channel3 global interrupt.
+  *     @arg DMA2_IT_TC3: DMA2 Channel3 transfer complete interrupt.
+  *     @arg DMA2_IT_HT3: DMA2 Channel3 half transfer interrupt.
+  *     @arg DMA2_IT_TE3: DMA2 Channel3 transfer error interrupt.
+  *     @arg DMA2_IT_GL4: DMA2 Channel4 global interrupt.
+  *     @arg DMA2_IT_TC4: DMA2 Channel4 transfer complete interrupt.
+  *     @arg DMA2_IT_HT4: DMA2 Channel4 half transfer interrupt.
+  *     @arg DMA2_IT_TE4: DMA2 Channel4 transfer error interrupt.
+  *     @arg DMA2_IT_GL5: DMA2 Channel5 global interrupt.
+  *     @arg DMA2_IT_TC5: DMA2 Channel5 transfer complete interrupt.
+  *     @arg DMA2_IT_HT5: DMA2 Channel5 half transfer interrupt.
+  *     @arg DMA2_IT_TE5: DMA2 Channel5 transfer error interrupt.
+  * @retval The new state of DMAy_IT (SET or RESET).
+  */
+ITStatus DMA_GetITStatus(uint32_t DMAy_IT)
+{
+  ITStatus bitstatus = RESET;
+  uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_DMA_GET_IT(DMAy_IT));
+
+  /* Calculate the used DMA */
+  if ((DMAy_IT & FLAG_Mask) != (uint32_t)RESET)
+  {
+    /* Get DMA2 ISR register value */
+    tmpreg = DMA2->ISR;
+  }
+  else
+  {
+    /* Get DMA1 ISR register value */
+    tmpreg = DMA1->ISR;
+  }
+
+  /* Check the status of the specified DMAy interrupt */
+  if ((tmpreg & DMAy_IT) != (uint32_t)RESET)
+  {
+    /* DMAy_IT is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* DMAy_IT is reset */
+    bitstatus = RESET;
+  }
+  /* Return the DMA_IT status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the DMAy Channelx's interrupt pending bits.
+  * @param  DMAy_IT: specifies the DMAy interrupt pending bit to clear.
+  *   This parameter can be any combination (for the same DMA) of the following values:
+  *     @arg DMA1_IT_GL1: DMA1 Channel1 global interrupt.
+  *     @arg DMA1_IT_TC1: DMA1 Channel1 transfer complete interrupt.
+  *     @arg DMA1_IT_HT1: DMA1 Channel1 half transfer interrupt.
+  *     @arg DMA1_IT_TE1: DMA1 Channel1 transfer error interrupt.
+  *     @arg DMA1_IT_GL2: DMA1 Channel2 global interrupt.
+  *     @arg DMA1_IT_TC2: DMA1 Channel2 transfer complete interrupt.
+  *     @arg DMA1_IT_HT2: DMA1 Channel2 half transfer interrupt.
+  *     @arg DMA1_IT_TE2: DMA1 Channel2 transfer error interrupt.
+  *     @arg DMA1_IT_GL3: DMA1 Channel3 global interrupt.
+  *     @arg DMA1_IT_TC3: DMA1 Channel3 transfer complete interrupt.
+  *     @arg DMA1_IT_HT3: DMA1 Channel3 half transfer interrupt.
+  *     @arg DMA1_IT_TE3: DMA1 Channel3 transfer error interrupt.
+  *     @arg DMA1_IT_GL4: DMA1 Channel4 global interrupt.
+  *     @arg DMA1_IT_TC4: DMA1 Channel4 transfer complete interrupt.
+  *     @arg DMA1_IT_HT4: DMA1 Channel4 half transfer interrupt.
+  *     @arg DMA1_IT_TE4: DMA1 Channel4 transfer error interrupt.
+  *     @arg DMA1_IT_GL5: DMA1 Channel5 global interrupt.
+  *     @arg DMA1_IT_TC5: DMA1 Channel5 transfer complete interrupt.
+  *     @arg DMA1_IT_HT5: DMA1 Channel5 half transfer interrupt.
+  *     @arg DMA1_IT_TE5: DMA1 Channel5 transfer error interrupt.
+  *     @arg DMA1_IT_GL6: DMA1 Channel6 global interrupt.
+  *     @arg DMA1_IT_TC6: DMA1 Channel6 transfer complete interrupt.
+  *     @arg DMA1_IT_HT6: DMA1 Channel6 half transfer interrupt.
+  *     @arg DMA1_IT_TE6: DMA1 Channel6 transfer error interrupt.
+  *     @arg DMA1_IT_GL7: DMA1 Channel7 global interrupt.
+  *     @arg DMA1_IT_TC7: DMA1 Channel7 transfer complete interrupt.
+  *     @arg DMA1_IT_HT7: DMA1 Channel7 half transfer interrupt.
+  *     @arg DMA1_IT_TE7: DMA1 Channel7 transfer error interrupt.
+  *     @arg DMA2_IT_GL1: DMA2 Channel1 global interrupt.
+  *     @arg DMA2_IT_TC1: DMA2 Channel1 transfer complete interrupt.
+  *     @arg DMA2_IT_HT1: DMA2 Channel1 half transfer interrupt.
+  *     @arg DMA2_IT_TE1: DMA2 Channel1 transfer error interrupt.
+  *     @arg DMA2_IT_GL2: DMA2 Channel2 global interrupt.
+  *     @arg DMA2_IT_TC2: DMA2 Channel2 transfer complete interrupt.
+  *     @arg DMA2_IT_HT2: DMA2 Channel2 half transfer interrupt.
+  *     @arg DMA2_IT_TE2: DMA2 Channel2 transfer error interrupt.
+  *     @arg DMA2_IT_GL3: DMA2 Channel3 global interrupt.
+  *     @arg DMA2_IT_TC3: DMA2 Channel3 transfer complete interrupt.
+  *     @arg DMA2_IT_HT3: DMA2 Channel3 half transfer interrupt.
+  *     @arg DMA2_IT_TE3: DMA2 Channel3 transfer error interrupt.
+  *     @arg DMA2_IT_GL4: DMA2 Channel4 global interrupt.
+  *     @arg DMA2_IT_TC4: DMA2 Channel4 transfer complete interrupt.
+  *     @arg DMA2_IT_HT4: DMA2 Channel4 half transfer interrupt.
+  *     @arg DMA2_IT_TE4: DMA2 Channel4 transfer error interrupt.
+  *     @arg DMA2_IT_GL5: DMA2 Channel5 global interrupt.
+  *     @arg DMA2_IT_TC5: DMA2 Channel5 transfer complete interrupt.
+  *     @arg DMA2_IT_HT5: DMA2 Channel5 half transfer interrupt.
+  *     @arg DMA2_IT_TE5: DMA2 Channel5 transfer error interrupt.
+  * @retval None
+  */
+void DMA_ClearITPendingBit(uint32_t DMAy_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA_CLEAR_IT(DMAy_IT));
+
+  /* Calculate the used DMAy */
+  if ((DMAy_IT & FLAG_Mask) != (uint32_t)RESET)
+  {
+    /* Clear the selected DMAy interrupt pending bits */
+    DMA2->IFCR = DMAy_IT;
+  }
+  else
+  {
+    /* Clear the selected DMAy interrupt pending bits */
+    DMA1->IFCR = DMAy_IT;
+  }
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_exti.c b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_exti.c
new file mode 100644
index 0000000..ab73462
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_exti.c
@@ -0,0 +1,269 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_exti.c
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file provides all the EXTI firmware functions.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x_exti.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup EXTI
+  * @brief EXTI driver modules
+  * @{
+  */
+
+/** @defgroup EXTI_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup EXTI_Private_Defines
+  * @{
+  */
+
+#define EXTI_LINENONE    ((uint32_t)0x00000)  /* No interrupt selected */
+
+/**
+  * @}
+  */
+
+/** @defgroup EXTI_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup EXTI_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup EXTI_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup EXTI_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the EXTI peripheral registers to their default reset values.
+  * @param  None
+  * @retval None
+  */
+void EXTI_DeInit(void)
+{
+  EXTI->IMR = 0x00000000;
+  EXTI->EMR = 0x00000000;
+  EXTI->RTSR = 0x00000000;
+  EXTI->FTSR = 0x00000000;
+  EXTI->PR = 0x000FFFFF;
+}
+
+/**
+  * @brief  Initializes the EXTI peripheral according to the specified
+  *         parameters in the EXTI_InitStruct.
+  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure
+  *         that contains the configuration information for the EXTI peripheral.
+  * @retval None
+  */
+void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
+{
+  uint32_t tmp = 0;
+
+  /* Check the parameters */
+  assert_param(IS_EXTI_MODE(EXTI_InitStruct->EXTI_Mode));
+  assert_param(IS_EXTI_TRIGGER(EXTI_InitStruct->EXTI_Trigger));
+  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));
+  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));
+
+  tmp = (uint32_t)EXTI_BASE;
+
+  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
+  {
+    /* Clear EXTI line configuration */
+    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
+    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
+
+    tmp += EXTI_InitStruct->EXTI_Mode;
+
+    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
+
+    /* Clear Rising Falling edge configuration */
+    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
+    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
+
+    /* Select the trigger for the selected external interrupts */
+    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
+    {
+      /* Rising Falling edge */
+      EXTI->RTSR |= EXTI_InitStruct->EXTI_Line;
+      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
+    }
+    else
+    {
+      tmp = (uint32_t)EXTI_BASE;
+      tmp += EXTI_InitStruct->EXTI_Trigger;
+
+      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
+    }
+  }
+  else
+  {
+    tmp += EXTI_InitStruct->EXTI_Mode;
+
+    /* Disable the selected external lines */
+    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
+  }
+}
+
+/**
+  * @brief  Fills each EXTI_InitStruct member with its reset value.
+  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure which will
+  *         be initialized.
+  * @retval None
+  */
+void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
+{
+  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
+  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
+  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Falling;
+  EXTI_InitStruct->EXTI_LineCmd = DISABLE;
+}
+
+/**
+  * @brief  Generates a Software interrupt.
+  * @param  EXTI_Line: specifies the EXTI lines to be enabled or disabled.
+  *   This parameter can be any combination of EXTI_Linex where x can be (0..19).
+  * @retval None
+  */
+void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)
+{
+  /* Check the parameters */
+  assert_param(IS_EXTI_LINE(EXTI_Line));
+
+  EXTI->SWIER |= EXTI_Line;
+}
+
+/**
+  * @brief  Checks whether the specified EXTI line flag is set or not.
+  * @param  EXTI_Line: specifies the EXTI line flag to check.
+  *   This parameter can be:
+  *     @arg EXTI_Linex: External interrupt line x where x(0..19)
+  * @retval The new state of EXTI_Line (SET or RESET).
+  */
+FlagStatus EXTI_GetFlagStatus(uint32_t EXTI_Line)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
+
+  if ((EXTI->PR & EXTI_Line) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the EXTI's line pending flags.
+  * @param  EXTI_Line: specifies the EXTI lines flags to clear.
+  *   This parameter can be any combination of EXTI_Linex where x can be (0..19).
+  * @retval None
+  */
+void EXTI_ClearFlag(uint32_t EXTI_Line)
+{
+  /* Check the parameters */
+  assert_param(IS_EXTI_LINE(EXTI_Line));
+
+  EXTI->PR = EXTI_Line;
+}
+
+/**
+  * @brief  Checks whether the specified EXTI line is asserted or not.
+  * @param  EXTI_Line: specifies the EXTI line to check.
+  *   This parameter can be:
+  *     @arg EXTI_Linex: External interrupt line x where x(0..19)
+  * @retval The new state of EXTI_Line (SET or RESET).
+  */
+ITStatus EXTI_GetITStatus(uint32_t EXTI_Line)
+{
+  ITStatus bitstatus = RESET;
+  uint32_t enablestatus = 0;
+  /* Check the parameters */
+  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
+
+  enablestatus =  EXTI->IMR & EXTI_Line;
+  if (((EXTI->PR & EXTI_Line) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the EXTI's line pending bits.
+  * @param  EXTI_Line: specifies the EXTI lines to clear.
+  *   This parameter can be any combination of EXTI_Linex where x can be (0..19).
+  * @retval None
+  */
+void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
+{
+  /* Check the parameters */
+  assert_param(IS_EXTI_LINE(EXTI_Line));
+
+  EXTI->PR = EXTI_Line;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_flash.c b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_flash.c
new file mode 100644
index 0000000..f6c7bf1
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_flash.c
@@ -0,0 +1,1684 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_flash.c
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file provides all the FLASH firmware functions.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x_flash.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup FLASH
+  * @brief FLASH driver modules
+  * @{
+  */
+
+/** @defgroup FLASH_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup FLASH_Private_Defines
+  * @{
+  */
+
+/* Flash Access Control Register bits */
+#define ACR_LATENCY_Mask         ((uint32_t)0x00000038)
+#define ACR_HLFCYA_Mask          ((uint32_t)0xFFFFFFF7)
+#define ACR_PRFTBE_Mask          ((uint32_t)0xFFFFFFEF)
+
+/* Flash Access Control Register bits */
+#define ACR_PRFTBS_Mask          ((uint32_t)0x00000020)
+
+/* Flash Control Register bits */
+#define CR_PG_Set                ((uint32_t)0x00000001)
+#define CR_PG_Reset              ((uint32_t)0x00001FFE)
+#define CR_PER_Set               ((uint32_t)0x00000002)
+#define CR_PER_Reset             ((uint32_t)0x00001FFD)
+#define CR_MER_Set               ((uint32_t)0x00000004)
+#define CR_MER_Reset             ((uint32_t)0x00001FFB)
+#define CR_OPTPG_Set             ((uint32_t)0x00000010)
+#define CR_OPTPG_Reset           ((uint32_t)0x00001FEF)
+#define CR_OPTER_Set             ((uint32_t)0x00000020)
+#define CR_OPTER_Reset           ((uint32_t)0x00001FDF)
+#define CR_STRT_Set              ((uint32_t)0x00000040)
+#define CR_LOCK_Set              ((uint32_t)0x00000080)
+
+/* FLASH Mask */
+#define RDPRT_Mask               ((uint32_t)0x00000002)
+#define WRP0_Mask                ((uint32_t)0x000000FF)
+#define WRP1_Mask                ((uint32_t)0x0000FF00)
+#define WRP2_Mask                ((uint32_t)0x00FF0000)
+#define WRP3_Mask                ((uint32_t)0xFF000000)
+#define OB_USER_BFB2             ((uint16_t)0x0008)
+
+/* FLASH Keys */
+#define RDP_Key                  ((uint16_t)0x00A5)
+#define FLASH_KEY1               ((uint32_t)0x45670123)
+#define FLASH_KEY2               ((uint32_t)0xCDEF89AB)
+
+/* FLASH BANK address */
+#define FLASH_BANK1_END_ADDRESS   ((uint32_t)0x807FFFF)
+
+/* Delay definition */
+#define EraseTimeout          ((uint32_t)0x000B0000)
+#define ProgramTimeout        ((uint32_t)0x00002000)
+/**
+  * @}
+  */
+
+/** @defgroup FLASH_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup FLASH_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup FLASH_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup FLASH_Private_Functions
+  * @{
+  */
+
+/**
+@code
+
+ This driver provides functions to configure and program the Flash memory of all STM32F10x devices,
+ including the latest STM32F10x_XL density devices.
+
+ STM32F10x_XL devices feature up to 1 Mbyte with dual bank architecture for read-while-write (RWW) capability:
+    - bank1: fixed size of 512 Kbytes (256 pages of 2Kbytes each)
+    - bank2: up to 512 Kbytes (up to 256 pages of 2Kbytes each)
+ While other STM32F10x devices features only one bank with memory up to 512 Kbytes.
+
+ In version V3.3.0, some functions were updated and new ones were added to support
+ STM32F10x_XL devices. Thus some functions manages all devices, while other are
+ dedicated for XL devices only.
+
+ The table below presents the list of available functions depending on the used STM32F10x devices.
+
+   ***************************************************
+   * Legacy functions used for all STM32F10x devices *
+   ***************************************************
+   +----------------------------------------------------------------------------------------------------------------------------------+
+   |       Functions prototypes         |STM32F10x_XL|Other STM32F10x|    Comments                                                    |
+   |                                    |   devices  |  devices      |                                                                |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   |FLASH_SetLatency                    |    Yes     |      Yes      | No change                                                      |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   |FLASH_HalfCycleAccessCmd            |    Yes     |      Yes      | No change                                                      |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   |FLASH_PrefetchBufferCmd             |    Yes     |      Yes      | No change                                                      |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   |FLASH_Unlock                        |    Yes     |      Yes      | - For STM32F10X_XL devices: unlock Bank1 and Bank2.            |
+   |                                    |            |               | - For other devices: unlock Bank1 and it is equivalent         |
+   |                                    |            |               |   to FLASH_UnlockBank1 function.                               |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   |FLASH_Lock                          |    Yes     |      Yes      | - For STM32F10X_XL devices: lock Bank1 and Bank2.              |
+   |                                    |            |               | - For other devices: lock Bank1 and it is equivalent           |
+   |                                    |            |               |   to FLASH_LockBank1 function.                                 |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   |FLASH_ErasePage                     |    Yes     |      Yes      | - For STM32F10x_XL devices: erase a page in Bank1 and Bank2    |
+   |                                    |            |               | - For other devices: erase a page in Bank1                     |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   |FLASH_EraseAllPages                 |    Yes     |      Yes      | - For STM32F10x_XL devices: erase all pages in Bank1 and Bank2 |
+   |                                    |            |               | - For other devices: erase all pages in Bank1                  |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   |FLASH_EraseOptionBytes              |    Yes     |      Yes      | No change                                                      |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   |FLASH_ProgramWord                   |    Yes     |      Yes      | Updated to program up to 1MByte (depending on the used device) |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   |FLASH_ProgramHalfWord               |    Yes     |      Yes      | Updated to program up to 1MByte (depending on the used device) |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   |FLASH_ProgramOptionByteData         |    Yes     |      Yes      | No change                                                      |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   |FLASH_EnableWriteProtection         |    Yes     |      Yes      | No change                                                      |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   |FLASH_ReadOutProtection             |    Yes     |      Yes      | No change                                                      |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   |FLASH_UserOptionByteConfig          |    Yes     |      Yes      | No change                                                      |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   |FLASH_GetUserOptionByte             |    Yes     |      Yes      | No change                                                      |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   |FLASH_GetWriteProtectionOptionByte  |    Yes     |      Yes      | No change                                                      |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   |FLASH_GetReadOutProtectionStatus    |    Yes     |      Yes      | No change                                                      |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   |FLASH_GetPrefetchBufferStatus       |    Yes     |      Yes      | No change                                                      |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   |FLASH_ITConfig                      |    Yes     |      Yes      | - For STM32F10x_XL devices: enable Bank1 and Bank2's interrupts|
+   |                                    |            |               | - For other devices: enable Bank1's interrupts                 |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   |FLASH_GetFlagStatus                 |    Yes     |      Yes      | - For STM32F10x_XL devices: return Bank1 and Bank2's flag status|
+   |                                    |            |               | - For other devices: return Bank1's flag status                |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   |FLASH_ClearFlag                     |    Yes     |      Yes      | - For STM32F10x_XL devices: clear Bank1 and Bank2's flag       |
+   |                                    |            |               | - For other devices: clear Bank1's flag                        |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   |FLASH_GetStatus                     |    Yes     |      Yes      | - Return the status of Bank1 (for all devices)                 |
+   |                                    |            |               |   equivalent to FLASH_GetBank1Status function                  |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   |FLASH_WaitForLastOperation          |    Yes     |      Yes      | - Wait for Bank1 last operation (for all devices)              |
+   |                                    |            |               |   equivalent to: FLASH_WaitForLastBank1Operation function      |
+   +----------------------------------------------------------------------------------------------------------------------------------+
+
+   ************************************************************************************************************************
+   * New functions used for all STM32F10x devices to manage Bank1:                                                        *
+   *   - These functions are mainly useful for STM32F10x_XL density devices, to have separate control for Bank1 and bank2 *
+   *   - For other devices, these functions are optional (covered by functions listed above)                              *
+   ************************************************************************************************************************
+   +----------------------------------------------------------------------------------------------------------------------------------+
+   |       Functions prototypes         |STM32F10x_XL|Other STM32F10x|    Comments                                                    |
+   |                                    |   devices  |  devices      |                                                                |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   | FLASH_UnlockBank1                  |    Yes     |      Yes      | - Unlock Bank1                                                 |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   |FLASH_LockBank1                     |    Yes     |      Yes      | - Lock Bank1                                                   |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   | FLASH_EraseAllBank1Pages           |    Yes     |      Yes      | - Erase all pages in Bank1                                     |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   | FLASH_GetBank1Status               |    Yes     |      Yes      | - Return the status of Bank1                                   |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   | FLASH_WaitForLastBank1Operation    |    Yes     |      Yes      | - Wait for Bank1 last operation                                |
+   +----------------------------------------------------------------------------------------------------------------------------------+
+
+   *****************************************************************************
+   * New Functions used only with STM32F10x_XL density devices to manage Bank2 *
+   *****************************************************************************
+   +----------------------------------------------------------------------------------------------------------------------------------+
+   |       Functions prototypes         |STM32F10x_XL|Other STM32F10x|    Comments                                                    |
+   |                                    |   devices  |  devices      |                                                                |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   | FLASH_UnlockBank2                  |    Yes     |      No       | - Unlock Bank2                                                 |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   |FLASH_LockBank2                     |    Yes     |      No       | - Lock Bank2                                                   |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   | FLASH_EraseAllBank2Pages           |    Yes     |      No       | - Erase all pages in Bank2                                     |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   | FLASH_GetBank2Status               |    Yes     |      No       | - Return the status of Bank2                                   |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   | FLASH_WaitForLastBank2Operation    |    Yes     |      No       | - Wait for Bank2 last operation                                |
+   |----------------------------------------------------------------------------------------------------------------------------------|
+   | FLASH_BootConfig                   |    Yes     |      No       | - Configure to boot from Bank1 or Bank2                        |
+   +----------------------------------------------------------------------------------------------------------------------------------+
+@endcode
+*/
+
+
+/**
+  * @brief  Sets the code latency value.
+  * @note   This function can be used for all STM32F10x devices.
+  * @param  FLASH_Latency: specifies the FLASH Latency value.
+  *   This parameter can be one of the following values:
+  *     @arg FLASH_Latency_0: FLASH Zero Latency cycle
+  *     @arg FLASH_Latency_1: FLASH One Latency cycle
+  *     @arg FLASH_Latency_2: FLASH Two Latency cycles
+  * @retval None
+  */
+void FLASH_SetLatency(uint32_t FLASH_Latency)
+{
+  uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_FLASH_LATENCY(FLASH_Latency));
+
+  /* Read the ACR register */
+  tmpreg = FLASH->ACR;
+
+  /* Sets the Latency value */
+  tmpreg &= ACR_LATENCY_Mask;
+  tmpreg |= FLASH_Latency;
+
+  /* Write the ACR register */
+  FLASH->ACR = tmpreg;
+}
+
+/**
+  * @brief  Enables or disables the Half cycle flash access.
+  * @note   This function can be used for all STM32F10x devices.
+  * @param  FLASH_HalfCycleAccess: specifies the FLASH Half cycle Access mode.
+  *   This parameter can be one of the following values:
+  *     @arg FLASH_HalfCycleAccess_Enable: FLASH Half Cycle Enable
+  *     @arg FLASH_HalfCycleAccess_Disable: FLASH Half Cycle Disable
+  * @retval None
+  */
+void FLASH_HalfCycleAccessCmd(uint32_t FLASH_HalfCycleAccess)
+{
+  /* Check the parameters */
+  assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
+
+  /* Enable or disable the Half cycle access */
+  FLASH->ACR &= ACR_HLFCYA_Mask;
+  FLASH->ACR |= FLASH_HalfCycleAccess;
+}
+
+/**
+  * @brief  Enables or disables the Prefetch Buffer.
+  * @note   This function can be used for all STM32F10x devices.
+  * @param  FLASH_PrefetchBuffer: specifies the Prefetch buffer status.
+  *   This parameter can be one of the following values:
+  *     @arg FLASH_PrefetchBuffer_Enable: FLASH Prefetch Buffer Enable
+  *     @arg FLASH_PrefetchBuffer_Disable: FLASH Prefetch Buffer Disable
+  * @retval None
+  */
+void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer)
+{
+  /* Check the parameters */
+  assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
+
+  /* Enable or disable the Prefetch Buffer */
+  FLASH->ACR &= ACR_PRFTBE_Mask;
+  FLASH->ACR |= FLASH_PrefetchBuffer;
+}
+
+/**
+  * @brief  Unlocks the FLASH Program Erase Controller.
+  * @note   This function can be used for all STM32F10x devices.
+  *         - For STM32F10X_XL devices this function unlocks Bank1 and Bank2.
+  *         - For all other devices it unlocks Bank1 and it is equivalent
+  *           to FLASH_UnlockBank1 function..
+  * @param  None
+  * @retval None
+  */
+void FLASH_Unlock(void)
+{
+  /* Authorize the FPEC of Bank1 Access */
+  FLASH->KEYR = FLASH_KEY1;
+  FLASH->KEYR = FLASH_KEY2;
+
+#ifdef STM32F10X_XL
+  /* Authorize the FPEC of Bank2 Access */
+  FLASH->KEYR2 = FLASH_KEY1;
+  FLASH->KEYR2 = FLASH_KEY2;
+#endif /* STM32F10X_XL */
+}
+/**
+  * @brief  Unlocks the FLASH Bank1 Program Erase Controller.
+  * @note   This function can be used for all STM32F10x devices.
+  *         - For STM32F10X_XL devices this function unlocks Bank1.
+  *         - For all other devices it unlocks Bank1 and it is
+  *           equivalent to FLASH_Unlock function.
+  * @param  None
+  * @retval None
+  */
+void FLASH_UnlockBank1(void)
+{
+  /* Authorize the FPEC of Bank1 Access */
+  FLASH->KEYR = FLASH_KEY1;
+  FLASH->KEYR = FLASH_KEY2;
+}
+
+#ifdef STM32F10X_XL
+/**
+  * @brief  Unlocks the FLASH Bank2 Program Erase Controller.
+  * @note   This function can be used only for STM32F10X_XL density devices.
+  * @param  None
+  * @retval None
+  */
+void FLASH_UnlockBank2(void)
+{
+  /* Authorize the FPEC of Bank2 Access */
+  FLASH->KEYR2 = FLASH_KEY1;
+  FLASH->KEYR2 = FLASH_KEY2;
+
+}
+#endif /* STM32F10X_XL */
+
+/**
+  * @brief  Locks the FLASH Program Erase Controller.
+  * @note   This function can be used for all STM32F10x devices.
+  *         - For STM32F10X_XL devices this function Locks Bank1 and Bank2.
+  *         - For all other devices it Locks Bank1 and it is equivalent
+  *           to FLASH_LockBank1 function.
+  * @param  None
+  * @retval None
+  */
+void FLASH_Lock(void)
+{
+  /* Set the Lock Bit to lock the FPEC and the CR of  Bank1 */
+  FLASH->CR |= CR_LOCK_Set;
+
+#ifdef STM32F10X_XL
+  /* Set the Lock Bit to lock the FPEC and the CR of  Bank2 */
+  FLASH->CR2 |= CR_LOCK_Set;
+#endif /* STM32F10X_XL */
+}
+
+/**
+  * @brief  Locks the FLASH Bank1 Program Erase Controller.
+  * @note   this function can be used for all STM32F10x devices.
+  *         - For STM32F10X_XL devices this function Locks Bank1.
+  *         - For all other devices it Locks Bank1 and it is equivalent
+  *           to FLASH_Lock function.
+  * @param  None
+  * @retval None
+  */
+void FLASH_LockBank1(void)
+{
+  /* Set the Lock Bit to lock the FPEC and the CR of  Bank1 */
+  FLASH->CR |= CR_LOCK_Set;
+}
+
+#ifdef STM32F10X_XL
+/**
+  * @brief  Locks the FLASH Bank2 Program Erase Controller.
+  * @note   This function can be used only for STM32F10X_XL density devices.
+  * @param  None
+  * @retval None
+  */
+void FLASH_LockBank2(void)
+{
+  /* Set the Lock Bit to lock the FPEC and the CR of  Bank2 */
+  FLASH->CR2 |= CR_LOCK_Set;
+}
+#endif /* STM32F10X_XL */
+
+/**
+  * @brief  Erases a specified FLASH page.
+  * @note   This function can be used for all STM32F10x devices.
+  * @param  Page_Address: The page address to be erased.
+  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,
+  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
+  */
+FLASH_Status FLASH_ErasePage(uint32_t Page_Address)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+  /* Check the parameters */
+  assert_param(IS_FLASH_ADDRESS(Page_Address));
+
+#ifdef STM32F10X_XL
+  if(Page_Address < FLASH_BANK1_END_ADDRESS)
+  {
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastBank1Operation(EraseTimeout);
+    if(status == FLASH_COMPLETE)
+    {
+      /* if the previous operation is completed, proceed to erase the page */
+      FLASH->CR|= CR_PER_Set;
+      FLASH->AR = Page_Address;
+      FLASH->CR|= CR_STRT_Set;
+
+      /* Wait for last operation to be completed */
+      status = FLASH_WaitForLastBank1Operation(EraseTimeout);
+
+      /* Disable the PER Bit */
+      FLASH->CR &= CR_PER_Reset;
+    }
+  }
+  else
+  {
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastBank2Operation(EraseTimeout);
+    if(status == FLASH_COMPLETE)
+    {
+      /* if the previous operation is completed, proceed to erase the page */
+      FLASH->CR2|= CR_PER_Set;
+      FLASH->AR2 = Page_Address;
+      FLASH->CR2|= CR_STRT_Set;
+
+      /* Wait for last operation to be completed */
+      status = FLASH_WaitForLastBank2Operation(EraseTimeout);
+
+      /* Disable the PER Bit */
+      FLASH->CR2 &= CR_PER_Reset;
+    }
+  }
+#else
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation(EraseTimeout);
+
+  if(status == FLASH_COMPLETE)
+  {
+    /* if the previous operation is completed, proceed to erase the page */
+    FLASH->CR|= CR_PER_Set;
+    FLASH->AR = Page_Address;
+    FLASH->CR|= CR_STRT_Set;
+
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation(EraseTimeout);
+
+    /* Disable the PER Bit */
+    FLASH->CR &= CR_PER_Reset;
+  }
+#endif /* STM32F10X_XL */
+
+  /* Return the Erase Status */
+  return status;
+}
+
+/**
+  * @brief  Erases all FLASH pages.
+  * @note   This function can be used for all STM32F10x devices.
+  * @param  None
+  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
+  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
+  */
+FLASH_Status FLASH_EraseAllPages(void)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+
+#ifdef STM32F10X_XL
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastBank1Operation(EraseTimeout);
+
+  if(status == FLASH_COMPLETE)
+  {
+    /* if the previous operation is completed, proceed to erase all pages */
+     FLASH->CR |= CR_MER_Set;
+     FLASH->CR |= CR_STRT_Set;
+
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastBank1Operation(EraseTimeout);
+
+    /* Disable the MER Bit */
+    FLASH->CR &= CR_MER_Reset;
+  }
+  if(status == FLASH_COMPLETE)
+  {
+    /* if the previous operation is completed, proceed to erase all pages */
+     FLASH->CR2 |= CR_MER_Set;
+     FLASH->CR2 |= CR_STRT_Set;
+
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastBank2Operation(EraseTimeout);
+
+    /* Disable the MER Bit */
+    FLASH->CR2 &= CR_MER_Reset;
+  }
+#else
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation(EraseTimeout);
+  if(status == FLASH_COMPLETE)
+  {
+    /* if the previous operation is completed, proceed to erase all pages */
+     FLASH->CR |= CR_MER_Set;
+     FLASH->CR |= CR_STRT_Set;
+
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation(EraseTimeout);
+
+    /* Disable the MER Bit */
+    FLASH->CR &= CR_MER_Reset;
+  }
+#endif /* STM32F10X_XL */
+
+  /* Return the Erase Status */
+  return status;
+}
+
+/**
+  * @brief  Erases all Bank1 FLASH pages.
+  * @note   This function can be used for all STM32F10x devices.
+  *         - For STM32F10X_XL devices this function erases all Bank1 pages.
+  *         - For all other devices it erases all Bank1 pages and it is equivalent
+  *           to FLASH_EraseAllPages function.
+  * @param  None
+  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
+  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
+  */
+FLASH_Status FLASH_EraseAllBank1Pages(void)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastBank1Operation(EraseTimeout);
+
+  if(status == FLASH_COMPLETE)
+  {
+    /* if the previous operation is completed, proceed to erase all pages */
+     FLASH->CR |= CR_MER_Set;
+     FLASH->CR |= CR_STRT_Set;
+
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastBank1Operation(EraseTimeout);
+
+    /* Disable the MER Bit */
+    FLASH->CR &= CR_MER_Reset;
+  }
+  /* Return the Erase Status */
+  return status;
+}
+
+#ifdef STM32F10X_XL
+/**
+  * @brief  Erases all Bank2 FLASH pages.
+  * @note   This function can be used only for STM32F10x_XL density devices.
+  * @param  None
+  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
+  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
+  */
+FLASH_Status FLASH_EraseAllBank2Pages(void)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastBank2Operation(EraseTimeout);
+
+  if(status == FLASH_COMPLETE)
+  {
+    /* if the previous operation is completed, proceed to erase all pages */
+     FLASH->CR2 |= CR_MER_Set;
+     FLASH->CR2 |= CR_STRT_Set;
+
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastBank2Operation(EraseTimeout);
+
+    /* Disable the MER Bit */
+    FLASH->CR2 &= CR_MER_Reset;
+  }
+  /* Return the Erase Status */
+  return status;
+}
+#endif /* STM32F10X_XL */
+
+/**
+  * @brief  Erases the FLASH option bytes.
+  * @note   This functions erases all option bytes except the Read protection (RDP).
+  * @note   This function can be used for all STM32F10x devices.
+  * @param  None
+  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
+  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
+  */
+FLASH_Status FLASH_EraseOptionBytes(void)
+{
+  uint16_t rdptmp = RDP_Key;
+
+  FLASH_Status status = FLASH_COMPLETE;
+
+  /* Get the actual read protection Option Byte value */
+  if(FLASH_GetReadOutProtectionStatus() != RESET)
+  {
+    rdptmp = 0x00;
+  }
+
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation(EraseTimeout);
+  if(status == FLASH_COMPLETE)
+  {
+    /* Authorize the small information block programming */
+    FLASH->OPTKEYR = FLASH_KEY1;
+    FLASH->OPTKEYR = FLASH_KEY2;
+
+    /* if the previous operation is completed, proceed to erase the option bytes */
+    FLASH->CR |= CR_OPTER_Set;
+    FLASH->CR |= CR_STRT_Set;
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation(EraseTimeout);
+
+    if(status == FLASH_COMPLETE)
+    {
+      /* if the erase operation is completed, disable the OPTER Bit */
+      FLASH->CR &= CR_OPTER_Reset;
+
+      /* Enable the Option Bytes Programming operation */
+      FLASH->CR |= CR_OPTPG_Set;
+      /* Restore the last read protection Option Byte value */
+      OB->RDP = (uint16_t)rdptmp;
+      /* Wait for last operation to be completed */
+      status = FLASH_WaitForLastOperation(ProgramTimeout);
+
+      if(status != FLASH_TIMEOUT)
+      {
+        /* if the program operation is completed, disable the OPTPG Bit */
+        FLASH->CR &= CR_OPTPG_Reset;
+      }
+    }
+    else
+    {
+      if (status != FLASH_TIMEOUT)
+      {
+        /* Disable the OPTPG Bit */
+        FLASH->CR &= CR_OPTPG_Reset;
+      }
+    }
+  }
+  /* Return the erase status */
+  return status;
+}
+
+/**
+  * @brief  Programs a word at a specified address.
+  * @note   This function can be used for all STM32F10x devices.
+  * @param  Address: specifies the address to be programmed.
+  * @param  Data: specifies the data to be programmed.
+  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
+  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
+  */
+FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+  __IO uint32_t tmp = 0;
+
+  /* Check the parameters */
+  assert_param(IS_FLASH_ADDRESS(Address));
+
+#ifdef STM32F10X_XL
+  if(Address < FLASH_BANK1_END_ADDRESS - 2)
+  {
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
+    if(status == FLASH_COMPLETE)
+    {
+      /* if the previous operation is completed, proceed to program the new first
+        half word */
+      FLASH->CR |= CR_PG_Set;
+
+      *(__IO uint16_t*)Address = (uint16_t)Data;
+      /* Wait for last operation to be completed */
+      status = FLASH_WaitForLastOperation(ProgramTimeout);
+
+      if(status == FLASH_COMPLETE)
+      {
+        /* if the previous operation is completed, proceed to program the new second
+        half word */
+        tmp = Address + 2;
+
+        *(__IO uint16_t*) tmp = Data >> 16;
+
+        /* Wait for last operation to be completed */
+        status = FLASH_WaitForLastOperation(ProgramTimeout);
+
+        /* Disable the PG Bit */
+        FLASH->CR &= CR_PG_Reset;
+      }
+      else
+      {
+        /* Disable the PG Bit */
+        FLASH->CR &= CR_PG_Reset;
+       }
+    }
+  }
+  else if(Address == (FLASH_BANK1_END_ADDRESS - 1))
+  {
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
+
+    if(status == FLASH_COMPLETE)
+    {
+      /* if the previous operation is completed, proceed to program the new first
+        half word */
+      FLASH->CR |= CR_PG_Set;
+
+      *(__IO uint16_t*)Address = (uint16_t)Data;
+
+      /* Wait for last operation to be completed */
+      status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
+
+	  /* Disable the PG Bit */
+      FLASH->CR &= CR_PG_Reset;
+    }
+    else
+    {
+      /* Disable the PG Bit */
+      FLASH->CR &= CR_PG_Reset;
+    }
+
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
+
+    if(status == FLASH_COMPLETE)
+    {
+      /* if the previous operation is completed, proceed to program the new second
+      half word */
+      FLASH->CR2 |= CR_PG_Set;
+      tmp = Address + 2;
+
+      *(__IO uint16_t*) tmp = Data >> 16;
+
+      /* Wait for last operation to be completed */
+      status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
+
+      /* Disable the PG Bit */
+      FLASH->CR2 &= CR_PG_Reset;
+    }
+    else
+    {
+      /* Disable the PG Bit */
+      FLASH->CR2 &= CR_PG_Reset;
+    }
+  }
+  else
+  {
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
+
+    if(status == FLASH_COMPLETE)
+    {
+      /* if the previous operation is completed, proceed to program the new first
+        half word */
+      FLASH->CR2 |= CR_PG_Set;
+
+      *(__IO uint16_t*)Address = (uint16_t)Data;
+      /* Wait for last operation to be completed */
+      status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
+
+      if(status == FLASH_COMPLETE)
+      {
+        /* if the previous operation is completed, proceed to program the new second
+        half word */
+        tmp = Address + 2;
+
+        *(__IO uint16_t*) tmp = Data >> 16;
+
+        /* Wait for last operation to be completed */
+        status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
+
+        /* Disable the PG Bit */
+        FLASH->CR2 &= CR_PG_Reset;
+      }
+      else
+      {
+        /* Disable the PG Bit */
+        FLASH->CR2 &= CR_PG_Reset;
+      }
+    }
+  }
+#else
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation(ProgramTimeout);
+
+  if(status == FLASH_COMPLETE)
+  {
+    /* if the previous operation is completed, proceed to program the new first
+    half word */
+    FLASH->CR |= CR_PG_Set;
+
+    *(__IO uint16_t*)Address = (uint16_t)Data;
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation(ProgramTimeout);
+
+    if(status == FLASH_COMPLETE)
+    {
+      /* if the previous operation is completed, proceed to program the new second
+      half word */
+      tmp = Address + 2;
+
+      *(__IO uint16_t*) tmp = Data >> 16;
+
+      /* Wait for last operation to be completed */
+      status = FLASH_WaitForLastOperation(ProgramTimeout);
+
+      /* Disable the PG Bit */
+      FLASH->CR &= CR_PG_Reset;
+    }
+    else
+    {
+      /* Disable the PG Bit */
+      FLASH->CR &= CR_PG_Reset;
+    }
+  }
+#endif /* STM32F10X_XL */
+
+  /* Return the Program Status */
+  return status;
+}
+
+/**
+  * @brief  Programs a half word at a specified address.
+  * @note   This function can be used for all STM32F10x devices.
+  * @param  Address: specifies the address to be programmed.
+  * @param  Data: specifies the data to be programmed.
+  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
+  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
+  */
+FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+  /* Check the parameters */
+  assert_param(IS_FLASH_ADDRESS(Address));
+
+#ifdef STM32F10X_XL
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation(ProgramTimeout);
+
+  if(Address < FLASH_BANK1_END_ADDRESS)
+  {
+    if(status == FLASH_COMPLETE)
+    {
+      /* if the previous operation is completed, proceed to program the new data */
+      FLASH->CR |= CR_PG_Set;
+
+      *(__IO uint16_t*)Address = Data;
+      /* Wait for last operation to be completed */
+      status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
+
+      /* Disable the PG Bit */
+      FLASH->CR &= CR_PG_Reset;
+    }
+  }
+  else
+  {
+    if(status == FLASH_COMPLETE)
+    {
+      /* if the previous operation is completed, proceed to program the new data */
+      FLASH->CR2 |= CR_PG_Set;
+
+      *(__IO uint16_t*)Address = Data;
+      /* Wait for last operation to be completed */
+      status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
+
+      /* Disable the PG Bit */
+      FLASH->CR2 &= CR_PG_Reset;
+    }
+  }
+#else
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation(ProgramTimeout);
+
+  if(status == FLASH_COMPLETE)
+  {
+    /* if the previous operation is completed, proceed to program the new data */
+    FLASH->CR |= CR_PG_Set;
+
+    *(__IO uint16_t*)Address = Data;
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation(ProgramTimeout);
+
+    /* Disable the PG Bit */
+    FLASH->CR &= CR_PG_Reset;
+  }
+#endif  /* STM32F10X_XL */
+
+  /* Return the Program Status */
+  return status;
+}
+
+/**
+  * @brief  Programs a half word at a specified Option Byte Data address.
+  * @note   This function can be used for all STM32F10x devices.
+  * @param  Address: specifies the address to be programmed.
+  *   This parameter can be 0x1FFFF804 or 0x1FFFF806.
+  * @param  Data: specifies the data to be programmed.
+  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
+  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
+  */
+FLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+  /* Check the parameters */
+  assert_param(IS_OB_DATA_ADDRESS(Address));
+  status = FLASH_WaitForLastOperation(ProgramTimeout);
+
+  if(status == FLASH_COMPLETE)
+  {
+    /* Authorize the small information block programming */
+    FLASH->OPTKEYR = FLASH_KEY1;
+    FLASH->OPTKEYR = FLASH_KEY2;
+    /* Enables the Option Bytes Programming operation */
+    FLASH->CR |= CR_OPTPG_Set;
+    *(__IO uint16_t*)Address = Data;
+
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation(ProgramTimeout);
+    if(status != FLASH_TIMEOUT)
+    {
+      /* if the program operation is completed, disable the OPTPG Bit */
+      FLASH->CR &= CR_OPTPG_Reset;
+    }
+  }
+  /* Return the Option Byte Data Program Status */
+  return status;
+}
+
+/**
+  * @brief  Write protects the desired pages
+  * @note   This function can be used for all STM32F10x devices.
+  * @param  FLASH_Pages: specifies the address of the pages to be write protected.
+  *   This parameter can be:
+  *     @arg For @b STM32_Low-density_devices: value between FLASH_WRProt_Pages0to3 and FLASH_WRProt_Pages28to31
+  *     @arg For @b STM32_Medium-density_devices: value between FLASH_WRProt_Pages0to3
+  *       and FLASH_WRProt_Pages124to127
+  *     @arg For @b STM32_High-density_devices: value between FLASH_WRProt_Pages0to1 and
+  *       FLASH_WRProt_Pages60to61 or FLASH_WRProt_Pages62to255
+  *     @arg For @b STM32_Connectivity_line_devices: value between FLASH_WRProt_Pages0to1 and
+  *       FLASH_WRProt_Pages60to61 or FLASH_WRProt_Pages62to127
+  *     @arg For @b STM32_XL-density_devices: value between FLASH_WRProt_Pages0to1 and
+  *       FLASH_WRProt_Pages60to61 or FLASH_WRProt_Pages62to511
+  *     @arg FLASH_WRProt_AllPages
+  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
+  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
+  */
+FLASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages)
+{
+  uint16_t WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;
+
+  FLASH_Status status = FLASH_COMPLETE;
+
+  /* Check the parameters */
+  assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
+
+  FLASH_Pages = (uint32_t)(~FLASH_Pages);
+  WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
+  WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);
+  WRP2_Data = (uint16_t)((FLASH_Pages & WRP2_Mask) >> 16);
+  WRP3_Data = (uint16_t)((FLASH_Pages & WRP3_Mask) >> 24);
+
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation(ProgramTimeout);
+
+  if(status == FLASH_COMPLETE)
+  {
+    /* Authorizes the small information block programming */
+    FLASH->OPTKEYR = FLASH_KEY1;
+    FLASH->OPTKEYR = FLASH_KEY2;
+    FLASH->CR |= CR_OPTPG_Set;
+    if(WRP0_Data != 0xFF)
+    {
+      OB->WRP0 = WRP0_Data;
+
+      /* Wait for last operation to be completed */
+      status = FLASH_WaitForLastOperation(ProgramTimeout);
+    }
+    if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
+    {
+      OB->WRP1 = WRP1_Data;
+
+      /* Wait for last operation to be completed */
+      status = FLASH_WaitForLastOperation(ProgramTimeout);
+    }
+    if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
+    {
+      OB->WRP2 = WRP2_Data;
+
+      /* Wait for last operation to be completed */
+      status = FLASH_WaitForLastOperation(ProgramTimeout);
+    }
+
+    if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
+    {
+      OB->WRP3 = WRP3_Data;
+
+      /* Wait for last operation to be completed */
+      status = FLASH_WaitForLastOperation(ProgramTimeout);
+    }
+
+    if(status != FLASH_TIMEOUT)
+    {
+      /* if the program operation is completed, disable the OPTPG Bit */
+      FLASH->CR &= CR_OPTPG_Reset;
+    }
+  }
+  /* Return the write protection operation Status */
+  return status;
+}
+
+/**
+  * @brief  Enables or disables the read out protection.
+  * @note   If the user has already programmed the other option bytes before calling
+  *   this function, he must re-program them since this function erases all option bytes.
+  * @note   This function can be used for all STM32F10x devices.
+  * @param  Newstate: new state of the ReadOut Protection.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
+  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
+  */
+FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  status = FLASH_WaitForLastOperation(EraseTimeout);
+  if(status == FLASH_COMPLETE)
+  {
+    /* Authorizes the small information block programming */
+    FLASH->OPTKEYR = FLASH_KEY1;
+    FLASH->OPTKEYR = FLASH_KEY2;
+    FLASH->CR |= CR_OPTER_Set;
+    FLASH->CR |= CR_STRT_Set;
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation(EraseTimeout);
+    if(status == FLASH_COMPLETE)
+    {
+      /* if the erase operation is completed, disable the OPTER Bit */
+      FLASH->CR &= CR_OPTER_Reset;
+      /* Enable the Option Bytes Programming operation */
+      FLASH->CR |= CR_OPTPG_Set;
+      if(NewState != DISABLE)
+      {
+        OB->RDP = 0x00;
+      }
+      else
+      {
+        OB->RDP = RDP_Key;
+      }
+      /* Wait for last operation to be completed */
+      status = FLASH_WaitForLastOperation(EraseTimeout);
+
+      if(status != FLASH_TIMEOUT)
+      {
+        /* if the program operation is completed, disable the OPTPG Bit */
+        FLASH->CR &= CR_OPTPG_Reset;
+      }
+    }
+    else
+    {
+      if(status != FLASH_TIMEOUT)
+      {
+        /* Disable the OPTER Bit */
+        FLASH->CR &= CR_OPTER_Reset;
+      }
+    }
+  }
+  /* Return the protection operation Status */
+  return status;
+}
+
+/**
+  * @brief  Programs the FLASH User Option Byte: IWDG_SW / RST_STOP / RST_STDBY.
+  * @note   This function can be used for all STM32F10x devices.
+  * @param  OB_IWDG: Selects the IWDG mode
+  *   This parameter can be one of the following values:
+  *     @arg OB_IWDG_SW: Software IWDG selected
+  *     @arg OB_IWDG_HW: Hardware IWDG selected
+  * @param  OB_STOP: Reset event when entering STOP mode.
+  *   This parameter can be one of the following values:
+  *     @arg OB_STOP_NoRST: No reset generated when entering in STOP
+  *     @arg OB_STOP_RST: Reset generated when entering in STOP
+  * @param  OB_STDBY: Reset event when entering Standby mode.
+  *   This parameter can be one of the following values:
+  *     @arg OB_STDBY_NoRST: No reset generated when entering in STANDBY
+  *     @arg OB_STDBY_RST: Reset generated when entering in STANDBY
+  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
+  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
+  */
+FLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+
+  /* Check the parameters */
+  assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
+  assert_param(IS_OB_STOP_SOURCE(OB_STOP));
+  assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
+
+  /* Authorize the small information block programming */
+  FLASH->OPTKEYR = FLASH_KEY1;
+  FLASH->OPTKEYR = FLASH_KEY2;
+
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation(ProgramTimeout);
+
+  if(status == FLASH_COMPLETE)
+  {
+    /* Enable the Option Bytes Programming operation */
+    FLASH->CR |= CR_OPTPG_Set;
+
+    OB->USER = OB_IWDG | (uint16_t)(OB_STOP | (uint16_t)(OB_STDBY | ((uint16_t)0xF8)));
+
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation(ProgramTimeout);
+    if(status != FLASH_TIMEOUT)
+    {
+      /* if the program operation is completed, disable the OPTPG Bit */
+      FLASH->CR &= CR_OPTPG_Reset;
+    }
+  }
+  /* Return the Option Byte program Status */
+  return status;
+}
+
+#ifdef STM32F10X_XL
+/**
+  * @brief  Configures to boot from Bank1 or Bank2.
+  * @note   This function can be used only for STM32F10x_XL density devices.
+  * @param  FLASH_BOOT: select the FLASH Bank to boot from.
+  *   This parameter can be one of the following values:
+  *     @arg FLASH_BOOT_Bank1: At startup, if boot pins are set in boot from user Flash
+  *        position and this parameter is selected the device will boot from Bank1(Default).
+  *     @arg FLASH_BOOT_Bank2: At startup, if boot pins are set in boot from user Flash
+  *        position and this parameter is selected the device will boot from Bank2 or Bank1,
+  *        depending on the activation of the bank. The active banks are checked in
+  *        the following order: Bank2, followed by Bank1.
+  *        The active bank is recognized by the value programmed at the base address
+  *        of the respective bank (corresponding to the initial stack pointer value
+  *        in the interrupt vector table).
+  *        For more information, please refer to AN2606 from www.st.com.
+  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
+  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
+  */
+FLASH_Status FLASH_BootConfig(uint16_t FLASH_BOOT)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+  assert_param(IS_FLASH_BOOT(FLASH_BOOT));
+  /* Authorize the small information block programming */
+  FLASH->OPTKEYR = FLASH_KEY1;
+  FLASH->OPTKEYR = FLASH_KEY2;
+
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation(ProgramTimeout);
+
+  if(status == FLASH_COMPLETE)
+  {
+    /* Enable the Option Bytes Programming operation */
+    FLASH->CR |= CR_OPTPG_Set;
+
+    if(FLASH_BOOT == FLASH_BOOT_Bank1)
+    {
+      OB->USER |= OB_USER_BFB2;
+    }
+    else
+    {
+      OB->USER &= (uint16_t)(~(uint16_t)(OB_USER_BFB2));
+    }
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation(ProgramTimeout);
+    if(status != FLASH_TIMEOUT)
+    {
+      /* if the program operation is completed, disable the OPTPG Bit */
+      FLASH->CR &= CR_OPTPG_Reset;
+    }
+  }
+  /* Return the Option Byte program Status */
+  return status;
+}
+#endif /* STM32F10X_XL */
+
+/**
+  * @brief  Returns the FLASH User Option Bytes values.
+  * @note   This function can be used for all STM32F10x devices.
+  * @param  None
+  * @retval The FLASH User Option Bytes values:IWDG_SW(Bit0), RST_STOP(Bit1)
+  *         and RST_STDBY(Bit2).
+  */
+uint32_t FLASH_GetUserOptionByte(void)
+{
+  /* Return the User Option Byte */
+  return (uint32_t)(FLASH->OBR >> 2);
+}
+
+/**
+  * @brief  Returns the FLASH Write Protection Option Bytes Register value.
+  * @note   This function can be used for all STM32F10x devices.
+  * @param  None
+  * @retval The FLASH Write Protection  Option Bytes Register value
+  */
+uint32_t FLASH_GetWriteProtectionOptionByte(void)
+{
+  /* Return the Flash write protection Register value */
+  return (uint32_t)(FLASH->WRPR);
+}
+
+/**
+  * @brief  Checks whether the FLASH Read Out Protection Status is set or not.
+  * @note   This function can be used for all STM32F10x devices.
+  * @param  None
+  * @retval FLASH ReadOut Protection Status(SET or RESET)
+  */
+FlagStatus FLASH_GetReadOutProtectionStatus(void)
+{
+  FlagStatus readoutstatus = RESET;
+  if ((FLASH->OBR & RDPRT_Mask) != (uint32_t)RESET)
+  {
+    readoutstatus = SET;
+  }
+  else
+  {
+    readoutstatus = RESET;
+  }
+  return readoutstatus;
+}
+
+/**
+  * @brief  Checks whether the FLASH Prefetch Buffer status is set or not.
+  * @note   This function can be used for all STM32F10x devices.
+  * @param  None
+  * @retval FLASH Prefetch Buffer Status (SET or RESET).
+  */
+FlagStatus FLASH_GetPrefetchBufferStatus(void)
+{
+  FlagStatus bitstatus = RESET;
+
+  if ((FLASH->ACR & ACR_PRFTBS_Mask) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
+  return bitstatus;
+}
+
+/**
+  * @brief  Enables or disables the specified FLASH interrupts.
+  * @note   This function can be used for all STM32F10x devices.
+  *         - For STM32F10X_XL devices, enables or disables the specified FLASH interrupts
+              for Bank1 and Bank2.
+  *         - For other devices it enables or disables the specified FLASH interrupts for Bank1.
+  * @param  FLASH_IT: specifies the FLASH interrupt sources to be enabled or disabled.
+  *   This parameter can be any combination of the following values:
+  *     @arg FLASH_IT_ERROR: FLASH Error Interrupt
+  *     @arg FLASH_IT_EOP: FLASH end of operation Interrupt
+  * @param  NewState: new state of the specified Flash interrupts.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
+{
+#ifdef STM32F10X_XL
+  /* Check the parameters */
+  assert_param(IS_FLASH_IT(FLASH_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if((FLASH_IT & 0x80000000) != 0x0)
+  {
+    if(NewState != DISABLE)
+    {
+      /* Enable the interrupt sources */
+      FLASH->CR2 |= (FLASH_IT & 0x7FFFFFFF);
+    }
+    else
+    {
+      /* Disable the interrupt sources */
+      FLASH->CR2 &= ~(uint32_t)(FLASH_IT & 0x7FFFFFFF);
+    }
+  }
+  else
+  {
+    if(NewState != DISABLE)
+    {
+      /* Enable the interrupt sources */
+      FLASH->CR |= FLASH_IT;
+    }
+    else
+    {
+      /* Disable the interrupt sources */
+      FLASH->CR &= ~(uint32_t)FLASH_IT;
+    }
+  }
+#else
+  /* Check the parameters */
+  assert_param(IS_FLASH_IT(FLASH_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if(NewState != DISABLE)
+  {
+    /* Enable the interrupt sources */
+    FLASH->CR |= FLASH_IT;
+  }
+  else
+  {
+    /* Disable the interrupt sources */
+    FLASH->CR &= ~(uint32_t)FLASH_IT;
+  }
+#endif /* STM32F10X_XL */
+}
+
+/**
+  * @brief  Checks whether the specified FLASH flag is set or not.
+  * @note   This function can be used for all STM32F10x devices.
+  *         - For STM32F10X_XL devices, this function checks whether the specified
+  *           Bank1 or Bank2 flag is set or not.
+  *         - For other devices, it checks whether the specified Bank1 flag is
+  *           set or not.
+  * @param  FLASH_FLAG: specifies the FLASH flag to check.
+  *   This parameter can be one of the following values:
+  *     @arg FLASH_FLAG_BSY: FLASH Busy flag
+  *     @arg FLASH_FLAG_PGERR: FLASH Program error flag
+  *     @arg FLASH_FLAG_WRPRTERR: FLASH Write protected error flag
+  *     @arg FLASH_FLAG_EOP: FLASH End of Operation flag
+  *     @arg FLASH_FLAG_OPTERR:  FLASH Option Byte error flag
+  * @retval The new state of FLASH_FLAG (SET or RESET).
+  */
+FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+
+#ifdef STM32F10X_XL
+  /* Check the parameters */
+  assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
+  if(FLASH_FLAG == FLASH_FLAG_OPTERR)
+  {
+    if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
+    {
+      bitstatus = SET;
+    }
+    else
+    {
+      bitstatus = RESET;
+    }
+  }
+  else
+  {
+    if((FLASH_FLAG & 0x80000000) != 0x0)
+    {
+      if((FLASH->SR2 & FLASH_FLAG) != (uint32_t)RESET)
+      {
+        bitstatus = SET;
+      }
+      else
+      {
+        bitstatus = RESET;
+      }
+    }
+    else
+    {
+      if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
+      {
+        bitstatus = SET;
+      }
+      else
+      {
+        bitstatus = RESET;
+      }
+    }
+  }
+#else
+  /* Check the parameters */
+  assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
+  if(FLASH_FLAG == FLASH_FLAG_OPTERR)
+  {
+    if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
+    {
+      bitstatus = SET;
+    }
+    else
+    {
+      bitstatus = RESET;
+    }
+  }
+  else
+  {
+   if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
+    {
+      bitstatus = SET;
+    }
+    else
+    {
+      bitstatus = RESET;
+    }
+  }
+#endif /* STM32F10X_XL */
+
+  /* Return the new state of FLASH_FLAG (SET or RESET) */
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the FLASH's pending flags.
+  * @note   This function can be used for all STM32F10x devices.
+  *         - For STM32F10X_XL devices, this function clears Bank1 or Bank2s pending flags
+  *         - For other devices, it clears Bank1s pending flags.
+  * @param  FLASH_FLAG: specifies the FLASH flags to clear.
+  *   This parameter can be any combination of the following values:
+  *     @arg FLASH_FLAG_PGERR: FLASH Program error flag
+  *     @arg FLASH_FLAG_WRPRTERR: FLASH Write protected error flag
+  *     @arg FLASH_FLAG_EOP: FLASH End of Operation flag
+  * @retval None
+  */
+void FLASH_ClearFlag(uint32_t FLASH_FLAG)
+{
+#ifdef STM32F10X_XL
+  /* Check the parameters */
+  assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
+
+  if((FLASH_FLAG & 0x80000000) != 0x0)
+  {
+    /* Clear the flags */
+    FLASH->SR2 = FLASH_FLAG;
+  }
+  else
+  {
+    /* Clear the flags */
+    FLASH->SR = FLASH_FLAG;
+  }
+
+#else
+  /* Check the parameters */
+  assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
+
+  /* Clear the flags */
+  FLASH->SR = FLASH_FLAG;
+#endif /* STM32F10X_XL */
+}
+
+/**
+  * @brief  Returns the FLASH Status.
+  * @note   This function can be used for all STM32F10x devices, it is equivalent
+  *         to FLASH_GetBank1Status function.
+  * @param  None
+  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,
+  *         FLASH_ERROR_WRP or FLASH_COMPLETE
+  */
+FLASH_Status FLASH_GetStatus(void)
+{
+  FLASH_Status flashstatus = FLASH_COMPLETE;
+
+  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY)
+  {
+    flashstatus = FLASH_BUSY;
+  }
+  else
+  {
+    if((FLASH->SR & FLASH_FLAG_PGERR) != 0)
+    {
+      flashstatus = FLASH_ERROR_PG;
+    }
+    else
+    {
+      if((FLASH->SR & FLASH_FLAG_WRPRTERR) != 0 )
+      {
+        flashstatus = FLASH_ERROR_WRP;
+      }
+      else
+      {
+        flashstatus = FLASH_COMPLETE;
+      }
+    }
+  }
+  /* Return the Flash Status */
+  return flashstatus;
+}
+
+/**
+  * @brief  Returns the FLASH Bank1 Status.
+  * @note   This function can be used for all STM32F10x devices, it is equivalent
+  *         to FLASH_GetStatus function.
+  * @param  None
+  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,
+  *         FLASH_ERROR_WRP or FLASH_COMPLETE
+  */
+FLASH_Status FLASH_GetBank1Status(void)
+{
+  FLASH_Status flashstatus = FLASH_COMPLETE;
+
+  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY)
+  {
+    flashstatus = FLASH_BUSY;
+  }
+  else
+  {
+    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
+    {
+      flashstatus = FLASH_ERROR_PG;
+    }
+    else
+    {
+      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
+      {
+        flashstatus = FLASH_ERROR_WRP;
+      }
+      else
+      {
+        flashstatus = FLASH_COMPLETE;
+      }
+    }
+  }
+  /* Return the Flash Status */
+  return flashstatus;
+}
+
+#ifdef STM32F10X_XL
+/**
+  * @brief  Returns the FLASH Bank2 Status.
+  * @note   This function can be used for STM32F10x_XL density devices.
+  * @param  None
+  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,
+  *        FLASH_ERROR_WRP or FLASH_COMPLETE
+  */
+FLASH_Status FLASH_GetBank2Status(void)
+{
+  FLASH_Status flashstatus = FLASH_COMPLETE;
+
+  if((FLASH->SR2 & (FLASH_FLAG_BANK2_BSY & 0x7FFFFFFF)) == (FLASH_FLAG_BANK2_BSY & 0x7FFFFFFF))
+  {
+    flashstatus = FLASH_BUSY;
+  }
+  else
+  {
+    if((FLASH->SR2 & (FLASH_FLAG_BANK2_PGERR & 0x7FFFFFFF)) != 0)
+    {
+      flashstatus = FLASH_ERROR_PG;
+    }
+    else
+    {
+      if((FLASH->SR2 & (FLASH_FLAG_BANK2_WRPRTERR & 0x7FFFFFFF)) != 0 )
+      {
+        flashstatus = FLASH_ERROR_WRP;
+      }
+      else
+      {
+        flashstatus = FLASH_COMPLETE;
+      }
+    }
+  }
+  /* Return the Flash Status */
+  return flashstatus;
+}
+#endif /* STM32F10X_XL */
+/**
+  * @brief  Waits for a Flash operation to complete or a TIMEOUT to occur.
+  * @note   This function can be used for all STM32F10x devices,
+  *         it is equivalent to FLASH_WaitForLastBank1Operation.
+  *         - For STM32F10X_XL devices this function waits for a Bank1 Flash operation
+  *           to complete or a TIMEOUT to occur.
+  *         - For all other devices it waits for a Flash operation to complete
+  *           or a TIMEOUT to occur.
+  * @param  Timeout: FLASH programming Timeout
+  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
+  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
+  */
+FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+
+  /* Check for the Flash Status */
+  status = FLASH_GetBank1Status();
+  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
+  while((status == FLASH_BUSY) && (Timeout != 0x00))
+  {
+    status = FLASH_GetBank1Status();
+    Timeout--;
+  }
+  if(Timeout == 0x00 )
+  {
+    status = FLASH_TIMEOUT;
+  }
+  /* Return the operation status */
+  return status;
+}
+
+/**
+  * @brief  Waits for a Flash operation on Bank1 to complete or a TIMEOUT to occur.
+  * @note   This function can be used for all STM32F10x devices,
+  *         it is equivalent to FLASH_WaitForLastOperation.
+  * @param  Timeout: FLASH programming Timeout
+  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
+  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
+  */
+FLASH_Status FLASH_WaitForLastBank1Operation(uint32_t Timeout)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+
+  /* Check for the Flash Status */
+  status = FLASH_GetBank1Status();
+  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
+  while((status == FLASH_FLAG_BANK1_BSY) && (Timeout != 0x00))
+  {
+    status = FLASH_GetBank1Status();
+    Timeout--;
+  }
+  if(Timeout == 0x00 )
+  {
+    status = FLASH_TIMEOUT;
+  }
+  /* Return the operation status */
+  return status;
+}
+
+#ifdef STM32F10X_XL
+/**
+  * @brief  Waits for a Flash operation on Bank2 to complete or a TIMEOUT to occur.
+  * @note   This function can be used only for STM32F10x_XL density devices.
+  * @param  Timeout: FLASH programming Timeout
+  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
+  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
+  */
+FLASH_Status FLASH_WaitForLastBank2Operation(uint32_t Timeout)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+
+  /* Check for the Flash Status */
+  status = FLASH_GetBank2Status();
+  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
+  while((status == (FLASH_FLAG_BANK2_BSY & 0x7FFFFFFF)) && (Timeout != 0x00))
+  {
+    status = FLASH_GetBank2Status();
+    Timeout--;
+  }
+  if(Timeout == 0x00 )
+  {
+    status = FLASH_TIMEOUT;
+  }
+  /* Return the operation status */
+  return status;
+}
+#endif /* STM32F10X_XL */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_fsmc.c b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_fsmc.c
new file mode 100644
index 0000000..c75137c
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_fsmc.c
@@ -0,0 +1,866 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_fsmc.c
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file provides all the FSMC firmware functions.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x_fsmc.h"
+#include "stm32f10x_rcc.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup FSMC
+  * @brief FSMC driver modules
+  * @{
+  */
+
+/** @defgroup FSMC_Private_TypesDefinitions
+  * @{
+  */
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Private_Defines
+  * @{
+  */
+
+/* --------------------- FSMC registers bit mask ---------------------------- */
+
+/* FSMC BCRx Mask */
+#define BCR_MBKEN_Set                       ((uint32_t)0x00000001)
+#define BCR_MBKEN_Reset                     ((uint32_t)0x000FFFFE)
+#define BCR_FACCEN_Set                      ((uint32_t)0x00000040)
+
+/* FSMC PCRx Mask */
+#define PCR_PBKEN_Set                       ((uint32_t)0x00000004)
+#define PCR_PBKEN_Reset                     ((uint32_t)0x000FFFFB)
+#define PCR_ECCEN_Set                       ((uint32_t)0x00000040)
+#define PCR_ECCEN_Reset                     ((uint32_t)0x000FFFBF)
+#define PCR_MemoryType_NAND                 ((uint32_t)0x00000008)
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup FSMC_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the FSMC NOR/SRAM Banks registers to their default
+  *         reset values.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *   This parameter can be one of the following values:
+  *     @arg FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1
+  *     @arg FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2
+  *     @arg FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3
+  *     @arg FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4
+  * @retval None
+  */
+void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank)
+{
+  /* Check the parameter */
+  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
+
+  /* FSMC_Bank1_NORSRAM1 */
+  if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
+  {
+    FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;
+  }
+  /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
+  else
+  {
+    FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2;
+  }
+  FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
+  FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;
+}
+
+/**
+  * @brief  Deinitializes the FSMC NAND Banks registers to their default reset values.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *   This parameter can be one of the following values:
+  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND
+  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
+  * @retval None
+  */
+void FSMC_NANDDeInit(uint32_t FSMC_Bank)
+{
+  /* Check the parameter */
+  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
+
+  if(FSMC_Bank == FSMC_Bank2_NAND)
+  {
+    /* Set the FSMC_Bank2 registers to their reset values */
+    FSMC_Bank2->PCR2 = 0x00000018;
+    FSMC_Bank2->SR2 = 0x00000040;
+    FSMC_Bank2->PMEM2 = 0xFCFCFCFC;
+    FSMC_Bank2->PATT2 = 0xFCFCFCFC;
+  }
+  /* FSMC_Bank3_NAND */
+  else
+  {
+    /* Set the FSMC_Bank3 registers to their reset values */
+    FSMC_Bank3->PCR3 = 0x00000018;
+    FSMC_Bank3->SR3 = 0x00000040;
+    FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
+    FSMC_Bank3->PATT3 = 0xFCFCFCFC;
+  }
+}
+
+/**
+  * @brief  Deinitializes the FSMC PCCARD Bank registers to their default reset values.
+  * @param  None
+  * @retval None
+  */
+void FSMC_PCCARDDeInit(void)
+{
+  /* Set the FSMC_Bank4 registers to their reset values */
+  FSMC_Bank4->PCR4 = 0x00000018;
+  FSMC_Bank4->SR4 = 0x00000000;
+  FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
+  FSMC_Bank4->PATT4 = 0xFCFCFCFC;
+  FSMC_Bank4->PIO4 = 0xFCFCFCFC;
+}
+
+/**
+  * @brief  Initializes the FSMC NOR/SRAM Banks according to the specified
+  *         parameters in the FSMC_NORSRAMInitStruct.
+  * @param  FSMC_NORSRAMInitStruct : pointer to a FSMC_NORSRAMInitTypeDef
+  *         structure that contains the configuration information for
+  *        the FSMC NOR/SRAM specified Banks.
+  * @retval None
+  */
+void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
+{
+  /* Check the parameters */
+  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct->FSMC_Bank));
+  assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct->FSMC_DataAddressMux));
+  assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct->FSMC_MemoryType));
+  assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth));
+  assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode));
+  assert_param(IS_FSMC_ASYNWAIT(FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait));
+  assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity));
+  assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct->FSMC_WrapMode));
+  assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive));
+  assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct->FSMC_WriteOperation));
+  assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct->FSMC_WaitSignal));
+  assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode));
+  assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct->FSMC_WriteBurst));
+  assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime));
+  assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime));
+  assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime));
+  assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration));
+  assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
+  assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
+  assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode));
+
+  /* Bank1 NOR/SRAM control register configuration */
+  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] =
+            (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
+            FSMC_NORSRAMInitStruct->FSMC_MemoryType |
+            FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
+            FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
+            FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait |
+            FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
+            FSMC_NORSRAMInitStruct->FSMC_WrapMode |
+            FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
+            FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
+            FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
+            FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
+            FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
+
+  if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
+  {
+    FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_Set;
+  }
+
+  /* Bank1 NOR/SRAM timing register configuration */
+  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] =
+            (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
+            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
+            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
+            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
+            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
+            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
+             FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
+
+
+  /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
+  if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
+  {
+    assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime));
+    assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));
+    assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
+    assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));
+    assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));
+    assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
+    FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] =
+              (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
+              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
+              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
+              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
+              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
+               FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
+  }
+  else
+  {
+    FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
+  }
+}
+
+/**
+  * @brief  Initializes the FSMC NAND Banks according to the specified
+  *         parameters in the FSMC_NANDInitStruct.
+  * @param  FSMC_NANDInitStruct : pointer to a FSMC_NANDInitTypeDef
+  *         structure that contains the configuration information for the FSMC
+  *         NAND specified Banks.
+  * @retval None
+  */
+void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
+{
+  uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000;
+
+  /* Check the parameters */
+  assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct->FSMC_Bank));
+  assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct->FSMC_Waitfeature));
+  assert_param( IS_FSMC_MEMORY_WIDTH(FSMC_NANDInitStruct->FSMC_MemoryDataWidth));
+  assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct->FSMC_ECC));
+  assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct->FSMC_ECCPageSize));
+  assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct->FSMC_TCLRSetupTime));
+  assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct->FSMC_TARSetupTime));
+  assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
+  assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
+  assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
+  assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
+  assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
+  assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
+  assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
+  assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
+
+  /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
+  tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
+            PCR_MemoryType_NAND |
+            FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
+            FSMC_NANDInitStruct->FSMC_ECC |
+            FSMC_NANDInitStruct->FSMC_ECCPageSize |
+            (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
+            (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
+
+  /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
+  tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
+            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
+            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
+            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24);
+
+  /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
+  tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
+            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
+            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
+            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
+
+  if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
+  {
+    /* FSMC_Bank2_NAND registers configuration */
+    FSMC_Bank2->PCR2 = tmppcr;
+    FSMC_Bank2->PMEM2 = tmppmem;
+    FSMC_Bank2->PATT2 = tmppatt;
+  }
+  else
+  {
+    /* FSMC_Bank3_NAND registers configuration */
+    FSMC_Bank3->PCR3 = tmppcr;
+    FSMC_Bank3->PMEM3 = tmppmem;
+    FSMC_Bank3->PATT3 = tmppatt;
+  }
+}
+
+/**
+  * @brief  Initializes the FSMC PCCARD Bank according to the specified
+  *         parameters in the FSMC_PCCARDInitStruct.
+  * @param  FSMC_PCCARDInitStruct : pointer to a FSMC_PCCARDInitTypeDef
+  *         structure that contains the configuration information for the FSMC
+  *         PCCARD Bank.
+  * @retval None
+  */
+void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
+{
+  /* Check the parameters */
+  assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct->FSMC_Waitfeature));
+  assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime));
+  assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct->FSMC_TARSetupTime));
+
+  assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
+  assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
+  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
+  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
+
+  assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
+  assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
+  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
+  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
+  assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime));
+  assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
+  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
+  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
+
+  /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
+  FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
+                     FSMC_MemoryDataWidth_16b |
+                     (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
+                     (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
+
+  /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
+  FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
+                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
+                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
+                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24);
+
+  /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
+  FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
+                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
+                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
+                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
+
+  /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
+  FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
+                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
+                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
+                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24);
+}
+
+/**
+  * @brief  Fills each FSMC_NORSRAMInitStruct member with its default value.
+  * @param  FSMC_NORSRAMInitStruct: pointer to a FSMC_NORSRAMInitTypeDef
+  *         structure which will be initialized.
+  * @retval None
+  */
+void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
+{
+  /* Reset NOR/SRAM Init structure parameters values */
+  FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
+  FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
+  FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
+  FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
+  FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
+  FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
+  FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
+  FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
+  FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
+  FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
+  FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
+  FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
+  FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
+  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
+  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
+  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
+  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
+  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;
+  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;
+  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;
+  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime = 0xF;
+  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime = 0xF;
+  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime = 0xFF;
+  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
+  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision = 0xF;
+  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency = 0xF;
+  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;
+}
+
+/**
+  * @brief  Fills each FSMC_NANDInitStruct member with its default value.
+  * @param  FSMC_NANDInitStruct: pointer to a FSMC_NANDInitTypeDef
+  *         structure which will be initialized.
+  * @retval None
+  */
+void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
+{
+  /* Reset NAND Init structure parameters values */
+  FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
+  FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
+  FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
+  FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
+  FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
+  FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
+  FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
+  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
+  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
+  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
+  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
+  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
+  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
+  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
+  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
+}
+
+/**
+  * @brief  Fills each FSMC_PCCARDInitStruct member with its default value.
+  * @param  FSMC_PCCARDInitStruct: pointer to a FSMC_PCCARDInitTypeDef
+  *         structure which will be initialized.
+  * @retval None
+  */
+void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
+{
+  /* Reset PCCARD Init structure parameters values */
+  FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
+  FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
+  FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
+  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
+  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
+  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
+  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
+  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
+  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
+  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
+  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
+  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
+  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
+  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
+  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
+}
+
+/**
+  * @brief  Enables or disables the specified NOR/SRAM Memory Bank.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *   This parameter can be one of the following values:
+  *     @arg FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1
+  *     @arg FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2
+  *     @arg FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3
+  *     @arg FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4
+  * @param  NewState: new state of the FSMC_Bank. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState)
+{
+  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
+    FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_Set;
+  }
+  else
+  {
+    /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
+    FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified NAND Memory Bank.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *   This parameter can be one of the following values:
+  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND
+  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
+  * @param  NewState: new state of the FSMC_Bank. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState)
+{
+  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
+    if(FSMC_Bank == FSMC_Bank2_NAND)
+    {
+      FSMC_Bank2->PCR2 |= PCR_PBKEN_Set;
+    }
+    else
+    {
+      FSMC_Bank3->PCR3 |= PCR_PBKEN_Set;
+    }
+  }
+  else
+  {
+    /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
+    if(FSMC_Bank == FSMC_Bank2_NAND)
+    {
+      FSMC_Bank2->PCR2 &= PCR_PBKEN_Reset;
+    }
+    else
+    {
+      FSMC_Bank3->PCR3 &= PCR_PBKEN_Reset;
+    }
+  }
+}
+
+/**
+  * @brief  Enables or disables the PCCARD Memory Bank.
+  * @param  NewState: new state of the PCCARD Memory Bank.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void FSMC_PCCARDCmd(FunctionalState NewState)
+{
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
+    FSMC_Bank4->PCR4 |= PCR_PBKEN_Set;
+  }
+  else
+  {
+    /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
+    FSMC_Bank4->PCR4 &= PCR_PBKEN_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the FSMC NAND ECC feature.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *   This parameter can be one of the following values:
+  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND
+  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
+  * @param  NewState: new state of the FSMC NAND ECC feature.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState)
+{
+  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
+    if(FSMC_Bank == FSMC_Bank2_NAND)
+    {
+      FSMC_Bank2->PCR2 |= PCR_ECCEN_Set;
+    }
+    else
+    {
+      FSMC_Bank3->PCR3 |= PCR_ECCEN_Set;
+    }
+  }
+  else
+  {
+    /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
+    if(FSMC_Bank == FSMC_Bank2_NAND)
+    {
+      FSMC_Bank2->PCR2 &= PCR_ECCEN_Reset;
+    }
+    else
+    {
+      FSMC_Bank3->PCR3 &= PCR_ECCEN_Reset;
+    }
+  }
+}
+
+/**
+  * @brief  Returns the error correction code register value.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *   This parameter can be one of the following values:
+  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND
+  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
+  * @retval The Error Correction Code (ECC) value.
+  */
+uint32_t FSMC_GetECC(uint32_t FSMC_Bank)
+{
+  uint32_t eccval = 0x00000000;
+
+  if(FSMC_Bank == FSMC_Bank2_NAND)
+  {
+    /* Get the ECCR2 register value */
+    eccval = FSMC_Bank2->ECCR2;
+  }
+  else
+  {
+    /* Get the ECCR3 register value */
+    eccval = FSMC_Bank3->ECCR3;
+  }
+  /* Return the error correction code value */
+  return(eccval);
+}
+
+/**
+  * @brief  Enables or disables the specified FSMC interrupts.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *   This parameter can be one of the following values:
+  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND
+  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
+  *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
+  * @param  FSMC_IT: specifies the FSMC interrupt sources to be enabled or disabled.
+  *   This parameter can be any combination of the following values:
+  *     @arg FSMC_IT_RisingEdge: Rising edge detection interrupt.
+  *     @arg FSMC_IT_Level: Level edge detection interrupt.
+  *     @arg FSMC_IT_FallingEdge: Falling edge detection interrupt.
+  * @param  NewState: new state of the specified FSMC interrupts.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState)
+{
+  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
+  assert_param(IS_FSMC_IT(FSMC_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected FSMC_Bank2 interrupts */
+    if(FSMC_Bank == FSMC_Bank2_NAND)
+    {
+      FSMC_Bank2->SR2 |= FSMC_IT;
+    }
+    /* Enable the selected FSMC_Bank3 interrupts */
+    else if (FSMC_Bank == FSMC_Bank3_NAND)
+    {
+      FSMC_Bank3->SR3 |= FSMC_IT;
+    }
+    /* Enable the selected FSMC_Bank4 interrupts */
+    else
+    {
+      FSMC_Bank4->SR4 |= FSMC_IT;
+    }
+  }
+  else
+  {
+    /* Disable the selected FSMC_Bank2 interrupts */
+    if(FSMC_Bank == FSMC_Bank2_NAND)
+    {
+
+      FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;
+    }
+    /* Disable the selected FSMC_Bank3 interrupts */
+    else if (FSMC_Bank == FSMC_Bank3_NAND)
+    {
+      FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;
+    }
+    /* Disable the selected FSMC_Bank4 interrupts */
+    else
+    {
+      FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;
+    }
+  }
+}
+
+/**
+  * @brief  Checks whether the specified FSMC flag is set or not.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *   This parameter can be one of the following values:
+  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND
+  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
+  *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
+  * @param  FSMC_FLAG: specifies the flag to check.
+  *   This parameter can be one of the following values:
+  *     @arg FSMC_FLAG_RisingEdge: Rising egde detection Flag.
+  *     @arg FSMC_FLAG_Level: Level detection Flag.
+  *     @arg FSMC_FLAG_FallingEdge: Falling egde detection Flag.
+  *     @arg FSMC_FLAG_FEMPT: Fifo empty Flag.
+  * @retval The new state of FSMC_FLAG (SET or RESET).
+  */
+FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  uint32_t tmpsr = 0x00000000;
+
+  /* Check the parameters */
+  assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
+  assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
+
+  if(FSMC_Bank == FSMC_Bank2_NAND)
+  {
+    tmpsr = FSMC_Bank2->SR2;
+  }
+  else if(FSMC_Bank == FSMC_Bank3_NAND)
+  {
+    tmpsr = FSMC_Bank3->SR3;
+  }
+  /* FSMC_Bank4_PCCARD*/
+  else
+  {
+    tmpsr = FSMC_Bank4->SR4;
+  }
+
+  /* Get the flag status */
+  if ((tmpsr & FSMC_FLAG) != (uint16_t)RESET )
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  /* Return the flag status */
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the FSMC's pending flags.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *   This parameter can be one of the following values:
+  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND
+  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
+  *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
+  * @param  FSMC_FLAG: specifies the flag to clear.
+  *   This parameter can be any combination of the following values:
+  *     @arg FSMC_FLAG_RisingEdge: Rising egde detection Flag.
+  *     @arg FSMC_FLAG_Level: Level detection Flag.
+  *     @arg FSMC_FLAG_FallingEdge: Falling egde detection Flag.
+  * @retval None
+  */
+void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
+{
+ /* Check the parameters */
+  assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
+  assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
+
+  if(FSMC_Bank == FSMC_Bank2_NAND)
+  {
+    FSMC_Bank2->SR2 &= ~FSMC_FLAG;
+  }
+  else if(FSMC_Bank == FSMC_Bank3_NAND)
+  {
+    FSMC_Bank3->SR3 &= ~FSMC_FLAG;
+  }
+  /* FSMC_Bank4_PCCARD*/
+  else
+  {
+    FSMC_Bank4->SR4 &= ~FSMC_FLAG;
+  }
+}
+
+/**
+  * @brief  Checks whether the specified FSMC interrupt has occurred or not.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *   This parameter can be one of the following values:
+  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND
+  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
+  *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
+  * @param  FSMC_IT: specifies the FSMC interrupt source to check.
+  *   This parameter can be one of the following values:
+  *     @arg FSMC_IT_RisingEdge: Rising edge detection interrupt.
+  *     @arg FSMC_IT_Level: Level edge detection interrupt.
+  *     @arg FSMC_IT_FallingEdge: Falling edge detection interrupt.
+  * @retval The new state of FSMC_IT (SET or RESET).
+  */
+ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT)
+{
+  ITStatus bitstatus = RESET;
+  uint32_t tmpsr = 0x0, itstatus = 0x0, itenable = 0x0;
+
+  /* Check the parameters */
+  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
+  assert_param(IS_FSMC_GET_IT(FSMC_IT));
+
+  if(FSMC_Bank == FSMC_Bank2_NAND)
+  {
+    tmpsr = FSMC_Bank2->SR2;
+  }
+  else if(FSMC_Bank == FSMC_Bank3_NAND)
+  {
+    tmpsr = FSMC_Bank3->SR3;
+  }
+  /* FSMC_Bank4_PCCARD*/
+  else
+  {
+    tmpsr = FSMC_Bank4->SR4;
+  }
+
+  itstatus = tmpsr & FSMC_IT;
+
+  itenable = tmpsr & (FSMC_IT >> 3);
+  if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the FSMC's interrupt pending bits.
+  * @param  FSMC_Bank: specifies the FSMC Bank to be used
+  *   This parameter can be one of the following values:
+  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND
+  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
+  *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
+  * @param  FSMC_IT: specifies the interrupt pending bit to clear.
+  *   This parameter can be any combination of the following values:
+  *     @arg FSMC_IT_RisingEdge: Rising edge detection interrupt.
+  *     @arg FSMC_IT_Level: Level edge detection interrupt.
+  *     @arg FSMC_IT_FallingEdge: Falling edge detection interrupt.
+  * @retval None
+  */
+void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
+  assert_param(IS_FSMC_IT(FSMC_IT));
+
+  if(FSMC_Bank == FSMC_Bank2_NAND)
+  {
+    FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3);
+  }
+  else if(FSMC_Bank == FSMC_Bank3_NAND)
+  {
+    FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
+  }
+  /* FSMC_Bank4_PCCARD*/
+  else
+  {
+    FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
+  }
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_gpio.c b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_gpio.c
new file mode 100644
index 0000000..93dbcd7
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_gpio.c
@@ -0,0 +1,650 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_gpio.c
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file provides all the GPIO firmware functions.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x_gpio.h"
+#include "stm32f10x_rcc.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup GPIO
+  * @brief GPIO driver modules
+  * @{
+  */
+
+/** @defgroup GPIO_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup GPIO_Private_Defines
+  * @{
+  */
+
+/* ------------ RCC registers bit address in the alias region ----------------*/
+#define AFIO_OFFSET                 (AFIO_BASE - PERIPH_BASE)
+
+/* --- EVENTCR Register -----*/
+
+/* Alias word address of EVOE bit */
+#define EVCR_OFFSET                 (AFIO_OFFSET + 0x00)
+#define EVOE_BitNumber              ((uint8_t)0x07)
+#define EVCR_EVOE_BB                (PERIPH_BB_BASE + (EVCR_OFFSET * 32) + (EVOE_BitNumber * 4))
+
+
+/* ---  MAPR Register ---*/
+/* Alias word address of MII_RMII_SEL bit */
+#define MAPR_OFFSET                 (AFIO_OFFSET + 0x04)
+#define MII_RMII_SEL_BitNumber      ((u8)0x17)
+#define MAPR_MII_RMII_SEL_BB        (PERIPH_BB_BASE + (MAPR_OFFSET * 32) + (MII_RMII_SEL_BitNumber * 4))
+
+
+#define EVCR_PORTPINCONFIG_MASK     ((uint16_t)0xFF80)
+#define LSB_MASK                    ((uint16_t)0xFFFF)
+#define DBGAFR_POSITION_MASK        ((uint32_t)0x000F0000)
+#define DBGAFR_SWJCFG_MASK          ((uint32_t)0xF0FFFFFF)
+#define DBGAFR_LOCATION_MASK        ((uint32_t)0x00200000)
+#define DBGAFR_NUMBITS_MASK         ((uint32_t)0x00100000)
+/**
+  * @}
+  */
+
+/** @defgroup GPIO_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup GPIO_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup GPIO_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup GPIO_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the GPIOx peripheral registers to their default reset values.
+  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
+  * @retval None
+  */
+void GPIO_DeInit(GPIO_TypeDef* GPIOx)
+{
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+
+  if (GPIOx == GPIOA)
+  {
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
+  }
+  else if (GPIOx == GPIOB)
+  {
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
+  }
+  else if (GPIOx == GPIOC)
+  {
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
+  }
+  else if (GPIOx == GPIOD)
+  {
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
+  }
+  else if (GPIOx == GPIOE)
+  {
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
+  }
+  else if (GPIOx == GPIOF)
+  {
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, DISABLE);
+  }
+  else
+  {
+    if (GPIOx == GPIOG)
+    {
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
+    }
+  }
+}
+
+/**
+  * @brief  Deinitializes the Alternate Functions (remap, event control
+  *   and EXTI configuration) registers to their default reset values.
+  * @param  None
+  * @retval None
+  */
+void GPIO_AFIODeInit(void)
+{
+  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
+  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, DISABLE);
+}
+
+/**
+  * @brief  Initializes the GPIOx peripheral according to the specified
+  *         parameters in the GPIO_InitStruct.
+  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
+  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
+  *         contains the configuration information for the specified GPIO peripheral.
+  * @retval None
+  */
+void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
+{
+  uint32_t currentmode = 0x00, currentpin = 0x00, pinpos = 0x00, pos = 0x00;
+  uint32_t tmpreg = 0x00, pinmask = 0x00;
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
+  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));
+
+/*---------------------------- GPIO Mode Configuration -----------------------*/
+  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
+  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
+  {
+    /* Check the parameters */
+    assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
+    /* Output mode */
+    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
+  }
+/*---------------------------- GPIO CRL Configuration ------------------------*/
+  /* Configure the eight low port pins */
+  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
+  {
+    tmpreg = GPIOx->CRL;
+    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
+    {
+      pos = ((uint32_t)0x01) << pinpos;
+      /* Get the port pins position */
+      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
+      if (currentpin == pos)
+      {
+        pos = pinpos << 2;
+        /* Clear the corresponding low control register bits */
+        pinmask = ((uint32_t)0x0F) << pos;
+        tmpreg &= ~pinmask;
+        /* Write the mode configuration in the corresponding bits */
+        tmpreg |= (currentmode << pos);
+        /* Reset the corresponding ODR bit */
+        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
+        {
+          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
+        }
+        else
+        {
+          /* Set the corresponding ODR bit */
+          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
+          {
+            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
+          }
+        }
+      }
+    }
+    GPIOx->CRL = tmpreg;
+  }
+/*---------------------------- GPIO CRH Configuration ------------------------*/
+  /* Configure the eight high port pins */
+  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
+  {
+    tmpreg = GPIOx->CRH;
+    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
+    {
+      pos = (((uint32_t)0x01) << (pinpos + 0x08));
+      /* Get the port pins position */
+      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
+      if (currentpin == pos)
+      {
+        pos = pinpos << 2;
+        /* Clear the corresponding high control register bits */
+        pinmask = ((uint32_t)0x0F) << pos;
+        tmpreg &= ~pinmask;
+        /* Write the mode configuration in the corresponding bits */
+        tmpreg |= (currentmode << pos);
+        /* Reset the corresponding ODR bit */
+        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
+        {
+          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
+        }
+        /* Set the corresponding ODR bit */
+        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
+        {
+          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
+        }
+      }
+    }
+    GPIOx->CRH = tmpreg;
+  }
+}
+
+/**
+  * @brief  Fills each GPIO_InitStruct member with its default value.
+  * @param  GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure which will
+  *         be initialized.
+  * @retval None
+  */
+void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
+{
+  /* Reset GPIO init structure parameters values */
+  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
+  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
+  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
+}
+
+/**
+  * @brief  Reads the specified input port pin.
+  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
+  * @param  GPIO_Pin:  specifies the port bit to read.
+  *   This parameter can be GPIO_Pin_x where x can be (0..15).
+  * @retval The input port pin value.
+  */
+uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
+{
+  uint8_t bitstatus = 0x00;
+
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
+
+  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
+  {
+    bitstatus = (uint8_t)Bit_SET;
+  }
+  else
+  {
+    bitstatus = (uint8_t)Bit_RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Reads the specified GPIO input data port.
+  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
+  * @retval GPIO input data port value.
+  */
+uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
+{
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+
+  return ((uint16_t)GPIOx->IDR);
+}
+
+/**
+  * @brief  Reads the specified output data port bit.
+  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
+  * @param  GPIO_Pin:  specifies the port bit to read.
+  *   This parameter can be GPIO_Pin_x where x can be (0..15).
+  * @retval The output port pin value.
+  */
+uint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
+{
+  uint8_t bitstatus = 0x00;
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
+
+  if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
+  {
+    bitstatus = (uint8_t)Bit_SET;
+  }
+  else
+  {
+    bitstatus = (uint8_t)Bit_RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Reads the specified GPIO output data port.
+  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
+  * @retval GPIO output data port value.
+  */
+uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
+{
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+
+  return ((uint16_t)GPIOx->ODR);
+}
+
+/**
+  * @brief  Sets the selected data port bits.
+  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
+  * @param  GPIO_Pin: specifies the port bits to be written.
+  *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
+  * @retval None
+  */
+void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
+{
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  assert_param(IS_GPIO_PIN(GPIO_Pin));
+
+  GPIOx->BSRR = GPIO_Pin;
+}
+
+/**
+  * @brief  Clears the selected data port bits.
+  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
+  * @param  GPIO_Pin: specifies the port bits to be written.
+  *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
+  * @retval None
+  */
+void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
+{
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  assert_param(IS_GPIO_PIN(GPIO_Pin));
+
+  GPIOx->BRR = GPIO_Pin;
+}
+
+/**
+  * @brief  Sets or clears the selected data port bit.
+  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
+  * @param  GPIO_Pin: specifies the port bit to be written.
+  *   This parameter can be one of GPIO_Pin_x where x can be (0..15).
+  * @param  BitVal: specifies the value to be written to the selected bit.
+  *   This parameter can be one of the BitAction enum values:
+  *     @arg Bit_RESET: to clear the port pin
+  *     @arg Bit_SET: to set the port pin
+  * @retval None
+  */
+void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)
+{
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
+  assert_param(IS_GPIO_BIT_ACTION(BitVal));
+
+  if (BitVal != Bit_RESET)
+  {
+    GPIOx->BSRR = GPIO_Pin;
+  }
+  else
+  {
+    GPIOx->BRR = GPIO_Pin;
+  }
+}
+
+/**
+  * @brief  Writes data to the specified GPIO data port.
+  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
+  * @param  PortVal: specifies the value to be written to the port output data register.
+  * @retval None
+  */
+void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
+{
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+
+  GPIOx->ODR = PortVal;
+}
+
+/**
+  * @brief  Locks GPIO Pins configuration registers.
+  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
+  * @param  GPIO_Pin: specifies the port bit to be written.
+  *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
+  * @retval None
+  */
+void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
+{
+  uint32_t tmp = 0x00010000;
+
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  assert_param(IS_GPIO_PIN(GPIO_Pin));
+
+  tmp |= GPIO_Pin;
+  /* Set LCKK bit */
+  GPIOx->LCKR = tmp;
+  /* Reset LCKK bit */
+  GPIOx->LCKR =  GPIO_Pin;
+  /* Set LCKK bit */
+  GPIOx->LCKR = tmp;
+  /* Read LCKK bit*/
+  tmp = GPIOx->LCKR;
+  /* Read LCKK bit*/
+  tmp = GPIOx->LCKR;
+}
+
+/**
+  * @brief  Selects the GPIO pin used as Event output.
+  * @param  GPIO_PortSource: selects the GPIO port to be used as source
+  *   for Event output.
+  *   This parameter can be GPIO_PortSourceGPIOx where x can be (A..E).
+  * @param  GPIO_PinSource: specifies the pin for the Event output.
+  *   This parameter can be GPIO_PinSourcex where x can be (0..15).
+  * @retval None
+  */
+void GPIO_EventOutputConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)
+{
+  uint32_t tmpreg = 0x00;
+  /* Check the parameters */
+  assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
+  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
+
+  tmpreg = AFIO->EVCR;
+  /* Clear the PORT[6:4] and PIN[3:0] bits */
+  tmpreg &= EVCR_PORTPINCONFIG_MASK;
+  tmpreg |= (uint32_t)GPIO_PortSource << 0x04;
+  tmpreg |= GPIO_PinSource;
+  AFIO->EVCR = tmpreg;
+}
+
+/**
+  * @brief  Enables or disables the Event Output.
+  * @param  NewState: new state of the Event output.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void GPIO_EventOutputCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(__IO uint32_t *) EVCR_EVOE_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Changes the mapping of the specified pin.
+  * @param  GPIO_Remap: selects the pin to remap.
+  *   This parameter can be one of the following values:
+  *     @arg GPIO_Remap_SPI1             : SPI1 Alternate Function mapping
+  *     @arg GPIO_Remap_I2C1             : I2C1 Alternate Function mapping
+  *     @arg GPIO_Remap_USART1           : USART1 Alternate Function mapping
+  *     @arg GPIO_Remap_USART2           : USART2 Alternate Function mapping
+  *     @arg GPIO_PartialRemap_USART3    : USART3 Partial Alternate Function mapping
+  *     @arg GPIO_FullRemap_USART3       : USART3 Full Alternate Function mapping
+  *     @arg GPIO_PartialRemap_TIM1      : TIM1 Partial Alternate Function mapping
+  *     @arg GPIO_FullRemap_TIM1         : TIM1 Full Alternate Function mapping
+  *     @arg GPIO_PartialRemap1_TIM2     : TIM2 Partial1 Alternate Function mapping
+  *     @arg GPIO_PartialRemap2_TIM2     : TIM2 Partial2 Alternate Function mapping
+  *     @arg GPIO_FullRemap_TIM2         : TIM2 Full Alternate Function mapping
+  *     @arg GPIO_PartialRemap_TIM3      : TIM3 Partial Alternate Function mapping
+  *     @arg GPIO_FullRemap_TIM3         : TIM3 Full Alternate Function mapping
+  *     @arg GPIO_Remap_TIM4             : TIM4 Alternate Function mapping
+  *     @arg GPIO_Remap1_CAN1            : CAN1 Alternate Function mapping
+  *     @arg GPIO_Remap2_CAN1            : CAN1 Alternate Function mapping
+  *     @arg GPIO_Remap_PD01             : PD01 Alternate Function mapping
+  *     @arg GPIO_Remap_TIM5CH4_LSI      : LSI connected to TIM5 Channel4 input capture for calibration
+  *     @arg GPIO_Remap_ADC1_ETRGINJ     : ADC1 External Trigger Injected Conversion remapping
+  *     @arg GPIO_Remap_ADC1_ETRGREG     : ADC1 External Trigger Regular Conversion remapping
+  *     @arg GPIO_Remap_ADC2_ETRGINJ     : ADC2 External Trigger Injected Conversion remapping
+  *     @arg GPIO_Remap_ADC2_ETRGREG     : ADC2 External Trigger Regular Conversion remapping
+  *     @arg GPIO_Remap_ETH              : Ethernet remapping (only for Connectivity line devices)
+  *     @arg GPIO_Remap_CAN2             : CAN2 remapping (only for Connectivity line devices)
+  *     @arg GPIO_Remap_SWJ_NoJTRST      : Full SWJ Enabled (JTAG-DP + SW-DP) but without JTRST
+  *     @arg GPIO_Remap_SWJ_JTAGDisable  : JTAG-DP Disabled and SW-DP Enabled
+  *     @arg GPIO_Remap_SWJ_Disable      : Full SWJ Disabled (JTAG-DP + SW-DP)
+  *     @arg GPIO_Remap_SPI3             : SPI3/I2S3 Alternate Function mapping (only for Connectivity line devices)
+  *                                        When the SPI3/I2S3 is remapped using this function, the SWJ is configured
+  *                                        to Full SWJ Enabled (JTAG-DP + SW-DP) but without JTRST.
+  *     @arg GPIO_Remap_TIM2ITR1_PTP_SOF : Ethernet PTP output or USB OTG SOF (Start of Frame) connected
+  *                                        to TIM2 Internal Trigger 1 for calibration (only for Connectivity line devices)
+  *                                        If the GPIO_Remap_TIM2ITR1_PTP_SOF is enabled the TIM2 ITR1 is connected to
+  *                                        Ethernet PTP output. When Reset TIM2 ITR1 is connected to USB OTG SOF output.
+  *     @arg GPIO_Remap_PTP_PPS          : Ethernet MAC PPS_PTS output on PB05 (only for Connectivity line devices)
+  *     @arg GPIO_Remap_TIM15            : TIM15 Alternate Function mapping (only for Value line devices)
+  *     @arg GPIO_Remap_TIM16            : TIM16 Alternate Function mapping (only for Value line devices)
+  *     @arg GPIO_Remap_TIM17            : TIM17 Alternate Function mapping (only for Value line devices)
+  *     @arg GPIO_Remap_CEC              : CEC Alternate Function mapping (only for Value line devices)
+  *     @arg GPIO_Remap_TIM1_DMA         : TIM1 DMA requests mapping (only for Value line devices)
+  *     @arg GPIO_Remap_TIM9             : TIM9 Alternate Function mapping (only for XL-density devices)
+  *     @arg GPIO_Remap_TIM10            : TIM10 Alternate Function mapping (only for XL-density devices)
+  *     @arg GPIO_Remap_TIM11            : TIM11 Alternate Function mapping (only for XL-density devices)
+  *     @arg GPIO_Remap_TIM13            : TIM13 Alternate Function mapping (only for High density Value line and XL-density devices)
+  *     @arg GPIO_Remap_TIM14            : TIM14 Alternate Function mapping (only for High density Value line and XL-density devices)
+  *     @arg GPIO_Remap_FSMC_NADV        : FSMC_NADV Alternate Function mapping (only for High density Value line and XL-density devices)
+  *     @arg GPIO_Remap_TIM67_DAC_DMA    : TIM6/TIM7 and DAC DMA requests remapping (only for High density Value line devices)
+  *     @arg GPIO_Remap_TIM12            : TIM12 Alternate Function mapping (only for High density Value line devices)
+  *     @arg GPIO_Remap_MISC             : Miscellaneous Remap (DMA2 Channel5 Position and DAC Trigger remapping,
+  *                                        only for High density Value line devices)
+  * @param  NewState: new state of the port pin remapping.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void GPIO_PinRemapConfig(uint32_t GPIO_Remap, FunctionalState NewState)
+{
+  uint32_t tmp = 0x00, tmp1 = 0x00, tmpreg = 0x00, tmpmask = 0x00;
+
+  /* Check the parameters */
+  assert_param(IS_GPIO_REMAP(GPIO_Remap));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if((GPIO_Remap & 0x80000000) == 0x80000000)
+  {
+    tmpreg = AFIO->MAPR2;
+  }
+  else
+  {
+    tmpreg = AFIO->MAPR;
+  }
+
+  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
+  tmp = GPIO_Remap & LSB_MASK;
+
+  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
+  {
+    tmpreg &= DBGAFR_SWJCFG_MASK;
+    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
+  }
+  else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
+  {
+    tmp1 = ((uint32_t)0x03) << tmpmask;
+    tmpreg &= ~tmp1;
+    tmpreg |= ~DBGAFR_SWJCFG_MASK;
+  }
+  else
+  {
+    tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
+    tmpreg |= ~DBGAFR_SWJCFG_MASK;
+  }
+
+  if (NewState != DISABLE)
+  {
+    tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
+  }
+
+  if((GPIO_Remap & 0x80000000) == 0x80000000)
+  {
+    AFIO->MAPR2 = tmpreg;
+  }
+  else
+  {
+    AFIO->MAPR = tmpreg;
+  }
+}
+
+/**
+  * @brief  Selects the GPIO pin used as EXTI Line.
+  * @param  GPIO_PortSource: selects the GPIO port to be used as source for EXTI lines.
+  *   This parameter can be GPIO_PortSourceGPIOx where x can be (A..G).
+  * @param  GPIO_PinSource: specifies the EXTI line to be configured.
+  *   This parameter can be GPIO_PinSourcex where x can be (0..15).
+  * @retval None
+  */
+void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)
+{
+  uint32_t tmp = 0x00;
+  /* Check the parameters */
+  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
+  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
+
+  tmp = ((uint32_t)0x0F) << (0x04 * (GPIO_PinSource & (uint8_t)0x03));
+  AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
+  AFIO->EXTICR[GPIO_PinSource >> 0x02] |= (((uint32_t)GPIO_PortSource) << (0x04 * (GPIO_PinSource & (uint8_t)0x03)));
+}
+
+/**
+  * @brief  Selects the Ethernet media interface.
+  * @note   This function applies only to STM32 Connectivity line devices.
+  * @param  GPIO_ETH_MediaInterface: specifies the Media Interface mode.
+  *   This parameter can be one of the following values:
+  *     @arg GPIO_ETH_MediaInterface_MII: MII mode
+  *     @arg GPIO_ETH_MediaInterface_RMII: RMII mode
+  * @retval None
+  */
+void GPIO_ETH_MediaInterfaceConfig(uint32_t GPIO_ETH_MediaInterface)
+{
+  assert_param(IS_GPIO_ETH_MEDIA_INTERFACE(GPIO_ETH_MediaInterface));
+
+  /* Configure MII_RMII selection bit */
+  *(__IO uint32_t *) MAPR_MII_RMII_SEL_BB = GPIO_ETH_MediaInterface;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_i2c.c b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_i2c.c
new file mode 100644
index 0000000..8896726
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_i2c.c
@@ -0,0 +1,1331 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_i2c.c
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file provides all the I2C firmware functions.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x_i2c.h"
+#include "stm32f10x_rcc.h"
+
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup I2C
+  * @brief I2C driver modules
+  * @{
+  */
+
+/** @defgroup I2C_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup I2C_Private_Defines
+  * @{
+  */
+
+/* I2C SPE mask */
+#define CR1_PE_Set              ((uint16_t)0x0001)
+#define CR1_PE_Reset            ((uint16_t)0xFFFE)
+
+/* I2C START mask */
+#define CR1_START_Set           ((uint16_t)0x0100)
+#define CR1_START_Reset         ((uint16_t)0xFEFF)
+
+/* I2C STOP mask */
+#define CR1_STOP_Set            ((uint16_t)0x0200)
+#define CR1_STOP_Reset          ((uint16_t)0xFDFF)
+
+/* I2C ACK mask */
+#define CR1_ACK_Set             ((uint16_t)0x0400)
+#define CR1_ACK_Reset           ((uint16_t)0xFBFF)
+
+/* I2C ENGC mask */
+#define CR1_ENGC_Set            ((uint16_t)0x0040)
+#define CR1_ENGC_Reset          ((uint16_t)0xFFBF)
+
+/* I2C SWRST mask */
+#define CR1_SWRST_Set           ((uint16_t)0x8000)
+#define CR1_SWRST_Reset         ((uint16_t)0x7FFF)
+
+/* I2C PEC mask */
+#define CR1_PEC_Set             ((uint16_t)0x1000)
+#define CR1_PEC_Reset           ((uint16_t)0xEFFF)
+
+/* I2C ENPEC mask */
+#define CR1_ENPEC_Set           ((uint16_t)0x0020)
+#define CR1_ENPEC_Reset         ((uint16_t)0xFFDF)
+
+/* I2C ENARP mask */
+#define CR1_ENARP_Set           ((uint16_t)0x0010)
+#define CR1_ENARP_Reset         ((uint16_t)0xFFEF)
+
+/* I2C NOSTRETCH mask */
+#define CR1_NOSTRETCH_Set       ((uint16_t)0x0080)
+#define CR1_NOSTRETCH_Reset     ((uint16_t)0xFF7F)
+
+/* I2C registers Masks */
+#define CR1_CLEAR_Mask          ((uint16_t)0xFBF5)
+
+/* I2C DMAEN mask */
+#define CR2_DMAEN_Set           ((uint16_t)0x0800)
+#define CR2_DMAEN_Reset         ((uint16_t)0xF7FF)
+
+/* I2C LAST mask */
+#define CR2_LAST_Set            ((uint16_t)0x1000)
+#define CR2_LAST_Reset          ((uint16_t)0xEFFF)
+
+/* I2C FREQ mask */
+#define CR2_FREQ_Reset          ((uint16_t)0xFFC0)
+
+/* I2C ADD0 mask */
+#define OAR1_ADD0_Set           ((uint16_t)0x0001)
+#define OAR1_ADD0_Reset         ((uint16_t)0xFFFE)
+
+/* I2C ENDUAL mask */
+#define OAR2_ENDUAL_Set         ((uint16_t)0x0001)
+#define OAR2_ENDUAL_Reset       ((uint16_t)0xFFFE)
+
+/* I2C ADD2 mask */
+#define OAR2_ADD2_Reset         ((uint16_t)0xFF01)
+
+/* I2C F/S mask */
+#define CCR_FS_Set              ((uint16_t)0x8000)
+
+/* I2C CCR mask */
+#define CCR_CCR_Set             ((uint16_t)0x0FFF)
+
+/* I2C FLAG mask */
+#define FLAG_Mask               ((uint32_t)0x00FFFFFF)
+
+/* I2C Interrupt Enable mask */
+#define ITEN_Mask               ((uint32_t)0x07000000)
+
+/**
+  * @}
+  */
+
+/** @defgroup I2C_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup I2C_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup I2C_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup I2C_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the I2Cx peripheral registers to their default reset values.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @retval None
+  */
+void I2C_DeInit(I2C_TypeDef* I2Cx)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+
+  if (I2Cx == I2C1)
+  {
+    /* Enable I2C1 reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
+    /* Release I2C1 from reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
+  }
+  else
+  {
+    /* Enable I2C2 reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
+    /* Release I2C2 from reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
+  }
+}
+
+/**
+  * @brief  Initializes the I2Cx peripheral according to the specified
+  *   parameters in the I2C_InitStruct.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  I2C_InitStruct: pointer to a I2C_InitTypeDef structure that
+  *   contains the configuration information for the specified I2C peripheral.
+  * @retval None
+  */
+void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
+{
+  uint16_t tmpreg = 0, freqrange = 0;
+  uint16_t result = 0x04;
+  uint32_t pclk1 = 8000000;
+  RCC_ClocksTypeDef  rcc_clocks;
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
+  assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
+  assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
+  assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
+  assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
+  assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
+
+/*---------------------------- I2Cx CR2 Configuration ------------------------*/
+  /* Get the I2Cx CR2 value */
+  tmpreg = I2Cx->CR2;
+  /* Clear frequency FREQ[5:0] bits */
+  tmpreg &= CR2_FREQ_Reset;
+  /* Get pclk1 frequency value */
+  RCC_GetClocksFreq(&rcc_clocks);
+  pclk1 = rcc_clocks.PCLK1_Frequency;
+  /* Set frequency bits depending on pclk1 value */
+  freqrange = (uint16_t)(pclk1 / 1000000);
+  tmpreg |= freqrange;
+  /* Write to I2Cx CR2 */
+  I2Cx->CR2 = tmpreg;
+
+/*---------------------------- I2Cx CCR Configuration ------------------------*/
+  /* Disable the selected I2C peripheral to configure TRISE */
+  I2Cx->CR1 &= CR1_PE_Reset;
+  /* Reset tmpreg value */
+  /* Clear F/S, DUTY and CCR[11:0] bits */
+  tmpreg = 0;
+
+  /* Configure speed in standard mode */
+  if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
+  {
+    /* Standard mode speed calculate */
+    result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
+    /* Test if CCR value is under 0x4*/
+    if (result < 0x04)
+    {
+      /* Set minimum allowed value */
+      result = 0x04;
+    }
+    /* Set speed value for standard mode */
+    tmpreg |= result;
+    /* Set Maximum Rise Time for standard mode */
+    I2Cx->TRISE = freqrange + 1;
+  }
+  /* Configure speed in fast mode */
+  else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
+  {
+    if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
+    {
+      /* Fast mode speed calculate: Tlow/Thigh = 2 */
+      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
+    }
+    else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
+    {
+      /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
+      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
+      /* Set DUTY bit */
+      result |= I2C_DutyCycle_16_9;
+    }
+
+    /* Test if CCR value is under 0x1*/
+    if ((result & CCR_CCR_Set) == 0)
+    {
+      /* Set minimum allowed value */
+      result |= (uint16_t)0x0001;
+    }
+    /* Set speed value and set F/S bit for fast mode */
+    tmpreg |= (uint16_t)(result | CCR_FS_Set);
+    /* Set Maximum Rise Time for fast mode */
+    I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);
+  }
+
+  /* Write to I2Cx CCR */
+  I2Cx->CCR = tmpreg;
+  /* Enable the selected I2C peripheral */
+  I2Cx->CR1 |= CR1_PE_Set;
+
+/*---------------------------- I2Cx CR1 Configuration ------------------------*/
+  /* Get the I2Cx CR1 value */
+  tmpreg = I2Cx->CR1;
+  /* Clear ACK, SMBTYPE and  SMBUS bits */
+  tmpreg &= CR1_CLEAR_Mask;
+  /* Configure I2Cx: mode and acknowledgement */
+  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
+  /* Set ACK bit according to I2C_Ack value */
+  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
+  /* Write to I2Cx CR1 */
+  I2Cx->CR1 = tmpreg;
+
+/*---------------------------- I2Cx OAR1 Configuration -----------------------*/
+  /* Set I2Cx Own Address1 and acknowledged address */
+  I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
+}
+
+/**
+  * @brief  Fills each I2C_InitStruct member with its default value.
+  * @param  I2C_InitStruct: pointer to an I2C_InitTypeDef structure which will be initialized.
+  * @retval None
+  */
+void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
+{
+/*---------------- Reset I2C init structure parameters values ----------------*/
+  /* initialize the I2C_ClockSpeed member */
+  I2C_InitStruct->I2C_ClockSpeed = 5000;
+  /* Initialize the I2C_Mode member */
+  I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
+  /* Initialize the I2C_DutyCycle member */
+  I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
+  /* Initialize the I2C_OwnAddress1 member */
+  I2C_InitStruct->I2C_OwnAddress1 = 0;
+  /* Initialize the I2C_Ack member */
+  I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
+  /* Initialize the I2C_AcknowledgedAddress member */
+  I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
+}
+
+/**
+  * @brief  Enables or disables the specified I2C peripheral.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  NewState: new state of the I2Cx peripheral.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected I2C peripheral */
+    I2Cx->CR1 |= CR1_PE_Set;
+  }
+  else
+  {
+    /* Disable the selected I2C peripheral */
+    I2Cx->CR1 &= CR1_PE_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified I2C DMA requests.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  NewState: new state of the I2C DMA transfer.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected I2C DMA requests */
+    I2Cx->CR2 |= CR2_DMAEN_Set;
+  }
+  else
+  {
+    /* Disable the selected I2C DMA requests */
+    I2Cx->CR2 &= CR2_DMAEN_Reset;
+  }
+}
+
+/**
+  * @brief  Specifies if the next DMA transfer will be the last one.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  NewState: new state of the I2C DMA last transfer.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Next DMA transfer is the last transfer */
+    I2Cx->CR2 |= CR2_LAST_Set;
+  }
+  else
+  {
+    /* Next DMA transfer is not the last transfer */
+    I2Cx->CR2 &= CR2_LAST_Reset;
+  }
+}
+
+/**
+  * @brief  Generates I2Cx communication START condition.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  NewState: new state of the I2C START condition generation.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None.
+  */
+void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Generate a START condition */
+    I2Cx->CR1 |= CR1_START_Set;
+  }
+  else
+  {
+    /* Disable the START condition generation */
+    I2Cx->CR1 &= CR1_START_Reset;
+  }
+}
+
+/**
+  * @brief  Generates I2Cx communication STOP condition.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  NewState: new state of the I2C STOP condition generation.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None.
+  */
+void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Generate a STOP condition */
+    I2Cx->CR1 |= CR1_STOP_Set;
+  }
+  else
+  {
+    /* Disable the STOP condition generation */
+    I2Cx->CR1 &= CR1_STOP_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified I2C acknowledge feature.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  NewState: new state of the I2C Acknowledgement.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None.
+  */
+void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the acknowledgement */
+    I2Cx->CR1 |= CR1_ACK_Set;
+  }
+  else
+  {
+    /* Disable the acknowledgement */
+    I2Cx->CR1 &= CR1_ACK_Reset;
+  }
+}
+
+/**
+  * @brief  Configures the specified I2C own address2.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  Address: specifies the 7bit I2C own address2.
+  * @retval None.
+  */
+void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
+{
+  uint16_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+
+  /* Get the old register value */
+  tmpreg = I2Cx->OAR2;
+
+  /* Reset I2Cx Own address2 bit [7:1] */
+  tmpreg &= OAR2_ADD2_Reset;
+
+  /* Set I2Cx Own address2 */
+  tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
+
+  /* Store the new register value */
+  I2Cx->OAR2 = tmpreg;
+}
+
+/**
+  * @brief  Enables or disables the specified I2C dual addressing mode.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  NewState: new state of the I2C dual addressing mode.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable dual addressing mode */
+    I2Cx->OAR2 |= OAR2_ENDUAL_Set;
+  }
+  else
+  {
+    /* Disable dual addressing mode */
+    I2Cx->OAR2 &= OAR2_ENDUAL_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified I2C general call feature.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  NewState: new state of the I2C General call.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable generall call */
+    I2Cx->CR1 |= CR1_ENGC_Set;
+  }
+  else
+  {
+    /* Disable generall call */
+    I2Cx->CR1 &= CR1_ENGC_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified I2C interrupts.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  I2C_IT: specifies the I2C interrupts sources to be enabled or disabled.
+  *   This parameter can be any combination of the following values:
+  *     @arg I2C_IT_BUF: Buffer interrupt mask
+  *     @arg I2C_IT_EVT: Event interrupt mask
+  *     @arg I2C_IT_ERR: Error interrupt mask
+  * @param  NewState: new state of the specified I2C interrupts.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected I2C interrupts */
+    I2Cx->CR2 |= I2C_IT;
+  }
+  else
+  {
+    /* Disable the selected I2C interrupts */
+    I2Cx->CR2 &= (uint16_t)~I2C_IT;
+  }
+}
+
+/**
+  * @brief  Sends a data byte through the I2Cx peripheral.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  Data: Byte to be transmitted..
+  * @retval None
+  */
+void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  /* Write in the DR register the data to be sent */
+  I2Cx->DR = Data;
+}
+
+/**
+  * @brief  Returns the most recent received data by the I2Cx peripheral.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @retval The value of the received data.
+  */
+uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  /* Return the data in the DR register */
+  return (uint8_t)I2Cx->DR;
+}
+
+/**
+  * @brief  Transmits the address byte to select the slave device.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  Address: specifies the slave address which will be transmitted
+  * @param  I2C_Direction: specifies whether the I2C device will be a
+  *   Transmitter or a Receiver. This parameter can be one of the following values
+  *     @arg I2C_Direction_Transmitter: Transmitter mode
+  *     @arg I2C_Direction_Receiver: Receiver mode
+  * @retval None.
+  */
+void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_DIRECTION(I2C_Direction));
+  /* Test on the direction to set/reset the read/write bit */
+  if (I2C_Direction != I2C_Direction_Transmitter)
+  {
+    /* Set the address bit0 for read */
+    Address |= OAR1_ADD0_Set;
+  }
+  else
+  {
+    /* Reset the address bit0 for write */
+    Address &= OAR1_ADD0_Reset;
+  }
+  /* Send the address */
+  I2Cx->DR = Address;
+}
+
+/**
+  * @brief  Reads the specified I2C register and returns its value.
+  * @param  I2C_Register: specifies the register to read.
+  *   This parameter can be one of the following values:
+  *     @arg I2C_Register_CR1:  CR1 register.
+  *     @arg I2C_Register_CR2:   CR2 register.
+  *     @arg I2C_Register_OAR1:  OAR1 register.
+  *     @arg I2C_Register_OAR2:  OAR2 register.
+  *     @arg I2C_Register_DR:    DR register.
+  *     @arg I2C_Register_SR1:   SR1 register.
+  *     @arg I2C_Register_SR2:   SR2 register.
+  *     @arg I2C_Register_CCR:   CCR register.
+  *     @arg I2C_Register_TRISE: TRISE register.
+  * @retval The value of the read register.
+  */
+uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
+{
+  __IO uint32_t tmp = 0;
+
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_REGISTER(I2C_Register));
+
+  tmp = (uint32_t) I2Cx;
+  tmp += I2C_Register;
+
+  /* Return the selected register value */
+  return (*(__IO uint16_t *) tmp);
+}
+
+/**
+  * @brief  Enables or disables the specified I2C software reset.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  NewState: new state of the I2C software reset.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Peripheral under reset */
+    I2Cx->CR1 |= CR1_SWRST_Set;
+  }
+  else
+  {
+    /* Peripheral not under reset */
+    I2Cx->CR1 &= CR1_SWRST_Reset;
+  }
+}
+
+/**
+  * @brief  Selects the specified I2C NACK position in master receiver mode.
+  *         This function is useful in I2C Master Receiver mode when the number
+  *         of data to be received is equal to 2. In this case, this function
+  *         should be called (with parameter I2C_NACKPosition_Next) before data
+  *         reception starts,as described in the 2-byte reception procedure
+  *         recommended in Reference Manual in Section: Master receiver.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  I2C_NACKPosition: specifies the NACK position.
+  *   This parameter can be one of the following values:
+  *     @arg I2C_NACKPosition_Next: indicates that the next byte will be the last
+  *          received byte.
+  *     @arg I2C_NACKPosition_Current: indicates that current byte is the last
+  *          received byte.
+  *
+  * @note    This function configures the same bit (POS) as I2C_PECPositionConfig()
+  *          but is intended to be used in I2C mode while I2C_PECPositionConfig()
+  *          is intended to used in SMBUS mode.
+  *
+  * @retval None
+  */
+void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
+
+  /* Check the input parameter */
+  if (I2C_NACKPosition == I2C_NACKPosition_Next)
+  {
+    /* Next byte in shift register is the last received byte */
+    I2Cx->CR1 |= I2C_NACKPosition_Next;
+  }
+  else
+  {
+    /* Current byte in shift register is the last received byte */
+    I2Cx->CR1 &= I2C_NACKPosition_Current;
+  }
+}
+
+/**
+  * @brief  Drives the SMBusAlert pin high or low for the specified I2C.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  I2C_SMBusAlert: specifies SMBAlert pin level.
+  *   This parameter can be one of the following values:
+  *     @arg I2C_SMBusAlert_Low: SMBAlert pin driven low
+  *     @arg I2C_SMBusAlert_High: SMBAlert pin driven high
+  * @retval None
+  */
+void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
+  if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
+  {
+    /* Drive the SMBusAlert pin Low */
+    I2Cx->CR1 |= I2C_SMBusAlert_Low;
+  }
+  else
+  {
+    /* Drive the SMBusAlert pin High  */
+    I2Cx->CR1 &= I2C_SMBusAlert_High;
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified I2C PEC transfer.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  NewState: new state of the I2C PEC transmission.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected I2C PEC transmission */
+    I2Cx->CR1 |= CR1_PEC_Set;
+  }
+  else
+  {
+    /* Disable the selected I2C PEC transmission */
+    I2Cx->CR1 &= CR1_PEC_Reset;
+  }
+}
+
+/**
+  * @brief  Selects the specified I2C PEC position.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  I2C_PECPosition: specifies the PEC position.
+  *   This parameter can be one of the following values:
+  *     @arg I2C_PECPosition_Next: indicates that the next byte is PEC
+  *     @arg I2C_PECPosition_Current: indicates that current byte is PEC
+  *
+  * @note    This function configures the same bit (POS) as I2C_NACKPositionConfig()
+  *          but is intended to be used in SMBUS mode while I2C_NACKPositionConfig()
+  *          is intended to used in I2C mode.
+  *
+  * @retval None
+  */
+void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
+  if (I2C_PECPosition == I2C_PECPosition_Next)
+  {
+    /* Next byte in shift register is PEC */
+    I2Cx->CR1 |= I2C_PECPosition_Next;
+  }
+  else
+  {
+    /* Current byte in shift register is PEC */
+    I2Cx->CR1 &= I2C_PECPosition_Current;
+  }
+}
+
+/**
+  * @brief  Enables or disables the PEC value calculation of the transferred bytes.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  NewState: new state of the I2Cx PEC value calculation.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected I2C PEC calculation */
+    I2Cx->CR1 |= CR1_ENPEC_Set;
+  }
+  else
+  {
+    /* Disable the selected I2C PEC calculation */
+    I2Cx->CR1 &= CR1_ENPEC_Reset;
+  }
+}
+
+/**
+  * @brief  Returns the PEC value for the specified I2C.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @retval The PEC value.
+  */
+uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  /* Return the selected I2C PEC value */
+  return ((I2Cx->SR2) >> 8);
+}
+
+/**
+  * @brief  Enables or disables the specified I2C ARP.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  NewState: new state of the I2Cx ARP.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected I2C ARP */
+    I2Cx->CR1 |= CR1_ENARP_Set;
+  }
+  else
+  {
+    /* Disable the selected I2C ARP */
+    I2Cx->CR1 &= CR1_ENARP_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified I2C Clock stretching.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  NewState: new state of the I2Cx Clock stretching.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState == DISABLE)
+  {
+    /* Enable the selected I2C Clock stretching */
+    I2Cx->CR1 |= CR1_NOSTRETCH_Set;
+  }
+  else
+  {
+    /* Disable the selected I2C Clock stretching */
+    I2Cx->CR1 &= CR1_NOSTRETCH_Reset;
+  }
+}
+
+/**
+  * @brief  Selects the specified I2C fast mode duty cycle.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  I2C_DutyCycle: specifies the fast mode duty cycle.
+  *   This parameter can be one of the following values:
+  *     @arg I2C_DutyCycle_2: I2C fast mode Tlow/Thigh = 2
+  *     @arg I2C_DutyCycle_16_9: I2C fast mode Tlow/Thigh = 16/9
+  * @retval None
+  */
+void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
+  if (I2C_DutyCycle != I2C_DutyCycle_16_9)
+  {
+    /* I2C fast mode Tlow/Thigh=2 */
+    I2Cx->CCR &= I2C_DutyCycle_2;
+  }
+  else
+  {
+    /* I2C fast mode Tlow/Thigh=16/9 */
+    I2Cx->CCR |= I2C_DutyCycle_16_9;
+  }
+}
+
+
+
+/**
+ * @brief
+ ****************************************************************************************
+ *
+ *                         I2C State Monitoring Functions
+ *
+ ****************************************************************************************
+ * This I2C driver provides three different ways for I2C state monitoring
+ *  depending on the application requirements and constraints:
+ *
+ *
+ * 1) Basic state monitoring:
+ *    Using I2C_CheckEvent() function:
+ *    It compares the status registers (SR1 and SR2) content to a given event
+ *    (can be the combination of one or more flags).
+ *    It returns SUCCESS if the current status includes the given flags
+ *    and returns ERROR if one or more flags are missing in the current status.
+ *    - When to use:
+ *      - This function is suitable for most applications as well as for startup
+ *      activity since the events are fully described in the product reference manual
+ *      (RM0008).
+ *      - It is also suitable for users who need to define their own events.
+ *    - Limitations:
+ *      - If an error occurs (ie. error flags are set besides to the monitored flags),
+ *        the I2C_CheckEvent() function may return SUCCESS despite the communication
+ *        hold or corrupted real state.
+ *        In this case, it is advised to use error interrupts to monitor the error
+ *        events and handle them in the interrupt IRQ handler.
+ *
+ *        @note
+ *        For error management, it is advised to use the following functions:
+ *          - I2C_ITConfig() to configure and enable the error interrupts (I2C_IT_ERR).
+ *          - I2Cx_ER_IRQHandler() which is called when the error interrupt occurs.
+ *            Where x is the peripheral instance (I2C1, I2C2 ...)
+ *          - I2C_GetFlagStatus() or I2C_GetITStatus() to be called into I2Cx_ER_IRQHandler()
+ *            in order to determine which error occured.
+ *          - I2C_ClearFlag() or I2C_ClearITPendingBit() and/or I2C_SoftwareResetCmd()
+ *            and/or I2C_GenerateStop() in order to clear the error flag and source,
+ *            and return to correct communication status.
+ *
+ *
+ *  2) Advanced state monitoring:
+ *     Using the function I2C_GetLastEvent() which returns the image of both status
+ *     registers in a single word (uint32_t) (Status Register 2 value is shifted left
+ *     by 16 bits and concatenated to Status Register 1).
+ *     - When to use:
+ *       - This function is suitable for the same applications above but it allows to
+ *         overcome the mentioned limitation of I2C_GetFlagStatus() function.
+ *         The returned value could be compared to events already defined in the
+ *         library (stm32f10x_i2c.h) or to custom values defined by user.
+ *       - This function is suitable when multiple flags are monitored at the same time.
+ *       - At the opposite of I2C_CheckEvent() function, this function allows user to
+ *         choose when an event is accepted (when all events flags are set and no
+ *         other flags are set or just when the needed flags are set like
+ *         I2C_CheckEvent() function).
+ *     - Limitations:
+ *       - User may need to define his own events.
+ *       - Same remark concerning the error management is applicable for this
+ *         function if user decides to check only regular communication flags (and
+ *         ignores error flags).
+ *
+ *
+ *  3) Flag-based state monitoring:
+ *     Using the function I2C_GetFlagStatus() which simply returns the status of
+ *     one single flag (ie. I2C_FLAG_RXNE ...).
+ *     - When to use:
+ *        - This function could be used for specific applications or in debug phase.
+ *        - It is suitable when only one flag checking is needed (most I2C events
+ *          are monitored through multiple flags).
+ *     - Limitations:
+ *        - When calling this function, the Status register is accessed. Some flags are
+ *          cleared when the status register is accessed. So checking the status
+ *          of one Flag, may clear other ones.
+ *        - Function may need to be called twice or more in order to monitor one
+ *          single event.
+ *
+ *  For detailed description of Events, please refer to section I2C_Events in
+ *  stm32f10x_i2c.h file.
+ *
+ */
+
+/**
+ *
+ *  1) Basic state monitoring
+ *******************************************************************************
+ */
+
+/**
+  * @brief  Checks whether the last I2Cx Event is equal to the one passed
+  *   as parameter.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  I2C_EVENT: specifies the event to be checked.
+  *   This parameter can be one of the following values:
+  *     @arg I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED           : EV1
+  *     @arg I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED              : EV1
+  *     @arg I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED     : EV1
+  *     @arg I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED        : EV1
+  *     @arg I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED            : EV1
+  *     @arg I2C_EVENT_SLAVE_BYTE_RECEIVED                         : EV2
+  *     @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF)      : EV2
+  *     @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)    : EV2
+  *     @arg I2C_EVENT_SLAVE_BYTE_TRANSMITTED                      : EV3
+  *     @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF)   : EV3
+  *     @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL) : EV3
+  *     @arg I2C_EVENT_SLAVE_ACK_FAILURE                           : EV3_2
+  *     @arg I2C_EVENT_SLAVE_STOP_DETECTED                         : EV4
+  *     @arg I2C_EVENT_MASTER_MODE_SELECT                          : EV5
+  *     @arg I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED            : EV6
+  *     @arg I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED               : EV6
+  *     @arg I2C_EVENT_MASTER_BYTE_RECEIVED                        : EV7
+  *     @arg I2C_EVENT_MASTER_BYTE_TRANSMITTING                    : EV8
+  *     @arg I2C_EVENT_MASTER_BYTE_TRANSMITTED                     : EV8_2
+  *     @arg I2C_EVENT_MASTER_MODE_ADDRESS10                       : EV9
+  *
+  * @note: For detailed description of Events, please refer to section
+  *    I2C_Events in stm32f10x_i2c.h file.
+  *
+  * @retval An ErrorStatus enumeration value:
+  * - SUCCESS: Last event is equal to the I2C_EVENT
+  * - ERROR: Last event is different from the I2C_EVENT
+  */
+ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
+{
+  uint32_t lastevent = 0;
+  uint32_t flag1 = 0, flag2 = 0;
+  ErrorStatus status = ERROR;
+
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_EVENT(I2C_EVENT));
+
+  /* Read the I2Cx status register */
+  flag1 = I2Cx->SR1;
+  flag2 = I2Cx->SR2;
+  flag2 = flag2 << 16;
+
+  /* Get the last event value from I2C status register */
+  lastevent = (flag1 | flag2) & FLAG_Mask;
+
+  /* Check whether the last event contains the I2C_EVENT */
+  if ((lastevent & I2C_EVENT) == I2C_EVENT)
+  {
+    /* SUCCESS: last event is equal to I2C_EVENT */
+    status = SUCCESS;
+  }
+  else
+  {
+    /* ERROR: last event is different from I2C_EVENT */
+    status = ERROR;
+  }
+  /* Return status */
+  return status;
+}
+
+/**
+ *
+ *  2) Advanced state monitoring
+ *******************************************************************************
+ */
+
+/**
+  * @brief  Returns the last I2Cx Event.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  *
+  * @note: For detailed description of Events, please refer to section
+  *    I2C_Events in stm32f10x_i2c.h file.
+  *
+  * @retval The last event
+  */
+uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
+{
+  uint32_t lastevent = 0;
+  uint32_t flag1 = 0, flag2 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+
+  /* Read the I2Cx status register */
+  flag1 = I2Cx->SR1;
+  flag2 = I2Cx->SR2;
+  flag2 = flag2 << 16;
+
+  /* Get the last event value from I2C status register */
+  lastevent = (flag1 | flag2) & FLAG_Mask;
+
+  /* Return status */
+  return lastevent;
+}
+
+/**
+ *
+ *  3) Flag-based state monitoring
+ *******************************************************************************
+ */
+
+/**
+  * @brief  Checks whether the specified I2C flag is set or not.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  I2C_FLAG: specifies the flag to check.
+  *   This parameter can be one of the following values:
+  *     @arg I2C_FLAG_DUALF: Dual flag (Slave mode)
+  *     @arg I2C_FLAG_SMBHOST: SMBus host header (Slave mode)
+  *     @arg I2C_FLAG_SMBDEFAULT: SMBus default header (Slave mode)
+  *     @arg I2C_FLAG_GENCALL: General call header flag (Slave mode)
+  *     @arg I2C_FLAG_TRA: Transmitter/Receiver flag
+  *     @arg I2C_FLAG_BUSY: Bus busy flag
+  *     @arg I2C_FLAG_MSL: Master/Slave flag
+  *     @arg I2C_FLAG_SMBALERT: SMBus Alert flag
+  *     @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
+  *     @arg I2C_FLAG_PECERR: PEC error in reception flag
+  *     @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
+  *     @arg I2C_FLAG_AF: Acknowledge failure flag
+  *     @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
+  *     @arg I2C_FLAG_BERR: Bus error flag
+  *     @arg I2C_FLAG_TXE: Data register empty flag (Transmitter)
+  *     @arg I2C_FLAG_RXNE: Data register not empty (Receiver) flag
+  *     @arg I2C_FLAG_STOPF: Stop detection flag (Slave mode)
+  *     @arg I2C_FLAG_ADD10: 10-bit header sent flag (Master mode)
+  *     @arg I2C_FLAG_BTF: Byte transfer finished flag
+  *     @arg I2C_FLAG_ADDR: Address sent flag (Master mode) "ADSL"
+  *   Address matched flag (Slave mode)"ENDA"
+  *     @arg I2C_FLAG_SB: Start bit flag (Master mode)
+  * @retval The new state of I2C_FLAG (SET or RESET).
+  */
+FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  __IO uint32_t i2creg = 0, i2cxbase = 0;
+
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
+
+  /* Get the I2Cx peripheral base address */
+  i2cxbase = (uint32_t)I2Cx;
+
+  /* Read flag register index */
+  i2creg = I2C_FLAG >> 28;
+
+  /* Get bit[23:0] of the flag */
+  I2C_FLAG &= FLAG_Mask;
+
+  if(i2creg != 0)
+  {
+    /* Get the I2Cx SR1 register address */
+    i2cxbase += 0x14;
+  }
+  else
+  {
+    /* Flag in I2Cx SR2 Register */
+    I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
+    /* Get the I2Cx SR2 register address */
+    i2cxbase += 0x18;
+  }
+
+  if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
+  {
+    /* I2C_FLAG is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* I2C_FLAG is reset */
+    bitstatus = RESET;
+  }
+
+  /* Return the I2C_FLAG status */
+  return  bitstatus;
+}
+
+
+
+/**
+  * @brief  Clears the I2Cx's pending flags.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  I2C_FLAG: specifies the flag to clear.
+  *   This parameter can be any combination of the following values:
+  *     @arg I2C_FLAG_SMBALERT: SMBus Alert flag
+  *     @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
+  *     @arg I2C_FLAG_PECERR: PEC error in reception flag
+  *     @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
+  *     @arg I2C_FLAG_AF: Acknowledge failure flag
+  *     @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
+  *     @arg I2C_FLAG_BERR: Bus error flag
+  *
+  * @note
+  *   - STOPF (STOP detection) is cleared by software sequence: a read operation
+  *     to I2C_SR1 register (I2C_GetFlagStatus()) followed by a write operation
+  *     to I2C_CR1 register (I2C_Cmd() to re-enable the I2C peripheral).
+  *   - ADD10 (10-bit header sent) is cleared by software sequence: a read
+  *     operation to I2C_SR1 (I2C_GetFlagStatus()) followed by writing the
+  *     second byte of the address in DR register.
+  *   - BTF (Byte Transfer Finished) is cleared by software sequence: a read
+  *     operation to I2C_SR1 register (I2C_GetFlagStatus()) followed by a
+  *     read/write to I2C_DR register (I2C_SendData()).
+  *   - ADDR (Address sent) is cleared by software sequence: a read operation to
+  *     I2C_SR1 register (I2C_GetFlagStatus()) followed by a read operation to
+  *     I2C_SR2 register ((void)(I2Cx->SR2)).
+  *   - SB (Start Bit) is cleared software sequence: a read operation to I2C_SR1
+  *     register (I2C_GetFlagStatus()) followed by a write operation to I2C_DR
+  *     register  (I2C_SendData()).
+  * @retval None
+  */
+void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
+{
+  uint32_t flagpos = 0;
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
+  /* Get the I2C flag position */
+  flagpos = I2C_FLAG & FLAG_Mask;
+  /* Clear the selected I2C flag */
+  I2Cx->SR1 = (uint16_t)~flagpos;
+}
+
+/**
+  * @brief  Checks whether the specified I2C interrupt has occurred or not.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  I2C_IT: specifies the interrupt source to check.
+  *   This parameter can be one of the following values:
+  *     @arg I2C_IT_SMBALERT: SMBus Alert flag
+  *     @arg I2C_IT_TIMEOUT: Timeout or Tlow error flag
+  *     @arg I2C_IT_PECERR: PEC error in reception flag
+  *     @arg I2C_IT_OVR: Overrun/Underrun flag (Slave mode)
+  *     @arg I2C_IT_AF: Acknowledge failure flag
+  *     @arg I2C_IT_ARLO: Arbitration lost flag (Master mode)
+  *     @arg I2C_IT_BERR: Bus error flag
+  *     @arg I2C_IT_TXE: Data register empty flag (Transmitter)
+  *     @arg I2C_IT_RXNE: Data register not empty (Receiver) flag
+  *     @arg I2C_IT_STOPF: Stop detection flag (Slave mode)
+  *     @arg I2C_IT_ADD10: 10-bit header sent flag (Master mode)
+  *     @arg I2C_IT_BTF: Byte transfer finished flag
+  *     @arg I2C_IT_ADDR: Address sent flag (Master mode) "ADSL"
+  *                       Address matched flag (Slave mode)"ENDAD"
+  *     @arg I2C_IT_SB: Start bit flag (Master mode)
+  * @retval The new state of I2C_IT (SET or RESET).
+  */
+ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
+{
+  ITStatus bitstatus = RESET;
+  uint32_t enablestatus = 0;
+
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_GET_IT(I2C_IT));
+
+  /* Check if the interrupt source is enabled or not */
+  enablestatus = (uint32_t)(((I2C_IT & ITEN_Mask) >> 16) & (I2Cx->CR2)) ;
+
+  /* Get bit[23:0] of the flag */
+  I2C_IT &= FLAG_Mask;
+
+  /* Check the status of the specified I2C flag */
+  if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
+  {
+    /* I2C_IT is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* I2C_IT is reset */
+    bitstatus = RESET;
+  }
+  /* Return the I2C_IT status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the I2Cxs interrupt pending bits.
+  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+  * @param  I2C_IT: specifies the interrupt pending bit to clear.
+  *   This parameter can be any combination of the following values:
+  *     @arg I2C_IT_SMBALERT: SMBus Alert interrupt
+  *     @arg I2C_IT_TIMEOUT: Timeout or Tlow error interrupt
+  *     @arg I2C_IT_PECERR: PEC error in reception  interrupt
+  *     @arg I2C_IT_OVR: Overrun/Underrun interrupt (Slave mode)
+  *     @arg I2C_IT_AF: Acknowledge failure interrupt
+  *     @arg I2C_IT_ARLO: Arbitration lost interrupt (Master mode)
+  *     @arg I2C_IT_BERR: Bus error interrupt
+  *
+  * @note
+  *   - STOPF (STOP detection) is cleared by software sequence: a read operation
+  *     to I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to
+  *     I2C_CR1 register (I2C_Cmd() to re-enable the I2C peripheral).
+  *   - ADD10 (10-bit header sent) is cleared by software sequence: a read
+  *     operation to I2C_SR1 (I2C_GetITStatus()) followed by writing the second
+  *     byte of the address in I2C_DR register.
+  *   - BTF (Byte Transfer Finished) is cleared by software sequence: a read
+  *     operation to I2C_SR1 register (I2C_GetITStatus()) followed by a
+  *     read/write to I2C_DR register (I2C_SendData()).
+  *   - ADDR (Address sent) is cleared by software sequence: a read operation to
+  *     I2C_SR1 register (I2C_GetITStatus()) followed by a read operation to
+  *     I2C_SR2 register ((void)(I2Cx->SR2)).
+  *   - SB (Start Bit) is cleared by software sequence: a read operation to
+  *     I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to
+  *     I2C_DR register (I2C_SendData()).
+  * @retval None
+  */
+void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
+{
+  uint32_t flagpos = 0;
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_CLEAR_IT(I2C_IT));
+  /* Get the I2C flag position */
+  flagpos = I2C_IT & FLAG_Mask;
+  /* Clear the selected I2C flag */
+  I2Cx->SR1 = (uint16_t)~flagpos;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_iwdg.c b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_iwdg.c
new file mode 100644
index 0000000..9d3b0e8
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_iwdg.c
@@ -0,0 +1,190 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_iwdg.c
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file provides all the IWDG firmware functions.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x_iwdg.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup IWDG
+  * @brief IWDG driver modules
+  * @{
+  */
+
+/** @defgroup IWDG_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup IWDG_Private_Defines
+  * @{
+  */
+
+/* ---------------------- IWDG registers bit mask ----------------------------*/
+
+/* KR register bit mask */
+#define KR_KEY_Reload    ((uint16_t)0xAAAA)
+#define KR_KEY_Enable    ((uint16_t)0xCCCC)
+
+/**
+  * @}
+  */
+
+/** @defgroup IWDG_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup IWDG_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup IWDG_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup IWDG_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables write access to IWDG_PR and IWDG_RLR registers.
+  * @param  IWDG_WriteAccess: new state of write access to IWDG_PR and IWDG_RLR registers.
+  *   This parameter can be one of the following values:
+  *     @arg IWDG_WriteAccess_Enable: Enable write access to IWDG_PR and IWDG_RLR registers
+  *     @arg IWDG_WriteAccess_Disable: Disable write access to IWDG_PR and IWDG_RLR registers
+  * @retval None
+  */
+void IWDG_WriteAccessCmd(uint16_t IWDG_WriteAccess)
+{
+  /* Check the parameters */
+  assert_param(IS_IWDG_WRITE_ACCESS(IWDG_WriteAccess));
+  IWDG->KR = IWDG_WriteAccess;
+}
+
+/**
+  * @brief  Sets IWDG Prescaler value.
+  * @param  IWDG_Prescaler: specifies the IWDG Prescaler value.
+  *   This parameter can be one of the following values:
+  *     @arg IWDG_Prescaler_4: IWDG prescaler set to 4
+  *     @arg IWDG_Prescaler_8: IWDG prescaler set to 8
+  *     @arg IWDG_Prescaler_16: IWDG prescaler set to 16
+  *     @arg IWDG_Prescaler_32: IWDG prescaler set to 32
+  *     @arg IWDG_Prescaler_64: IWDG prescaler set to 64
+  *     @arg IWDG_Prescaler_128: IWDG prescaler set to 128
+  *     @arg IWDG_Prescaler_256: IWDG prescaler set to 256
+  * @retval None
+  */
+void IWDG_SetPrescaler(uint8_t IWDG_Prescaler)
+{
+  /* Check the parameters */
+  assert_param(IS_IWDG_PRESCALER(IWDG_Prescaler));
+  IWDG->PR = IWDG_Prescaler;
+}
+
+/**
+  * @brief  Sets IWDG Reload value.
+  * @param  Reload: specifies the IWDG Reload value.
+  *   This parameter must be a number between 0 and 0x0FFF.
+  * @retval None
+  */
+void IWDG_SetReload(uint16_t Reload)
+{
+  /* Check the parameters */
+  assert_param(IS_IWDG_RELOAD(Reload));
+  IWDG->RLR = Reload;
+}
+
+/**
+  * @brief  Reloads IWDG counter with value defined in the reload register
+  *   (write access to IWDG_PR and IWDG_RLR registers disabled).
+  * @param  None
+  * @retval None
+  */
+void IWDG_ReloadCounter(void)
+{
+  IWDG->KR = KR_KEY_Reload;
+}
+
+/**
+  * @brief  Enables IWDG (write access to IWDG_PR and IWDG_RLR registers disabled).
+  * @param  None
+  * @retval None
+  */
+void IWDG_Enable(void)
+{
+  IWDG->KR = KR_KEY_Enable;
+}
+
+/**
+  * @brief  Checks whether the specified IWDG flag is set or not.
+  * @param  IWDG_FLAG: specifies the flag to check.
+  *   This parameter can be one of the following values:
+  *     @arg IWDG_FLAG_PVU: Prescaler Value Update on going
+  *     @arg IWDG_FLAG_RVU: Reload Value Update on going
+  * @retval The new state of IWDG_FLAG (SET or RESET).
+  */
+FlagStatus IWDG_GetFlagStatus(uint16_t IWDG_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_IWDG_FLAG(IWDG_FLAG));
+  if ((IWDG->SR & IWDG_FLAG) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  /* Return the flag status */
+  return bitstatus;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_pwr.c b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_pwr.c
new file mode 100644
index 0000000..147bf0f
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_pwr.c
@@ -0,0 +1,307 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_pwr.c
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file provides all the PWR firmware functions.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x_pwr.h"
+#include "stm32f10x_rcc.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup PWR
+  * @brief PWR driver modules
+  * @{
+  */
+
+/** @defgroup PWR_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup PWR_Private_Defines
+  * @{
+  */
+
+/* --------- PWR registers bit address in the alias region ---------- */
+#define PWR_OFFSET               (PWR_BASE - PERIPH_BASE)
+
+/* --- CR Register ---*/
+
+/* Alias word address of DBP bit */
+#define CR_OFFSET                (PWR_OFFSET + 0x00)
+#define DBP_BitNumber            0x08
+#define CR_DBP_BB                (PERIPH_BB_BASE + (CR_OFFSET * 32) + (DBP_BitNumber * 4))
+
+/* Alias word address of PVDE bit */
+#define PVDE_BitNumber           0x04
+#define CR_PVDE_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PVDE_BitNumber * 4))
+
+/* --- CSR Register ---*/
+
+/* Alias word address of EWUP bit */
+#define CSR_OFFSET               (PWR_OFFSET + 0x04)
+#define EWUP_BitNumber           0x08
+#define CSR_EWUP_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (EWUP_BitNumber * 4))
+
+/* ------------------ PWR registers bit mask ------------------------ */
+
+/* CR register bit mask */
+#define CR_DS_MASK               ((uint32_t)0xFFFFFFFC)
+#define CR_PLS_MASK              ((uint32_t)0xFFFFFF1F)
+
+
+/**
+  * @}
+  */
+
+/** @defgroup PWR_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup PWR_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup PWR_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup PWR_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the PWR peripheral registers to their default reset values.
+  * @param  None
+  * @retval None
+  */
+void PWR_DeInit(void)
+{
+  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
+  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
+}
+
+/**
+  * @brief  Enables or disables access to the RTC and backup registers.
+  * @param  NewState: new state of the access to the RTC and backup registers.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void PWR_BackupAccessCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Enables or disables the Power Voltage Detector(PVD).
+  * @param  NewState: new state of the PVD.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void PWR_PVDCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Configures the voltage threshold detected by the Power Voltage Detector(PVD).
+  * @param  PWR_PVDLevel: specifies the PVD detection level
+  *   This parameter can be one of the following values:
+  *     @arg PWR_PVDLevel_2V2: PVD detection level set to 2.2V
+  *     @arg PWR_PVDLevel_2V3: PVD detection level set to 2.3V
+  *     @arg PWR_PVDLevel_2V4: PVD detection level set to 2.4V
+  *     @arg PWR_PVDLevel_2V5: PVD detection level set to 2.5V
+  *     @arg PWR_PVDLevel_2V6: PVD detection level set to 2.6V
+  *     @arg PWR_PVDLevel_2V7: PVD detection level set to 2.7V
+  *     @arg PWR_PVDLevel_2V8: PVD detection level set to 2.8V
+  *     @arg PWR_PVDLevel_2V9: PVD detection level set to 2.9V
+  * @retval None
+  */
+void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel)
+{
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
+  tmpreg = PWR->CR;
+  /* Clear PLS[7:5] bits */
+  tmpreg &= CR_PLS_MASK;
+  /* Set PLS[7:5] bits according to PWR_PVDLevel value */
+  tmpreg |= PWR_PVDLevel;
+  /* Store the new value */
+  PWR->CR = tmpreg;
+}
+
+/**
+  * @brief  Enables or disables the WakeUp Pin functionality.
+  * @param  NewState: new state of the WakeUp Pin functionality.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void PWR_WakeUpPinCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  *(__IO uint32_t *) CSR_EWUP_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Enters STOP mode.
+  * @param  PWR_Regulator: specifies the regulator state in STOP mode.
+  *   This parameter can be one of the following values:
+  *     @arg PWR_Regulator_ON: STOP mode with regulator ON
+  *     @arg PWR_Regulator_LowPower: STOP mode with regulator in low power mode
+  * @param  PWR_STOPEntry: specifies if STOP mode in entered with WFI or WFE instruction.
+  *   This parameter can be one of the following values:
+  *     @arg PWR_STOPEntry_WFI: enter STOP mode with WFI instruction
+  *     @arg PWR_STOPEntry_WFE: enter STOP mode with WFE instruction
+  * @retval None
+  */
+void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
+{
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_PWR_REGULATOR(PWR_Regulator));
+  assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
+
+  /* Select the regulator state in STOP mode ---------------------------------*/
+  tmpreg = PWR->CR;
+  /* Clear PDDS and LPDS bits */
+  tmpreg &= CR_DS_MASK;
+  /* Set LPDS bit according to PWR_Regulator value */
+  tmpreg |= PWR_Regulator;
+  /* Store the new value */
+  PWR->CR = tmpreg;
+  /* Set SLEEPDEEP bit of Cortex System Control Register */
+  SCB->SCR |= SCB_SCR_SLEEPDEEP;
+
+  /* Select STOP mode entry --------------------------------------------------*/
+  if(PWR_STOPEntry == PWR_STOPEntry_WFI)
+  {
+    /* Request Wait For Interrupt */
+    __WFI();
+  }
+  else
+  {
+    /* Request Wait For Event */
+    __WFE();
+  }
+
+  /* Reset SLEEPDEEP bit of Cortex System Control Register */
+  SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP);
+}
+
+/**
+  * @brief  Enters STANDBY mode.
+  * @param  None
+  * @retval None
+  */
+void PWR_EnterSTANDBYMode(void)
+{
+  /* Clear Wake-up flag */
+  PWR->CR |= PWR_CR_CWUF;
+  /* Select STANDBY mode */
+  PWR->CR |= PWR_CR_PDDS;
+  /* Set SLEEPDEEP bit of Cortex System Control Register */
+  SCB->SCR |= SCB_SCR_SLEEPDEEP;
+/* This option is used to ensure that store operations are completed */
+#if defined ( __CC_ARM   )
+  __force_stores();
+#endif
+  /* Request Wait For Interrupt */
+  __WFI();
+}
+
+/**
+  * @brief  Checks whether the specified PWR flag is set or not.
+  * @param  PWR_FLAG: specifies the flag to check.
+  *   This parameter can be one of the following values:
+  *     @arg PWR_FLAG_WU: Wake Up flag
+  *     @arg PWR_FLAG_SB: StandBy flag
+  *     @arg PWR_FLAG_PVDO: PVD Output
+  * @retval The new state of PWR_FLAG (SET or RESET).
+  */
+FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
+
+  if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  /* Return the flag status */
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the PWR's pending flags.
+  * @param  PWR_FLAG: specifies the flag to clear.
+  *   This parameter can be one of the following values:
+  *     @arg PWR_FLAG_WU: Wake Up flag
+  *     @arg PWR_FLAG_SB: StandBy flag
+  * @retval None
+  */
+void PWR_ClearFlag(uint32_t PWR_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
+
+  PWR->CR |=  PWR_FLAG << 2;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_rcc.c b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_rcc.c
new file mode 100644
index 0000000..4b2ec1f
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_rcc.c
@@ -0,0 +1,1470 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_rcc.c
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file provides all the RCC firmware functions.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x_rcc.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup RCC
+  * @brief RCC driver modules
+  * @{
+  */
+
+/** @defgroup RCC_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup RCC_Private_Defines
+  * @{
+  */
+
+/* ------------ RCC registers bit address in the alias region ----------- */
+#define RCC_OFFSET                (RCC_BASE - PERIPH_BASE)
+
+/* --- CR Register ---*/
+
+/* Alias word address of HSION bit */
+#define CR_OFFSET                 (RCC_OFFSET + 0x00)
+#define HSION_BitNumber           0x00
+#define CR_HSION_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (HSION_BitNumber * 4))
+
+/* Alias word address of PLLON bit */
+#define PLLON_BitNumber           0x18
+#define CR_PLLON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLLON_BitNumber * 4))
+
+#ifdef STM32F10X_CL
+ /* Alias word address of PLL2ON bit */
+ #define PLL2ON_BitNumber          0x1A
+ #define CR_PLL2ON_BB              (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLL2ON_BitNumber * 4))
+
+ /* Alias word address of PLL3ON bit */
+ #define PLL3ON_BitNumber          0x1C
+ #define CR_PLL3ON_BB              (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLL3ON_BitNumber * 4))
+#endif /* STM32F10X_CL */
+
+/* Alias word address of CSSON bit */
+#define CSSON_BitNumber           0x13
+#define CR_CSSON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (CSSON_BitNumber * 4))
+
+/* --- CFGR Register ---*/
+
+/* Alias word address of USBPRE bit */
+#define CFGR_OFFSET               (RCC_OFFSET + 0x04)
+
+#ifndef STM32F10X_CL
+ #define USBPRE_BitNumber          0x16
+ #define CFGR_USBPRE_BB            (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (USBPRE_BitNumber * 4))
+#else
+ #define OTGFSPRE_BitNumber        0x16
+ #define CFGR_OTGFSPRE_BB          (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (OTGFSPRE_BitNumber * 4))
+#endif /* STM32F10X_CL */
+
+/* --- BDCR Register ---*/
+
+/* Alias word address of RTCEN bit */
+#define BDCR_OFFSET               (RCC_OFFSET + 0x20)
+#define RTCEN_BitNumber           0x0F
+#define BDCR_RTCEN_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (RTCEN_BitNumber * 4))
+
+/* Alias word address of BDRST bit */
+#define BDRST_BitNumber           0x10
+#define BDCR_BDRST_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (BDRST_BitNumber * 4))
+
+/* --- CSR Register ---*/
+
+/* Alias word address of LSION bit */
+#define CSR_OFFSET                (RCC_OFFSET + 0x24)
+#define LSION_BitNumber           0x00
+#define CSR_LSION_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (LSION_BitNumber * 4))
+
+#ifdef STM32F10X_CL
+/* --- CFGR2 Register ---*/
+
+ /* Alias word address of I2S2SRC bit */
+ #define CFGR2_OFFSET              (RCC_OFFSET + 0x2C)
+ #define I2S2SRC_BitNumber         0x11
+ #define CFGR2_I2S2SRC_BB          (PERIPH_BB_BASE + (CFGR2_OFFSET * 32) + (I2S2SRC_BitNumber * 4))
+
+ /* Alias word address of I2S3SRC bit */
+ #define I2S3SRC_BitNumber         0x12
+ #define CFGR2_I2S3SRC_BB          (PERIPH_BB_BASE + (CFGR2_OFFSET * 32) + (I2S3SRC_BitNumber * 4))
+#endif /* STM32F10X_CL */
+
+/* ---------------------- RCC registers bit mask ------------------------ */
+
+/* CR register bit mask */
+#define CR_HSEBYP_Reset           ((uint32_t)0xFFFBFFFF)
+#define CR_HSEBYP_Set             ((uint32_t)0x00040000)
+#define CR_HSEON_Reset            ((uint32_t)0xFFFEFFFF)
+#define CR_HSEON_Set              ((uint32_t)0x00010000)
+#define CR_HSITRIM_Mask           ((uint32_t)0xFFFFFF07)
+
+/* CFGR register bit mask */
+#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL) || defined (STM32F10X_CL)
+ #define CFGR_PLL_Mask            ((uint32_t)0xFFC2FFFF)
+#else
+ #define CFGR_PLL_Mask            ((uint32_t)0xFFC0FFFF)
+#endif /* STM32F10X_CL */
+
+#define CFGR_PLLMull_Mask         ((uint32_t)0x003C0000)
+#define CFGR_PLLSRC_Mask          ((uint32_t)0x00010000)
+#define CFGR_PLLXTPRE_Mask        ((uint32_t)0x00020000)
+#define CFGR_SWS_Mask             ((uint32_t)0x0000000C)
+#define CFGR_SW_Mask              ((uint32_t)0xFFFFFFFC)
+#define CFGR_HPRE_Reset_Mask      ((uint32_t)0xFFFFFF0F)
+#define CFGR_HPRE_Set_Mask        ((uint32_t)0x000000F0)
+#define CFGR_PPRE1_Reset_Mask     ((uint32_t)0xFFFFF8FF)
+#define CFGR_PPRE1_Set_Mask       ((uint32_t)0x00000700)
+#define CFGR_PPRE2_Reset_Mask     ((uint32_t)0xFFFFC7FF)
+#define CFGR_PPRE2_Set_Mask       ((uint32_t)0x00003800)
+#define CFGR_ADCPRE_Reset_Mask    ((uint32_t)0xFFFF3FFF)
+#define CFGR_ADCPRE_Set_Mask      ((uint32_t)0x0000C000)
+
+/* CSR register bit mask */
+#define CSR_RMVF_Set              ((uint32_t)0x01000000)
+
+#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL) || defined (STM32F10X_CL)
+/* CFGR2 register bit mask */
+ #define CFGR2_PREDIV1SRC         ((uint32_t)0x00010000)
+ #define CFGR2_PREDIV1            ((uint32_t)0x0000000F)
+#endif
+#ifdef STM32F10X_CL
+ #define CFGR2_PREDIV2            ((uint32_t)0x000000F0)
+ #define CFGR2_PLL2MUL            ((uint32_t)0x00000F00)
+ #define CFGR2_PLL3MUL            ((uint32_t)0x0000F000)
+#endif /* STM32F10X_CL */
+
+/* RCC Flag Mask */
+#define FLAG_Mask                 ((uint8_t)0x1F)
+
+/* CIR register byte 2 (Bits[15:8]) base address */
+#define CIR_BYTE2_ADDRESS         ((uint32_t)0x40021009)
+
+/* CIR register byte 3 (Bits[23:16]) base address */
+#define CIR_BYTE3_ADDRESS         ((uint32_t)0x4002100A)
+
+/* CFGR register byte 4 (Bits[31:24]) base address */
+#define CFGR_BYTE4_ADDRESS        ((uint32_t)0x40021007)
+
+/* BDCR register base address */
+#define BDCR_ADDRESS              (PERIPH_BASE + BDCR_OFFSET)
+
+/**
+  * @}
+  */
+
+/** @defgroup RCC_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup RCC_Private_Variables
+  * @{
+  */
+
+static __I uint8_t APBAHBPrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};
+static __I uint8_t ADCPrescTable[4] = {2, 4, 6, 8};
+
+/**
+  * @}
+  */
+
+/** @defgroup RCC_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup RCC_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Resets the RCC clock configuration to the default reset state.
+  * @param  None
+  * @retval None
+  */
+void RCC_DeInit(void)
+{
+  /* Set HSION bit */
+  RCC->CR |= (uint32_t)0x00000001;
+
+  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
+#ifndef STM32F10X_CL
+  RCC->CFGR &= (uint32_t)0xF8FF0000;
+#else
+  RCC->CFGR &= (uint32_t)0xF0FF0000;
+#endif /* STM32F10X_CL */
+
+  /* Reset HSEON, CSSON and PLLON bits */
+  RCC->CR &= (uint32_t)0xFEF6FFFF;
+
+  /* Reset HSEBYP bit */
+  RCC->CR &= (uint32_t)0xFFFBFFFF;
+
+  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
+  RCC->CFGR &= (uint32_t)0xFF80FFFF;
+
+#ifdef STM32F10X_CL
+  /* Reset PLL2ON and PLL3ON bits */
+  RCC->CR &= (uint32_t)0xEBFFFFFF;
+
+  /* Disable all interrupts and clear pending bits  */
+  RCC->CIR = 0x00FF0000;
+
+  /* Reset CFGR2 register */
+  RCC->CFGR2 = 0x00000000;
+#elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
+  /* Disable all interrupts and clear pending bits  */
+  RCC->CIR = 0x009F0000;
+
+  /* Reset CFGR2 register */
+  RCC->CFGR2 = 0x00000000;
+#else
+  /* Disable all interrupts and clear pending bits  */
+  RCC->CIR = 0x009F0000;
+#endif /* STM32F10X_CL */
+
+}
+
+/**
+  * @brief  Configures the External High Speed oscillator (HSE).
+  * @note   HSE can not be stopped if it is used directly or through the PLL as system clock.
+  * @param  RCC_HSE: specifies the new state of the HSE.
+  *   This parameter can be one of the following values:
+  *     @arg RCC_HSE_OFF: HSE oscillator OFF
+  *     @arg RCC_HSE_ON: HSE oscillator ON
+  *     @arg RCC_HSE_Bypass: HSE oscillator bypassed with external clock
+  * @retval None
+  */
+void RCC_HSEConfig(uint32_t RCC_HSE)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_HSE(RCC_HSE));
+  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
+  /* Reset HSEON bit */
+  RCC->CR &= CR_HSEON_Reset;
+  /* Reset HSEBYP bit */
+  RCC->CR &= CR_HSEBYP_Reset;
+  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
+  switch(RCC_HSE)
+  {
+    case RCC_HSE_ON:
+      /* Set HSEON bit */
+      RCC->CR |= CR_HSEON_Set;
+      break;
+
+    case RCC_HSE_Bypass:
+      /* Set HSEBYP and HSEON bits */
+      RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
+      break;
+
+    default:
+      break;
+  }
+}
+
+/**
+  * @brief  Waits for HSE start-up.
+  * @param  None
+  * @retval An ErrorStatus enumuration value:
+  * - SUCCESS: HSE oscillator is stable and ready to use
+  * - ERROR: HSE oscillator not yet ready
+  */
+ErrorStatus RCC_WaitForHSEStartUp(void)
+{
+  __IO uint32_t StartUpCounter = 0;
+  ErrorStatus status = ERROR;
+  FlagStatus HSEStatus = RESET;
+
+  /* Wait till HSE is ready and if Time out is reached exit */
+  do
+  {
+    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
+    StartUpCounter++;
+  } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
+
+  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
+  {
+    status = SUCCESS;
+  }
+  else
+  {
+    status = ERROR;
+  }
+  return (status);
+}
+
+/**
+  * @brief  Adjusts the Internal High Speed oscillator (HSI) calibration value.
+  * @param  HSICalibrationValue: specifies the calibration trimming value.
+  *   This parameter must be a number between 0 and 0x1F.
+  * @retval None
+  */
+void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
+{
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
+  tmpreg = RCC->CR;
+  /* Clear HSITRIM[4:0] bits */
+  tmpreg &= CR_HSITRIM_Mask;
+  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
+  tmpreg |= (uint32_t)HSICalibrationValue << 3;
+  /* Store the new value */
+  RCC->CR = tmpreg;
+}
+
+/**
+  * @brief  Enables or disables the Internal High Speed oscillator (HSI).
+  * @note   HSI can not be stopped if it is used directly or through the PLL as system clock.
+  * @param  NewState: new state of the HSI. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_HSICmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Configures the PLL clock source and multiplication factor.
+  * @note   This function must be used only when the PLL is disabled.
+  * @param  RCC_PLLSource: specifies the PLL entry clock source.
+  *   For @b STM32_Connectivity_line_devices or @b STM32_Value_line_devices,
+  *   this parameter can be one of the following values:
+  *     @arg RCC_PLLSource_HSI_Div2: HSI oscillator clock divided by 2 selected as PLL clock entry
+  *     @arg RCC_PLLSource_PREDIV1: PREDIV1 clock selected as PLL clock entry
+  *   For @b other_STM32_devices, this parameter can be one of the following values:
+  *     @arg RCC_PLLSource_HSI_Div2: HSI oscillator clock divided by 2 selected as PLL clock entry
+  *     @arg RCC_PLLSource_HSE_Div1: HSE oscillator clock selected as PLL clock entry
+  *     @arg RCC_PLLSource_HSE_Div2: HSE oscillator clock divided by 2 selected as PLL clock entry
+  * @param  RCC_PLLMul: specifies the PLL multiplication factor.
+  *   For @b STM32_Connectivity_line_devices, this parameter can be RCC_PLLMul_x where x:{[4,9], 6_5}
+  *   For @b other_STM32_devices, this parameter can be RCC_PLLMul_x where x:[2,16]
+  * @retval None
+  */
+void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
+{
+  uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
+  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
+
+  tmpreg = RCC->CFGR;
+  /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
+  tmpreg &= CFGR_PLL_Mask;
+  /* Set the PLL configuration bits */
+  tmpreg |= RCC_PLLSource | RCC_PLLMul;
+  /* Store the new value */
+  RCC->CFGR = tmpreg;
+}
+
+/**
+  * @brief  Enables or disables the PLL.
+  * @note   The PLL can not be disabled if it is used as system clock.
+  * @param  NewState: new state of the PLL. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_PLLCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
+}
+
+#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL) || defined (STM32F10X_CL)
+/**
+  * @brief  Configures the PREDIV1 division factor.
+  * @note
+  *   - This function must be used only when the PLL is disabled.
+  *   - This function applies only to STM32 Connectivity line and Value line
+  *     devices.
+  * @param  RCC_PREDIV1_Source: specifies the PREDIV1 clock source.
+  *   This parameter can be one of the following values:
+  *     @arg RCC_PREDIV1_Source_HSE: HSE selected as PREDIV1 clock
+  *     @arg RCC_PREDIV1_Source_PLL2: PLL2 selected as PREDIV1 clock
+  * @note
+  *   For @b STM32_Value_line_devices this parameter is always RCC_PREDIV1_Source_HSE
+  * @param  RCC_PREDIV1_Div: specifies the PREDIV1 clock division factor.
+  *   This parameter can be RCC_PREDIV1_Divx where x:[1,16]
+  * @retval None
+  */
+void RCC_PREDIV1Config(uint32_t RCC_PREDIV1_Source, uint32_t RCC_PREDIV1_Div)
+{
+  uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_RCC_PREDIV1_SOURCE(RCC_PREDIV1_Source));
+  assert_param(IS_RCC_PREDIV1(RCC_PREDIV1_Div));
+
+  tmpreg = RCC->CFGR2;
+  /* Clear PREDIV1[3:0] and PREDIV1SRC bits */
+  tmpreg &= ~(CFGR2_PREDIV1 | CFGR2_PREDIV1SRC);
+  /* Set the PREDIV1 clock source and division factor */
+  tmpreg |= RCC_PREDIV1_Source | RCC_PREDIV1_Div ;
+  /* Store the new value */
+  RCC->CFGR2 = tmpreg;
+}
+#endif
+
+#ifdef STM32F10X_CL
+/**
+  * @brief  Configures the PREDIV2 division factor.
+  * @note
+  *   - This function must be used only when both PLL2 and PLL3 are disabled.
+  *   - This function applies only to STM32 Connectivity line devices.
+  * @param  RCC_PREDIV2_Div: specifies the PREDIV2 clock division factor.
+  *   This parameter can be RCC_PREDIV2_Divx where x:[1,16]
+  * @retval None
+  */
+void RCC_PREDIV2Config(uint32_t RCC_PREDIV2_Div)
+{
+  uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_RCC_PREDIV2(RCC_PREDIV2_Div));
+
+  tmpreg = RCC->CFGR2;
+  /* Clear PREDIV2[3:0] bits */
+  tmpreg &= ~CFGR2_PREDIV2;
+  /* Set the PREDIV2 division factor */
+  tmpreg |= RCC_PREDIV2_Div;
+  /* Store the new value */
+  RCC->CFGR2 = tmpreg;
+}
+
+/**
+  * @brief  Configures the PLL2 multiplication factor.
+  * @note
+  *   - This function must be used only when the PLL2 is disabled.
+  *   - This function applies only to STM32 Connectivity line devices.
+  * @param  RCC_PLL2Mul: specifies the PLL2 multiplication factor.
+  *   This parameter can be RCC_PLL2Mul_x where x:{[8,14], 16, 20}
+  * @retval None
+  */
+void RCC_PLL2Config(uint32_t RCC_PLL2Mul)
+{
+  uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_RCC_PLL2_MUL(RCC_PLL2Mul));
+
+  tmpreg = RCC->CFGR2;
+  /* Clear PLL2Mul[3:0] bits */
+  tmpreg &= ~CFGR2_PLL2MUL;
+  /* Set the PLL2 configuration bits */
+  tmpreg |= RCC_PLL2Mul;
+  /* Store the new value */
+  RCC->CFGR2 = tmpreg;
+}
+
+
+/**
+  * @brief  Enables or disables the PLL2.
+  * @note
+  *   - The PLL2 can not be disabled if it is used indirectly as system clock
+  *     (i.e. it is used as PLL clock entry that is used as System clock).
+  *   - This function applies only to STM32 Connectivity line devices.
+  * @param  NewState: new state of the PLL2. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_PLL2Cmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(__IO uint32_t *) CR_PLL2ON_BB = (uint32_t)NewState;
+}
+
+
+/**
+  * @brief  Configures the PLL3 multiplication factor.
+  * @note
+  *   - This function must be used only when the PLL3 is disabled.
+  *   - This function applies only to STM32 Connectivity line devices.
+  * @param  RCC_PLL3Mul: specifies the PLL3 multiplication factor.
+  *   This parameter can be RCC_PLL3Mul_x where x:{[8,14], 16, 20}
+  * @retval None
+  */
+void RCC_PLL3Config(uint32_t RCC_PLL3Mul)
+{
+  uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_RCC_PLL3_MUL(RCC_PLL3Mul));
+
+  tmpreg = RCC->CFGR2;
+  /* Clear PLL3Mul[3:0] bits */
+  tmpreg &= ~CFGR2_PLL3MUL;
+  /* Set the PLL3 configuration bits */
+  tmpreg |= RCC_PLL3Mul;
+  /* Store the new value */
+  RCC->CFGR2 = tmpreg;
+}
+
+
+/**
+  * @brief  Enables or disables the PLL3.
+  * @note   This function applies only to STM32 Connectivity line devices.
+  * @param  NewState: new state of the PLL3. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_PLL3Cmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  *(__IO uint32_t *) CR_PLL3ON_BB = (uint32_t)NewState;
+}
+#endif /* STM32F10X_CL */
+
+/**
+  * @brief  Configures the system clock (SYSCLK).
+  * @param  RCC_SYSCLKSource: specifies the clock source used as system clock.
+  *   This parameter can be one of the following values:
+  *     @arg RCC_SYSCLKSource_HSI: HSI selected as system clock
+  *     @arg RCC_SYSCLKSource_HSE: HSE selected as system clock
+  *     @arg RCC_SYSCLKSource_PLLCLK: PLL selected as system clock
+  * @retval None
+  */
+void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
+{
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
+  tmpreg = RCC->CFGR;
+  /* Clear SW[1:0] bits */
+  tmpreg &= CFGR_SW_Mask;
+  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
+  tmpreg |= RCC_SYSCLKSource;
+  /* Store the new value */
+  RCC->CFGR = tmpreg;
+}
+
+/**
+  * @brief  Returns the clock source used as system clock.
+  * @param  None
+  * @retval The clock source used as system clock. The returned value can
+  *   be one of the following:
+  *     - 0x00: HSI used as system clock
+  *     - 0x04: HSE used as system clock
+  *     - 0x08: PLL used as system clock
+  */
+uint8_t RCC_GetSYSCLKSource(void)
+{
+  return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
+}
+
+/**
+  * @brief  Configures the AHB clock (HCLK).
+  * @param  RCC_SYSCLK: defines the AHB clock divider. This clock is derived from
+  *   the system clock (SYSCLK).
+  *   This parameter can be one of the following values:
+  *     @arg RCC_SYSCLK_Div1: AHB clock = SYSCLK
+  *     @arg RCC_SYSCLK_Div2: AHB clock = SYSCLK/2
+  *     @arg RCC_SYSCLK_Div4: AHB clock = SYSCLK/4
+  *     @arg RCC_SYSCLK_Div8: AHB clock = SYSCLK/8
+  *     @arg RCC_SYSCLK_Div16: AHB clock = SYSCLK/16
+  *     @arg RCC_SYSCLK_Div64: AHB clock = SYSCLK/64
+  *     @arg RCC_SYSCLK_Div128: AHB clock = SYSCLK/128
+  *     @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
+  *     @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
+  * @retval None
+  */
+void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
+{
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
+  tmpreg = RCC->CFGR;
+  /* Clear HPRE[3:0] bits */
+  tmpreg &= CFGR_HPRE_Reset_Mask;
+  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
+  tmpreg |= RCC_SYSCLK;
+  /* Store the new value */
+  RCC->CFGR = tmpreg;
+}
+
+/**
+  * @brief  Configures the Low Speed APB clock (PCLK1).
+  * @param  RCC_HCLK: defines the APB1 clock divider. This clock is derived from
+  *   the AHB clock (HCLK).
+  *   This parameter can be one of the following values:
+  *     @arg RCC_HCLK_Div1: APB1 clock = HCLK
+  *     @arg RCC_HCLK_Div2: APB1 clock = HCLK/2
+  *     @arg RCC_HCLK_Div4: APB1 clock = HCLK/4
+  *     @arg RCC_HCLK_Div8: APB1 clock = HCLK/8
+  *     @arg RCC_HCLK_Div16: APB1 clock = HCLK/16
+  * @retval None
+  */
+void RCC_PCLK1Config(uint32_t RCC_HCLK)
+{
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_RCC_PCLK(RCC_HCLK));
+  tmpreg = RCC->CFGR;
+  /* Clear PPRE1[2:0] bits */
+  tmpreg &= CFGR_PPRE1_Reset_Mask;
+  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
+  tmpreg |= RCC_HCLK;
+  /* Store the new value */
+  RCC->CFGR = tmpreg;
+}
+
+/**
+  * @brief  Configures the High Speed APB clock (PCLK2).
+  * @param  RCC_HCLK: defines the APB2 clock divider. This clock is derived from
+  *   the AHB clock (HCLK).
+  *   This parameter can be one of the following values:
+  *     @arg RCC_HCLK_Div1: APB2 clock = HCLK
+  *     @arg RCC_HCLK_Div2: APB2 clock = HCLK/2
+  *     @arg RCC_HCLK_Div4: APB2 clock = HCLK/4
+  *     @arg RCC_HCLK_Div8: APB2 clock = HCLK/8
+  *     @arg RCC_HCLK_Div16: APB2 clock = HCLK/16
+  * @retval None
+  */
+void RCC_PCLK2Config(uint32_t RCC_HCLK)
+{
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_RCC_PCLK(RCC_HCLK));
+  tmpreg = RCC->CFGR;
+  /* Clear PPRE2[2:0] bits */
+  tmpreg &= CFGR_PPRE2_Reset_Mask;
+  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
+  tmpreg |= RCC_HCLK << 3;
+  /* Store the new value */
+  RCC->CFGR = tmpreg;
+}
+
+/**
+  * @brief  Enables or disables the specified RCC interrupts.
+  * @param  RCC_IT: specifies the RCC interrupt sources to be enabled or disabled.
+  *
+  *   For @b STM32_Connectivity_line_devices, this parameter can be any combination
+  *   of the following values
+  *     @arg RCC_IT_LSIRDY: LSI ready interrupt
+  *     @arg RCC_IT_LSERDY: LSE ready interrupt
+  *     @arg RCC_IT_HSIRDY: HSI ready interrupt
+  *     @arg RCC_IT_HSERDY: HSE ready interrupt
+  *     @arg RCC_IT_PLLRDY: PLL ready interrupt
+  *     @arg RCC_IT_PLL2RDY: PLL2 ready interrupt
+  *     @arg RCC_IT_PLL3RDY: PLL3 ready interrupt
+  *
+  *   For @b other_STM32_devices, this parameter can be any combination of the
+  *   following values
+  *     @arg RCC_IT_LSIRDY: LSI ready interrupt
+  *     @arg RCC_IT_LSERDY: LSE ready interrupt
+  *     @arg RCC_IT_HSIRDY: HSI ready interrupt
+  *     @arg RCC_IT_HSERDY: HSE ready interrupt
+  *     @arg RCC_IT_PLLRDY: PLL ready interrupt
+  *
+  * @param  NewState: new state of the specified RCC interrupts.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_IT(RCC_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Perform Byte access to RCC_CIR bits to enable the selected interrupts */
+    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
+  }
+  else
+  {
+    /* Perform Byte access to RCC_CIR bits to disable the selected interrupts */
+    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
+  }
+}
+
+#ifndef STM32F10X_CL
+/**
+  * @brief  Configures the USB clock (USBCLK).
+  * @param  RCC_USBCLKSource: specifies the USB clock source. This clock is
+  *   derived from the PLL output.
+  *   This parameter can be one of the following values:
+  *     @arg RCC_USBCLKSource_PLLCLK_1Div5: PLL clock divided by 1,5 selected as USB
+  *                                     clock source
+  *     @arg RCC_USBCLKSource_PLLCLK_Div1: PLL clock selected as USB clock source
+  * @retval None
+  */
+void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));
+
+  *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
+}
+#else
+/**
+  * @brief  Configures the USB OTG FS clock (OTGFSCLK).
+  *   This function applies only to STM32 Connectivity line devices.
+  * @param  RCC_OTGFSCLKSource: specifies the USB OTG FS clock source.
+  *   This clock is derived from the PLL output.
+  *   This parameter can be one of the following values:
+  *     @arg  RCC_OTGFSCLKSource_PLLVCO_Div3: PLL VCO clock divided by 2 selected as USB OTG FS clock source
+  *     @arg  RCC_OTGFSCLKSource_PLLVCO_Div2: PLL VCO clock divided by 2 selected as USB OTG FS clock source
+  * @retval None
+  */
+void RCC_OTGFSCLKConfig(uint32_t RCC_OTGFSCLKSource)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_OTGFSCLK_SOURCE(RCC_OTGFSCLKSource));
+
+  *(__IO uint32_t *) CFGR_OTGFSPRE_BB = RCC_OTGFSCLKSource;
+}
+#endif /* STM32F10X_CL */
+
+/**
+  * @brief  Configures the ADC clock (ADCCLK).
+  * @param  RCC_PCLK2: defines the ADC clock divider. This clock is derived from
+  *   the APB2 clock (PCLK2).
+  *   This parameter can be one of the following values:
+  *     @arg RCC_PCLK2_Div2: ADC clock = PCLK2/2
+  *     @arg RCC_PCLK2_Div4: ADC clock = PCLK2/4
+  *     @arg RCC_PCLK2_Div6: ADC clock = PCLK2/6
+  *     @arg RCC_PCLK2_Div8: ADC clock = PCLK2/8
+  * @retval None
+  */
+void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
+{
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
+  tmpreg = RCC->CFGR;
+  /* Clear ADCPRE[1:0] bits */
+  tmpreg &= CFGR_ADCPRE_Reset_Mask;
+  /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
+  tmpreg |= RCC_PCLK2;
+  /* Store the new value */
+  RCC->CFGR = tmpreg;
+}
+
+#ifdef STM32F10X_CL
+/**
+  * @brief  Configures the I2S2 clock source(I2S2CLK).
+  * @note
+  *   - This function must be called before enabling I2S2 APB clock.
+  *   - This function applies only to STM32 Connectivity line devices.
+  * @param  RCC_I2S2CLKSource: specifies the I2S2 clock source.
+  *   This parameter can be one of the following values:
+  *     @arg RCC_I2S2CLKSource_SYSCLK: system clock selected as I2S2 clock entry
+  *     @arg RCC_I2S2CLKSource_PLL3_VCO: PLL3 VCO clock selected as I2S2 clock entry
+  * @retval None
+  */
+void RCC_I2S2CLKConfig(uint32_t RCC_I2S2CLKSource)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_I2S2CLK_SOURCE(RCC_I2S2CLKSource));
+
+  *(__IO uint32_t *) CFGR2_I2S2SRC_BB = RCC_I2S2CLKSource;
+}
+
+/**
+  * @brief  Configures the I2S3 clock source(I2S2CLK).
+  * @note
+  *   - This function must be called before enabling I2S3 APB clock.
+  *   - This function applies only to STM32 Connectivity line devices.
+  * @param  RCC_I2S3CLKSource: specifies the I2S3 clock source.
+  *   This parameter can be one of the following values:
+  *     @arg RCC_I2S3CLKSource_SYSCLK: system clock selected as I2S3 clock entry
+  *     @arg RCC_I2S3CLKSource_PLL3_VCO: PLL3 VCO clock selected as I2S3 clock entry
+  * @retval None
+  */
+void RCC_I2S3CLKConfig(uint32_t RCC_I2S3CLKSource)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_I2S3CLK_SOURCE(RCC_I2S3CLKSource));
+
+  *(__IO uint32_t *) CFGR2_I2S3SRC_BB = RCC_I2S3CLKSource;
+}
+#endif /* STM32F10X_CL */
+
+/**
+  * @brief  Configures the External Low Speed oscillator (LSE).
+  * @param  RCC_LSE: specifies the new state of the LSE.
+  *   This parameter can be one of the following values:
+  *     @arg RCC_LSE_OFF: LSE oscillator OFF
+  *     @arg RCC_LSE_ON: LSE oscillator ON
+  *     @arg RCC_LSE_Bypass: LSE oscillator bypassed with external clock
+  * @retval None
+  */
+void RCC_LSEConfig(uint8_t RCC_LSE)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_LSE(RCC_LSE));
+  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
+  /* Reset LSEON bit */
+  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
+  /* Reset LSEBYP bit */
+  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
+  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
+  switch(RCC_LSE)
+  {
+    case RCC_LSE_ON:
+      /* Set LSEON bit */
+      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
+      break;
+
+    case RCC_LSE_Bypass:
+      /* Set LSEBYP and LSEON bits */
+      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
+      break;
+
+    default:
+      break;
+  }
+}
+
+/**
+  * @brief  Enables or disables the Internal Low Speed oscillator (LSI).
+  * @note   LSI can not be disabled if the IWDG is running.
+  * @param  NewState: new state of the LSI. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_LSICmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Configures the RTC clock (RTCCLK).
+  * @note   Once the RTC clock is selected it can't be changed unless the Backup domain is reset.
+  * @param  RCC_RTCCLKSource: specifies the RTC clock source.
+  *   This parameter can be one of the following values:
+  *     @arg RCC_RTCCLKSource_LSE: LSE selected as RTC clock
+  *     @arg RCC_RTCCLKSource_LSI: LSI selected as RTC clock
+  *     @arg RCC_RTCCLKSource_HSE_Div128: HSE clock divided by 128 selected as RTC clock
+  * @retval None
+  */
+void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
+  /* Select the RTC clock source */
+  RCC->BDCR |= RCC_RTCCLKSource;
+}
+
+/**
+  * @brief  Enables or disables the RTC clock.
+  * @note   This function must be used only after the RTC clock was selected using the RCC_RTCCLKConfig function.
+  * @param  NewState: new state of the RTC clock. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_RTCCLKCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Returns the frequencies of different on chip clocks.
+  * @param  RCC_Clocks: pointer to a RCC_ClocksTypeDef structure which will hold
+  *         the clocks frequencies.
+  * @note   The result of this function could be not correct when using
+  *         fractional value for HSE crystal.
+  * @retval None
+  */
+void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
+{
+  uint32_t tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
+
+#ifdef  STM32F10X_CL
+  uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
+#endif /* STM32F10X_CL */
+
+#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
+  uint32_t prediv1factor = 0;
+#endif
+
+  /* Get SYSCLK source -------------------------------------------------------*/
+  tmp = RCC->CFGR & CFGR_SWS_Mask;
+
+  switch (tmp)
+  {
+    case 0x00:  /* HSI used as system clock */
+      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
+      break;
+    case 0x04:  /* HSE used as system clock */
+      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
+      break;
+    case 0x08:  /* PLL used as system clock */
+
+      /* Get PLL clock source and multiplication factor ----------------------*/
+      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
+      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
+
+#ifndef STM32F10X_CL
+      pllmull = ( pllmull >> 18) + 2;
+
+      if (pllsource == 0x00)
+      {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
+        RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
+      }
+      else
+      {
+ #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
+       prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
+       /* HSE oscillator clock selected as PREDIV1 clock entry */
+       RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull;
+ #else
+        /* HSE selected as PLL clock entry */
+        if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
+        {/* HSE oscillator clock divided by 2 */
+          RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE >> 1) * pllmull;
+        }
+        else
+        {
+          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE * pllmull;
+        }
+ #endif
+      }
+#else
+      pllmull = pllmull >> 18;
+
+      if (pllmull != 0x0D)
+      {
+         pllmull += 2;
+      }
+      else
+      { /* PLL multiplication factor = PLL input clock * 6.5 */
+        pllmull = 13 / 2;
+      }
+
+      if (pllsource == 0x00)
+      {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
+        RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
+      }
+      else
+      {/* PREDIV1 selected as PLL clock entry */
+
+        /* Get PREDIV1 clock source and division factor */
+        prediv1source = RCC->CFGR2 & CFGR2_PREDIV1SRC;
+        prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
+
+        if (prediv1source == 0)
+        { /* HSE oscillator clock selected as PREDIV1 clock entry */
+          RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull;
+        }
+        else
+        {/* PLL2 clock selected as PREDIV1 clock entry */
+
+          /* Get PREDIV2 division factor and PLL2 multiplication factor */
+          prediv2factor = ((RCC->CFGR2 & CFGR2_PREDIV2) >> 4) + 1;
+          pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2;
+          RCC_Clocks->SYSCLK_Frequency = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;
+        }
+      }
+#endif /* STM32F10X_CL */
+      break;
+
+    default:
+      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
+      break;
+  }
+
+  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
+  /* Get HCLK prescaler */
+  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
+  tmp = tmp >> 4;
+  presc = APBAHBPrescTable[tmp];
+  /* HCLK clock frequency */
+  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
+  /* Get PCLK1 prescaler */
+  tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
+  tmp = tmp >> 8;
+  presc = APBAHBPrescTable[tmp];
+  /* PCLK1 clock frequency */
+  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
+  /* Get PCLK2 prescaler */
+  tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
+  tmp = tmp >> 11;
+  presc = APBAHBPrescTable[tmp];
+  /* PCLK2 clock frequency */
+  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
+  /* Get ADCCLK prescaler */
+  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
+  tmp = tmp >> 14;
+  presc = ADCPrescTable[tmp];
+  /* ADCCLK clock frequency */
+  RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
+}
+
+/**
+  * @brief  Enables or disables the AHB peripheral clock.
+  * @param  RCC_AHBPeriph: specifies the AHB peripheral to gates its clock.
+  *
+  *   For @b STM32_Connectivity_line_devices, this parameter can be any combination
+  *   of the following values:
+  *     @arg RCC_AHBPeriph_DMA1
+  *     @arg RCC_AHBPeriph_DMA2
+  *     @arg RCC_AHBPeriph_SRAM
+  *     @arg RCC_AHBPeriph_FLITF
+  *     @arg RCC_AHBPeriph_CRC
+  *     @arg RCC_AHBPeriph_OTG_FS
+  *     @arg RCC_AHBPeriph_ETH_MAC
+  *     @arg RCC_AHBPeriph_ETH_MAC_Tx
+  *     @arg RCC_AHBPeriph_ETH_MAC_Rx
+  *
+  *   For @b other_STM32_devices, this parameter can be any combination of the
+  *   following values:
+  *     @arg RCC_AHBPeriph_DMA1
+  *     @arg RCC_AHBPeriph_DMA2
+  *     @arg RCC_AHBPeriph_SRAM
+  *     @arg RCC_AHBPeriph_FLITF
+  *     @arg RCC_AHBPeriph_CRC
+  *     @arg RCC_AHBPeriph_FSMC
+  *     @arg RCC_AHBPeriph_SDIO
+  *
+  * @note SRAM and FLITF clock can be disabled only during sleep mode.
+  * @param  NewState: new state of the specified peripheral clock.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    RCC->AHBENR |= RCC_AHBPeriph;
+  }
+  else
+  {
+    RCC->AHBENR &= ~RCC_AHBPeriph;
+  }
+}
+
+/**
+  * @brief  Enables or disables the High Speed APB (APB2) peripheral clock.
+  * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
+  *   This parameter can be any combination of the following values:
+  *     @arg RCC_APB2Periph_AFIO, RCC_APB2Periph_GPIOA, RCC_APB2Periph_GPIOB,
+  *          RCC_APB2Periph_GPIOC, RCC_APB2Periph_GPIOD, RCC_APB2Periph_GPIOE,
+  *          RCC_APB2Periph_GPIOF, RCC_APB2Periph_GPIOG, RCC_APB2Periph_ADC1,
+  *          RCC_APB2Periph_ADC2, RCC_APB2Periph_TIM1, RCC_APB2Periph_SPI1,
+  *          RCC_APB2Periph_TIM8, RCC_APB2Periph_USART1, RCC_APB2Periph_ADC3,
+  *          RCC_APB2Periph_TIM15, RCC_APB2Periph_TIM16, RCC_APB2Periph_TIM17,
+  *          RCC_APB2Periph_TIM9, RCC_APB2Periph_TIM10, RCC_APB2Periph_TIM11
+  * @param  NewState: new state of the specified peripheral clock.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    RCC->APB2ENR |= RCC_APB2Periph;
+  }
+  else
+  {
+    RCC->APB2ENR &= ~RCC_APB2Periph;
+  }
+}
+
+/**
+  * @brief  Enables or disables the Low Speed APB (APB1) peripheral clock.
+  * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.
+  *   This parameter can be any combination of the following values:
+  *     @arg RCC_APB1Periph_TIM2, RCC_APB1Periph_TIM3, RCC_APB1Periph_TIM4,
+  *          RCC_APB1Periph_TIM5, RCC_APB1Periph_TIM6, RCC_APB1Periph_TIM7,
+  *          RCC_APB1Periph_WWDG, RCC_APB1Periph_SPI2, RCC_APB1Periph_SPI3,
+  *          RCC_APB1Periph_USART2, RCC_APB1Periph_USART3, RCC_APB1Periph_USART4,
+  *          RCC_APB1Periph_USART5, RCC_APB1Periph_I2C1, RCC_APB1Periph_I2C2,
+  *          RCC_APB1Periph_USB, RCC_APB1Periph_CAN1, RCC_APB1Periph_BKP,
+  *          RCC_APB1Periph_PWR, RCC_APB1Periph_DAC, RCC_APB1Periph_CEC,
+  *          RCC_APB1Periph_TIM12, RCC_APB1Periph_TIM13, RCC_APB1Periph_TIM14
+  * @param  NewState: new state of the specified peripheral clock.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    RCC->APB1ENR |= RCC_APB1Periph;
+  }
+  else
+  {
+    RCC->APB1ENR &= ~RCC_APB1Periph;
+  }
+}
+
+#ifdef STM32F10X_CL
+/**
+  * @brief  Forces or releases AHB peripheral reset.
+  * @note   This function applies only to STM32 Connectivity line devices.
+  * @param  RCC_AHBPeriph: specifies the AHB peripheral to reset.
+  *   This parameter can be any combination of the following values:
+  *     @arg RCC_AHBPeriph_OTG_FS
+  *     @arg RCC_AHBPeriph_ETH_MAC
+  * @param  NewState: new state of the specified peripheral reset.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_AHB_PERIPH_RESET(RCC_AHBPeriph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    RCC->AHBRSTR |= RCC_AHBPeriph;
+  }
+  else
+  {
+    RCC->AHBRSTR &= ~RCC_AHBPeriph;
+  }
+}
+#endif /* STM32F10X_CL */
+
+/**
+  * @brief  Forces or releases High Speed APB (APB2) peripheral reset.
+  * @param  RCC_APB2Periph: specifies the APB2 peripheral to reset.
+  *   This parameter can be any combination of the following values:
+  *     @arg RCC_APB2Periph_AFIO, RCC_APB2Periph_GPIOA, RCC_APB2Periph_GPIOB,
+  *          RCC_APB2Periph_GPIOC, RCC_APB2Periph_GPIOD, RCC_APB2Periph_GPIOE,
+  *          RCC_APB2Periph_GPIOF, RCC_APB2Periph_GPIOG, RCC_APB2Periph_ADC1,
+  *          RCC_APB2Periph_ADC2, RCC_APB2Periph_TIM1, RCC_APB2Periph_SPI1,
+  *          RCC_APB2Periph_TIM8, RCC_APB2Periph_USART1, RCC_APB2Periph_ADC3,
+  *          RCC_APB2Periph_TIM15, RCC_APB2Periph_TIM16, RCC_APB2Periph_TIM17,
+  *          RCC_APB2Periph_TIM9, RCC_APB2Periph_TIM10, RCC_APB2Periph_TIM11
+  * @param  NewState: new state of the specified peripheral reset.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    RCC->APB2RSTR |= RCC_APB2Periph;
+  }
+  else
+  {
+    RCC->APB2RSTR &= ~RCC_APB2Periph;
+  }
+}
+
+/**
+  * @brief  Forces or releases Low Speed APB (APB1) peripheral reset.
+  * @param  RCC_APB1Periph: specifies the APB1 peripheral to reset.
+  *   This parameter can be any combination of the following values:
+  *     @arg RCC_APB1Periph_TIM2, RCC_APB1Periph_TIM3, RCC_APB1Periph_TIM4,
+  *          RCC_APB1Periph_TIM5, RCC_APB1Periph_TIM6, RCC_APB1Periph_TIM7,
+  *          RCC_APB1Periph_WWDG, RCC_APB1Periph_SPI2, RCC_APB1Periph_SPI3,
+  *          RCC_APB1Periph_USART2, RCC_APB1Periph_USART3, RCC_APB1Periph_USART4,
+  *          RCC_APB1Periph_USART5, RCC_APB1Periph_I2C1, RCC_APB1Periph_I2C2,
+  *          RCC_APB1Periph_USB, RCC_APB1Periph_CAN1, RCC_APB1Periph_BKP,
+  *          RCC_APB1Periph_PWR, RCC_APB1Periph_DAC, RCC_APB1Periph_CEC,
+  *          RCC_APB1Periph_TIM12, RCC_APB1Periph_TIM13, RCC_APB1Periph_TIM14
+  * @param  NewState: new state of the specified peripheral clock.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    RCC->APB1RSTR |= RCC_APB1Periph;
+  }
+  else
+  {
+    RCC->APB1RSTR &= ~RCC_APB1Periph;
+  }
+}
+
+/**
+  * @brief  Forces or releases the Backup domain reset.
+  * @param  NewState: new state of the Backup domain reset.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_BackupResetCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Enables or disables the Clock Security System.
+  * @param  NewState: new state of the Clock Security System..
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Selects the clock source to output on MCO pin.
+  * @param  RCC_MCO: specifies the clock source to output.
+  *
+  *   For @b STM32_Connectivity_line_devices, this parameter can be one of the
+  *   following values:
+  *     @arg RCC_MCO_NoClock: No clock selected
+  *     @arg RCC_MCO_SYSCLK: System clock selected
+  *     @arg RCC_MCO_HSI: HSI oscillator clock selected
+  *     @arg RCC_MCO_HSE: HSE oscillator clock selected
+  *     @arg RCC_MCO_PLLCLK_Div2: PLL clock divided by 2 selected
+  *     @arg RCC_MCO_PLL2CLK: PLL2 clock selected
+  *     @arg RCC_MCO_PLL3CLK_Div2: PLL3 clock divided by 2 selected
+  *     @arg RCC_MCO_XT1: External 3-25 MHz oscillator clock selected
+  *     @arg RCC_MCO_PLL3CLK: PLL3 clock selected
+  *
+  *   For  @b other_STM32_devices, this parameter can be one of the following values:
+  *     @arg RCC_MCO_NoClock: No clock selected
+  *     @arg RCC_MCO_SYSCLK: System clock selected
+  *     @arg RCC_MCO_HSI: HSI oscillator clock selected
+  *     @arg RCC_MCO_HSE: HSE oscillator clock selected
+  *     @arg RCC_MCO_PLLCLK_Div2: PLL clock divided by 2 selected
+  *
+  * @retval None
+  */
+void RCC_MCOConfig(uint8_t RCC_MCO)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_MCO(RCC_MCO));
+
+  /* Perform Byte access to MCO bits to select the MCO source */
+  *(__IO uint8_t *) CFGR_BYTE4_ADDRESS = RCC_MCO;
+}
+
+/**
+  * @brief  Checks whether the specified RCC flag is set or not.
+  * @param  RCC_FLAG: specifies the flag to check.
+  *
+  *   For @b STM32_Connectivity_line_devices, this parameter can be one of the
+  *   following values:
+  *     @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready
+  *     @arg RCC_FLAG_HSERDY: HSE oscillator clock ready
+  *     @arg RCC_FLAG_PLLRDY: PLL clock ready
+  *     @arg RCC_FLAG_PLL2RDY: PLL2 clock ready
+  *     @arg RCC_FLAG_PLL3RDY: PLL3 clock ready
+  *     @arg RCC_FLAG_LSERDY: LSE oscillator clock ready
+  *     @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready
+  *     @arg RCC_FLAG_PINRST: Pin reset
+  *     @arg RCC_FLAG_PORRST: POR/PDR reset
+  *     @arg RCC_FLAG_SFTRST: Software reset
+  *     @arg RCC_FLAG_IWDGRST: Independent Watchdog reset
+  *     @arg RCC_FLAG_WWDGRST: Window Watchdog reset
+  *     @arg RCC_FLAG_LPWRRST: Low Power reset
+  *
+  *   For @b other_STM32_devices, this parameter can be one of the following values:
+  *     @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready
+  *     @arg RCC_FLAG_HSERDY: HSE oscillator clock ready
+  *     @arg RCC_FLAG_PLLRDY: PLL clock ready
+  *     @arg RCC_FLAG_LSERDY: LSE oscillator clock ready
+  *     @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready
+  *     @arg RCC_FLAG_PINRST: Pin reset
+  *     @arg RCC_FLAG_PORRST: POR/PDR reset
+  *     @arg RCC_FLAG_SFTRST: Software reset
+  *     @arg RCC_FLAG_IWDGRST: Independent Watchdog reset
+  *     @arg RCC_FLAG_WWDGRST: Window Watchdog reset
+  *     @arg RCC_FLAG_LPWRRST: Low Power reset
+  *
+  * @retval The new state of RCC_FLAG (SET or RESET).
+  */
+FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
+{
+  uint32_t tmp = 0;
+  uint32_t statusreg = 0;
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_RCC_FLAG(RCC_FLAG));
+
+  /* Get the RCC register index */
+  tmp = RCC_FLAG >> 5;
+  if (tmp == 1)               /* The flag to check is in CR register */
+  {
+    statusreg = RCC->CR;
+  }
+  else if (tmp == 2)          /* The flag to check is in BDCR register */
+  {
+    statusreg = RCC->BDCR;
+  }
+  else                       /* The flag to check is in CSR register */
+  {
+    statusreg = RCC->CSR;
+  }
+
+  /* Get the flag position */
+  tmp = RCC_FLAG & FLAG_Mask;
+  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+
+  /* Return the flag status */
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the RCC reset flags.
+  * @note   The reset flags are: RCC_FLAG_PINRST, RCC_FLAG_PORRST, RCC_FLAG_SFTRST,
+  *   RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST, RCC_FLAG_LPWRRST
+  * @param  None
+  * @retval None
+  */
+void RCC_ClearFlag(void)
+{
+  /* Set RMVF bit to clear the reset flags */
+  RCC->CSR |= CSR_RMVF_Set;
+}
+
+/**
+  * @brief  Checks whether the specified RCC interrupt has occurred or not.
+  * @param  RCC_IT: specifies the RCC interrupt source to check.
+  *
+  *   For @b STM32_Connectivity_line_devices, this parameter can be one of the
+  *   following values:
+  *     @arg RCC_IT_LSIRDY: LSI ready interrupt
+  *     @arg RCC_IT_LSERDY: LSE ready interrupt
+  *     @arg RCC_IT_HSIRDY: HSI ready interrupt
+  *     @arg RCC_IT_HSERDY: HSE ready interrupt
+  *     @arg RCC_IT_PLLRDY: PLL ready interrupt
+  *     @arg RCC_IT_PLL2RDY: PLL2 ready interrupt
+  *     @arg RCC_IT_PLL3RDY: PLL3 ready interrupt
+  *     @arg RCC_IT_CSS: Clock Security System interrupt
+  *
+  *   For @b other_STM32_devices, this parameter can be one of the following values:
+  *     @arg RCC_IT_LSIRDY: LSI ready interrupt
+  *     @arg RCC_IT_LSERDY: LSE ready interrupt
+  *     @arg RCC_IT_HSIRDY: HSI ready interrupt
+  *     @arg RCC_IT_HSERDY: HSE ready interrupt
+  *     @arg RCC_IT_PLLRDY: PLL ready interrupt
+  *     @arg RCC_IT_CSS: Clock Security System interrupt
+  *
+  * @retval The new state of RCC_IT (SET or RESET).
+  */
+ITStatus RCC_GetITStatus(uint8_t RCC_IT)
+{
+  ITStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_RCC_GET_IT(RCC_IT));
+
+  /* Check the status of the specified RCC interrupt */
+  if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+
+  /* Return the RCC_IT status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the RCC's interrupt pending bits.
+  * @param  RCC_IT: specifies the interrupt pending bit to clear.
+  *
+  *   For @b STM32_Connectivity_line_devices, this parameter can be any combination
+  *   of the following values:
+  *     @arg RCC_IT_LSIRDY: LSI ready interrupt
+  *     @arg RCC_IT_LSERDY: LSE ready interrupt
+  *     @arg RCC_IT_HSIRDY: HSI ready interrupt
+  *     @arg RCC_IT_HSERDY: HSE ready interrupt
+  *     @arg RCC_IT_PLLRDY: PLL ready interrupt
+  *     @arg RCC_IT_PLL2RDY: PLL2 ready interrupt
+  *     @arg RCC_IT_PLL3RDY: PLL3 ready interrupt
+  *     @arg RCC_IT_CSS: Clock Security System interrupt
+  *
+  *   For @b other_STM32_devices, this parameter can be any combination of the
+  *   following values:
+  *     @arg RCC_IT_LSIRDY: LSI ready interrupt
+  *     @arg RCC_IT_LSERDY: LSE ready interrupt
+  *     @arg RCC_IT_HSIRDY: HSI ready interrupt
+  *     @arg RCC_IT_HSERDY: HSE ready interrupt
+  *     @arg RCC_IT_PLLRDY: PLL ready interrupt
+  *
+  *     @arg RCC_IT_CSS: Clock Security System interrupt
+  * @retval None
+  */
+void RCC_ClearITPendingBit(uint8_t RCC_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_CLEAR_IT(RCC_IT));
+
+  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
+     pending bits */
+  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_rtc.c b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_rtc.c
new file mode 100644
index 0000000..012b1ff
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_rtc.c
@@ -0,0 +1,359 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_rtc.c
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file provides all the RTC firmware functions.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x_rtc.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup RTC
+  * @brief RTC driver modules
+  * @{
+  */
+
+/** @defgroup RTC_Private_TypesDefinitions
+  * @{
+  */
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Private_Defines
+  * @{
+  */
+#define RTC_LSB_MASK     ((uint32_t)0x0000FFFF)  /*!< RTC LSB Mask */
+#define PRLH_MSB_MASK    ((uint32_t)0x000F0000)  /*!< RTC Prescaler MSB Mask */
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Enables or disables the specified RTC interrupts.
+  * @param  RTC_IT: specifies the RTC interrupts sources to be enabled or disabled.
+  *   This parameter can be any combination of the following values:
+  *     @arg RTC_IT_OW: Overflow interrupt
+  *     @arg RTC_IT_ALR: Alarm interrupt
+  *     @arg RTC_IT_SEC: Second interrupt
+  * @param  NewState: new state of the specified RTC interrupts.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void RTC_ITConfig(uint16_t RTC_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RTC_IT(RTC_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    RTC->CRH |= RTC_IT;
+  }
+  else
+  {
+    RTC->CRH &= (uint16_t)~RTC_IT;
+  }
+}
+
+/**
+  * @brief  Enters the RTC configuration mode.
+  * @param  None
+  * @retval None
+  */
+void RTC_EnterConfigMode(void)
+{
+  /* Set the CNF flag to enter in the Configuration Mode */
+  RTC->CRL |= RTC_CRL_CNF;
+}
+
+/**
+  * @brief  Exits from the RTC configuration mode.
+  * @param  None
+  * @retval None
+  */
+void RTC_ExitConfigMode(void)
+{
+  /* Reset the CNF flag to exit from the Configuration Mode */
+  RTC->CRL &= (uint16_t)~((uint16_t)RTC_CRL_CNF);
+}
+
+/**
+  * @brief  Gets the RTC counter value.
+  * @param  None
+  * @retval RTC counter value.
+  */
+uint32_t RTC_GetCounter(void)
+{
+  uint16_t tmp = 0;
+  tmp = RTC->CNTL;
+  return (((uint32_t)RTC->CNTH << 16 ) | tmp) ;
+}
+
+/**
+  * @brief  Sets the RTC counter value.
+  * @param  CounterValue: RTC counter new value.
+  * @retval None
+  */
+void RTC_SetCounter(uint32_t CounterValue)
+{
+  RTC_EnterConfigMode();
+  /* Set RTC COUNTER MSB word */
+  RTC->CNTH = CounterValue >> 16;
+  /* Set RTC COUNTER LSB word */
+  RTC->CNTL = (CounterValue & RTC_LSB_MASK);
+  RTC_ExitConfigMode();
+}
+
+/**
+  * @brief  Sets the RTC prescaler value.
+  * @param  PrescalerValue: RTC prescaler new value.
+  * @retval None
+  */
+void RTC_SetPrescaler(uint32_t PrescalerValue)
+{
+  /* Check the parameters */
+  assert_param(IS_RTC_PRESCALER(PrescalerValue));
+
+  RTC_EnterConfigMode();
+  /* Set RTC PRESCALER MSB word */
+  RTC->PRLH = (PrescalerValue & PRLH_MSB_MASK) >> 16;
+  /* Set RTC PRESCALER LSB word */
+  RTC->PRLL = (PrescalerValue & RTC_LSB_MASK);
+  RTC_ExitConfigMode();
+}
+
+/**
+  * @brief  Sets the RTC alarm value.
+  * @param  AlarmValue: RTC alarm new value.
+  * @retval None
+  */
+void RTC_SetAlarm(uint32_t AlarmValue)
+{
+  RTC_EnterConfigMode();
+  /* Set the ALARM MSB word */
+  RTC->ALRH = AlarmValue >> 16;
+  /* Set the ALARM LSB word */
+  RTC->ALRL = (AlarmValue & RTC_LSB_MASK);
+  RTC_ExitConfigMode();
+}
+
+/**
+  * @brief  Gets the RTC divider value.
+  * @param  None
+  * @retval RTC Divider value.
+  */
+uint32_t RTC_GetDivider(void)
+{
+  uint32_t tmp = 0x00;
+  tmp = ((uint32_t)RTC->DIVH & (uint32_t)0x000F) << 16;
+  tmp |= RTC->DIVL;
+  return tmp;
+}
+
+/**
+  * @brief  Waits until last write operation on RTC registers has finished.
+  * @note   This function must be called before any write to RTC registers.
+  * @param  None
+  * @retval None
+  */
+void RTC_WaitForLastTask(void)
+{
+  /* Loop until RTOFF flag is set */
+  while ((RTC->CRL & RTC_FLAG_RTOFF) == (uint16_t)RESET)
+  {
+  }
+}
+
+/**
+  * @brief  Waits until the RTC registers (RTC_CNT, RTC_ALR and RTC_PRL)
+  *   are synchronized with RTC APB clock.
+  * @note   This function must be called before any read operation after an APB reset
+  *   or an APB clock stop.
+  * @param  None
+  * @retval None
+  */
+void RTC_WaitForSynchro(void)
+{
+  /* Clear RSF flag */
+  RTC->CRL &= (uint16_t)~RTC_FLAG_RSF;
+  /* Loop until RSF flag is set */
+  while ((RTC->CRL & RTC_FLAG_RSF) == (uint16_t)RESET)
+  {
+  }
+}
+
+/**
+  * @brief  Checks whether the specified RTC flag is set or not.
+  * @param  RTC_FLAG: specifies the flag to check.
+  *   This parameter can be one the following values:
+  *     @arg RTC_FLAG_RTOFF: RTC Operation OFF flag
+  *     @arg RTC_FLAG_RSF: Registers Synchronized flag
+  *     @arg RTC_FLAG_OW: Overflow flag
+  *     @arg RTC_FLAG_ALR: Alarm flag
+  *     @arg RTC_FLAG_SEC: Second flag
+  * @retval The new state of RTC_FLAG (SET or RESET).
+  */
+FlagStatus RTC_GetFlagStatus(uint16_t RTC_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+
+  /* Check the parameters */
+  assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
+
+  if ((RTC->CRL & RTC_FLAG) != (uint16_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the RTC's pending flags.
+  * @param  RTC_FLAG: specifies the flag to clear.
+  *   This parameter can be any combination of the following values:
+  *     @arg RTC_FLAG_RSF: Registers Synchronized flag. This flag is cleared only after
+  *                        an APB reset or an APB Clock stop.
+  *     @arg RTC_FLAG_OW: Overflow flag
+  *     @arg RTC_FLAG_ALR: Alarm flag
+  *     @arg RTC_FLAG_SEC: Second flag
+  * @retval None
+  */
+void RTC_ClearFlag(uint16_t RTC_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));
+
+  /* Clear the corresponding RTC flag */
+  RTC->CRL &= (uint16_t)~RTC_FLAG;
+}
+
+/**
+  * @brief  Checks whether the specified RTC interrupt has occurred or not.
+  * @param  RTC_IT: specifies the RTC interrupts sources to check.
+  *   This parameter can be one of the following values:
+  *     @arg RTC_IT_OW: Overflow interrupt
+  *     @arg RTC_IT_ALR: Alarm interrupt
+  *     @arg RTC_IT_SEC: Second interrupt
+  * @retval The new state of the RTC_IT (SET or RESET).
+  */
+ITStatus RTC_GetITStatus(uint16_t RTC_IT)
+{
+  ITStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_RTC_GET_IT(RTC_IT));
+
+  bitstatus = (ITStatus)(RTC->CRL & RTC_IT);
+  if (((RTC->CRH & RTC_IT) != (uint16_t)RESET) && (bitstatus != (uint16_t)RESET))
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the RTC's interrupt pending bits.
+  * @param  RTC_IT: specifies the interrupt pending bit to clear.
+  *   This parameter can be any combination of the following values:
+  *     @arg RTC_IT_OW: Overflow interrupt
+  *     @arg RTC_IT_ALR: Alarm interrupt
+  *     @arg RTC_IT_SEC: Second interrupt
+  * @retval None
+  */
+void RTC_ClearITPendingBit(uint16_t RTC_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_RTC_IT(RTC_IT));
+
+  /* Clear the corresponding RTC pending bit */
+  RTC->CRL &= (uint16_t)~RTC_IT;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
+
+//
+// Copy pasted from version 2.0.x
+//
+/*******************************************************************************
+* Function Name  : RTC_GetAlarm
+* Description    : Gets the RTC alarm value.
+* Input          : None
+* Output         : None
+* Return         : RTC alarm value.
+*******************************************************************************/
+u32 RTC_GetAlarm(void)
+{
+  u16 tmp = 0;
+  tmp = RTC->ALRL;
+
+  return (((u32)RTC->ALRH << 16 ) | tmp) ;
+}
+
+
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_sdio.c b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_sdio.c
new file mode 100644
index 0000000..d1870ce
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_sdio.c
@@ -0,0 +1,799 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_sdio.c
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file provides all the SDIO firmware functions.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x_sdio.h"
+#include "stm32f10x_rcc.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup SDIO
+  * @brief SDIO driver modules
+  * @{
+  */
+
+/** @defgroup SDIO_Private_TypesDefinitions
+  * @{
+  */
+
+/* ------------ SDIO registers bit address in the alias region ----------- */
+#define SDIO_OFFSET                (SDIO_BASE - PERIPH_BASE)
+
+/* --- CLKCR Register ---*/
+
+/* Alias word address of CLKEN bit */
+#define CLKCR_OFFSET              (SDIO_OFFSET + 0x04)
+#define CLKEN_BitNumber           0x08
+#define CLKCR_CLKEN_BB            (PERIPH_BB_BASE + (CLKCR_OFFSET * 32) + (CLKEN_BitNumber * 4))
+
+/* --- CMD Register ---*/
+
+/* Alias word address of SDIOSUSPEND bit */
+#define CMD_OFFSET                (SDIO_OFFSET + 0x0C)
+#define SDIOSUSPEND_BitNumber     0x0B
+#define CMD_SDIOSUSPEND_BB        (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (SDIOSUSPEND_BitNumber * 4))
+
+/* Alias word address of ENCMDCOMPL bit */
+#define ENCMDCOMPL_BitNumber      0x0C
+#define CMD_ENCMDCOMPL_BB         (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (ENCMDCOMPL_BitNumber * 4))
+
+/* Alias word address of NIEN bit */
+#define NIEN_BitNumber            0x0D
+#define CMD_NIEN_BB               (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (NIEN_BitNumber * 4))
+
+/* Alias word address of ATACMD bit */
+#define ATACMD_BitNumber          0x0E
+#define CMD_ATACMD_BB             (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (ATACMD_BitNumber * 4))
+
+/* --- DCTRL Register ---*/
+
+/* Alias word address of DMAEN bit */
+#define DCTRL_OFFSET              (SDIO_OFFSET + 0x2C)
+#define DMAEN_BitNumber           0x03
+#define DCTRL_DMAEN_BB            (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (DMAEN_BitNumber * 4))
+
+/* Alias word address of RWSTART bit */
+#define RWSTART_BitNumber         0x08
+#define DCTRL_RWSTART_BB          (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWSTART_BitNumber * 4))
+
+/* Alias word address of RWSTOP bit */
+#define RWSTOP_BitNumber          0x09
+#define DCTRL_RWSTOP_BB           (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWSTOP_BitNumber * 4))
+
+/* Alias word address of RWMOD bit */
+#define RWMOD_BitNumber           0x0A
+#define DCTRL_RWMOD_BB            (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWMOD_BitNumber * 4))
+
+/* Alias word address of SDIOEN bit */
+#define SDIOEN_BitNumber          0x0B
+#define DCTRL_SDIOEN_BB           (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (SDIOEN_BitNumber * 4))
+
+/* ---------------------- SDIO registers bit mask ------------------------ */
+
+/* --- CLKCR Register ---*/
+
+/* CLKCR register clear mask */
+#define CLKCR_CLEAR_MASK         ((uint32_t)0xFFFF8100)
+
+/* --- PWRCTRL Register ---*/
+
+/* SDIO PWRCTRL Mask */
+#define PWR_PWRCTRL_MASK         ((uint32_t)0xFFFFFFFC)
+
+/* --- DCTRL Register ---*/
+
+/* SDIO DCTRL Clear Mask */
+#define DCTRL_CLEAR_MASK         ((uint32_t)0xFFFFFF08)
+
+/* --- CMD Register ---*/
+
+/* CMD Register clear mask */
+#define CMD_CLEAR_MASK           ((uint32_t)0xFFFFF800)
+
+/* SDIO RESP Registers Address */
+#define SDIO_RESP_ADDR           ((uint32_t)(SDIO_BASE + 0x14))
+
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Private_Defines
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup SDIO_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the SDIO peripheral registers to their default reset values.
+  * @param  None
+  * @retval None
+  */
+void SDIO_DeInit(void)
+{
+  SDIO->POWER = 0x00000000;
+  SDIO->CLKCR = 0x00000000;
+  SDIO->ARG = 0x00000000;
+  SDIO->CMD = 0x00000000;
+  SDIO->DTIMER = 0x00000000;
+  SDIO->DLEN = 0x00000000;
+  SDIO->DCTRL = 0x00000000;
+  SDIO->ICR = 0x00C007FF;
+  SDIO->MASK = 0x00000000;
+}
+
+/**
+  * @brief  Initializes the SDIO peripheral according to the specified
+  *         parameters in the SDIO_InitStruct.
+  * @param  SDIO_InitStruct : pointer to a SDIO_InitTypeDef structure
+  *         that contains the configuration information for the SDIO peripheral.
+  * @retval None
+  */
+void SDIO_Init(SDIO_InitTypeDef* SDIO_InitStruct)
+{
+  uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_SDIO_CLOCK_EDGE(SDIO_InitStruct->SDIO_ClockEdge));
+  assert_param(IS_SDIO_CLOCK_BYPASS(SDIO_InitStruct->SDIO_ClockBypass));
+  assert_param(IS_SDIO_CLOCK_POWER_SAVE(SDIO_InitStruct->SDIO_ClockPowerSave));
+  assert_param(IS_SDIO_BUS_WIDE(SDIO_InitStruct->SDIO_BusWide));
+  assert_param(IS_SDIO_HARDWARE_FLOW_CONTROL(SDIO_InitStruct->SDIO_HardwareFlowControl));
+
+/*---------------------------- SDIO CLKCR Configuration ------------------------*/
+  /* Get the SDIO CLKCR value */
+  tmpreg = SDIO->CLKCR;
+
+  /* Clear CLKDIV, PWRSAV, BYPASS, WIDBUS, NEGEDGE, HWFC_EN bits */
+  tmpreg &= CLKCR_CLEAR_MASK;
+
+  /* Set CLKDIV bits according to SDIO_ClockDiv value */
+  /* Set PWRSAV bit according to SDIO_ClockPowerSave value */
+  /* Set BYPASS bit according to SDIO_ClockBypass value */
+  /* Set WIDBUS bits according to SDIO_BusWide value */
+  /* Set NEGEDGE bits according to SDIO_ClockEdge value */
+  /* Set HWFC_EN bits according to SDIO_HardwareFlowControl value */
+  tmpreg |= (SDIO_InitStruct->SDIO_ClockDiv  | SDIO_InitStruct->SDIO_ClockPowerSave |
+             SDIO_InitStruct->SDIO_ClockBypass | SDIO_InitStruct->SDIO_BusWide |
+             SDIO_InitStruct->SDIO_ClockEdge | SDIO_InitStruct->SDIO_HardwareFlowControl);
+
+  /* Write to SDIO CLKCR */
+  SDIO->CLKCR = tmpreg;
+}
+
+/**
+  * @brief  Fills each SDIO_InitStruct member with its default value.
+  * @param  SDIO_InitStruct: pointer to an SDIO_InitTypeDef structure which
+  *   will be initialized.
+  * @retval None
+  */
+void SDIO_StructInit(SDIO_InitTypeDef* SDIO_InitStruct)
+{
+  /* SDIO_InitStruct members default value */
+  SDIO_InitStruct->SDIO_ClockDiv = 0x00;
+  SDIO_InitStruct->SDIO_ClockEdge = SDIO_ClockEdge_Rising;
+  SDIO_InitStruct->SDIO_ClockBypass = SDIO_ClockBypass_Disable;
+  SDIO_InitStruct->SDIO_ClockPowerSave = SDIO_ClockPowerSave_Disable;
+  SDIO_InitStruct->SDIO_BusWide = SDIO_BusWide_1b;
+  SDIO_InitStruct->SDIO_HardwareFlowControl = SDIO_HardwareFlowControl_Disable;
+}
+
+/**
+  * @brief  Enables or disables the SDIO Clock.
+  * @param  NewState: new state of the SDIO Clock. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SDIO_ClockCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(__IO uint32_t *) CLKCR_CLKEN_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Sets the power status of the controller.
+  * @param  SDIO_PowerState: new state of the Power state.
+  *   This parameter can be one of the following values:
+  *     @arg SDIO_PowerState_OFF
+  *     @arg SDIO_PowerState_ON
+  * @retval None
+  */
+void SDIO_SetPowerState(uint32_t SDIO_PowerState)
+{
+  /* Check the parameters */
+  assert_param(IS_SDIO_POWER_STATE(SDIO_PowerState));
+
+  SDIO->POWER &= PWR_PWRCTRL_MASK;
+  SDIO->POWER |= SDIO_PowerState;
+}
+
+/**
+  * @brief  Gets the power status of the controller.
+  * @param  None
+  * @retval Power status of the controller. The returned value can
+  *   be one of the following:
+  * - 0x00: Power OFF
+  * - 0x02: Power UP
+  * - 0x03: Power ON
+  */
+uint32_t SDIO_GetPowerState(void)
+{
+  return (SDIO->POWER & (~PWR_PWRCTRL_MASK));
+}
+
+/**
+  * @brief  Enables or disables the SDIO interrupts.
+  * @param  SDIO_IT: specifies the SDIO interrupt sources to be enabled or disabled.
+  *   This parameter can be one or a combination of the following values:
+  *     @arg SDIO_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
+  *     @arg SDIO_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
+  *     @arg SDIO_IT_CTIMEOUT: Command response timeout interrupt
+  *     @arg SDIO_IT_DTIMEOUT: Data timeout interrupt
+  *     @arg SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt
+  *     @arg SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt
+  *     @arg SDIO_IT_CMDREND:  Command response received (CRC check passed) interrupt
+  *     @arg SDIO_IT_CMDSENT:  Command sent (no response required) interrupt
+  *     @arg SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is zero) interrupt
+  *     @arg SDIO_IT_STBITERR: Start bit not detected on all data signals in wide
+  *                            bus mode interrupt
+  *     @arg SDIO_IT_DBCKEND:  Data block sent/received (CRC check passed) interrupt
+  *     @arg SDIO_IT_CMDACT:   Command transfer in progress interrupt
+  *     @arg SDIO_IT_TXACT:    Data transmit in progress interrupt
+  *     @arg SDIO_IT_RXACT:    Data receive in progress interrupt
+  *     @arg SDIO_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt
+  *     @arg SDIO_IT_RXFIFOHF: Receive FIFO Half Full interrupt
+  *     @arg SDIO_IT_TXFIFOF:  Transmit FIFO full interrupt
+  *     @arg SDIO_IT_RXFIFOF:  Receive FIFO full interrupt
+  *     @arg SDIO_IT_TXFIFOE:  Transmit FIFO empty interrupt
+  *     @arg SDIO_IT_RXFIFOE:  Receive FIFO empty interrupt
+  *     @arg SDIO_IT_TXDAVL:   Data available in transmit FIFO interrupt
+  *     @arg SDIO_IT_RXDAVL:   Data available in receive FIFO interrupt
+  *     @arg SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt
+  *     @arg SDIO_IT_CEATAEND: CE-ATA command completion signal received for CMD61 interrupt
+  * @param  NewState: new state of the specified SDIO interrupts.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SDIO_ITConfig(uint32_t SDIO_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_SDIO_IT(SDIO_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the SDIO interrupts */
+    SDIO->MASK |= SDIO_IT;
+  }
+  else
+  {
+    /* Disable the SDIO interrupts */
+    SDIO->MASK &= ~SDIO_IT;
+  }
+}
+
+/**
+  * @brief  Enables or disables the SDIO DMA request.
+  * @param  NewState: new state of the selected SDIO DMA request.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SDIO_DMACmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(__IO uint32_t *) DCTRL_DMAEN_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Initializes the SDIO Command according to the specified
+  *         parameters in the SDIO_CmdInitStruct and send the command.
+  * @param  SDIO_CmdInitStruct : pointer to a SDIO_CmdInitTypeDef
+  *         structure that contains the configuration information for the SDIO command.
+  * @retval None
+  */
+void SDIO_SendCommand(SDIO_CmdInitTypeDef *SDIO_CmdInitStruct)
+{
+  uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_SDIO_CMD_INDEX(SDIO_CmdInitStruct->SDIO_CmdIndex));
+  assert_param(IS_SDIO_RESPONSE(SDIO_CmdInitStruct->SDIO_Response));
+  assert_param(IS_SDIO_WAIT(SDIO_CmdInitStruct->SDIO_Wait));
+  assert_param(IS_SDIO_CPSM(SDIO_CmdInitStruct->SDIO_CPSM));
+
+/*---------------------------- SDIO ARG Configuration ------------------------*/
+  /* Set the SDIO Argument value */
+  SDIO->ARG = SDIO_CmdInitStruct->SDIO_Argument;
+
+/*---------------------------- SDIO CMD Configuration ------------------------*/
+  /* Get the SDIO CMD value */
+  tmpreg = SDIO->CMD;
+  /* Clear CMDINDEX, WAITRESP, WAITINT, WAITPEND, CPSMEN bits */
+  tmpreg &= CMD_CLEAR_MASK;
+  /* Set CMDINDEX bits according to SDIO_CmdIndex value */
+  /* Set WAITRESP bits according to SDIO_Response value */
+  /* Set WAITINT and WAITPEND bits according to SDIO_Wait value */
+  /* Set CPSMEN bits according to SDIO_CPSM value */
+  tmpreg |= (uint32_t)SDIO_CmdInitStruct->SDIO_CmdIndex | SDIO_CmdInitStruct->SDIO_Response
+           | SDIO_CmdInitStruct->SDIO_Wait | SDIO_CmdInitStruct->SDIO_CPSM;
+
+  /* Write to SDIO CMD */
+  SDIO->CMD = tmpreg;
+}
+
+/**
+  * @brief  Fills each SDIO_CmdInitStruct member with its default value.
+  * @param  SDIO_CmdInitStruct: pointer to an SDIO_CmdInitTypeDef
+  *         structure which will be initialized.
+  * @retval None
+  */
+void SDIO_CmdStructInit(SDIO_CmdInitTypeDef* SDIO_CmdInitStruct)
+{
+  /* SDIO_CmdInitStruct members default value */
+  SDIO_CmdInitStruct->SDIO_Argument = 0x00;
+  SDIO_CmdInitStruct->SDIO_CmdIndex = 0x00;
+  SDIO_CmdInitStruct->SDIO_Response = SDIO_Response_No;
+  SDIO_CmdInitStruct->SDIO_Wait = SDIO_Wait_No;
+  SDIO_CmdInitStruct->SDIO_CPSM = SDIO_CPSM_Disable;
+}
+
+/**
+  * @brief  Returns command index of last command for which response received.
+  * @param  None
+  * @retval Returns the command index of the last command response received.
+  */
+uint8_t SDIO_GetCommandResponse(void)
+{
+  return (uint8_t)(SDIO->RESPCMD);
+}
+
+/**
+  * @brief  Returns response received from the card for the last command.
+  * @param  SDIO_RESP: Specifies the SDIO response register.
+  *   This parameter can be one of the following values:
+  *     @arg SDIO_RESP1: Response Register 1
+  *     @arg SDIO_RESP2: Response Register 2
+  *     @arg SDIO_RESP3: Response Register 3
+  *     @arg SDIO_RESP4: Response Register 4
+  * @retval The Corresponding response register value.
+  */
+uint32_t SDIO_GetResponse(uint32_t SDIO_RESP)
+{
+  __IO uint32_t tmp = 0;
+
+  /* Check the parameters */
+  assert_param(IS_SDIO_RESP(SDIO_RESP));
+
+  tmp = SDIO_RESP_ADDR + SDIO_RESP;
+
+  return (*(__IO uint32_t *) tmp);
+}
+
+/**
+  * @brief  Initializes the SDIO data path according to the specified
+  *   parameters in the SDIO_DataInitStruct.
+  * @param  SDIO_DataInitStruct : pointer to a SDIO_DataInitTypeDef structure that
+  *   contains the configuration information for the SDIO command.
+  * @retval None
+  */
+void SDIO_DataConfig(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
+{
+  uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_SDIO_DATA_LENGTH(SDIO_DataInitStruct->SDIO_DataLength));
+  assert_param(IS_SDIO_BLOCK_SIZE(SDIO_DataInitStruct->SDIO_DataBlockSize));
+  assert_param(IS_SDIO_TRANSFER_DIR(SDIO_DataInitStruct->SDIO_TransferDir));
+  assert_param(IS_SDIO_TRANSFER_MODE(SDIO_DataInitStruct->SDIO_TransferMode));
+  assert_param(IS_SDIO_DPSM(SDIO_DataInitStruct->SDIO_DPSM));
+
+/*---------------------------- SDIO DTIMER Configuration ---------------------*/
+  /* Set the SDIO Data TimeOut value */
+  SDIO->DTIMER = SDIO_DataInitStruct->SDIO_DataTimeOut;
+
+/*---------------------------- SDIO DLEN Configuration -----------------------*/
+  /* Set the SDIO DataLength value */
+  SDIO->DLEN = SDIO_DataInitStruct->SDIO_DataLength;
+
+/*---------------------------- SDIO DCTRL Configuration ----------------------*/
+  /* Get the SDIO DCTRL value */
+  tmpreg = SDIO->DCTRL;
+  /* Clear DEN, DTMODE, DTDIR and DBCKSIZE bits */
+  tmpreg &= DCTRL_CLEAR_MASK;
+  /* Set DEN bit according to SDIO_DPSM value */
+  /* Set DTMODE bit according to SDIO_TransferMode value */
+  /* Set DTDIR bit according to SDIO_TransferDir value */
+  /* Set DBCKSIZE bits according to SDIO_DataBlockSize value */
+  tmpreg |= (uint32_t)SDIO_DataInitStruct->SDIO_DataBlockSize | SDIO_DataInitStruct->SDIO_TransferDir
+           | SDIO_DataInitStruct->SDIO_TransferMode | SDIO_DataInitStruct->SDIO_DPSM;
+
+  /* Write to SDIO DCTRL */
+  SDIO->DCTRL = tmpreg;
+}
+
+/**
+  * @brief  Fills each SDIO_DataInitStruct member with its default value.
+  * @param  SDIO_DataInitStruct: pointer to an SDIO_DataInitTypeDef structure which
+  *         will be initialized.
+  * @retval None
+  */
+void SDIO_DataStructInit(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
+{
+  /* SDIO_DataInitStruct members default value */
+  SDIO_DataInitStruct->SDIO_DataTimeOut = 0xFFFFFFFF;
+  SDIO_DataInitStruct->SDIO_DataLength = 0x00;
+  SDIO_DataInitStruct->SDIO_DataBlockSize = SDIO_DataBlockSize_1b;
+  SDIO_DataInitStruct->SDIO_TransferDir = SDIO_TransferDir_ToCard;
+  SDIO_DataInitStruct->SDIO_TransferMode = SDIO_TransferMode_Block;
+  SDIO_DataInitStruct->SDIO_DPSM = SDIO_DPSM_Disable;
+}
+
+/**
+  * @brief  Returns number of remaining data bytes to be transferred.
+  * @param  None
+  * @retval Number of remaining data bytes to be transferred
+  */
+uint32_t SDIO_GetDataCounter(void)
+{
+  return SDIO->DCOUNT;
+}
+
+/**
+  * @brief  Read one data word from Rx FIFO.
+  * @param  None
+  * @retval Data received
+  */
+uint32_t SDIO_ReadData(void)
+{
+  return SDIO->FIFO;
+}
+
+/**
+  * @brief  Write one data word to Tx FIFO.
+  * @param  Data: 32-bit data word to write.
+  * @retval None
+  */
+void SDIO_WriteData(uint32_t Data)
+{
+  SDIO->FIFO = Data;
+}
+
+/**
+  * @brief  Returns the number of words left to be written to or read from FIFO.
+  * @param  None
+  * @retval Remaining number of words.
+  */
+uint32_t SDIO_GetFIFOCount(void)
+{
+  return SDIO->FIFOCNT;
+}
+
+/**
+  * @brief  Starts the SD I/O Read Wait operation.
+  * @param  NewState: new state of the Start SDIO Read Wait operation.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SDIO_StartSDIOReadWait(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(__IO uint32_t *) DCTRL_RWSTART_BB = (uint32_t) NewState;
+}
+
+/**
+  * @brief  Stops the SD I/O Read Wait operation.
+  * @param  NewState: new state of the Stop SDIO Read Wait operation.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SDIO_StopSDIOReadWait(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(__IO uint32_t *) DCTRL_RWSTOP_BB = (uint32_t) NewState;
+}
+
+/**
+  * @brief  Sets one of the two options of inserting read wait interval.
+  * @param  SDIO_ReadWaitMode: SD I/O Read Wait operation mode.
+  *   This parameter can be:
+  *     @arg SDIO_ReadWaitMode_CLK: Read Wait control by stopping SDIOCLK
+  *     @arg SDIO_ReadWaitMode_DATA2: Read Wait control using SDIO_DATA2
+  * @retval None
+  */
+void SDIO_SetSDIOReadWaitMode(uint32_t SDIO_ReadWaitMode)
+{
+  /* Check the parameters */
+  assert_param(IS_SDIO_READWAIT_MODE(SDIO_ReadWaitMode));
+
+  *(__IO uint32_t *) DCTRL_RWMOD_BB = SDIO_ReadWaitMode;
+}
+
+/**
+  * @brief  Enables or disables the SD I/O Mode Operation.
+  * @param  NewState: new state of SDIO specific operation.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SDIO_SetSDIOOperation(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(__IO uint32_t *) DCTRL_SDIOEN_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Enables or disables the SD I/O Mode suspend command sending.
+  * @param  NewState: new state of the SD I/O Mode suspend command.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SDIO_SendSDIOSuspendCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(__IO uint32_t *) CMD_SDIOSUSPEND_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Enables or disables the command completion signal.
+  * @param  NewState: new state of command completion signal.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SDIO_CommandCompletionCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(__IO uint32_t *) CMD_ENCMDCOMPL_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Enables or disables the CE-ATA interrupt.
+  * @param  NewState: new state of CE-ATA interrupt. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SDIO_CEATAITCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(__IO uint32_t *) CMD_NIEN_BB = (uint32_t)((~((uint32_t)NewState)) & ((uint32_t)0x1));
+}
+
+/**
+  * @brief  Sends CE-ATA command (CMD61).
+  * @param  NewState: new state of CE-ATA command. This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SDIO_SendCEATACmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(__IO uint32_t *) CMD_ATACMD_BB = (uint32_t)NewState;
+}
+
+/**
+  * @brief  Checks whether the specified SDIO flag is set or not.
+  * @param  SDIO_FLAG: specifies the flag to check.
+  *   This parameter can be one of the following values:
+  *     @arg SDIO_FLAG_CCRCFAIL: Command response received (CRC check failed)
+  *     @arg SDIO_FLAG_DCRCFAIL: Data block sent/received (CRC check failed)
+  *     @arg SDIO_FLAG_CTIMEOUT: Command response timeout
+  *     @arg SDIO_FLAG_DTIMEOUT: Data timeout
+  *     @arg SDIO_FLAG_TXUNDERR: Transmit FIFO underrun error
+  *     @arg SDIO_FLAG_RXOVERR:  Received FIFO overrun error
+  *     @arg SDIO_FLAG_CMDREND:  Command response received (CRC check passed)
+  *     @arg SDIO_FLAG_CMDSENT:  Command sent (no response required)
+  *     @arg SDIO_FLAG_DATAEND:  Data end (data counter, SDIDCOUNT, is zero)
+  *     @arg SDIO_FLAG_STBITERR: Start bit not detected on all data signals in wide
+  *                              bus mode.
+  *     @arg SDIO_FLAG_DBCKEND:  Data block sent/received (CRC check passed)
+  *     @arg SDIO_FLAG_CMDACT:   Command transfer in progress
+  *     @arg SDIO_FLAG_TXACT:    Data transmit in progress
+  *     @arg SDIO_FLAG_RXACT:    Data receive in progress
+  *     @arg SDIO_FLAG_TXFIFOHE: Transmit FIFO Half Empty
+  *     @arg SDIO_FLAG_RXFIFOHF: Receive FIFO Half Full
+  *     @arg SDIO_FLAG_TXFIFOF:  Transmit FIFO full
+  *     @arg SDIO_FLAG_RXFIFOF:  Receive FIFO full
+  *     @arg SDIO_FLAG_TXFIFOE:  Transmit FIFO empty
+  *     @arg SDIO_FLAG_RXFIFOE:  Receive FIFO empty
+  *     @arg SDIO_FLAG_TXDAVL:   Data available in transmit FIFO
+  *     @arg SDIO_FLAG_RXDAVL:   Data available in receive FIFO
+  *     @arg SDIO_FLAG_SDIOIT:   SD I/O interrupt received
+  *     @arg SDIO_FLAG_CEATAEND: CE-ATA command completion signal received for CMD61
+  * @retval The new state of SDIO_FLAG (SET or RESET).
+  */
+FlagStatus SDIO_GetFlagStatus(uint32_t SDIO_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+
+  /* Check the parameters */
+  assert_param(IS_SDIO_FLAG(SDIO_FLAG));
+
+  if ((SDIO->STA & SDIO_FLAG) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the SDIO's pending flags.
+  * @param  SDIO_FLAG: specifies the flag to clear.
+  *   This parameter can be one or a combination of the following values:
+  *     @arg SDIO_FLAG_CCRCFAIL: Command response received (CRC check failed)
+  *     @arg SDIO_FLAG_DCRCFAIL: Data block sent/received (CRC check failed)
+  *     @arg SDIO_FLAG_CTIMEOUT: Command response timeout
+  *     @arg SDIO_FLAG_DTIMEOUT: Data timeout
+  *     @arg SDIO_FLAG_TXUNDERR: Transmit FIFO underrun error
+  *     @arg SDIO_FLAG_RXOVERR:  Received FIFO overrun error
+  *     @arg SDIO_FLAG_CMDREND:  Command response received (CRC check passed)
+  *     @arg SDIO_FLAG_CMDSENT:  Command sent (no response required)
+  *     @arg SDIO_FLAG_DATAEND:  Data end (data counter, SDIDCOUNT, is zero)
+  *     @arg SDIO_FLAG_STBITERR: Start bit not detected on all data signals in wide
+  *                              bus mode
+  *     @arg SDIO_FLAG_DBCKEND:  Data block sent/received (CRC check passed)
+  *     @arg SDIO_FLAG_SDIOIT:   SD I/O interrupt received
+  *     @arg SDIO_FLAG_CEATAEND: CE-ATA command completion signal received for CMD61
+  * @retval None
+  */
+void SDIO_ClearFlag(uint32_t SDIO_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_SDIO_CLEAR_FLAG(SDIO_FLAG));
+
+  SDIO->ICR = SDIO_FLAG;
+}
+
+/**
+  * @brief  Checks whether the specified SDIO interrupt has occurred or not.
+  * @param  SDIO_IT: specifies the SDIO interrupt source to check.
+  *   This parameter can be one of the following values:
+  *     @arg SDIO_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
+  *     @arg SDIO_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
+  *     @arg SDIO_IT_CTIMEOUT: Command response timeout interrupt
+  *     @arg SDIO_IT_DTIMEOUT: Data timeout interrupt
+  *     @arg SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt
+  *     @arg SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt
+  *     @arg SDIO_IT_CMDREND:  Command response received (CRC check passed) interrupt
+  *     @arg SDIO_IT_CMDSENT:  Command sent (no response required) interrupt
+  *     @arg SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is zero) interrupt
+  *     @arg SDIO_IT_STBITERR: Start bit not detected on all data signals in wide
+  *                            bus mode interrupt
+  *     @arg SDIO_IT_DBCKEND:  Data block sent/received (CRC check passed) interrupt
+  *     @arg SDIO_IT_CMDACT:   Command transfer in progress interrupt
+  *     @arg SDIO_IT_TXACT:    Data transmit in progress interrupt
+  *     @arg SDIO_IT_RXACT:    Data receive in progress interrupt
+  *     @arg SDIO_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt
+  *     @arg SDIO_IT_RXFIFOHF: Receive FIFO Half Full interrupt
+  *     @arg SDIO_IT_TXFIFOF:  Transmit FIFO full interrupt
+  *     @arg SDIO_IT_RXFIFOF:  Receive FIFO full interrupt
+  *     @arg SDIO_IT_TXFIFOE:  Transmit FIFO empty interrupt
+  *     @arg SDIO_IT_RXFIFOE:  Receive FIFO empty interrupt
+  *     @arg SDIO_IT_TXDAVL:   Data available in transmit FIFO interrupt
+  *     @arg SDIO_IT_RXDAVL:   Data available in receive FIFO interrupt
+  *     @arg SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt
+  *     @arg SDIO_IT_CEATAEND: CE-ATA command completion signal received for CMD61 interrupt
+  * @retval The new state of SDIO_IT (SET or RESET).
+  */
+ITStatus SDIO_GetITStatus(uint32_t SDIO_IT)
+{
+  ITStatus bitstatus = RESET;
+
+  /* Check the parameters */
+  assert_param(IS_SDIO_GET_IT(SDIO_IT));
+  if ((SDIO->STA & SDIO_IT) != (uint32_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the SDIO's interrupt pending bits.
+  * @param  SDIO_IT: specifies the interrupt pending bit to clear.
+  *   This parameter can be one or a combination of the following values:
+  *     @arg SDIO_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
+  *     @arg SDIO_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
+  *     @arg SDIO_IT_CTIMEOUT: Command response timeout interrupt
+  *     @arg SDIO_IT_DTIMEOUT: Data timeout interrupt
+  *     @arg SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt
+  *     @arg SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt
+  *     @arg SDIO_IT_CMDREND:  Command response received (CRC check passed) interrupt
+  *     @arg SDIO_IT_CMDSENT:  Command sent (no response required) interrupt
+  *     @arg SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is zero) interrupt
+  *     @arg SDIO_IT_STBITERR: Start bit not detected on all data signals in wide
+  *                            bus mode interrupt
+  *     @arg SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt
+  *     @arg SDIO_IT_CEATAEND: CE-ATA command completion signal received for CMD61
+  * @retval None
+  */
+void SDIO_ClearITPendingBit(uint32_t SDIO_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_SDIO_CLEAR_IT(SDIO_IT));
+
+  SDIO->ICR = SDIO_IT;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_spi.c b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_spi.c
new file mode 100644
index 0000000..51a9cce
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_spi.c
@@ -0,0 +1,908 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_spi.c
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file provides all the SPI firmware functions.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x_spi.h"
+#include "stm32f10x_rcc.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup SPI
+  * @brief SPI driver modules
+  * @{
+  */
+
+/** @defgroup SPI_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+
+/** @defgroup SPI_Private_Defines
+  * @{
+  */
+
+/* SPI SPE mask */
+#define CR1_SPE_Set          ((uint16_t)0x0040)
+#define CR1_SPE_Reset        ((uint16_t)0xFFBF)
+
+/* I2S I2SE mask */
+#define I2SCFGR_I2SE_Set     ((uint16_t)0x0400)
+#define I2SCFGR_I2SE_Reset   ((uint16_t)0xFBFF)
+
+/* SPI CRCNext mask */
+#define CR1_CRCNext_Set      ((uint16_t)0x1000)
+
+/* SPI CRCEN mask */
+#define CR1_CRCEN_Set        ((uint16_t)0x2000)
+#define CR1_CRCEN_Reset      ((uint16_t)0xDFFF)
+
+/* SPI SSOE mask */
+#define CR2_SSOE_Set         ((uint16_t)0x0004)
+#define CR2_SSOE_Reset       ((uint16_t)0xFFFB)
+
+/* SPI registers Masks */
+#define CR1_CLEAR_Mask       ((uint16_t)0x3040)
+#define I2SCFGR_CLEAR_Mask   ((uint16_t)0xF040)
+
+/* SPI or I2S mode selection masks */
+#define SPI_Mode_Select      ((uint16_t)0xF7FF)
+#define I2S_Mode_Select      ((uint16_t)0x0800)
+
+/* I2S clock source selection masks */
+#define I2S2_CLOCK_SRC       ((uint32_t)(0x00020000))
+#define I2S3_CLOCK_SRC       ((uint32_t)(0x00040000))
+#define I2S_MUL_MASK         ((uint32_t)(0x0000F000))
+#define I2S_DIV_MASK         ((uint32_t)(0x000000F0))
+
+/**
+  * @}
+  */
+
+/** @defgroup SPI_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup SPI_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup SPI_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup SPI_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the SPIx peripheral registers to their default
+  *         reset values (Affects also the I2Ss).
+  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+  * @retval None
+  */
+void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+
+  if (SPIx == SPI1)
+  {
+    /* Enable SPI1 reset state */
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
+    /* Release SPI1 from reset state */
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
+  }
+  else if (SPIx == SPI2)
+  {
+    /* Enable SPI2 reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
+    /* Release SPI2 from reset state */
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
+  }
+  else
+  {
+    if (SPIx == SPI3)
+    {
+      /* Enable SPI3 reset state */
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
+      /* Release SPI3 from reset state */
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
+    }
+  }
+}
+
+/**
+  * @brief  Initializes the SPIx peripheral according to the specified
+  *         parameters in the SPI_InitStruct.
+  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+  * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
+  *         contains the configuration information for the specified SPI peripheral.
+  * @retval None
+  */
+void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
+{
+  uint16_t tmpreg = 0;
+
+  /* check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+
+  /* Check the SPI parameters */
+  assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
+  assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
+  assert_param(IS_SPI_DATASIZE(SPI_InitStruct->SPI_DataSize));
+  assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
+  assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
+  assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
+  assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
+  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
+  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));
+
+/*---------------------------- SPIx CR1 Configuration ------------------------*/
+  /* Get the SPIx CR1 value */
+  tmpreg = SPIx->CR1;
+  /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
+  tmpreg &= CR1_CLEAR_Mask;
+  /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
+     master/salve mode, CPOL and CPHA */
+  /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
+  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
+  /* Set LSBFirst bit according to SPI_FirstBit value */
+  /* Set BR bits according to SPI_BaudRatePrescaler value */
+  /* Set CPOL bit according to SPI_CPOL value */
+  /* Set CPHA bit according to SPI_CPHA value */
+  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
+                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |
+                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |
+                  SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
+  /* Write to SPIx CR1 */
+  SPIx->CR1 = tmpreg;
+
+  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
+  SPIx->I2SCFGR &= SPI_Mode_Select;
+
+/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
+  /* Write to SPIx CRCPOLY */
+  SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
+}
+
+/**
+  * @brief  Initializes the SPIx peripheral according to the specified
+  *         parameters in the I2S_InitStruct.
+  * @param  SPIx: where x can be  2 or 3 to select the SPI peripheral
+  *         (configured in I2S mode).
+  * @param  I2S_InitStruct: pointer to an I2S_InitTypeDef structure that
+  *         contains the configuration information for the specified SPI peripheral
+  *         configured in I2S mode.
+  * @note
+  *  The function calculates the optimal prescaler needed to obtain the most
+  *  accurate audio frequency (depending on the I2S clock source, the PLL values
+  *  and the product configuration). But in case the prescaler value is greater
+  *  than 511, the default value (0x02) will be configured instead.  *
+  * @retval None
+  */
+void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
+{
+  uint16_t tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
+  uint32_t tmp = 0;
+  RCC_ClocksTypeDef RCC_Clocks;
+  uint32_t sourceclock = 0;
+
+  /* Check the I2S parameters */
+  assert_param(IS_SPI_23_PERIPH(SPIx));
+  assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
+  assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
+  assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
+  assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct->I2S_MCLKOutput));
+  assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
+  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));
+
+/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
+  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
+  SPIx->I2SCFGR &= I2SCFGR_CLEAR_Mask;
+  SPIx->I2SPR = 0x0002;
+
+  /* Get the I2SCFGR register value */
+  tmpreg = SPIx->I2SCFGR;
+
+  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
+  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
+  {
+    i2sodd = (uint16_t)0;
+    i2sdiv = (uint16_t)2;
+  }
+  /* If the requested audio frequency is not the default, compute the prescaler */
+  else
+  {
+    /* Check the frame length (For the Prescaler computing) */
+    if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
+    {
+      /* Packet length is 16 bits */
+      packetlength = 1;
+    }
+    else
+    {
+      /* Packet length is 32 bits */
+      packetlength = 2;
+    }
+
+    /* Get the I2S clock source mask depending on the peripheral number */
+    if(((uint32_t)SPIx) == SPI2_BASE)
+    {
+      /* The mask is relative to I2S2 */
+      tmp = I2S2_CLOCK_SRC;
+    }
+    else
+    {
+      /* The mask is relative to I2S3 */
+      tmp = I2S3_CLOCK_SRC;
+    }
+
+    /* Check the I2S clock source configuration depending on the Device:
+       Only Connectivity line devices have the PLL3 VCO clock */
+#ifdef STM32F10X_CL
+    if((RCC->CFGR2 & tmp) != 0)
+    {
+      /* Get the configuration bits of RCC PLL3 multiplier */
+      tmp = (uint32_t)((RCC->CFGR2 & I2S_MUL_MASK) >> 12);
+
+      /* Get the value of the PLL3 multiplier */
+      if((tmp > 5) && (tmp < 15))
+      {
+        /* Multiplier is between 8 and 14 (value 15 is forbidden) */
+        tmp += 2;
+      }
+      else
+      {
+        if (tmp == 15)
+        {
+          /* Multiplier is 20 */
+          tmp = 20;
+        }
+      }
+      /* Get the PREDIV2 value */
+      sourceclock = (uint32_t)(((RCC->CFGR2 & I2S_DIV_MASK) >> 4) + 1);
+
+      /* Calculate the Source Clock frequency based on PLL3 and PREDIV2 values */
+      sourceclock = (uint32_t) ((HSE_Value / sourceclock) * tmp * 2);
+    }
+    else
+    {
+      /* I2S Clock source is System clock: Get System Clock frequency */
+      RCC_GetClocksFreq(&RCC_Clocks);
+
+      /* Get the source clock value: based on System Clock value */
+      sourceclock = RCC_Clocks.SYSCLK_Frequency;
+    }
+#else /* STM32F10X_HD */
+    /* I2S Clock source is System clock: Get System Clock frequency */
+    RCC_GetClocksFreq(&RCC_Clocks);
+
+    /* Get the source clock value: based on System Clock value */
+    sourceclock = RCC_Clocks.SYSCLK_Frequency;
+#endif /* STM32F10X_CL */
+
+    /* Compute the Real divider depending on the MCLK output state with a floating point */
+    if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
+    {
+      /* MCLK output is enabled */
+      tmp = (uint16_t)(((((sourceclock / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
+    }
+    else
+    {
+      /* MCLK output is disabled */
+      tmp = (uint16_t)(((((sourceclock / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
+    }
+
+    /* Remove the floating point */
+    tmp = tmp / 10;
+
+    /* Check the parity of the divider */
+    i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
+
+    /* Compute the i2sdiv prescaler */
+    i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
+
+    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
+    i2sodd = (uint16_t) (i2sodd << 8);
+  }
+
+  /* Test if the divider is 1 or 0 or greater than 0xFF */
+  if ((i2sdiv < 2) || (i2sdiv > 0xFF))
+  {
+    /* Set the default values */
+    i2sdiv = 2;
+    i2sodd = 0;
+  }
+
+  /* Write to SPIx I2SPR register the computed value */
+  SPIx->I2SPR = (uint16_t)(i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
+
+  /* Configure the I2S with the SPI_InitStruct values */
+  tmpreg |= (uint16_t)(I2S_Mode_Select | (uint16_t)(I2S_InitStruct->I2S_Mode | \
+                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
+                  (uint16_t)I2S_InitStruct->I2S_CPOL))));
+
+  /* Write to SPIx I2SCFGR */
+  SPIx->I2SCFGR = tmpreg;
+}
+
+/**
+  * @brief  Fills each SPI_InitStruct member with its default value.
+  * @param  SPI_InitStruct : pointer to a SPI_InitTypeDef structure which will be initialized.
+  * @retval None
+  */
+void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
+{
+/*--------------- Reset SPI init structure parameters values -----------------*/
+  /* Initialize the SPI_Direction member */
+  SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
+  /* initialize the SPI_Mode member */
+  SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
+  /* initialize the SPI_DataSize member */
+  SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
+  /* Initialize the SPI_CPOL member */
+  SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
+  /* Initialize the SPI_CPHA member */
+  SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
+  /* Initialize the SPI_NSS member */
+  SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
+  /* Initialize the SPI_BaudRatePrescaler member */
+  SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
+  /* Initialize the SPI_FirstBit member */
+  SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
+  /* Initialize the SPI_CRCPolynomial member */
+  SPI_InitStruct->SPI_CRCPolynomial = 7;
+}
+
+/**
+  * @brief  Fills each I2S_InitStruct member with its default value.
+  * @param  I2S_InitStruct : pointer to a I2S_InitTypeDef structure which will be initialized.
+  * @retval None
+  */
+void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
+{
+/*--------------- Reset I2S init structure parameters values -----------------*/
+  /* Initialize the I2S_Mode member */
+  I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
+
+  /* Initialize the I2S_Standard member */
+  I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
+
+  /* Initialize the I2S_DataFormat member */
+  I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
+
+  /* Initialize the I2S_MCLKOutput member */
+  I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
+
+  /* Initialize the I2S_AudioFreq member */
+  I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
+
+  /* Initialize the I2S_CPOL member */
+  I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
+}
+
+/**
+  * @brief  Enables or disables the specified SPI peripheral.
+  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+  * @param  NewState: new state of the SPIx peripheral.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected SPI peripheral */
+    SPIx->CR1 |= CR1_SPE_Set;
+  }
+  else
+  {
+    /* Disable the selected SPI peripheral */
+    SPIx->CR1 &= CR1_SPE_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified SPI peripheral (in I2S mode).
+  * @param  SPIx: where x can be 2 or 3 to select the SPI peripheral.
+  * @param  NewState: new state of the SPIx peripheral.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_23_PERIPH(SPIx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected SPI peripheral (in I2S mode) */
+    SPIx->I2SCFGR |= I2SCFGR_I2SE_Set;
+  }
+  else
+  {
+    /* Disable the selected SPI peripheral (in I2S mode) */
+    SPIx->I2SCFGR &= I2SCFGR_I2SE_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified SPI/I2S interrupts.
+  * @param  SPIx: where x can be
+  *   - 1, 2 or 3 in SPI mode
+  *   - 2 or 3 in I2S mode
+  * @param  SPI_I2S_IT: specifies the SPI/I2S interrupt source to be enabled or disabled.
+  *   This parameter can be one of the following values:
+  *     @arg SPI_I2S_IT_TXE: Tx buffer empty interrupt mask
+  *     @arg SPI_I2S_IT_RXNE: Rx buffer not empty interrupt mask
+  *     @arg SPI_I2S_IT_ERR: Error interrupt mask
+  * @param  NewState: new state of the specified SPI/I2S interrupt.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)
+{
+  uint16_t itpos = 0, itmask = 0 ;
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
+
+  /* Get the SPI/I2S IT index */
+  itpos = SPI_I2S_IT >> 4;
+
+  /* Set the IT mask */
+  itmask = (uint16_t)1 << (uint16_t)itpos;
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected SPI/I2S interrupt */
+    SPIx->CR2 |= itmask;
+  }
+  else
+  {
+    /* Disable the selected SPI/I2S interrupt */
+    SPIx->CR2 &= (uint16_t)~itmask;
+  }
+}
+
+/**
+  * @brief  Enables or disables the SPIx/I2Sx DMA interface.
+  * @param  SPIx: where x can be
+  *   - 1, 2 or 3 in SPI mode
+  *   - 2 or 3 in I2S mode
+  * @param  SPI_I2S_DMAReq: specifies the SPI/I2S DMA transfer request to be enabled or disabled.
+  *   This parameter can be any combination of the following values:
+  *     @arg SPI_I2S_DMAReq_Tx: Tx buffer DMA transfer request
+  *     @arg SPI_I2S_DMAReq_Rx: Rx buffer DMA transfer request
+  * @param  NewState: new state of the selected SPI/I2S DMA transfer request.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected SPI/I2S DMA requests */
+    SPIx->CR2 |= SPI_I2S_DMAReq;
+  }
+  else
+  {
+    /* Disable the selected SPI/I2S DMA requests */
+    SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
+  }
+}
+
+/**
+  * @brief  Transmits a Data through the SPIx/I2Sx peripheral.
+  * @param  SPIx: where x can be
+  *   - 1, 2 or 3 in SPI mode
+  *   - 2 or 3 in I2S mode
+  * @param  Data : Data to be transmitted.
+  * @retval None
+  */
+void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+
+  /* Write in the DR register the data to be sent */
+  SPIx->DR = Data;
+}
+
+/**
+  * @brief  Returns the most recent received data by the SPIx/I2Sx peripheral.
+  * @param  SPIx: where x can be
+  *   - 1, 2 or 3 in SPI mode
+  *   - 2 or 3 in I2S mode
+  * @retval The value of the received data.
+  */
+uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+
+  /* Return the data in the DR register */
+  return SPIx->DR;
+}
+
+/**
+  * @brief  Configures internally by software the NSS pin for the selected SPI.
+  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+  * @param  SPI_NSSInternalSoft: specifies the SPI NSS internal state.
+  *   This parameter can be one of the following values:
+  *     @arg SPI_NSSInternalSoft_Set: Set NSS pin internally
+  *     @arg SPI_NSSInternalSoft_Reset: Reset NSS pin internally
+  * @retval None
+  */
+void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
+  if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
+  {
+    /* Set NSS pin internally by software */
+    SPIx->CR1 |= SPI_NSSInternalSoft_Set;
+  }
+  else
+  {
+    /* Reset NSS pin internally by software */
+    SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the SS output for the selected SPI.
+  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+  * @param  NewState: new state of the SPIx SS output.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected SPI SS output */
+    SPIx->CR2 |= CR2_SSOE_Set;
+  }
+  else
+  {
+    /* Disable the selected SPI SS output */
+    SPIx->CR2 &= CR2_SSOE_Reset;
+  }
+}
+
+/**
+  * @brief  Configures the data size for the selected SPI.
+  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+  * @param  SPI_DataSize: specifies the SPI data size.
+  *   This parameter can be one of the following values:
+  *     @arg SPI_DataSize_16b: Set data frame format to 16bit
+  *     @arg SPI_DataSize_8b: Set data frame format to 8bit
+  * @retval None
+  */
+void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_SPI_DATASIZE(SPI_DataSize));
+  /* Clear DFF bit */
+  SPIx->CR1 &= (uint16_t)~SPI_DataSize_16b;
+  /* Set new DFF bit value */
+  SPIx->CR1 |= SPI_DataSize;
+}
+
+/**
+  * @brief  Transmit the SPIx CRC value.
+  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+  * @retval None
+  */
+void SPI_TransmitCRC(SPI_TypeDef* SPIx)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+
+  /* Enable the selected SPI CRC transmission */
+  SPIx->CR1 |= CR1_CRCNext_Set;
+}
+
+/**
+  * @brief  Enables or disables the CRC value calculation of the transferred bytes.
+  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+  * @param  NewState: new state of the SPIx CRC value calculation.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected SPI CRC calculation */
+    SPIx->CR1 |= CR1_CRCEN_Set;
+  }
+  else
+  {
+    /* Disable the selected SPI CRC calculation */
+    SPIx->CR1 &= CR1_CRCEN_Reset;
+  }
+}
+
+/**
+  * @brief  Returns the transmit or the receive CRC register value for the specified SPI.
+  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+  * @param  SPI_CRC: specifies the CRC register to be read.
+  *   This parameter can be one of the following values:
+  *     @arg SPI_CRC_Tx: Selects Tx CRC register
+  *     @arg SPI_CRC_Rx: Selects Rx CRC register
+  * @retval The selected CRC register value..
+  */
+uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC)
+{
+  uint16_t crcreg = 0;
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_SPI_CRC(SPI_CRC));
+  if (SPI_CRC != SPI_CRC_Rx)
+  {
+    /* Get the Tx CRC register */
+    crcreg = SPIx->TXCRCR;
+  }
+  else
+  {
+    /* Get the Rx CRC register */
+    crcreg = SPIx->RXCRCR;
+  }
+  /* Return the selected CRC register */
+  return crcreg;
+}
+
+/**
+  * @brief  Returns the CRC Polynomial register value for the specified SPI.
+  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+  * @retval The CRC Polynomial register value.
+  */
+uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+
+  /* Return the CRC polynomial register */
+  return SPIx->CRCPR;
+}
+
+/**
+  * @brief  Selects the data transfer direction in bi-directional mode for the specified SPI.
+  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+  * @param  SPI_Direction: specifies the data transfer direction in bi-directional mode.
+  *   This parameter can be one of the following values:
+  *     @arg SPI_Direction_Tx: Selects Tx transmission direction
+  *     @arg SPI_Direction_Rx: Selects Rx receive direction
+  * @retval None
+  */
+void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_SPI_DIRECTION(SPI_Direction));
+  if (SPI_Direction == SPI_Direction_Tx)
+  {
+    /* Set the Tx only mode */
+    SPIx->CR1 |= SPI_Direction_Tx;
+  }
+  else
+  {
+    /* Set the Rx only mode */
+    SPIx->CR1 &= SPI_Direction_Rx;
+  }
+}
+
+/**
+  * @brief  Checks whether the specified SPI/I2S flag is set or not.
+  * @param  SPIx: where x can be
+  *   - 1, 2 or 3 in SPI mode
+  *   - 2 or 3 in I2S mode
+  * @param  SPI_I2S_FLAG: specifies the SPI/I2S flag to check.
+  *   This parameter can be one of the following values:
+  *     @arg SPI_I2S_FLAG_TXE: Transmit buffer empty flag.
+  *     @arg SPI_I2S_FLAG_RXNE: Receive buffer not empty flag.
+  *     @arg SPI_I2S_FLAG_BSY: Busy flag.
+  *     @arg SPI_I2S_FLAG_OVR: Overrun flag.
+  *     @arg SPI_FLAG_MODF: Mode Fault flag.
+  *     @arg SPI_FLAG_CRCERR: CRC Error flag.
+  *     @arg I2S_FLAG_UDR: Underrun Error flag.
+  *     @arg I2S_FLAG_CHSIDE: Channel Side flag.
+  * @retval The new state of SPI_I2S_FLAG (SET or RESET).
+  */
+FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
+  /* Check the status of the specified SPI/I2S flag */
+  if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
+  {
+    /* SPI_I2S_FLAG is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* SPI_I2S_FLAG is reset */
+    bitstatus = RESET;
+  }
+  /* Return the SPI_I2S_FLAG status */
+  return  bitstatus;
+}
+
+/**
+  * @brief  Clears the SPIx CRC Error (CRCERR) flag.
+  * @param  SPIx: where x can be
+  *   - 1, 2 or 3 in SPI mode
+  * @param  SPI_I2S_FLAG: specifies the SPI flag to clear.
+  *   This function clears only CRCERR flag.
+  * @note
+  *   - OVR (OverRun error) flag is cleared by software sequence: a read
+  *     operation to SPI_DR register (SPI_I2S_ReceiveData()) followed by a read
+  *     operation to SPI_SR register (SPI_I2S_GetFlagStatus()).
+  *   - UDR (UnderRun error) flag is cleared by a read operation to
+  *     SPI_SR register (SPI_I2S_GetFlagStatus()).
+  *   - MODF (Mode Fault) flag is cleared by software sequence: a read/write
+  *     operation to SPI_SR register (SPI_I2S_GetFlagStatus()) followed by a
+  *     write operation to SPI_CR1 register (SPI_Cmd() to enable the SPI).
+  * @retval None
+  */
+void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
+
+    /* Clear the selected SPI CRC Error (CRCERR) flag */
+    SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
+}
+
+/**
+  * @brief  Checks whether the specified SPI/I2S interrupt has occurred or not.
+  * @param  SPIx: where x can be
+  *   - 1, 2 or 3 in SPI mode
+  *   - 2 or 3 in I2S mode
+  * @param  SPI_I2S_IT: specifies the SPI/I2S interrupt source to check.
+  *   This parameter can be one of the following values:
+  *     @arg SPI_I2S_IT_TXE: Transmit buffer empty interrupt.
+  *     @arg SPI_I2S_IT_RXNE: Receive buffer not empty interrupt.
+  *     @arg SPI_I2S_IT_OVR: Overrun interrupt.
+  *     @arg SPI_IT_MODF: Mode Fault interrupt.
+  *     @arg SPI_IT_CRCERR: CRC Error interrupt.
+  *     @arg I2S_IT_UDR: Underrun Error interrupt.
+  * @retval The new state of SPI_I2S_IT (SET or RESET).
+  */
+ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
+{
+  ITStatus bitstatus = RESET;
+  uint16_t itpos = 0, itmask = 0, enablestatus = 0;
+
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
+
+  /* Get the SPI/I2S IT index */
+  itpos = 0x01 << (SPI_I2S_IT & 0x0F);
+
+  /* Get the SPI/I2S IT mask */
+  itmask = SPI_I2S_IT >> 4;
+
+  /* Set the IT mask */
+  itmask = 0x01 << itmask;
+
+  /* Get the SPI_I2S_IT enable bit status */
+  enablestatus = (SPIx->CR2 & itmask) ;
+
+  /* Check the status of the specified SPI/I2S interrupt */
+  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
+  {
+    /* SPI_I2S_IT is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* SPI_I2S_IT is reset */
+    bitstatus = RESET;
+  }
+  /* Return the SPI_I2S_IT status */
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the SPIx CRC Error (CRCERR) interrupt pending bit.
+  * @param  SPIx: where x can be
+  *   - 1, 2 or 3 in SPI mode
+  * @param  SPI_I2S_IT: specifies the SPI interrupt pending bit to clear.
+  *   This function clears only CRCERR interrupt pending bit.
+  * @note
+  *   - OVR (OverRun Error) interrupt pending bit is cleared by software
+  *     sequence: a read operation to SPI_DR register (SPI_I2S_ReceiveData())
+  *     followed by a read operation to SPI_SR register (SPI_I2S_GetITStatus()).
+  *   - UDR (UnderRun Error) interrupt pending bit is cleared by a read
+  *     operation to SPI_SR register (SPI_I2S_GetITStatus()).
+  *   - MODF (Mode Fault) interrupt pending bit is cleared by software sequence:
+  *     a read/write operation to SPI_SR register (SPI_I2S_GetITStatus())
+  *     followed by a write operation to SPI_CR1 register (SPI_Cmd() to enable
+  *     the SPI).
+  * @retval None
+  */
+void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
+{
+  uint16_t itpos = 0;
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));
+
+  /* Get the SPI IT index */
+  itpos = 0x01 << (SPI_I2S_IT & 0x0F);
+
+  /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
+  SPIx->SR = (uint16_t)~itpos;
+}
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_tim.c b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_tim.c
new file mode 100644
index 0000000..81c8484
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_tim.c
@@ -0,0 +1,2890 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_tim.c
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file provides all the TIM firmware functions.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x_tim.h"
+#include "stm32f10x_rcc.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup TIM
+  * @brief TIM driver modules
+  * @{
+  */
+
+/** @defgroup TIM_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Private_Defines
+  * @{
+  */
+
+/* ---------------------- TIM registers bit mask ------------------------ */
+#define SMCR_ETR_Mask               ((uint16_t)0x00FF)
+#define CCMR_Offset                 ((uint16_t)0x0018)
+#define CCER_CCE_Set                ((uint16_t)0x0001)
+#define	CCER_CCNE_Set               ((uint16_t)0x0004)
+
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Private_FunctionPrototypes
+  * @{
+  */
+
+static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
+                       uint16_t TIM_ICFilter);
+static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
+                       uint16_t TIM_ICFilter);
+static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
+                       uint16_t TIM_ICFilter);
+static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
+                       uint16_t TIM_ICFilter);
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup TIM_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the TIMx peripheral registers to their default reset values.
+  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
+  * @retval None
+  */
+void TIM_DeInit(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+
+  if (TIMx == TIM1)
+  {
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);
+  }
+  else if (TIMx == TIM2)
+  {
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
+  }
+  else if (TIMx == TIM3)
+  {
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
+  }
+  else if (TIMx == TIM4)
+  {
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
+  }
+  else if (TIMx == TIM5)
+  {
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
+  }
+  else if (TIMx == TIM6)
+  {
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
+  }
+  else if (TIMx == TIM7)
+  {
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
+  }
+  else if (TIMx == TIM8)
+  {
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);
+  }
+  else if (TIMx == TIM9)
+  {
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);
+   }
+  else if (TIMx == TIM10)
+  {
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);
+  }
+  else if (TIMx == TIM11)
+  {
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);
+  }
+  else if (TIMx == TIM12)
+  {
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);
+  }
+  else if (TIMx == TIM13)
+  {
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);
+  }
+  else if (TIMx == TIM14)
+  {
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE);
+  }
+  else if (TIMx == TIM15)
+  {
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, ENABLE);
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, DISABLE);
+  }
+  else if (TIMx == TIM16)
+  {
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, ENABLE);
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, DISABLE);
+  }
+  else
+  {
+    if (TIMx == TIM17)
+    {
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, ENABLE);
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, DISABLE);
+    }
+  }
+}
+
+/**
+  * @brief  Initializes the TIMx Time Base Unit peripheral according to
+  *         the specified parameters in the TIM_TimeBaseInitStruct.
+  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
+  * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef
+  *         structure that contains the configuration information for the
+  *         specified TIM peripheral.
+  * @retval None
+  */
+void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
+{
+  uint16_t tmpcr1 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
+  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
+
+  tmpcr1 = TIMx->CR1;
+
+  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
+     (TIMx == TIM4) || (TIMx == TIM5))
+  {
+    /* Select the Counter Mode */
+    tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
+    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
+  }
+
+  if((TIMx != TIM6) && (TIMx != TIM7))
+  {
+    /* Set the clock division */
+    tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
+    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
+  }
+
+  TIMx->CR1 = tmpcr1;
+
+  /* Set the Autoreload value */
+  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
+
+  /* Set the Prescaler value */
+  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
+
+  if ((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)|| (TIMx == TIM16) || (TIMx == TIM17))
+  {
+    /* Set the Repetition Counter value */
+    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
+  }
+
+  /* Generate an update event to reload the Prescaler and the Repetition counter
+     values immediately */
+  TIMx->EGR = TIM_PSCReloadMode_Immediate;
+}
+
+/**
+  * @brief  Initializes the TIMx Channel1 according to the specified
+  *         parameters in the TIM_OCInitStruct.
+  * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.
+  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
+  *         that contains the configuration information for the specified TIM peripheral.
+  * @retval None
+  */
+void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
+{
+  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
+  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
+  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));
+ /* Disable the Channel 1: Reset the CC1E Bit */
+  TIMx->CCER &= (uint16_t)(~(uint16_t)TIM_CCER_CC1E);
+  /* Get the TIMx CCER register value */
+  tmpccer = TIMx->CCER;
+  /* Get the TIMx CR2 register value */
+  tmpcr2 =  TIMx->CR2;
+
+  /* Get the TIMx CCMR1 register value */
+  tmpccmrx = TIMx->CCMR1;
+
+  /* Reset the Output Compare Mode Bits */
+  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC1M));
+  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC1S));
+
+  /* Select the Output Compare Mode */
+  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
+
+  /* Reset the Output Polarity level */
+  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1P));
+  /* Set the Output Compare Polarity */
+  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
+
+  /* Set the Output State */
+  tmpccer |= TIM_OCInitStruct->TIM_OutputState;
+
+  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)||
+     (TIMx == TIM16)|| (TIMx == TIM17))
+  {
+    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
+    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
+    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
+    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
+
+    /* Reset the Output N Polarity level */
+    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NP));
+    /* Set the Output N Polarity */
+    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
+
+    /* Reset the Output N State */
+    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NE));
+    /* Set the Output N State */
+    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
+
+    /* Reset the Output Compare and Output Compare N IDLE State */
+    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1));
+    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1N));
+
+    /* Set the Output Idle state */
+    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
+    /* Set the Output N Idle state */
+    tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
+  }
+  /* Write to TIMx CR2 */
+  TIMx->CR2 = tmpcr2;
+
+  /* Write to TIMx CCMR1 */
+  TIMx->CCMR1 = tmpccmrx;
+
+  /* Set the Capture Compare Register value */
+  TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
+
+  /* Write to TIMx CCER */
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @brief  Initializes the TIMx Channel2 according to the specified
+  *         parameters in the TIM_OCInitStruct.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select
+  *         the TIM peripheral.
+  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
+  *         that contains the configuration information for the specified TIM peripheral.
+  * @retval None
+  */
+void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
+{
+  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
+  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
+  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));
+   /* Disable the Channel 2: Reset the CC2E Bit */
+  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC2E));
+
+  /* Get the TIMx CCER register value */
+  tmpccer = TIMx->CCER;
+  /* Get the TIMx CR2 register value */
+  tmpcr2 =  TIMx->CR2;
+
+  /* Get the TIMx CCMR1 register value */
+  tmpccmrx = TIMx->CCMR1;
+
+  /* Reset the Output Compare mode and Capture/Compare selection Bits */
+  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC2M));
+  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S));
+
+  /* Select the Output Compare Mode */
+  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
+
+  /* Reset the Output Polarity level */
+  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2P));
+  /* Set the Output Compare Polarity */
+  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
+
+  /* Set the Output State */
+  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
+
+  if((TIMx == TIM1) || (TIMx == TIM8))
+  {
+    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
+    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
+    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
+    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
+
+    /* Reset the Output N Polarity level */
+    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NP));
+    /* Set the Output N Polarity */
+    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
+
+    /* Reset the Output N State */
+    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NE));
+    /* Set the Output N State */
+    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
+
+    /* Reset the Output Compare and Output Compare N IDLE State */
+    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2));
+    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2N));
+
+    /* Set the Output Idle state */
+    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
+    /* Set the Output N Idle state */
+    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
+  }
+  /* Write to TIMx CR2 */
+  TIMx->CR2 = tmpcr2;
+
+  /* Write to TIMx CCMR1 */
+  TIMx->CCMR1 = tmpccmrx;
+
+  /* Set the Capture Compare Register value */
+  TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
+
+  /* Write to TIMx CCER */
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @brief  Initializes the TIMx Channel3 according to the specified
+  *         parameters in the TIM_OCInitStruct.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
+  *         that contains the configuration information for the specified TIM peripheral.
+  * @retval None
+  */
+void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
+{
+  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
+  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));
+  /* Disable the Channel 2: Reset the CC2E Bit */
+  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC3E));
+
+  /* Get the TIMx CCER register value */
+  tmpccer = TIMx->CCER;
+  /* Get the TIMx CR2 register value */
+  tmpcr2 =  TIMx->CR2;
+
+  /* Get the TIMx CCMR2 register value */
+  tmpccmrx = TIMx->CCMR2;
+
+  /* Reset the Output Compare mode and Capture/Compare selection Bits */
+  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC3M));
+  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC3S));
+  /* Select the Output Compare Mode */
+  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
+
+  /* Reset the Output Polarity level */
+  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3P));
+  /* Set the Output Compare Polarity */
+  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
+
+  /* Set the Output State */
+  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
+
+  if((TIMx == TIM1) || (TIMx == TIM8))
+  {
+    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
+    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
+    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
+    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
+
+    /* Reset the Output N Polarity level */
+    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NP));
+    /* Set the Output N Polarity */
+    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
+    /* Reset the Output N State */
+    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NE));
+
+    /* Set the Output N State */
+    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
+    /* Reset the Output Compare and Output Compare N IDLE State */
+    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3));
+    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3N));
+    /* Set the Output Idle state */
+    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
+    /* Set the Output N Idle state */
+    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
+  }
+  /* Write to TIMx CR2 */
+  TIMx->CR2 = tmpcr2;
+
+  /* Write to TIMx CCMR2 */
+  TIMx->CCMR2 = tmpccmrx;
+
+  /* Set the Capture Compare Register value */
+  TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
+
+  /* Write to TIMx CCER */
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @brief  Initializes the TIMx Channel4 according to the specified
+  *         parameters in the TIM_OCInitStruct.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
+  *         that contains the configuration information for the specified TIM peripheral.
+  * @retval None
+  */
+void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
+{
+  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
+  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));
+  /* Disable the Channel 2: Reset the CC4E Bit */
+  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC4E));
+
+  /* Get the TIMx CCER register value */
+  tmpccer = TIMx->CCER;
+  /* Get the TIMx CR2 register value */
+  tmpcr2 =  TIMx->CR2;
+
+  /* Get the TIMx CCMR2 register value */
+  tmpccmrx = TIMx->CCMR2;
+
+  /* Reset the Output Compare mode and Capture/Compare selection Bits */
+  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC4M));
+  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC4S));
+
+  /* Select the Output Compare Mode */
+  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
+
+  /* Reset the Output Polarity level */
+  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC4P));
+  /* Set the Output Compare Polarity */
+  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
+
+  /* Set the Output State */
+  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
+
+  if((TIMx == TIM1) || (TIMx == TIM8))
+  {
+    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
+    /* Reset the Output Compare IDLE State */
+    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS4));
+    /* Set the Output Idle state */
+    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
+  }
+  /* Write to TIMx CR2 */
+  TIMx->CR2 = tmpcr2;
+
+  /* Write to TIMx CCMR2 */
+  TIMx->CCMR2 = tmpccmrx;
+
+  /* Set the Capture Compare Register value */
+  TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
+
+  /* Write to TIMx CCER */
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @brief  Initializes the TIM peripheral according to the specified
+  *         parameters in the TIM_ICInitStruct.
+  * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.
+  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
+  *         that contains the configuration information for the specified TIM peripheral.
+  * @retval None
+  */
+void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));
+  assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
+  assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
+  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
+
+  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
+     (TIMx == TIM4) ||(TIMx == TIM5))
+  {
+    assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
+  }
+  else
+  {
+    assert_param(IS_TIM_IC_POLARITY_LITE(TIM_ICInitStruct->TIM_ICPolarity));
+  }
+  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
+  {
+    assert_param(IS_TIM_LIST8_PERIPH(TIMx));
+    /* TI1 Configuration */
+    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
+               TIM_ICInitStruct->TIM_ICSelection,
+               TIM_ICInitStruct->TIM_ICFilter);
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
+  }
+  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
+  {
+    assert_param(IS_TIM_LIST6_PERIPH(TIMx));
+    /* TI2 Configuration */
+    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
+               TIM_ICInitStruct->TIM_ICSelection,
+               TIM_ICInitStruct->TIM_ICFilter);
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
+  }
+  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
+  {
+    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+    /* TI3 Configuration */
+    TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
+               TIM_ICInitStruct->TIM_ICSelection,
+               TIM_ICInitStruct->TIM_ICFilter);
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
+  }
+  else
+  {
+    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+    /* TI4 Configuration */
+    TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
+               TIM_ICInitStruct->TIM_ICSelection,
+               TIM_ICInitStruct->TIM_ICFilter);
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
+  }
+}
+
+/**
+  * @brief  Configures the TIM peripheral according to the specified
+  *         parameters in the TIM_ICInitStruct to measure an external PWM signal.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
+  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
+  *         that contains the configuration information for the specified TIM peripheral.
+  * @retval None
+  */
+void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
+{
+  uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
+  uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
+  /* Select the Opposite Input Polarity */
+  if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
+  {
+    icoppositepolarity = TIM_ICPolarity_Falling;
+  }
+  else
+  {
+    icoppositepolarity = TIM_ICPolarity_Rising;
+  }
+  /* Select the Opposite Input */
+  if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
+  {
+    icoppositeselection = TIM_ICSelection_IndirectTI;
+  }
+  else
+  {
+    icoppositeselection = TIM_ICSelection_DirectTI;
+  }
+  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
+  {
+    /* TI1 Configuration */
+    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
+               TIM_ICInitStruct->TIM_ICFilter);
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
+    /* TI2 Configuration */
+    TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
+  }
+  else
+  {
+    /* TI2 Configuration */
+    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
+               TIM_ICInitStruct->TIM_ICFilter);
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
+    /* TI1 Configuration */
+    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
+  }
+}
+
+/**
+  * @brief  Configures the: Break feature, dead time, Lock level, the OSSI,
+  *         the OSSR State and the AOE(automatic output enable).
+  * @param  TIMx: where x can be  1 or 8 to select the TIM
+  * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure that
+  *         contains the BDTR Register configuration  information for the TIM peripheral.
+  * @retval None
+  */
+void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
+  assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
+  assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
+  assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
+  assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
+  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
+  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
+  /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
+     the OSSI State, the dead time value and the Automatic Output Enable Bit */
+  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
+             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
+             TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
+             TIM_BDTRInitStruct->TIM_AutomaticOutput;
+}
+
+/**
+  * @brief  Fills each TIM_TimeBaseInitStruct member with its default value.
+  * @param  TIM_TimeBaseInitStruct : pointer to a TIM_TimeBaseInitTypeDef
+  *         structure which will be initialized.
+  * @retval None
+  */
+void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
+{
+  /* Set the default configuration */
+  TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
+  TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
+  TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
+  TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
+  TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
+}
+
+/**
+  * @brief  Fills each TIM_OCInitStruct member with its default value.
+  * @param  TIM_OCInitStruct : pointer to a TIM_OCInitTypeDef structure which will
+  *         be initialized.
+  * @retval None
+  */
+void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
+{
+  /* Set the default configuration */
+  TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
+  TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
+  TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
+  TIM_OCInitStruct->TIM_Pulse = 0x0000;
+  TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
+  TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
+  TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
+  TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
+}
+
+/**
+  * @brief  Fills each TIM_ICInitStruct member with its default value.
+  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure which will
+  *         be initialized.
+  * @retval None
+  */
+void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
+{
+  /* Set the default configuration */
+  TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
+  TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
+  TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
+  TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
+  TIM_ICInitStruct->TIM_ICFilter = 0x00;
+}
+
+/**
+  * @brief  Fills each TIM_BDTRInitStruct member with its default value.
+  * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure which
+  *         will be initialized.
+  * @retval None
+  */
+void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
+{
+  /* Set the default configuration */
+  TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
+  TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
+  TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
+  TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
+  TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
+  TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
+  TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
+}
+
+/**
+  * @brief  Enables or disables the specified TIM peripheral.
+  * @param  TIMx: where x can be 1 to 17 to select the TIMx peripheral.
+  * @param  NewState: new state of the TIMx peripheral.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the TIM Counter */
+    TIMx->CR1 |= TIM_CR1_CEN;
+  }
+  else
+  {
+    /* Disable the TIM Counter */
+    TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
+  }
+}
+
+/**
+  * @brief  Enables or disables the TIM peripheral Main Outputs.
+  * @param  TIMx: where x can be 1, 8, 15, 16 or 17 to select the TIMx peripheral.
+  * @param  NewState: new state of the TIM peripheral Main Outputs.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the TIM Main Output */
+    TIMx->BDTR |= TIM_BDTR_MOE;
+  }
+  else
+  {
+    /* Disable the TIM Main Output */
+    TIMx->BDTR &= (uint16_t)(~((uint16_t)TIM_BDTR_MOE));
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified TIM interrupts.
+  * @param  TIMx: where x can be 1 to 17 to select the TIMx peripheral.
+  * @param  TIM_IT: specifies the TIM interrupts sources to be enabled or disabled.
+  *   This parameter can be any combination of the following values:
+  *     @arg TIM_IT_Update: TIM update Interrupt source
+  *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
+  *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
+  *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
+  *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
+  *     @arg TIM_IT_COM: TIM Commutation Interrupt source
+  *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source
+  *     @arg TIM_IT_Break: TIM Break Interrupt source
+  * @note
+  *   - TIM6 and TIM7 can only generate an update interrupt.
+  *   - TIM9, TIM12 and TIM15 can have only TIM_IT_Update, TIM_IT_CC1,
+  *      TIM_IT_CC2 or TIM_IT_Trigger.
+  *   - TIM10, TIM11, TIM13, TIM14, TIM16 and TIM17 can have TIM_IT_Update or TIM_IT_CC1.
+  *   - TIM_IT_Break is used only with TIM1, TIM8 and TIM15.
+  *   - TIM_IT_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.
+  * @param  NewState: new state of the TIM interrupts.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_IT(TIM_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the Interrupt sources */
+    TIMx->DIER |= TIM_IT;
+  }
+  else
+  {
+    /* Disable the Interrupt sources */
+    TIMx->DIER &= (uint16_t)~TIM_IT;
+  }
+}
+
+/**
+  * @brief  Configures the TIMx event to be generate by software.
+  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
+  * @param  TIM_EventSource: specifies the event source.
+  *   This parameter can be one or more of the following values:
+  *     @arg TIM_EventSource_Update: Timer update Event source
+  *     @arg TIM_EventSource_CC1: Timer Capture Compare 1 Event source
+  *     @arg TIM_EventSource_CC2: Timer Capture Compare 2 Event source
+  *     @arg TIM_EventSource_CC3: Timer Capture Compare 3 Event source
+  *     @arg TIM_EventSource_CC4: Timer Capture Compare 4 Event source
+  *     @arg TIM_EventSource_COM: Timer COM event source
+  *     @arg TIM_EventSource_Trigger: Timer Trigger Event source
+  *     @arg TIM_EventSource_Break: Timer Break event source
+  * @note
+  *   - TIM6 and TIM7 can only generate an update event.
+  *   - TIM_EventSource_COM and TIM_EventSource_Break are used only with TIM1 and TIM8.
+  * @retval None
+  */
+void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
+
+  /* Set the event sources */
+  TIMx->EGR = TIM_EventSource;
+}
+
+/**
+  * @brief  Configures the TIMx's DMA interface.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 15, 16 or 17 to select
+  *   the TIM peripheral.
+  * @param  TIM_DMABase: DMA Base address.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_DMABase_CR, TIM_DMABase_CR2, TIM_DMABase_SMCR,
+  *          TIM_DMABase_DIER, TIM1_DMABase_SR, TIM_DMABase_EGR,
+  *          TIM_DMABase_CCMR1, TIM_DMABase_CCMR2, TIM_DMABase_CCER,
+  *          TIM_DMABase_CNT, TIM_DMABase_PSC, TIM_DMABase_ARR,
+  *          TIM_DMABase_RCR, TIM_DMABase_CCR1, TIM_DMABase_CCR2,
+  *          TIM_DMABase_CCR3, TIM_DMABase_CCR4, TIM_DMABase_BDTR,
+  *          TIM_DMABase_DCR.
+  * @param  TIM_DMABurstLength: DMA Burst length.
+  *   This parameter can be one value between:
+  *   TIM_DMABurstLength_1Transfer and TIM_DMABurstLength_18Transfers.
+  * @retval None
+  */
+void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
+  assert_param(IS_TIM_DMA_BASE(TIM_DMABase));
+  assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
+  /* Set the DMA Base and the DMA Burst Length */
+  TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
+}
+
+/**
+  * @brief  Enables or disables the TIMx's DMA Requests.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 6, 7, 8, 15, 16 or 17
+  *   to select the TIM peripheral.
+  * @param  TIM_DMASource: specifies the DMA Request sources.
+  *   This parameter can be any combination of the following values:
+  *     @arg TIM_DMA_Update: TIM update Interrupt source
+  *     @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
+  *     @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
+  *     @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
+  *     @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
+  *     @arg TIM_DMA_COM: TIM Commutation DMA source
+  *     @arg TIM_DMA_Trigger: TIM Trigger DMA source
+  * @param  NewState: new state of the DMA Request sources.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST9_PERIPH(TIMx));
+  assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the DMA sources */
+    TIMx->DIER |= TIM_DMASource;
+  }
+  else
+  {
+    /* Disable the DMA sources */
+    TIMx->DIER &= (uint16_t)~TIM_DMASource;
+  }
+}
+
+/**
+  * @brief  Configures the TIMx internal Clock
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15
+  *         to select the TIM peripheral.
+  * @retval None
+  */
+void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
+  /* Disable slave mode to clock the prescaler directly with the internal clock */
+  TIMx->SMCR &=  (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
+}
+
+/**
+  * @brief  Configures the TIMx Internal Trigger as External Clock
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 9, 12 or 15 to select the TIM peripheral.
+  * @param  TIM_ITRSource: Trigger source.
+  *   This parameter can be one of the following values:
+  * @param  TIM_TS_ITR0: Internal Trigger 0
+  * @param  TIM_TS_ITR1: Internal Trigger 1
+  * @param  TIM_TS_ITR2: Internal Trigger 2
+  * @param  TIM_TS_ITR3: Internal Trigger 3
+  * @retval None
+  */
+void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
+  assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
+  /* Select the Internal Trigger */
+  TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
+  /* Select the External clock mode1 */
+  TIMx->SMCR |= TIM_SlaveMode_External1;
+}
+
+/**
+  * @brief  Configures the TIMx Trigger as External Clock
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 9, 12 or 15 to select the TIM peripheral.
+  * @param  TIM_TIxExternalCLKSource: Trigger source.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_TIxExternalCLK1Source_TI1ED: TI1 Edge Detector
+  *     @arg TIM_TIxExternalCLK1Source_TI1: Filtered Timer Input 1
+  *     @arg TIM_TIxExternalCLK1Source_TI2: Filtered Timer Input 2
+  * @param  TIM_ICPolarity: specifies the TIx Polarity.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ICPolarity_Rising
+  *     @arg TIM_ICPolarity_Falling
+  * @param  ICFilter : specifies the filter value.
+  *   This parameter must be a value between 0x0 and 0xF.
+  * @retval None
+  */
+void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
+                                uint16_t TIM_ICPolarity, uint16_t ICFilter)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
+  assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
+  assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
+  assert_param(IS_TIM_IC_FILTER(ICFilter));
+  /* Configure the Timer Input Clock Source */
+  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
+  {
+    TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
+  }
+  else
+  {
+    TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
+  }
+  /* Select the Trigger source */
+  TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
+  /* Select the External clock mode1 */
+  TIMx->SMCR |= TIM_SlaveMode_External1;
+}
+
+/**
+  * @brief  Configures the External clock Mode1
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
+  *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
+  *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
+  *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
+  * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
+  *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
+  * @param  ExtTRGFilter: External Trigger Filter.
+  *   This parameter must be a value between 0x00 and 0x0F
+  * @retval None
+  */
+void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
+                             uint16_t ExtTRGFilter)
+{
+  uint16_t tmpsmcr = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
+  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
+  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
+  /* Configure the ETR Clock source */
+  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
+
+  /* Get the TIMx SMCR register value */
+  tmpsmcr = TIMx->SMCR;
+  /* Reset the SMS Bits */
+  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
+  /* Select the External clock mode1 */
+  tmpsmcr |= TIM_SlaveMode_External1;
+  /* Select the Trigger selection : ETRF */
+  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
+  tmpsmcr |= TIM_TS_ETRF;
+  /* Write to TIMx SMCR */
+  TIMx->SMCR = tmpsmcr;
+}
+
+/**
+  * @brief  Configures the External clock Mode2
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
+  *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
+  *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
+  *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
+  * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
+  *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
+  * @param  ExtTRGFilter: External Trigger Filter.
+  *   This parameter must be a value between 0x00 and 0x0F
+  * @retval None
+  */
+void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
+                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
+  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
+  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
+  /* Configure the ETR Clock source */
+  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
+  /* Enable the External clock mode2 */
+  TIMx->SMCR |= TIM_SMCR_ECE;
+}
+
+/**
+  * @brief  Configures the TIMx External Trigger (ETR).
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
+  *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
+  *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
+  *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
+  * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
+  *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
+  * @param  ExtTRGFilter: External Trigger Filter.
+  *   This parameter must be a value between 0x00 and 0x0F
+  * @retval None
+  */
+void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
+                   uint16_t ExtTRGFilter)
+{
+  uint16_t tmpsmcr = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
+  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
+  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
+  tmpsmcr = TIMx->SMCR;
+  /* Reset the ETR Bits */
+  tmpsmcr &= SMCR_ETR_Mask;
+  /* Set the Prescaler, the Filter value and the Polarity */
+  tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
+  /* Write to TIMx SMCR */
+  TIMx->SMCR = tmpsmcr;
+}
+
+/**
+  * @brief  Configures the TIMx Prescaler.
+  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
+  * @param  Prescaler: specifies the Prescaler Register value
+  * @param  TIM_PSCReloadMode: specifies the TIM Prescaler Reload mode
+  *   This parameter can be one of the following values:
+  *     @arg TIM_PSCReloadMode_Update: The Prescaler is loaded at the update event.
+  *     @arg TIM_PSCReloadMode_Immediate: The Prescaler is loaded immediately.
+  * @retval None
+  */
+void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
+  /* Set the Prescaler value */
+  TIMx->PSC = Prescaler;
+  /* Set or reset the UG Bit */
+  TIMx->EGR = TIM_PSCReloadMode;
+}
+
+/**
+  * @brief  Specifies the TIMx Counter Mode to be used.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_CounterMode: specifies the Counter Mode to be used
+  *   This parameter can be one of the following values:
+  *     @arg TIM_CounterMode_Up: TIM Up Counting Mode
+  *     @arg TIM_CounterMode_Down: TIM Down Counting Mode
+  *     @arg TIM_CounterMode_CenterAligned1: TIM Center Aligned Mode1
+  *     @arg TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
+  *     @arg TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
+  * @retval None
+  */
+void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
+{
+  uint16_t tmpcr1 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
+  tmpcr1 = TIMx->CR1;
+  /* Reset the CMS and DIR Bits */
+  tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
+  /* Set the Counter Mode */
+  tmpcr1 |= TIM_CounterMode;
+  /* Write to TIMx CR1 register */
+  TIMx->CR1 = tmpcr1;
+}
+
+/**
+  * @brief  Selects the Input Trigger source
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
+  * @param  TIM_InputTriggerSource: The Input Trigger source.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_TS_ITR0: Internal Trigger 0
+  *     @arg TIM_TS_ITR1: Internal Trigger 1
+  *     @arg TIM_TS_ITR2: Internal Trigger 2
+  *     @arg TIM_TS_ITR3: Internal Trigger 3
+  *     @arg TIM_TS_TI1F_ED: TI1 Edge Detector
+  *     @arg TIM_TS_TI1FP1: Filtered Timer Input 1
+  *     @arg TIM_TS_TI2FP2: Filtered Timer Input 2
+  *     @arg TIM_TS_ETRF: External Trigger input
+  * @retval None
+  */
+void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
+{
+  uint16_t tmpsmcr = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
+  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
+  /* Get the TIMx SMCR register value */
+  tmpsmcr = TIMx->SMCR;
+  /* Reset the TS Bits */
+  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
+  /* Set the Input Trigger source */
+  tmpsmcr |= TIM_InputTriggerSource;
+  /* Write to TIMx SMCR */
+  TIMx->SMCR = tmpsmcr;
+}
+
+/**
+  * @brief  Configures the TIMx Encoder Interface.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_EncoderMode: specifies the TIMx Encoder Mode.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_EncoderMode_TI1: Counter counts on TI1FP1 edge depending on TI2FP2 level.
+  *     @arg TIM_EncoderMode_TI2: Counter counts on TI2FP2 edge depending on TI1FP1 level.
+  *     @arg TIM_EncoderMode_TI12: Counter counts on both TI1FP1 and TI2FP2 edges depending
+  *                                on the level of the other input.
+  * @param  TIM_IC1Polarity: specifies the IC1 Polarity
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ICPolarity_Falling: IC Falling edge.
+  *     @arg TIM_ICPolarity_Rising: IC Rising edge.
+  * @param  TIM_IC2Polarity: specifies the IC2 Polarity
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ICPolarity_Falling: IC Falling edge.
+  *     @arg TIM_ICPolarity_Rising: IC Rising edge.
+  * @retval None
+  */
+void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
+                                uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
+{
+  uint16_t tmpsmcr = 0;
+  uint16_t tmpccmr1 = 0;
+  uint16_t tmpccer = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST5_PERIPH(TIMx));
+  assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
+  assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
+  assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
+
+  /* Get the TIMx SMCR register value */
+  tmpsmcr = TIMx->SMCR;
+
+  /* Get the TIMx CCMR1 register value */
+  tmpccmr1 = TIMx->CCMR1;
+
+  /* Get the TIMx CCER register value */
+  tmpccer = TIMx->CCER;
+
+  /* Set the encoder Mode */
+  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
+  tmpsmcr |= TIM_EncoderMode;
+
+  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
+  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S)));
+  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
+
+  /* Set the TI1 and the TI2 Polarities */
+  tmpccer &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCER_CC1P)) & ((uint16_t)~((uint16_t)TIM_CCER_CC2P)));
+  tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
+
+  /* Write to TIMx SMCR */
+  TIMx->SMCR = tmpsmcr;
+  /* Write to TIMx CCMR1 */
+  TIMx->CCMR1 = tmpccmr1;
+  /* Write to TIMx CCER */
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @brief  Forces the TIMx output 1 waveform to active or inactive level.
+  * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.
+  * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ForcedAction_Active: Force active level on OC1REF
+  *     @arg TIM_ForcedAction_InActive: Force inactive level on OC1REF.
+  * @retval None
+  */
+void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
+{
+  uint16_t tmpccmr1 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
+  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
+  tmpccmr1 = TIMx->CCMR1;
+  /* Reset the OC1M Bits */
+  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1M);
+  /* Configure The Forced output Mode */
+  tmpccmr1 |= TIM_ForcedAction;
+  /* Write to TIMx CCMR1 register */
+  TIMx->CCMR1 = tmpccmr1;
+}
+
+/**
+  * @brief  Forces the TIMx output 2 waveform to active or inactive level.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
+  * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ForcedAction_Active: Force active level on OC2REF
+  *     @arg TIM_ForcedAction_InActive: Force inactive level on OC2REF.
+  * @retval None
+  */
+void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
+{
+  uint16_t tmpccmr1 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
+  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
+  tmpccmr1 = TIMx->CCMR1;
+  /* Reset the OC2M Bits */
+  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2M);
+  /* Configure The Forced output Mode */
+  tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
+  /* Write to TIMx CCMR1 register */
+  TIMx->CCMR1 = tmpccmr1;
+}
+
+/**
+  * @brief  Forces the TIMx output 3 waveform to active or inactive level.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ForcedAction_Active: Force active level on OC3REF
+  *     @arg TIM_ForcedAction_InActive: Force inactive level on OC3REF.
+  * @retval None
+  */
+void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
+{
+  uint16_t tmpccmr2 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
+  tmpccmr2 = TIMx->CCMR2;
+  /* Reset the OC1M Bits */
+  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3M);
+  /* Configure The Forced output Mode */
+  tmpccmr2 |= TIM_ForcedAction;
+  /* Write to TIMx CCMR2 register */
+  TIMx->CCMR2 = tmpccmr2;
+}
+
+/**
+  * @brief  Forces the TIMx output 4 waveform to active or inactive level.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ForcedAction_Active: Force active level on OC4REF
+  *     @arg TIM_ForcedAction_InActive: Force inactive level on OC4REF.
+  * @retval None
+  */
+void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
+{
+  uint16_t tmpccmr2 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
+  tmpccmr2 = TIMx->CCMR2;
+  /* Reset the OC2M Bits */
+  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4M);
+  /* Configure The Forced output Mode */
+  tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
+  /* Write to TIMx CCMR2 register */
+  TIMx->CCMR2 = tmpccmr2;
+}
+
+/**
+  * @brief  Enables or disables TIMx peripheral Preload register on ARR.
+  * @param  TIMx: where x can be  1 to 17 to select the TIM peripheral.
+  * @param  NewState: new state of the TIMx peripheral Preload register
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Set the ARR Preload Bit */
+    TIMx->CR1 |= TIM_CR1_ARPE;
+  }
+  else
+  {
+    /* Reset the ARR Preload Bit */
+    TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_ARPE);
+  }
+}
+
+/**
+  * @brief  Selects the TIM peripheral Commutation event.
+  * @param  TIMx: where x can be  1, 8, 15, 16 or 17 to select the TIMx peripheral
+  * @param  NewState: new state of the Commutation event.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Set the COM Bit */
+    TIMx->CR2 |= TIM_CR2_CCUS;
+  }
+  else
+  {
+    /* Reset the COM Bit */
+    TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCUS);
+  }
+}
+
+/**
+  * @brief  Selects the TIMx peripheral Capture Compare DMA source.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 15, 16 or 17 to select
+  *         the TIM peripheral.
+  * @param  NewState: new state of the Capture Compare DMA source
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Set the CCDS Bit */
+    TIMx->CR2 |= TIM_CR2_CCDS;
+  }
+  else
+  {
+    /* Reset the CCDS Bit */
+    TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCDS);
+  }
+}
+
+/**
+  * @brief  Sets or Resets the TIM peripheral Capture Compare Preload Control bit.
+  * @param  TIMx: where x can be   1, 2, 3, 4, 5, 8 or 15
+  *         to select the TIMx peripheral
+  * @param  NewState: new state of the Capture Compare Preload Control bit
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST5_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Set the CCPC Bit */
+    TIMx->CR2 |= TIM_CR2_CCPC;
+  }
+  else
+  {
+    /* Reset the CCPC Bit */
+    TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCPC);
+  }
+}
+
+/**
+  * @brief  Enables or disables the TIMx peripheral Preload register on CCR1.
+  * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.
+  * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCPreload_Enable
+  *     @arg TIM_OCPreload_Disable
+  * @retval None
+  */
+void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
+{
+  uint16_t tmpccmr1 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
+  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
+  tmpccmr1 = TIMx->CCMR1;
+  /* Reset the OC1PE Bit */
+  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1PE);
+  /* Enable or Disable the Output Compare Preload feature */
+  tmpccmr1 |= TIM_OCPreload;
+  /* Write to TIMx CCMR1 register */
+  TIMx->CCMR1 = tmpccmr1;
+}
+
+/**
+  * @brief  Enables or disables the TIMx peripheral Preload register on CCR2.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select
+  *         the TIM peripheral.
+  * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCPreload_Enable
+  *     @arg TIM_OCPreload_Disable
+  * @retval None
+  */
+void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
+{
+  uint16_t tmpccmr1 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
+  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
+  tmpccmr1 = TIMx->CCMR1;
+  /* Reset the OC2PE Bit */
+  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2PE);
+  /* Enable or Disable the Output Compare Preload feature */
+  tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
+  /* Write to TIMx CCMR1 register */
+  TIMx->CCMR1 = tmpccmr1;
+}
+
+/**
+  * @brief  Enables or disables the TIMx peripheral Preload register on CCR3.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCPreload_Enable
+  *     @arg TIM_OCPreload_Disable
+  * @retval None
+  */
+void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
+{
+  uint16_t tmpccmr2 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
+  tmpccmr2 = TIMx->CCMR2;
+  /* Reset the OC3PE Bit */
+  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3PE);
+  /* Enable or Disable the Output Compare Preload feature */
+  tmpccmr2 |= TIM_OCPreload;
+  /* Write to TIMx CCMR2 register */
+  TIMx->CCMR2 = tmpccmr2;
+}
+
+/**
+  * @brief  Enables or disables the TIMx peripheral Preload register on CCR4.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCPreload_Enable
+  *     @arg TIM_OCPreload_Disable
+  * @retval None
+  */
+void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
+{
+  uint16_t tmpccmr2 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
+  tmpccmr2 = TIMx->CCMR2;
+  /* Reset the OC4PE Bit */
+  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4PE);
+  /* Enable or Disable the Output Compare Preload feature */
+  tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
+  /* Write to TIMx CCMR2 register */
+  TIMx->CCMR2 = tmpccmr2;
+}
+
+/**
+  * @brief  Configures the TIMx Output Compare 1 Fast feature.
+  * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.
+  * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCFast_Enable: TIM output compare fast enable
+  *     @arg TIM_OCFast_Disable: TIM output compare fast disable
+  * @retval None
+  */
+void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
+{
+  uint16_t tmpccmr1 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
+  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
+  /* Get the TIMx CCMR1 register value */
+  tmpccmr1 = TIMx->CCMR1;
+  /* Reset the OC1FE Bit */
+  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1FE);
+  /* Enable or Disable the Output Compare Fast Bit */
+  tmpccmr1 |= TIM_OCFast;
+  /* Write to TIMx CCMR1 */
+  TIMx->CCMR1 = tmpccmr1;
+}
+
+/**
+  * @brief  Configures the TIMx Output Compare 2 Fast feature.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select
+  *         the TIM peripheral.
+  * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCFast_Enable: TIM output compare fast enable
+  *     @arg TIM_OCFast_Disable: TIM output compare fast disable
+  * @retval None
+  */
+void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
+{
+  uint16_t tmpccmr1 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
+  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
+  /* Get the TIMx CCMR1 register value */
+  tmpccmr1 = TIMx->CCMR1;
+  /* Reset the OC2FE Bit */
+  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2FE);
+  /* Enable or Disable the Output Compare Fast Bit */
+  tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
+  /* Write to TIMx CCMR1 */
+  TIMx->CCMR1 = tmpccmr1;
+}
+
+/**
+  * @brief  Configures the TIMx Output Compare 3 Fast feature.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCFast_Enable: TIM output compare fast enable
+  *     @arg TIM_OCFast_Disable: TIM output compare fast disable
+  * @retval None
+  */
+void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
+{
+  uint16_t tmpccmr2 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
+  /* Get the TIMx CCMR2 register value */
+  tmpccmr2 = TIMx->CCMR2;
+  /* Reset the OC3FE Bit */
+  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3FE);
+  /* Enable or Disable the Output Compare Fast Bit */
+  tmpccmr2 |= TIM_OCFast;
+  /* Write to TIMx CCMR2 */
+  TIMx->CCMR2 = tmpccmr2;
+}
+
+/**
+  * @brief  Configures the TIMx Output Compare 4 Fast feature.
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCFast_Enable: TIM output compare fast enable
+  *     @arg TIM_OCFast_Disable: TIM output compare fast disable
+  * @retval None
+  */
+void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
+{
+  uint16_t tmpccmr2 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
+  /* Get the TIMx CCMR2 register value */
+  tmpccmr2 = TIMx->CCMR2;
+  /* Reset the OC4FE Bit */
+  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4FE);
+  /* Enable or Disable the Output Compare Fast Bit */
+  tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
+  /* Write to TIMx CCMR2 */
+  TIMx->CCMR2 = tmpccmr2;
+}
+
+/**
+  * @brief  Clears or safeguards the OCREF1 signal on an external event
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCClear_Enable: TIM Output clear enable
+  *     @arg TIM_OCClear_Disable: TIM Output clear disable
+  * @retval None
+  */
+void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
+{
+  uint16_t tmpccmr1 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
+
+  tmpccmr1 = TIMx->CCMR1;
+
+  /* Reset the OC1CE Bit */
+  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1CE);
+  /* Enable or Disable the Output Compare Clear Bit */
+  tmpccmr1 |= TIM_OCClear;
+  /* Write to TIMx CCMR1 register */
+  TIMx->CCMR1 = tmpccmr1;
+}
+
+/**
+  * @brief  Clears or safeguards the OCREF2 signal on an external event
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCClear_Enable: TIM Output clear enable
+  *     @arg TIM_OCClear_Disable: TIM Output clear disable
+  * @retval None
+  */
+void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
+{
+  uint16_t tmpccmr1 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
+  tmpccmr1 = TIMx->CCMR1;
+  /* Reset the OC2CE Bit */
+  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2CE);
+  /* Enable or Disable the Output Compare Clear Bit */
+  tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
+  /* Write to TIMx CCMR1 register */
+  TIMx->CCMR1 = tmpccmr1;
+}
+
+/**
+  * @brief  Clears or safeguards the OCREF3 signal on an external event
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCClear_Enable: TIM Output clear enable
+  *     @arg TIM_OCClear_Disable: TIM Output clear disable
+  * @retval None
+  */
+void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
+{
+  uint16_t tmpccmr2 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
+  tmpccmr2 = TIMx->CCMR2;
+  /* Reset the OC3CE Bit */
+  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3CE);
+  /* Enable or Disable the Output Compare Clear Bit */
+  tmpccmr2 |= TIM_OCClear;
+  /* Write to TIMx CCMR2 register */
+  TIMx->CCMR2 = tmpccmr2;
+}
+
+/**
+  * @brief  Clears or safeguards the OCREF4 signal on an external event
+  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCClear_Enable: TIM Output clear enable
+  *     @arg TIM_OCClear_Disable: TIM Output clear disable
+  * @retval None
+  */
+void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
+{
+  uint16_t tmpccmr2 = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
+  tmpccmr2 = TIMx->CCMR2;
+  /* Reset the OC4CE Bit */
+  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4CE);
+  /* Enable or Disable the Output Compare Clear Bit */
+  tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
+  /* Write to TIMx CCMR2 register */
+  TIMx->CCMR2 = tmpccmr2;
+}
+
+/**
+  * @brief  Configures the TIMx channel 1 polarity.
+  * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
+  * @param  TIM_OCPolarity: specifies the OC1 Polarity
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCPolarity_High: Output Compare active high
+  *     @arg TIM_OCPolarity_Low: Output Compare active low
+  * @retval None
+  */
+void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
+{
+  uint16_t tmpccer = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
+  tmpccer = TIMx->CCER;
+  /* Set or Reset the CC1P Bit */
+  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1P);
+  tmpccer |= TIM_OCPolarity;
+  /* Write to TIMx CCER register */
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @brief  Configures the TIMx Channel 1N polarity.
+  * @param  TIMx: where x can be 1, 8, 15, 16 or 17 to select the TIM peripheral.
+  * @param  TIM_OCNPolarity: specifies the OC1N Polarity
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCNPolarity_High: Output Compare active high
+  *     @arg TIM_OCNPolarity_Low: Output Compare active low
+  * @retval None
+  */
+void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
+{
+  uint16_t tmpccer = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
+  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
+
+  tmpccer = TIMx->CCER;
+  /* Set or Reset the CC1NP Bit */
+  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1NP);
+  tmpccer |= TIM_OCNPolarity;
+  /* Write to TIMx CCER register */
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @brief  Configures the TIMx channel 2 polarity.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
+  * @param  TIM_OCPolarity: specifies the OC2 Polarity
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCPolarity_High: Output Compare active high
+  *     @arg TIM_OCPolarity_Low: Output Compare active low
+  * @retval None
+  */
+void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
+{
+  uint16_t tmpccer = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
+  tmpccer = TIMx->CCER;
+  /* Set or Reset the CC2P Bit */
+  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2P);
+  tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
+  /* Write to TIMx CCER register */
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @brief  Configures the TIMx Channel 2N polarity.
+  * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
+  * @param  TIM_OCNPolarity: specifies the OC2N Polarity
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCNPolarity_High: Output Compare active high
+  *     @arg TIM_OCNPolarity_Low: Output Compare active low
+  * @retval None
+  */
+void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
+{
+  uint16_t tmpccer = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
+  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
+
+  tmpccer = TIMx->CCER;
+  /* Set or Reset the CC2NP Bit */
+  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2NP);
+  tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
+  /* Write to TIMx CCER register */
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @brief  Configures the TIMx channel 3 polarity.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCPolarity: specifies the OC3 Polarity
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCPolarity_High: Output Compare active high
+  *     @arg TIM_OCPolarity_Low: Output Compare active low
+  * @retval None
+  */
+void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
+{
+  uint16_t tmpccer = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
+  tmpccer = TIMx->CCER;
+  /* Set or Reset the CC3P Bit */
+  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3P);
+  tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
+  /* Write to TIMx CCER register */
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @brief  Configures the TIMx Channel 3N polarity.
+  * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
+  * @param  TIM_OCNPolarity: specifies the OC3N Polarity
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCNPolarity_High: Output Compare active high
+  *     @arg TIM_OCNPolarity_Low: Output Compare active low
+  * @retval None
+  */
+void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
+{
+  uint16_t tmpccer = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
+  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
+
+  tmpccer = TIMx->CCER;
+  /* Set or Reset the CC3NP Bit */
+  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3NP);
+  tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
+  /* Write to TIMx CCER register */
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @brief  Configures the TIMx channel 4 polarity.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_OCPolarity: specifies the OC4 Polarity
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCPolarity_High: Output Compare active high
+  *     @arg TIM_OCPolarity_Low: Output Compare active low
+  * @retval None
+  */
+void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
+{
+  uint16_t tmpccer = 0;
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
+  tmpccer = TIMx->CCER;
+  /* Set or Reset the CC4P Bit */
+  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC4P);
+  tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
+  /* Write to TIMx CCER register */
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @brief  Enables or disables the TIM Capture Compare Channel x.
+  * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
+  * @param  TIM_Channel: specifies the TIM Channel
+  *   This parameter can be one of the following values:
+  *     @arg TIM_Channel_1: TIM Channel 1
+  *     @arg TIM_Channel_2: TIM Channel 2
+  *     @arg TIM_Channel_3: TIM Channel 3
+  *     @arg TIM_Channel_4: TIM Channel 4
+  * @param  TIM_CCx: specifies the TIM Channel CCxE bit new state.
+  *   This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable.
+  * @retval None
+  */
+void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
+{
+  uint16_t tmp = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
+  assert_param(IS_TIM_CHANNEL(TIM_Channel));
+  assert_param(IS_TIM_CCX(TIM_CCx));
+
+  tmp = CCER_CCE_Set << TIM_Channel;
+
+  /* Reset the CCxE Bit */
+  TIMx->CCER &= (uint16_t)~ tmp;
+
+  /* Set or reset the CCxE Bit */
+  TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
+}
+
+/**
+  * @brief  Enables or disables the TIM Capture Compare Channel xN.
+  * @param  TIMx: where x can be 1, 8, 15, 16 or 17 to select the TIM peripheral.
+  * @param  TIM_Channel: specifies the TIM Channel
+  *   This parameter can be one of the following values:
+  *     @arg TIM_Channel_1: TIM Channel 1
+  *     @arg TIM_Channel_2: TIM Channel 2
+  *     @arg TIM_Channel_3: TIM Channel 3
+  * @param  TIM_CCxN: specifies the TIM Channel CCxNE bit new state.
+  *   This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable.
+  * @retval None
+  */
+void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
+{
+  uint16_t tmp = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
+  assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
+  assert_param(IS_TIM_CCXN(TIM_CCxN));
+
+  tmp = CCER_CCNE_Set << TIM_Channel;
+
+  /* Reset the CCxNE Bit */
+  TIMx->CCER &= (uint16_t) ~tmp;
+
+  /* Set or reset the CCxNE Bit */
+  TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
+}
+
+/**
+  * @brief  Selects the TIM Output Compare Mode.
+  * @note   This function disables the selected channel before changing the Output
+  *         Compare Mode.
+  *         User has to enable this channel using TIM_CCxCmd and TIM_CCxNCmd functions.
+  * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
+  * @param  TIM_Channel: specifies the TIM Channel
+  *   This parameter can be one of the following values:
+  *     @arg TIM_Channel_1: TIM Channel 1
+  *     @arg TIM_Channel_2: TIM Channel 2
+  *     @arg TIM_Channel_3: TIM Channel 3
+  *     @arg TIM_Channel_4: TIM Channel 4
+  * @param  TIM_OCMode: specifies the TIM Output Compare Mode.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OCMode_Timing
+  *     @arg TIM_OCMode_Active
+  *     @arg TIM_OCMode_Toggle
+  *     @arg TIM_OCMode_PWM1
+  *     @arg TIM_OCMode_PWM2
+  *     @arg TIM_ForcedAction_Active
+  *     @arg TIM_ForcedAction_InActive
+  * @retval None
+  */
+void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
+{
+  uint32_t tmp = 0;
+  uint16_t tmp1 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
+  assert_param(IS_TIM_CHANNEL(TIM_Channel));
+  assert_param(IS_TIM_OCM(TIM_OCMode));
+
+  tmp = (uint32_t) TIMx;
+  tmp += CCMR_Offset;
+
+  tmp1 = CCER_CCE_Set << (uint16_t)TIM_Channel;
+
+  /* Disable the Channel: Reset the CCxE Bit */
+  TIMx->CCER &= (uint16_t) ~tmp1;
+
+  if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
+  {
+    tmp += (TIM_Channel>>1);
+
+    /* Reset the OCxM bits in the CCMRx register */
+    *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC1M);
+
+    /* Configure the OCxM bits in the CCMRx register */
+    *(__IO uint32_t *) tmp |= TIM_OCMode;
+  }
+  else
+  {
+    tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
+
+    /* Reset the OCxM bits in the CCMRx register */
+    *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC2M);
+
+    /* Configure the OCxM bits in the CCMRx register */
+    *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
+  }
+}
+
+/**
+  * @brief  Enables or Disables the TIMx Update event.
+  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
+  * @param  NewState: new state of the TIMx UDIS bit
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Set the Update Disable Bit */
+    TIMx->CR1 |= TIM_CR1_UDIS;
+  }
+  else
+  {
+    /* Reset the Update Disable Bit */
+    TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_UDIS);
+  }
+}
+
+/**
+  * @brief  Configures the TIMx Update Request Interrupt source.
+  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
+  * @param  TIM_UpdateSource: specifies the Update source.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_UpdateSource_Regular: Source of update is the counter overflow/underflow
+                                       or the setting of UG bit, or an update generation
+                                       through the slave mode controller.
+  *     @arg TIM_UpdateSource_Global: Source of update is counter overflow/underflow.
+  * @retval None
+  */
+void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
+  if (TIM_UpdateSource != TIM_UpdateSource_Global)
+  {
+    /* Set the URS Bit */
+    TIMx->CR1 |= TIM_CR1_URS;
+  }
+  else
+  {
+    /* Reset the URS Bit */
+    TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_URS);
+  }
+}
+
+/**
+  * @brief  Enables or disables the TIMx's Hall sensor interface.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  NewState: new state of the TIMx Hall sensor interface.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Set the TI1S Bit */
+    TIMx->CR2 |= TIM_CR2_TI1S;
+  }
+  else
+  {
+    /* Reset the TI1S Bit */
+    TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_TI1S);
+  }
+}
+
+/**
+  * @brief  Selects the TIMx's One Pulse Mode.
+  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
+  * @param  TIM_OPMode: specifies the OPM Mode to be used.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_OPMode_Single
+  *     @arg TIM_OPMode_Repetitive
+  * @retval None
+  */
+void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
+  /* Reset the OPM Bit */
+  TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_OPM);
+  /* Configure the OPM Mode */
+  TIMx->CR1 |= TIM_OPMode;
+}
+
+/**
+  * @brief  Selects the TIMx Trigger Output Mode.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 6, 7, 8, 9, 12 or 15 to select the TIM peripheral.
+  * @param  TIM_TRGOSource: specifies the Trigger Output source.
+  *   This paramter can be one of the following values:
+  *
+  *  - For all TIMx
+  *     @arg TIM_TRGOSource_Reset:  The UG bit in the TIM_EGR register is used as the trigger output (TRGO).
+  *     @arg TIM_TRGOSource_Enable: The Counter Enable CEN is used as the trigger output (TRGO).
+  *     @arg TIM_TRGOSource_Update: The update event is selected as the trigger output (TRGO).
+  *
+  *  - For all TIMx except TIM6 and TIM7
+  *     @arg TIM_TRGOSource_OC1: The trigger output sends a positive pulse when the CC1IF flag
+  *                              is to be set, as soon as a capture or compare match occurs (TRGO).
+  *     @arg TIM_TRGOSource_OC1Ref: OC1REF signal is used as the trigger output (TRGO).
+  *     @arg TIM_TRGOSource_OC2Ref: OC2REF signal is used as the trigger output (TRGO).
+  *     @arg TIM_TRGOSource_OC3Ref: OC3REF signal is used as the trigger output (TRGO).
+  *     @arg TIM_TRGOSource_OC4Ref: OC4REF signal is used as the trigger output (TRGO).
+  *
+  * @retval None
+  */
+void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST7_PERIPH(TIMx));
+  assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
+  /* Reset the MMS Bits */
+  TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_MMS);
+  /* Select the TRGO source */
+  TIMx->CR2 |=  TIM_TRGOSource;
+}
+
+/**
+  * @brief  Selects the TIMx Slave Mode.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
+  * @param  TIM_SlaveMode: specifies the Timer Slave Mode.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_SlaveMode_Reset: Rising edge of the selected trigger signal (TRGI) re-initializes
+  *                               the counter and triggers an update of the registers.
+  *     @arg TIM_SlaveMode_Gated:     The counter clock is enabled when the trigger signal (TRGI) is high.
+  *     @arg TIM_SlaveMode_Trigger:   The counter starts at a rising edge of the trigger TRGI.
+  *     @arg TIM_SlaveMode_External1: Rising edges of the selected trigger (TRGI) clock the counter.
+  * @retval None
+  */
+void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
+  assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
+ /* Reset the SMS Bits */
+  TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_SMS);
+  /* Select the Slave Mode */
+  TIMx->SMCR |= TIM_SlaveMode;
+}
+
+/**
+  * @brief  Sets or Resets the TIMx Master/Slave Mode.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
+  * @param  TIM_MasterSlaveMode: specifies the Timer Master Slave Mode.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_MasterSlaveMode_Enable: synchronization between the current timer
+  *                                      and its slaves (through TRGO).
+  *     @arg TIM_MasterSlaveMode_Disable: No action
+  * @retval None
+  */
+void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
+  assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
+  /* Reset the MSM Bit */
+  TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_MSM);
+
+  /* Set or Reset the MSM Bit */
+  TIMx->SMCR |= TIM_MasterSlaveMode;
+}
+
+/**
+  * @brief  Sets the TIMx Counter Register value
+  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
+  * @param  Counter: specifies the Counter register new value.
+  * @retval None
+  */
+void TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  /* Set the Counter Register value */
+  TIMx->CNT = Counter;
+}
+
+/**
+  * @brief  Sets the TIMx Autoreload Register value
+  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
+  * @param  Autoreload: specifies the Autoreload register new value.
+  * @retval None
+  */
+void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  /* Set the Autoreload Register value */
+  TIMx->ARR = Autoreload;
+}
+
+/**
+  * @brief  Sets the TIMx Capture Compare1 Register value
+  * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
+  * @param  Compare1: specifies the Capture Compare1 register new value.
+  * @retval None
+  */
+void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
+  /* Set the Capture Compare1 Register value */
+  TIMx->CCR1 = Compare1;
+}
+
+/**
+  * @brief  Sets the TIMx Capture Compare2 Register value
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
+  * @param  Compare2: specifies the Capture Compare2 register new value.
+  * @retval None
+  */
+void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
+  /* Set the Capture Compare2 Register value */
+  TIMx->CCR2 = Compare2;
+}
+
+/**
+  * @brief  Sets the TIMx Capture Compare3 Register value
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  Compare3: specifies the Capture Compare3 register new value.
+  * @retval None
+  */
+void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  /* Set the Capture Compare3 Register value */
+  TIMx->CCR3 = Compare3;
+}
+
+/**
+  * @brief  Sets the TIMx Capture Compare4 Register value
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  Compare4: specifies the Capture Compare4 register new value.
+  * @retval None
+  */
+void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  /* Set the Capture Compare4 Register value */
+  TIMx->CCR4 = Compare4;
+}
+
+/**
+  * @brief  Sets the TIMx Input Capture 1 prescaler.
+  * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
+  * @param  TIM_ICPSC: specifies the Input Capture1 prescaler new value.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ICPSC_DIV1: no prescaler
+  *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
+  *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
+  *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
+  * @retval None
+  */
+void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
+  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
+  /* Reset the IC1PSC Bits */
+  TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC1PSC);
+  /* Set the IC1PSC value */
+  TIMx->CCMR1 |= TIM_ICPSC;
+}
+
+/**
+  * @brief  Sets the TIMx Input Capture 2 prescaler.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
+  * @param  TIM_ICPSC: specifies the Input Capture2 prescaler new value.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ICPSC_DIV1: no prescaler
+  *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
+  *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
+  *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
+  * @retval None
+  */
+void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
+  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
+  /* Reset the IC2PSC Bits */
+  TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC2PSC);
+  /* Set the IC2PSC value */
+  TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
+}
+
+/**
+  * @brief  Sets the TIMx Input Capture 3 prescaler.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ICPSC: specifies the Input Capture3 prescaler new value.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ICPSC_DIV1: no prescaler
+  *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
+  *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
+  *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
+  * @retval None
+  */
+void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
+  /* Reset the IC3PSC Bits */
+  TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC3PSC);
+  /* Set the IC3PSC value */
+  TIMx->CCMR2 |= TIM_ICPSC;
+}
+
+/**
+  * @brief  Sets the TIMx Input Capture 4 prescaler.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ICPSC: specifies the Input Capture4 prescaler new value.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ICPSC_DIV1: no prescaler
+  *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
+  *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
+  *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
+  * @retval None
+  */
+void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
+  /* Reset the IC4PSC Bits */
+  TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC4PSC);
+  /* Set the IC4PSC value */
+  TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
+}
+
+/**
+  * @brief  Sets the TIMx Clock Division value.
+  * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select
+  *   the TIM peripheral.
+  * @param  TIM_CKD: specifies the clock division value.
+  *   This parameter can be one of the following value:
+  *     @arg TIM_CKD_DIV1: TDTS = Tck_tim
+  *     @arg TIM_CKD_DIV2: TDTS = 2*Tck_tim
+  *     @arg TIM_CKD_DIV4: TDTS = 4*Tck_tim
+  * @retval None
+  */
+void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
+  assert_param(IS_TIM_CKD_DIV(TIM_CKD));
+  /* Reset the CKD Bits */
+  TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_CKD);
+  /* Set the CKD value */
+  TIMx->CR1 |= TIM_CKD;
+}
+
+/**
+  * @brief  Gets the TIMx Input Capture 1 value.
+  * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
+  * @retval Capture Compare 1 Register value.
+  */
+uint16_t TIM_GetCapture1(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
+  /* Get the Capture 1 Register value */
+  return TIMx->CCR1;
+}
+
+/**
+  * @brief  Gets the TIMx Input Capture 2 value.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
+  * @retval Capture Compare 2 Register value.
+  */
+uint16_t TIM_GetCapture2(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
+  /* Get the Capture 2 Register value */
+  return TIMx->CCR2;
+}
+
+/**
+  * @brief  Gets the TIMx Input Capture 3 value.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @retval Capture Compare 3 Register value.
+  */
+uint16_t TIM_GetCapture3(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  /* Get the Capture 3 Register value */
+  return TIMx->CCR3;
+}
+
+/**
+  * @brief  Gets the TIMx Input Capture 4 value.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @retval Capture Compare 4 Register value.
+  */
+uint16_t TIM_GetCapture4(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
+  /* Get the Capture 4 Register value */
+  return TIMx->CCR4;
+}
+
+/**
+  * @brief  Gets the TIMx Counter value.
+  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
+  * @retval Counter Register value.
+  */
+uint16_t TIM_GetCounter(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  /* Get the Counter Register value */
+  return TIMx->CNT;
+}
+
+/**
+  * @brief  Gets the TIMx Prescaler value.
+  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
+  * @retval Prescaler Register value.
+  */
+uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  /* Get the Prescaler Register value */
+  return TIMx->PSC;
+}
+
+/**
+  * @brief  Checks whether the specified TIM flag is set or not.
+  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
+  * @param  TIM_FLAG: specifies the flag to check.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_FLAG_Update: TIM update Flag
+  *     @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
+  *     @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag
+  *     @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag
+  *     @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag
+  *     @arg TIM_FLAG_COM: TIM Commutation Flag
+  *     @arg TIM_FLAG_Trigger: TIM Trigger Flag
+  *     @arg TIM_FLAG_Break: TIM Break Flag
+  *     @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
+  *     @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
+  *     @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
+  *     @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
+  * @note
+  *   - TIM6 and TIM7 can have only one update flag.
+  *   - TIM9, TIM12 and TIM15 can have only TIM_FLAG_Update, TIM_FLAG_CC1,
+  *      TIM_FLAG_CC2 or TIM_FLAG_Trigger.
+  *   - TIM10, TIM11, TIM13, TIM14, TIM16 and TIM17 can have TIM_FLAG_Update or TIM_FLAG_CC1.
+  *   - TIM_FLAG_Break is used only with TIM1, TIM8 and TIM15.
+  *   - TIM_FLAG_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.
+  * @retval The new state of TIM_FLAG (SET or RESET).
+  */
+FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
+{
+  ITStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
+
+  if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the TIMx's pending flags.
+  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
+  * @param  TIM_FLAG: specifies the flag bit to clear.
+  *   This parameter can be any combination of the following values:
+  *     @arg TIM_FLAG_Update: TIM update Flag
+  *     @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
+  *     @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag
+  *     @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag
+  *     @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag
+  *     @arg TIM_FLAG_COM: TIM Commutation Flag
+  *     @arg TIM_FLAG_Trigger: TIM Trigger Flag
+  *     @arg TIM_FLAG_Break: TIM Break Flag
+  *     @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
+  *     @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
+  *     @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
+  *     @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
+  * @note
+  *   - TIM6 and TIM7 can have only one update flag.
+  *   - TIM9, TIM12 and TIM15 can have only TIM_FLAG_Update, TIM_FLAG_CC1,
+  *      TIM_FLAG_CC2 or TIM_FLAG_Trigger.
+  *   - TIM10, TIM11, TIM13, TIM14, TIM16 and TIM17 can have TIM_FLAG_Update or TIM_FLAG_CC1.
+  *   - TIM_FLAG_Break is used only with TIM1, TIM8 and TIM15.
+  *   - TIM_FLAG_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.
+  * @retval None
+  */
+void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_CLEAR_FLAG(TIM_FLAG));
+
+  /* Clear the flags */
+  TIMx->SR = (uint16_t)~TIM_FLAG;
+}
+
+/**
+  * @brief  Checks whether the TIM interrupt has occurred or not.
+  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
+  * @param  TIM_IT: specifies the TIM interrupt source to check.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_IT_Update: TIM update Interrupt source
+  *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
+  *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
+  *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
+  *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
+  *     @arg TIM_IT_COM: TIM Commutation Interrupt source
+  *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source
+  *     @arg TIM_IT_Break: TIM Break Interrupt source
+  * @note
+  *   - TIM6 and TIM7 can generate only an update interrupt.
+  *   - TIM9, TIM12 and TIM15 can have only TIM_IT_Update, TIM_IT_CC1,
+  *      TIM_IT_CC2 or TIM_IT_Trigger.
+  *   - TIM10, TIM11, TIM13, TIM14, TIM16 and TIM17 can have TIM_IT_Update or TIM_IT_CC1.
+  *   - TIM_IT_Break is used only with TIM1, TIM8 and TIM15.
+  *   - TIM_IT_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.
+  * @retval The new state of the TIM_IT(SET or RESET).
+  */
+ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
+{
+  ITStatus bitstatus = RESET;
+  uint16_t itstatus = 0x0, itenable = 0x0;
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_GET_IT(TIM_IT));
+
+  itstatus = TIMx->SR & TIM_IT;
+
+  itenable = TIMx->DIER & TIM_IT;
+  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the TIMx's interrupt pending bits.
+  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
+  * @param  TIM_IT: specifies the pending bit to clear.
+  *   This parameter can be any combination of the following values:
+  *     @arg TIM_IT_Update: TIM1 update Interrupt source
+  *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
+  *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
+  *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
+  *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
+  *     @arg TIM_IT_COM: TIM Commutation Interrupt source
+  *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source
+  *     @arg TIM_IT_Break: TIM Break Interrupt source
+  * @note
+  *   - TIM6 and TIM7 can generate only an update interrupt.
+  *   - TIM9, TIM12 and TIM15 can have only TIM_IT_Update, TIM_IT_CC1,
+  *      TIM_IT_CC2 or TIM_IT_Trigger.
+  *   - TIM10, TIM11, TIM13, TIM14, TIM16 and TIM17 can have TIM_IT_Update or TIM_IT_CC1.
+  *   - TIM_IT_Break is used only with TIM1, TIM8 and TIM15.
+  *   - TIM_IT_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.
+  * @retval None
+  */
+void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_IT(TIM_IT));
+  /* Clear the IT pending Bit */
+  TIMx->SR = (uint16_t)~TIM_IT;
+}
+
+/**
+  * @brief  Configure the TI1 as Input.
+  * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
+  * @param  TIM_ICPolarity : The Input Polarity.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ICPolarity_Rising
+  *     @arg TIM_ICPolarity_Falling
+  * @param  TIM_ICSelection: specifies the input to be used.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ICSelection_DirectTI: TIM Input 1 is selected to be connected to IC1.
+  *     @arg TIM_ICSelection_IndirectTI: TIM Input 1 is selected to be connected to IC2.
+  *     @arg TIM_ICSelection_TRC: TIM Input 1 is selected to be connected to TRC.
+  * @param  TIM_ICFilter: Specifies the Input Capture Filter.
+  *   This parameter must be a value between 0x00 and 0x0F.
+  * @retval None
+  */
+static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
+                       uint16_t TIM_ICFilter)
+{
+  uint16_t tmpccmr1 = 0, tmpccer = 0;
+  /* Disable the Channel 1: Reset the CC1E Bit */
+  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
+  tmpccmr1 = TIMx->CCMR1;
+  tmpccer = TIMx->CCER;
+  /* Select the Input and set the filter */
+  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
+  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
+
+  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
+     (TIMx == TIM4) ||(TIMx == TIM5))
+  {
+    /* Select the Polarity and set the CC1E Bit */
+    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P));
+    tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
+  }
+  else
+  {
+    /* Select the Polarity and set the CC1E Bit */
+    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP));
+    tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
+  }
+
+  /* Write to TIMx CCMR1 and CCER registers */
+  TIMx->CCMR1 = tmpccmr1;
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @brief  Configure the TI2 as Input.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
+  * @param  TIM_ICPolarity : The Input Polarity.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ICPolarity_Rising
+  *     @arg TIM_ICPolarity_Falling
+  * @param  TIM_ICSelection: specifies the input to be used.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ICSelection_DirectTI: TIM Input 2 is selected to be connected to IC2.
+  *     @arg TIM_ICSelection_IndirectTI: TIM Input 2 is selected to be connected to IC1.
+  *     @arg TIM_ICSelection_TRC: TIM Input 2 is selected to be connected to TRC.
+  * @param  TIM_ICFilter: Specifies the Input Capture Filter.
+  *   This parameter must be a value between 0x00 and 0x0F.
+  * @retval None
+  */
+static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
+                       uint16_t TIM_ICFilter)
+{
+  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
+  /* Disable the Channel 2: Reset the CC2E Bit */
+  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
+  tmpccmr1 = TIMx->CCMR1;
+  tmpccer = TIMx->CCER;
+  tmp = (uint16_t)(TIM_ICPolarity << 4);
+  /* Select the Input and set the filter */
+  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
+  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
+  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
+
+  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
+     (TIMx == TIM4) ||(TIMx == TIM5))
+  {
+    /* Select the Polarity and set the CC2E Bit */
+    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P));
+    tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
+  }
+  else
+  {
+    /* Select the Polarity and set the CC2E Bit */
+    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
+    tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC2E);
+  }
+
+  /* Write to TIMx CCMR1 and CCER registers */
+  TIMx->CCMR1 = tmpccmr1 ;
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @brief  Configure the TI3 as Input.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ICPolarity : The Input Polarity.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ICPolarity_Rising
+  *     @arg TIM_ICPolarity_Falling
+  * @param  TIM_ICSelection: specifies the input to be used.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ICSelection_DirectTI: TIM Input 3 is selected to be connected to IC3.
+  *     @arg TIM_ICSelection_IndirectTI: TIM Input 3 is selected to be connected to IC4.
+  *     @arg TIM_ICSelection_TRC: TIM Input 3 is selected to be connected to TRC.
+  * @param  TIM_ICFilter: Specifies the Input Capture Filter.
+  *   This parameter must be a value between 0x00 and 0x0F.
+  * @retval None
+  */
+static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
+                       uint16_t TIM_ICFilter)
+{
+  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
+  /* Disable the Channel 3: Reset the CC3E Bit */
+  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC3E);
+  tmpccmr2 = TIMx->CCMR2;
+  tmpccer = TIMx->CCER;
+  tmp = (uint16_t)(TIM_ICPolarity << 8);
+  /* Select the Input and set the filter */
+  tmpccmr2 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR2_CC3S)) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC3F)));
+  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
+
+  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
+     (TIMx == TIM4) ||(TIMx == TIM5))
+  {
+    /* Select the Polarity and set the CC3E Bit */
+    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P));
+    tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
+  }
+  else
+  {
+    /* Select the Polarity and set the CC3E Bit */
+    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC3NP));
+    tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC3E);
+  }
+
+  /* Write to TIMx CCMR2 and CCER registers */
+  TIMx->CCMR2 = tmpccmr2;
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @brief  Configure the TI4 as Input.
+  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+  * @param  TIM_ICPolarity : The Input Polarity.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ICPolarity_Rising
+  *     @arg TIM_ICPolarity_Falling
+  * @param  TIM_ICSelection: specifies the input to be used.
+  *   This parameter can be one of the following values:
+  *     @arg TIM_ICSelection_DirectTI: TIM Input 4 is selected to be connected to IC4.
+  *     @arg TIM_ICSelection_IndirectTI: TIM Input 4 is selected to be connected to IC3.
+  *     @arg TIM_ICSelection_TRC: TIM Input 4 is selected to be connected to TRC.
+  * @param  TIM_ICFilter: Specifies the Input Capture Filter.
+  *   This parameter must be a value between 0x00 and 0x0F.
+  * @retval None
+  */
+static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
+                       uint16_t TIM_ICFilter)
+{
+  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
+
+   /* Disable the Channel 4: Reset the CC4E Bit */
+  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC4E);
+  tmpccmr2 = TIMx->CCMR2;
+  tmpccer = TIMx->CCER;
+  tmp = (uint16_t)(TIM_ICPolarity << 12);
+  /* Select the Input and set the filter */
+  tmpccmr2 &= (uint16_t)((uint16_t)(~(uint16_t)TIM_CCMR2_CC4S) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC4F)));
+  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
+  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
+
+  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
+     (TIMx == TIM4) ||(TIMx == TIM5))
+  {
+    /* Select the Polarity and set the CC4E Bit */
+    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC4P));
+    tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
+  }
+  else
+  {
+    /* Select the Polarity and set the CC4E Bit */
+    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC4NP));
+    tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC4E);
+  }
+  /* Write to TIMx CCMR2 and CCER registers */
+  TIMx->CCMR2 = tmpccmr2;
+  TIMx->CCER = tmpccer;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_usart.c b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_usart.c
new file mode 100644
index 0000000..a3f16f1
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_usart.c
@@ -0,0 +1,1058 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_usart.c
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file provides all the USART firmware functions.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x_usart.h"
+#include "stm32f10x_rcc.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup USART
+  * @brief USART driver modules
+  * @{
+  */
+
+/** @defgroup USART_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup USART_Private_Defines
+  * @{
+  */
+
+#define CR1_UE_Set                ((uint16_t)0x2000)  /*!< USART Enable Mask */
+#define CR1_UE_Reset              ((uint16_t)0xDFFF)  /*!< USART Disable Mask */
+
+#define CR1_WAKE_Mask             ((uint16_t)0xF7FF)  /*!< USART WakeUp Method Mask */
+
+#define CR1_RWU_Set               ((uint16_t)0x0002)  /*!< USART mute mode Enable Mask */
+#define CR1_RWU_Reset             ((uint16_t)0xFFFD)  /*!< USART mute mode Enable Mask */
+#define CR1_SBK_Set               ((uint16_t)0x0001)  /*!< USART Break Character send Mask */
+#define CR1_CLEAR_Mask            ((uint16_t)0xE9F3)  /*!< USART CR1 Mask */
+#define CR2_Address_Mask          ((uint16_t)0xFFF0)  /*!< USART address Mask */
+
+#define CR2_LINEN_Set              ((uint16_t)0x4000)  /*!< USART LIN Enable Mask */
+#define CR2_LINEN_Reset            ((uint16_t)0xBFFF)  /*!< USART LIN Disable Mask */
+
+#define CR2_LBDL_Mask             ((uint16_t)0xFFDF)  /*!< USART LIN Break detection Mask */
+#define CR2_STOP_CLEAR_Mask       ((uint16_t)0xCFFF)  /*!< USART CR2 STOP Bits Mask */
+#define CR2_CLOCK_CLEAR_Mask      ((uint16_t)0xF0FF)  /*!< USART CR2 Clock Mask */
+
+#define CR3_SCEN_Set              ((uint16_t)0x0020)  /*!< USART SC Enable Mask */
+#define CR3_SCEN_Reset            ((uint16_t)0xFFDF)  /*!< USART SC Disable Mask */
+
+#define CR3_NACK_Set              ((uint16_t)0x0010)  /*!< USART SC NACK Enable Mask */
+#define CR3_NACK_Reset            ((uint16_t)0xFFEF)  /*!< USART SC NACK Disable Mask */
+
+#define CR3_HDSEL_Set             ((uint16_t)0x0008)  /*!< USART Half-Duplex Enable Mask */
+#define CR3_HDSEL_Reset           ((uint16_t)0xFFF7)  /*!< USART Half-Duplex Disable Mask */
+
+#define CR3_IRLP_Mask             ((uint16_t)0xFFFB)  /*!< USART IrDA LowPower mode Mask */
+#define CR3_CLEAR_Mask            ((uint16_t)0xFCFF)  /*!< USART CR3 Mask */
+
+#define CR3_IREN_Set              ((uint16_t)0x0002)  /*!< USART IrDA Enable Mask */
+#define CR3_IREN_Reset            ((uint16_t)0xFFFD)  /*!< USART IrDA Disable Mask */
+#define GTPR_LSB_Mask             ((uint16_t)0x00FF)  /*!< Guard Time Register LSB Mask */
+#define GTPR_MSB_Mask             ((uint16_t)0xFF00)  /*!< Guard Time Register MSB Mask */
+#define IT_Mask                   ((uint16_t)0x001F)  /*!< USART Interrupt Mask */
+
+/* USART OverSampling-8 Mask */
+#define CR1_OVER8_Set             ((u16)0x8000)  /* USART OVER8 mode Enable Mask */
+#define CR1_OVER8_Reset           ((u16)0x7FFF)  /* USART OVER8 mode Disable Mask */
+
+/* USART One Bit Sampling Mask */
+#define CR3_ONEBITE_Set           ((u16)0x0800)  /* USART ONEBITE mode Enable Mask */
+#define CR3_ONEBITE_Reset         ((u16)0xF7FF)  /* USART ONEBITE mode Disable Mask */
+
+/**
+  * @}
+  */
+
+/** @defgroup USART_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup USART_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup USART_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup USART_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the USARTx peripheral registers to their default reset values.
+  * @param  USARTx: Select the USART or the UART peripheral.
+  *   This parameter can be one of the following values:
+  *      USART1, USART2, USART3, UART4 or UART5.
+  * @retval None
+  */
+void USART_DeInit(USART_TypeDef* USARTx)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+
+  if (USARTx == USART1)
+  {
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
+    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
+  }
+  else if (USARTx == USART2)
+  {
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
+  }
+  else if (USARTx == USART3)
+  {
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
+  }
+  else if (USARTx == UART4)
+  {
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
+    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
+  }
+  else
+  {
+    if (USARTx == UART5)
+    {
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
+    }
+  }
+}
+
+/**
+  * @brief  Initializes the USARTx peripheral according to the specified
+  *         parameters in the USART_InitStruct .
+  * @param  USARTx: Select the USART or the UART peripheral.
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
+  *         that contains the configuration information for the specified USART
+  *         peripheral.
+  * @retval None
+  */
+void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
+{
+  uint32_t tmpreg = 0x00, apbclock = 0x00;
+  uint32_t integerdivider = 0x00;
+  uint32_t fractionaldivider = 0x00;
+  uint32_t usartxbase = 0;
+  RCC_ClocksTypeDef RCC_ClocksStatus;
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));
+  assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
+  assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
+  assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
+  assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
+  assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
+  /* The hardware flow control is available only for USART1, USART2 and USART3 */
+  if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
+  {
+    assert_param(IS_USART_123_PERIPH(USARTx));
+  }
+
+  usartxbase = (uint32_t)USARTx;
+
+/*---------------------------- USART CR2 Configuration -----------------------*/
+  tmpreg = USARTx->CR2;
+  /* Clear STOP[13:12] bits */
+  tmpreg &= CR2_STOP_CLEAR_Mask;
+  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
+  /* Set STOP[13:12] bits according to USART_StopBits value */
+  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
+
+  /* Write to USART CR2 */
+  USARTx->CR2 = (uint16_t)tmpreg;
+
+/*---------------------------- USART CR1 Configuration -----------------------*/
+  tmpreg = USARTx->CR1;
+  /* Clear M, PCE, PS, TE and RE bits */
+  tmpreg &= CR1_CLEAR_Mask;
+  /* Configure the USART Word Length, Parity and mode ----------------------- */
+  /* Set the M bits according to USART_WordLength value */
+  /* Set PCE and PS bits according to USART_Parity value */
+  /* Set TE and RE bits according to USART_Mode value */
+  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
+            USART_InitStruct->USART_Mode;
+  /* Write to USART CR1 */
+  USARTx->CR1 = (uint16_t)tmpreg;
+
+/*---------------------------- USART CR3 Configuration -----------------------*/
+  tmpreg = USARTx->CR3;
+  /* Clear CTSE and RTSE bits */
+  tmpreg &= CR3_CLEAR_Mask;
+  /* Configure the USART HFC -------------------------------------------------*/
+  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
+  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
+  /* Write to USART CR3 */
+  USARTx->CR3 = (uint16_t)tmpreg;
+
+/*---------------------------- USART BRR Configuration -----------------------*/
+  /* Configure the USART Baud Rate -------------------------------------------*/
+  RCC_GetClocksFreq(&RCC_ClocksStatus);
+  if (usartxbase == USART1_BASE)
+  {
+    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
+  }
+  else
+  {
+    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
+  }
+
+  /* Determine the integer part */
+  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
+  {
+    /* Integer part computing in case Oversampling mode is 8 Samples */
+    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));
+  }
+  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
+  {
+    /* Integer part computing in case Oversampling mode is 16 Samples */
+    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));
+  }
+  tmpreg = (integerdivider / 100) << 4;
+
+  /* Determine the fractional part */
+  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
+
+  /* Implement the fractional part in the register */
+  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
+  {
+    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
+  }
+  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
+  {
+    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
+  }
+
+  /* Write to USART BRR */
+  USARTx->BRR = (uint16_t)tmpreg;
+}
+
+/**
+  * @brief  Fills each USART_InitStruct member with its default value.
+  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
+  *         which will be initialized.
+  * @retval None
+  */
+void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
+{
+  /* USART_InitStruct members default value */
+  USART_InitStruct->USART_BaudRate = 9600;
+  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
+  USART_InitStruct->USART_StopBits = USART_StopBits_1;
+  USART_InitStruct->USART_Parity = USART_Parity_No ;
+  USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
+  USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;
+}
+
+/**
+  * @brief  Initializes the USARTx peripheral Clock according to the
+  *          specified parameters in the USART_ClockInitStruct .
+  * @param  USARTx: where x can be 1, 2, 3 to select the USART peripheral.
+  * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef
+  *         structure that contains the configuration information for the specified
+  *         USART peripheral.
+  * @note The Smart Card and Synchronous modes are not available for UART4 and UART5.
+  * @retval None
+  */
+void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
+{
+  uint32_t tmpreg = 0x00;
+  /* Check the parameters */
+  assert_param(IS_USART_123_PERIPH(USARTx));
+  assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
+  assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
+  assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
+  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
+
+/*---------------------------- USART CR2 Configuration -----------------------*/
+  tmpreg = USARTx->CR2;
+  /* Clear CLKEN, CPOL, CPHA and LBCL bits */
+  tmpreg &= CR2_CLOCK_CLEAR_Mask;
+  /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
+  /* Set CLKEN bit according to USART_Clock value */
+  /* Set CPOL bit according to USART_CPOL value */
+  /* Set CPHA bit according to USART_CPHA value */
+  /* Set LBCL bit according to USART_LastBit value */
+  tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL |
+                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
+  /* Write to USART CR2 */
+  USARTx->CR2 = (uint16_t)tmpreg;
+}
+
+/**
+  * @brief  Fills each USART_ClockInitStruct member with its default value.
+  * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef
+  *         structure which will be initialized.
+  * @retval None
+  */
+void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
+{
+  /* USART_ClockInitStruct members default value */
+  USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
+  USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
+  USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
+  USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
+}
+
+/**
+  * @brief  Enables or disables the specified USART peripheral.
+  * @param  USARTx: Select the USART or the UART peripheral.
+  *         This parameter can be one of the following values:
+  *           USART1, USART2, USART3, UART4 or UART5.
+  * @param  NewState: new state of the USARTx peripheral.
+  *         This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected USART by setting the UE bit in the CR1 register */
+    USARTx->CR1 |= CR1_UE_Set;
+  }
+  else
+  {
+    /* Disable the selected USART by clearing the UE bit in the CR1 register */
+    USARTx->CR1 &= CR1_UE_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the specified USART interrupts.
+  * @param  USARTx: Select the USART or the UART peripheral.
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  USART_IT: specifies the USART interrupt sources to be enabled or disabled.
+  *   This parameter can be one of the following values:
+  *     @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
+  *     @arg USART_IT_LBD:  LIN Break detection interrupt
+  *     @arg USART_IT_TXE:  Transmit Data Register empty interrupt
+  *     @arg USART_IT_TC:   Transmission complete interrupt
+  *     @arg USART_IT_RXNE: Receive Data register not empty interrupt
+  *     @arg USART_IT_IDLE: Idle line detection interrupt
+  *     @arg USART_IT_PE:   Parity Error interrupt
+  *     @arg USART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
+  * @param  NewState: new state of the specified USARTx interrupts.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
+{
+  uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
+  uint32_t usartxbase = 0x00;
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_CONFIG_IT(USART_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  /* The CTS interrupt is not available for UART4 and UART5 */
+  if (USART_IT == USART_IT_CTS)
+  {
+    assert_param(IS_USART_123_PERIPH(USARTx));
+  }
+
+  usartxbase = (uint32_t)USARTx;
+
+  /* Get the USART register index */
+  usartreg = (((uint8_t)USART_IT) >> 0x05);
+
+  /* Get the interrupt position */
+  itpos = USART_IT & IT_Mask;
+  itmask = (((uint32_t)0x01) << itpos);
+
+  if (usartreg == 0x01) /* The IT is in CR1 register */
+  {
+    usartxbase += 0x0C;
+  }
+  else if (usartreg == 0x02) /* The IT is in CR2 register */
+  {
+    usartxbase += 0x10;
+  }
+  else /* The IT is in CR3 register */
+  {
+    usartxbase += 0x14;
+  }
+  if (NewState != DISABLE)
+  {
+    *(__IO uint32_t*)usartxbase  |= itmask;
+  }
+  else
+  {
+    *(__IO uint32_t*)usartxbase &= ~itmask;
+  }
+}
+
+/**
+  * @brief  Enables or disables the USARTs DMA interface.
+  * @param  USARTx: Select the USART or the UART peripheral.
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  USART_DMAReq: specifies the DMA request.
+  *   This parameter can be any combination of the following values:
+  *     @arg USART_DMAReq_Tx: USART DMA transmit request
+  *     @arg USART_DMAReq_Rx: USART DMA receive request
+  * @param  NewState: new state of the DMA Request sources.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @note The DMA mode is not available for UART5 except in the STM32
+  *       High density value line devices(STM32F10X_HD_VL).
+  * @retval None
+  */
+void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_DMAREQ(USART_DMAReq));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the DMA transfer for selected requests by setting the DMAT and/or
+       DMAR bits in the USART CR3 register */
+    USARTx->CR3 |= USART_DMAReq;
+  }
+  else
+  {
+    /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
+       DMAR bits in the USART CR3 register */
+    USARTx->CR3 &= (uint16_t)~USART_DMAReq;
+  }
+}
+
+/**
+  * @brief  Sets the address of the USART node.
+  * @param  USARTx: Select the USART or the UART peripheral.
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  USART_Address: Indicates the address of the USART node.
+  * @retval None
+  */
+void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_ADDRESS(USART_Address));
+
+  /* Clear the USART address */
+  USARTx->CR2 &= CR2_Address_Mask;
+  /* Set the USART address node */
+  USARTx->CR2 |= USART_Address;
+}
+
+/**
+  * @brief  Selects the USART WakeUp method.
+  * @param  USARTx: Select the USART or the UART peripheral.
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  USART_WakeUp: specifies the USART wakeup method.
+  *   This parameter can be one of the following values:
+  *     @arg USART_WakeUp_IdleLine: WakeUp by an idle line detection
+  *     @arg USART_WakeUp_AddressMark: WakeUp by an address mark
+  * @retval None
+  */
+void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_WAKEUP(USART_WakeUp));
+
+  USARTx->CR1 &= CR1_WAKE_Mask;
+  USARTx->CR1 |= USART_WakeUp;
+}
+
+/**
+  * @brief  Determines if the USART is in mute mode or not.
+  * @param  USARTx: Select the USART or the UART peripheral.
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  NewState: new state of the USART mute mode.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
+    USARTx->CR1 |= CR1_RWU_Set;
+  }
+  else
+  {
+    /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
+    USARTx->CR1 &= CR1_RWU_Reset;
+  }
+}
+
+/**
+  * @brief  Sets the USART LIN Break detection length.
+  * @param  USARTx: Select the USART or the UART peripheral.
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  USART_LINBreakDetectLength: specifies the LIN break detection length.
+  *   This parameter can be one of the following values:
+  *     @arg USART_LINBreakDetectLength_10b: 10-bit break detection
+  *     @arg USART_LINBreakDetectLength_11b: 11-bit break detection
+  * @retval None
+  */
+void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
+
+  USARTx->CR2 &= CR2_LBDL_Mask;
+  USARTx->CR2 |= USART_LINBreakDetectLength;
+}
+
+/**
+  * @brief  Enables or disables the USARTs LIN mode.
+  * @param  USARTx: Select the USART or the UART peripheral.
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  NewState: new state of the USART LIN mode.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
+    USARTx->CR2 |= CR2_LINEN_Set;
+  }
+  else
+  {
+    /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
+    USARTx->CR2 &= CR2_LINEN_Reset;
+  }
+}
+
+/**
+  * @brief  Transmits single data through the USARTx peripheral.
+  * @param  USARTx: Select the USART or the UART peripheral.
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  Data: the data to transmit.
+  * @retval None
+  */
+void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_DATA(Data));
+
+  /* Transmit Data */
+  USARTx->DR = (Data & (uint16_t)0x01FF);
+}
+
+/**
+  * @brief  Returns the most recent received data by the USARTx peripheral.
+  * @param  USARTx: Select the USART or the UART peripheral.
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @retval The received data.
+  */
+uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+
+  /* Receive Data */
+  return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
+}
+
+/**
+  * @brief  Transmits break characters.
+  * @param  USARTx: Select the USART or the UART peripheral.
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @retval None
+  */
+void USART_SendBreak(USART_TypeDef* USARTx)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+
+  /* Send break characters */
+  USARTx->CR1 |= CR1_SBK_Set;
+}
+
+/**
+  * @brief  Sets the specified USART guard time.
+  * @param  USARTx: where x can be 1, 2 or 3 to select the USART peripheral.
+  * @param  USART_GuardTime: specifies the guard time.
+  * @note The guard time bits are not available for UART4 and UART5.
+  * @retval None
+  */
+void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_123_PERIPH(USARTx));
+
+  /* Clear the USART Guard time */
+  USARTx->GTPR &= GTPR_LSB_Mask;
+  /* Set the USART guard time */
+  USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
+}
+
+/**
+  * @brief  Sets the system clock prescaler.
+  * @param  USARTx: Select the USART or the UART peripheral.
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  USART_Prescaler: specifies the prescaler clock.
+  * @note   The function is used for IrDA mode with UART4 and UART5.
+  * @retval None
+  */
+void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+
+  /* Clear the USART prescaler */
+  USARTx->GTPR &= GTPR_MSB_Mask;
+  /* Set the USART prescaler */
+  USARTx->GTPR |= USART_Prescaler;
+}
+
+/**
+  * @brief  Enables or disables the USARTs Smart Card mode.
+  * @param  USARTx: where x can be 1, 2 or 3 to select the USART peripheral.
+  * @param  NewState: new state of the Smart Card mode.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @note The Smart Card mode is not available for UART4 and UART5.
+  * @retval None
+  */
+void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_123_PERIPH(USARTx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the SC mode by setting the SCEN bit in the CR3 register */
+    USARTx->CR3 |= CR3_SCEN_Set;
+  }
+  else
+  {
+    /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
+    USARTx->CR3 &= CR3_SCEN_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables NACK transmission.
+  * @param  USARTx: where x can be 1, 2 or 3 to select the USART peripheral.
+  * @param  NewState: new state of the NACK transmission.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @note The Smart Card mode is not available for UART4 and UART5.
+  * @retval None
+  */
+void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_123_PERIPH(USARTx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  if (NewState != DISABLE)
+  {
+    /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
+    USARTx->CR3 |= CR3_NACK_Set;
+  }
+  else
+  {
+    /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
+    USARTx->CR3 &= CR3_NACK_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the USARTs Half Duplex communication.
+  * @param  USARTx: Select the USART or the UART peripheral.
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  NewState: new state of the USART Communication.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
+    USARTx->CR3 |= CR3_HDSEL_Set;
+  }
+  else
+  {
+    /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
+    USARTx->CR3 &= CR3_HDSEL_Reset;
+  }
+}
+
+
+/**
+  * @brief  Enables or disables the USART's 8x oversampling mode.
+  * @param  USARTx: Select the USART or the UART peripheral.
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  NewState: new state of the USART one bit sampling method.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @note
+  *     This function has to be called before calling USART_Init()
+  *     function in order to have correct baudrate Divider value.
+  * @retval None
+  */
+void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
+    USARTx->CR1 |= CR1_OVER8_Set;
+  }
+  else
+  {
+    /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
+    USARTx->CR1 &= CR1_OVER8_Reset;
+  }
+}
+
+/**
+  * @brief  Enables or disables the USART's one bit sampling method.
+  * @param  USARTx: Select the USART or the UART peripheral.
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  NewState: new state of the USART one bit sampling method.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
+    USARTx->CR3 |= CR3_ONEBITE_Set;
+  }
+  else
+  {
+    /* Disable tthe one bit method by clearing the ONEBITE bit in the CR3 register */
+    USARTx->CR3 &= CR3_ONEBITE_Reset;
+  }
+}
+
+/**
+  * @brief  Configures the USART's IrDA interface.
+  * @param  USARTx: Select the USART or the UART peripheral.
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  USART_IrDAMode: specifies the IrDA mode.
+  *   This parameter can be one of the following values:
+  *     @arg USART_IrDAMode_LowPower
+  *     @arg USART_IrDAMode_Normal
+  * @retval None
+  */
+void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
+
+  USARTx->CR3 &= CR3_IRLP_Mask;
+  USARTx->CR3 |= USART_IrDAMode;
+}
+
+/**
+  * @brief  Enables or disables the USART's IrDA interface.
+  * @param  USARTx: Select the USART or the UART peripheral.
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  NewState: new state of the IrDA mode.
+  *   This parameter can be: ENABLE or DISABLE.
+  * @retval None
+  */
+void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
+    USARTx->CR3 |= CR3_IREN_Set;
+  }
+  else
+  {
+    /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
+    USARTx->CR3 &= CR3_IREN_Reset;
+  }
+}
+
+/**
+  * @brief  Checks whether the specified USART flag is set or not.
+  * @param  USARTx: Select the USART or the UART peripheral.
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  USART_FLAG: specifies the flag to check.
+  *   This parameter can be one of the following values:
+  *     @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5)
+  *     @arg USART_FLAG_LBD:  LIN Break detection flag
+  *     @arg USART_FLAG_TXE:  Transmit data register empty flag
+  *     @arg USART_FLAG_TC:   Transmission Complete flag
+  *     @arg USART_FLAG_RXNE: Receive data register not empty flag
+  *     @arg USART_FLAG_IDLE: Idle Line detection flag
+  *     @arg USART_FLAG_ORE:  OverRun Error flag
+  *     @arg USART_FLAG_NE:   Noise Error flag
+  *     @arg USART_FLAG_FE:   Framing Error flag
+  *     @arg USART_FLAG_PE:   Parity Error flag
+  * @retval The new state of USART_FLAG (SET or RESET).
+  */
+FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_FLAG(USART_FLAG));
+  /* The CTS flag is not available for UART4 and UART5 */
+  if (USART_FLAG == USART_FLAG_CTS)
+  {
+    assert_param(IS_USART_123_PERIPH(USARTx));
+  }
+
+  if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the USARTx's pending flags.
+  * @param  USARTx: Select the USART or the UART peripheral.
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  USART_FLAG: specifies the flag to clear.
+  *   This parameter can be any combination of the following values:
+  *     @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5).
+  *     @arg USART_FLAG_LBD:  LIN Break detection flag.
+  *     @arg USART_FLAG_TC:   Transmission Complete flag.
+  *     @arg USART_FLAG_RXNE: Receive data register not empty flag.
+  *
+  * @note
+  *   - PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun
+  *     error) and IDLE (Idle line detected) flags are cleared by software
+  *     sequence: a read operation to USART_SR register (USART_GetFlagStatus())
+  *     followed by a read operation to USART_DR register (USART_ReceiveData()).
+  *   - RXNE flag can be also cleared by a read to the USART_DR register
+  *     (USART_ReceiveData()).
+  *   - TC flag can be also cleared by software sequence: a read operation to
+  *     USART_SR register (USART_GetFlagStatus()) followed by a write operation
+  *     to USART_DR register (USART_SendData()).
+  *   - TXE flag is cleared only by a write to the USART_DR register
+  *     (USART_SendData()).
+  * @retval None
+  */
+void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
+  /* The CTS flag is not available for UART4 and UART5 */
+  if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
+  {
+    assert_param(IS_USART_123_PERIPH(USARTx));
+  }
+
+  USARTx->SR = (uint16_t)~USART_FLAG;
+}
+
+/**
+  * @brief  Checks whether the specified USART interrupt has occurred or not.
+  * @param  USARTx: Select the USART or the UART peripheral.
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  USART_IT: specifies the USART interrupt source to check.
+  *   This parameter can be one of the following values:
+  *     @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
+  *     @arg USART_IT_LBD:  LIN Break detection interrupt
+  *     @arg USART_IT_TXE:  Tansmit Data Register empty interrupt
+  *     @arg USART_IT_TC:   Transmission complete interrupt
+  *     @arg USART_IT_RXNE: Receive Data register not empty interrupt
+  *     @arg USART_IT_IDLE: Idle line detection interrupt
+  *     @arg USART_IT_ORE:  OverRun Error interrupt
+  *     @arg USART_IT_NE:   Noise Error interrupt
+  *     @arg USART_IT_FE:   Framing Error interrupt
+  *     @arg USART_IT_PE:   Parity Error interrupt
+  * @retval The new state of USART_IT (SET or RESET).
+  */
+ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
+{
+  uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
+  ITStatus bitstatus = RESET;
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_GET_IT(USART_IT));
+  /* The CTS interrupt is not available for UART4 and UART5 */
+  if (USART_IT == USART_IT_CTS)
+  {
+    assert_param(IS_USART_123_PERIPH(USARTx));
+  }
+
+  /* Get the USART register index */
+  usartreg = (((uint8_t)USART_IT) >> 0x05);
+  /* Get the interrupt position */
+  itmask = USART_IT & IT_Mask;
+  itmask = (uint32_t)0x01 << itmask;
+
+  if (usartreg == 0x01) /* The IT  is in CR1 register */
+  {
+    itmask &= USARTx->CR1;
+  }
+  else if (usartreg == 0x02) /* The IT  is in CR2 register */
+  {
+    itmask &= USARTx->CR2;
+  }
+  else /* The IT  is in CR3 register */
+  {
+    itmask &= USARTx->CR3;
+  }
+
+  bitpos = USART_IT >> 0x08;
+  bitpos = (uint32_t)0x01 << bitpos;
+  bitpos &= USARTx->SR;
+  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+
+  return bitstatus;
+}
+
+/**
+  * @brief  Clears the USARTx's interrupt pending bits.
+  * @param  USARTx: Select the USART or the UART peripheral.
+  *   This parameter can be one of the following values:
+  *   USART1, USART2, USART3, UART4 or UART5.
+  * @param  USART_IT: specifies the interrupt pending bit to clear.
+  *   This parameter can be one of the following values:
+  *     @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
+  *     @arg USART_IT_LBD:  LIN Break detection interrupt
+  *     @arg USART_IT_TC:   Transmission complete interrupt.
+  *     @arg USART_IT_RXNE: Receive Data register not empty interrupt.
+  *
+  * @note
+  *   - PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun
+  *     error) and IDLE (Idle line detected) pending bits are cleared by
+  *     software sequence: a read operation to USART_SR register
+  *     (USART_GetITStatus()) followed by a read operation to USART_DR register
+  *     (USART_ReceiveData()).
+  *   - RXNE pending bit can be also cleared by a read to the USART_DR register
+  *     (USART_ReceiveData()).
+  *   - TC pending bit can be also cleared by software sequence: a read
+  *     operation to USART_SR register (USART_GetITStatus()) followed by a write
+  *     operation to USART_DR register (USART_SendData()).
+  *   - TXE pending bit is cleared only by a write to the USART_DR register
+  *     (USART_SendData()).
+  * @retval None
+  */
+void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
+{
+  uint16_t bitpos = 0x00, itmask = 0x00;
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_CLEAR_IT(USART_IT));
+  /* The CTS interrupt is not available for UART4 and UART5 */
+  if (USART_IT == USART_IT_CTS)
+  {
+    assert_param(IS_USART_123_PERIPH(USARTx));
+  }
+
+  bitpos = USART_IT >> 0x08;
+  itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
+  USARTx->SR = (uint16_t)~itmask;
+}
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_wwdg.c b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_wwdg.c
new file mode 100644
index 0000000..77a7ce5
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_wwdg.c
@@ -0,0 +1,224 @@
+/**
+  ******************************************************************************
+  * @file    stm32f10x_wwdg.c
+  * @author  MCD Application Team
+  * @version V3.5.0
+  * @date    11-March-2011
+  * @brief   This file provides all the WWDG firmware functions.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32f10x_wwdg.h"
+#include "stm32f10x_rcc.h"
+
+/** @addtogroup STM32F10x_StdPeriph_Driver
+  * @{
+  */
+
+/** @defgroup WWDG
+  * @brief WWDG driver modules
+  * @{
+  */
+
+/** @defgroup WWDG_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup WWDG_Private_Defines
+  * @{
+  */
+
+/* ----------- WWDG registers bit address in the alias region ----------- */
+#define WWDG_OFFSET       (WWDG_BASE - PERIPH_BASE)
+
+/* Alias word address of EWI bit */
+#define CFR_OFFSET        (WWDG_OFFSET + 0x04)
+#define EWI_BitNumber     0x09
+#define CFR_EWI_BB        (PERIPH_BB_BASE + (CFR_OFFSET * 32) + (EWI_BitNumber * 4))
+
+/* --------------------- WWDG registers bit mask ------------------------ */
+
+/* CR register bit mask */
+#define CR_WDGA_Set       ((uint32_t)0x00000080)
+
+/* CFR register bit mask */
+#define CFR_WDGTB_Mask    ((uint32_t)0xFFFFFE7F)
+#define CFR_W_Mask        ((uint32_t)0xFFFFFF80)
+#define BIT_Mask          ((uint8_t)0x7F)
+
+/**
+  * @}
+  */
+
+/** @defgroup WWDG_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup WWDG_Private_Variables
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup WWDG_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @defgroup WWDG_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Deinitializes the WWDG peripheral registers to their default reset values.
+  * @param  None
+  * @retval None
+  */
+void WWDG_DeInit(void)
+{
+  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, ENABLE);
+  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, DISABLE);
+}
+
+/**
+  * @brief  Sets the WWDG Prescaler.
+  * @param  WWDG_Prescaler: specifies the WWDG Prescaler.
+  *   This parameter can be one of the following values:
+  *     @arg WWDG_Prescaler_1: WWDG counter clock = (PCLK1/4096)/1
+  *     @arg WWDG_Prescaler_2: WWDG counter clock = (PCLK1/4096)/2
+  *     @arg WWDG_Prescaler_4: WWDG counter clock = (PCLK1/4096)/4
+  *     @arg WWDG_Prescaler_8: WWDG counter clock = (PCLK1/4096)/8
+  * @retval None
+  */
+void WWDG_SetPrescaler(uint32_t WWDG_Prescaler)
+{
+  uint32_t tmpreg = 0;
+  /* Check the parameters */
+  assert_param(IS_WWDG_PRESCALER(WWDG_Prescaler));
+  /* Clear WDGTB[1:0] bits */
+  tmpreg = WWDG->CFR & CFR_WDGTB_Mask;
+  /* Set WDGTB[1:0] bits according to WWDG_Prescaler value */
+  tmpreg |= WWDG_Prescaler;
+  /* Store the new value */
+  WWDG->CFR = tmpreg;
+}
+
+/**
+  * @brief  Sets the WWDG window value.
+  * @param  WindowValue: specifies the window value to be compared to the downcounter.
+  *   This parameter value must be lower than 0x80.
+  * @retval None
+  */
+void WWDG_SetWindowValue(uint8_t WindowValue)
+{
+  __IO uint32_t tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_WWDG_WINDOW_VALUE(WindowValue));
+  /* Clear W[6:0] bits */
+
+  tmpreg = WWDG->CFR & CFR_W_Mask;
+
+  /* Set W[6:0] bits according to WindowValue value */
+  tmpreg |= WindowValue & (uint32_t) BIT_Mask;
+
+  /* Store the new value */
+  WWDG->CFR = tmpreg;
+}
+
+/**
+  * @brief  Enables the WWDG Early Wakeup interrupt(EWI).
+  * @param  None
+  * @retval None
+  */
+void WWDG_EnableIT(void)
+{
+  *(__IO uint32_t *) CFR_EWI_BB = (uint32_t)ENABLE;
+}
+
+/**
+  * @brief  Sets the WWDG counter value.
+  * @param  Counter: specifies the watchdog counter value.
+  *   This parameter must be a number between 0x40 and 0x7F.
+  * @retval None
+  */
+void WWDG_SetCounter(uint8_t Counter)
+{
+  /* Check the parameters */
+  assert_param(IS_WWDG_COUNTER(Counter));
+  /* Write to T[6:0] bits to configure the counter value, no need to do
+     a read-modify-write; writing a 0 to WDGA bit does nothing */
+  WWDG->CR = Counter & BIT_Mask;
+}
+
+/**
+  * @brief  Enables WWDG and load the counter value.
+  * @param  Counter: specifies the watchdog counter value.
+  *   This parameter must be a number between 0x40 and 0x7F.
+  * @retval None
+  */
+void WWDG_Enable(uint8_t Counter)
+{
+  /* Check the parameters */
+  assert_param(IS_WWDG_COUNTER(Counter));
+  WWDG->CR = CR_WDGA_Set | Counter;
+}
+
+/**
+  * @brief  Checks whether the Early Wakeup interrupt flag is set or not.
+  * @param  None
+  * @retval The new state of the Early Wakeup interrupt flag (SET or RESET)
+  */
+FlagStatus WWDG_GetFlagStatus(void)
+{
+  return (FlagStatus)(WWDG->SR);
+}
+
+/**
+  * @brief  Clears Early Wakeup interrupt flag.
+  * @param  None
+  * @retval None
+  */
+void WWDG_ClearFlag(void)
+{
+  WWDG->SR = (uint32_t)RESET;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Release_Notes.html b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Release_Notes.html
new file mode 100644
index 0000000..e753bf3
--- /dev/null
+++ b/bsp/boards/vesna/library/STM32F10x_StdPeriph_Lib_V3.5.0/Release_Notes.html
@@ -0,0 +1,1031 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:w="urn:schemas-microsoft-com:office:word" xmlns="http://www.w3.org/TR/REC-html40"><head>
+
+
+
+
+
+
+
+
+
+
+
+<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+<link rel="File-List" href="Library_files/filelist.xml">
+<link rel="Edit-Time-Data" href="Library_files/editdata.mso"><!--[if !mso]> <style> v\:* {behavior:url(#default#VML);} o\:* {behavior:url(#default#VML);} w\:* {behavior:url(#default#VML);} .shape {behavior:url(#default#VML);} </style> <![endif]--><title>Release Notes for STM32F10x Standard Peripherals Library</title><!--[if gte mso 9]><xml> <o:DocumentProperties> <o:Author>STMicroelectronics</o:Author> <o:LastAuthor>STMicroelectronics</o:LastAuthor> <o:Revision>37</o:Revision> <o:TotalTime>136</o:TotalTime> <o:Created>2009-02-27T19:26:00Z</o:Created> <o:LastSaved>2009-03-01T17:56:00Z</o:LastSaved> <o:Pages>1</o:Pages> <o:Words>522</o:Words> <o:Characters>2977</o:Characters> <o:Company>STMicroelectronics</o:Company> <o:Lines>24</o:Lines> <o:Paragraphs>6</o:Paragraphs> <o:CharactersWithSpaces>3493</o:CharactersWithSpaces> <o:Version>11.6568</o:Version> </o:DocumentProperties> </xml><![endif]--><!--[if gte mso 9]><xml> <w:WordDocument> <w:Zoom>110</w:Zoom> <w:ValidateAgainstSchemas/> <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid> <w:IgnoreMixedContent>false</w:IgnoreMixedContent> <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText> <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel> </w:WordDocument> </xml><![endif]--><!--[if gte mso 9]><xml> <w:LatentStyles DefLockedState="false" LatentStyleCount="156"> </w:LatentStyles> </xml><![endif]-->
+
+
+
+<style>
+<!--
+/* Style Definitions */
+p.MsoNormal, li.MsoNormal, div.MsoNormal
+{mso-style-parent:"";
+margin:0in;
+margin-bottom:.0001pt;
+mso-pagination:widow-orphan;
+font-size:12.0pt;
+font-family:"Times New Roman";
+mso-fareast-font-family:"Times New Roman";}
+h2
+{mso-style-next:Normal;
+margin-top:12.0pt;
+margin-right:0in;
+margin-bottom:3.0pt;
+margin-left:0in;
+mso-pagination:widow-orphan;
+page-break-after:avoid;
+mso-outline-level:2;
+font-size:14.0pt;
+font-family:Arial;
+font-weight:bold;
+font-style:italic;}
+a:link, span.MsoHyperlink
+{color:blue;
+text-decoration:underline;
+text-underline:single;}
+a:visited, span.MsoHyperlinkFollowed
+{color:blue;
+text-decoration:underline;
+text-underline:single;}
+p
+{mso-margin-top-alt:auto;
+margin-right:0in;
+mso-margin-bottom-alt:auto;
+margin-left:0in;
+mso-pagination:widow-orphan;
+font-size:12.0pt;
+font-family:"Times New Roman";
+mso-fareast-font-family:"Times New Roman";}
+@page Section1
+{size:8.5in 11.0in;
+margin:1.0in 1.25in 1.0in 1.25in;
+mso-header-margin:.5in;
+mso-footer-margin:.5in;
+mso-paper-source:0;}
+div.Section1
+{page:Section1;}
+-->
+</style><!--[if gte mso 10]> <style> /* Style Definitions */ table.MsoNormalTable {mso-style-name:"Table Normal"; mso-tstyle-rowband-size:0; mso-tstyle-colband-size:0; mso-style-noshow:yes; mso-style-parent:""; mso-padding-alt:0in 5.4pt 0in 5.4pt; mso-para-margin:0in; mso-para-margin-bottom:.0001pt; mso-pagination:widow-orphan; font-size:10.0pt; font-family:"Times New Roman"; mso-ansi-language:#0400; mso-fareast-language:#0400; mso-bidi-language:#0400;} </style> <![endif]--><!--[if gte mso 9]><xml> <o:shapedefaults v:ext="edit" spidmax="5122"/> </xml><![endif]--><!--[if gte mso 9]><xml> <o:shapelayout v:ext="edit"> <o:idmap v:ext="edit" data="1"/> </o:shapelayout></xml><![endif]--></head><body lang="EN-US" link="blue" vlink="blue">
+<div class="Section1">
+<p class="MsoNormal"><span style="font-family: Arial;"><o:p><br></o:p></span><a href="../../../DOC/Others/FWLib/CHM_Generator/Library_html/index.html"></a></p>
+<div align="center">
+<table class="MsoNormalTable" style="width: 675pt;" border="0" cellpadding="0" cellspacing="0" width="900">
+<tbody>
+<tr style="">
+<td style="padding: 0cm;" valign="top">
+<table class="MsoNormalTable" style="width: 675pt;" border="0" cellpadding="0" cellspacing="0" width="900">
+<tbody>
+<tr style="">
+<td style="padding: 1.5pt;">
+<h1 style="margin-bottom: 18pt; text-align: center;" align="center"><span style="font-size: 20pt; font-family: Verdana; color: rgb(51, 102, 255);">Release
+Notes for STM32F10x Standard Peripherals Library (StdPeriph_Lib)</span><span style="font-size: 20pt; font-family: Verdana;"><o:p></o:p></span></h1>
+
+<p class="MsoNormal" style="text-align: center;" align="center"><span style="font-size: 10pt; font-family: Arial; color: black;">Copyright 2011 STMicroelectronics</span><span style="color: black;"><u1:p></u1:p><o:p></o:p></span></p>
+<p class="MsoNormal" style="text-align: center;" align="center"><span style="font-size: 10pt; font-family: Arial; color: black;"><img id="_x0000_i1025" src="_htmresc/logo.bmp" style="border-style: solid; border-width: 0px; height: 65px; width: 86px;" height="65" width="86"></span><span style="font-size: 10pt;"><o:p></o:p></span></p>
+</td>
+</tr>
+</tbody>
+</table>
+<p class="MsoNormal"><span style="font-family: Arial; display: none;"><o:p>&nbsp;</o:p></span></p>
+<table class="MsoNormalTable" style="width: 675pt;" border="0" cellpadding="0" width="900">
+<tbody>
+<tr style="">
+<td style="padding: 0cm;" valign="top">
+<h2 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;"><span style="font-size: 12pt; color: white;">Contents<o:p></o:p></span></h2>
+<ol style="margin-top: 0cm;" start="1" type="1">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"><a href="#History">STM32F10x Standard Peripherals Library
+update History</a><o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"><a href="#License">License</a><o:p></o:p></span></li>
+</ol>
+<span style="font-family: &quot;Times New Roman&quot;;"></span>
+<h2 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;"><a name="History"></a><span style="font-size: 12pt; color: white;">STM32F10x Standard
+Peripherals Library update History</span></h2><br>
+            <h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial; margin-right: 500pt; width: 167px;"><span style="font-size: 10pt; font-family: Arial; color: white;">V3.5.0 / 08-April-2011<o:p></o:p></span></h3>
+            <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 18pt;"><b style=""><u><span style="font-size: 10pt; font-family: Verdana; color: black;">Main
+Changes<o:p></o:p></span></u></b></p>
+
+            <ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Specific system_stm32f10x.c file provided for each example</span></li>
+              <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">HTML file containing the examples list, with main features, provided in the root folder (allow search on key word/feature)</span></li>
+              <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Template projects updated to save configuration time and easy the examples use</span></li>
+              <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Refreshed example list vs. previous version:</span></li>
+              <ul>
+                <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Add two new Examples: MPU and TIM DMA Burst &nbsp;&nbsp;&nbsp; <br>
+                  </span></li>
+                <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">xWDG examples enhanced, ex. accurate IWDG timeout thanks to LSI freq measure w/ Timer</span></li>
+                <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">NVIC and SysTick examples enhanced to provide more details how to use them w/ CMSIS layer<br>
+                  </span></li>
+              </ul>
+
+            </ul>
+
+
+            <span style="font-size: 10pt; font-family: Verdana; color: black;"><o:p></o:p></span>
+            <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 23px; width: 868px;"><b style=""><u><span style="font-size: 10pt; font-family: Verdana; color: black;">Contents<o:p></o:p></span></u></b></p>
+
+            <ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">ARM CM3 CMSIS V1.30 (<a href="Libraries%5CCMSIS%5CCMSIS_changes.htm">release
+notes</a>)</span><br>
+<span style="font-size: 10pt; font-family: Verdana;"></span></li>
+              <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">STM32F10x CMSIS V3.5.0 (<a href="Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/Release_Notes.html">release
+notes</a>)</span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"></span><span style="font-size: 10pt; font-family: Verdana;">STM32F10x_StdPeriph_Driver V3.5.0 (<a href="Libraries/STM32F10x_StdPeriph_Driver/Release_Notes.html">release
+notes</a>)</span></li><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">STM32F10x_StdPeriph_Examples V3.5.0 (<a href="Project/STM32F10x_StdPeriph_Examples/Release_Notes.html">release
+notes</a>)</span></li><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">STM32F10x_StdPeriph_Template V3.5.0 (<a href="Project/STM32F10x_StdPeriph_Template/Release_Notes.html">release
+notes</a>)</span></li><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">STM32_EVAL V4.5.0 (<a href="Utilities/STM32_EVAL/Release_Notes.html">release
+notes</a>)</span></li>
+            </ul>
+
+            <span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;"><span style="font-weight: bold;"></span></span></span>
+            <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 23px; width: 868px;"><b style=""><u><span style="font-size: 10pt; font-family: Verdana; color: black;">Development Toolchains and Compilers<o:p></o:p></span></u></b></p>
+
+
+
+
+            <ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">IAR Embedded Workbench for ARM (EWARM) toolchain V5.50.5<br>
+</span></li><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Hitex&nbsp;IDE/Debugger
+                </span><span style="font-size: 10pt; font-family: Verdana;">(</span><span style="font-size: 10pt; font-family: Verdana;">HiTOP</span><span style="font-size: 10pt; font-family: Verdana;">)&nbsp;toolchain V5.40.0051</span></li><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">RealView Microcontroller
+Development Kit (MDK-ARM)&nbsp;toolchain V4.13
+  </span></li><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Raisonance IDE RIDE7
+(RIDE)&nbsp;toolchain (RIDE7 IDE:7.30.10, RKitARM for RIDE7:1.30.10)</span></li>
+              <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"></span><span style="font-size: 10pt; font-family: Verdana;">Atollic TrueSTUDIO STM32
+(TrueSTUDIO)&nbsp;toolchain V1.4.0</span></li>
+
+            </ul>
+
+
+
+
+
+
+            <h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial; margin-right: 558.05pt;"><span style="font-size: 10pt; font-family: Arial; color: white;">3.4.0 - 10/15/2010</span></h3>
+
+
+            <ol style="margin-top: 0in;" start="1" type="1">
+<li class="MsoNormal" style=""><b><i><span style="font-size: 10pt; font-family: Verdana;">General</span></i></b><i><span style="font-size: 10pt; font-family: Verdana;"> </span></i><i><span style="font-size: 10pt;"><o:p></o:p></span></i></li>
+            </ol>
+
+
+            <ul style="margin-top: 0in;" type="disc">
+<li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Add support for <span style="font-weight: bold;">STM32F10x High-density Value line</span> devices. <br>
+</span></li>
+              <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Add 3 examples: FSMC OneNAND, I2C TSENSOR (Temperature Sensro) and I2C IOExpander.<br>
+</span></li>
+              <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Utilities STM32&nbsp; EVAL drivers enhancements:</span></li>
+              <ul>
+                <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">I2C EEPROM, Temperature Sensor and IO Expander drivers updated to use the DMA for read/write transfer and add more robustness.</span></li>
+                <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">SD Card (SDIO) driver updated to add more robustness.<br>
+</span></li>
+              </ul>
+
+            </ul>
+
+
+            <ol style="margin-top: 0in;" start="2" type="1">
+<li class="MsoNormal" style=""><b><i><span style="font-size: 10pt; font-family: Verdana;">Libraries</span></i></b><b><i><span style="font-size: 10pt;"><o:p></o:p></span></i></b></li>
+            </ol>
+
+
+            <ul style="margin-top: 0in;" type="disc">
+<li class="MsoNormal" style=""><i><u><span style="font-size: 10pt; font-family: Verdana;">CMSIS</span></u></i><u><span style="font-size: 10pt;"><o:p></o:p></span></u></li>
+            </ul>
+
+
+            <ul style="margin-top: 0in;" type="disc">
+<ul style="margin-top: 0in;" type="circle"><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">See <a href="Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/Release_Notes.html">Release Notes for STM32F10x CMSIS</a></span></li></ul>
+            </ul>
+
+
+            <ul style="margin-top: 0in;" type="disc">
+<li class="MsoNormal" style=""><i><u><span style="font-size: 10pt; font-family: Verdana;">STM32F10x_StdPeriph_Drive</span></u></i><u><span style="font-size: 10pt; font-family: Verdana;">r</span></u><u><span style="font-size: 10pt;"></span></u></li>
+            </ul>
+
+
+
+            <ul style="margin-top: 0in;" type="disc">
+<ul style="margin-top: 0in;" type="circle"><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">See <a href="Libraries/STM32F10x_StdPeriph_Driver/Release_Notes.html">Release Notes for STM32F10x_StdPeriph_Driver</a></span><b><i><span style="font-size: 10pt; font-family: Verdana;"></span></i></b></li></ul>
+            </ul>
+            <ol start="3">
+<li class="MsoNormal" style=""><b><i><span style="font-size: 10pt; font-family: Verdana;">Project</span></i></b><b><i><span style="font-size: 10pt;"><o:p></o:p></span></i></b></li>
+            </ol>
+
+
+            <ul style="margin-top: 0in;" type="disc">
+<li class="MsoNormal" style=""><i><u><span style="font-size: 10pt; font-family: Verdana;">STM32F10x_StdPeriph_Examples</span></u></i><u><span style="font-size: 10pt;"><o:p></o:p></span></u></li>
+            </ul>
+
+
+            <ul style="margin-top: 0in;" type="disc">
+<ul style="margin-top: 0in;" type="circle"><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">See&nbsp;<a href="Project/STM32F10x_StdPeriph_Examples/Release_Notes.html">Release Notes for STM32F10x_StdPeriph_Examples</a></span></li></ul>
+            </ul>
+
+
+            <ul style="margin-top: 0in;" type="disc">
+<li class="MsoNormal" style=""><i><u><span style="font-size: 10pt; font-family: Verdana;">STM32F10x_StdPeriph_Template</span></u></i><u><span style="font-size: 10pt; font-family: Verdana;"></span></u><u><span style="font-size: 10pt;"></span></u></li>
+            </ul>
+
+
+
+            <ul>
+<ul><li><span style="font-size: 10pt; font-family: Verdana;">See&nbsp;<a href="Project/STM32F10x_StdPeriph_Template/Release_Notes.html">Release Notes for STM32F10x_StdPeriph_Template</a></span></li></ul>
+            </ul>
+            <ol start="4">
+<li class="MsoNormal" style=""><b><i><span style="font-size: 10pt; font-family: Verdana;">Utilities</span></i></b><b><i><span style="font-size: 10pt;"><o:p></o:p></span></i></b></li>
+            </ol>
+
+
+            <ul style="margin-top: 0in;" type="disc">
+<li class="MsoNormal" style=""><i><u><span style="font-size: 10pt; font-family: Verdana;">STM32_EVAL</span></u></i><u><span style="font-size: 10pt;"><o:p></o:p></span></u></li>
+            </ul>
+
+
+            <ul style="margin-top: 0in;" type="disc">
+<ul style="margin-top: 0in;" type="circle"><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">See&nbsp;<a href="Utilities/STM32_EVAL/Release_Notes.html">Release Notes_for_STM32_EVAL</a></span></li></ul>
+            </ul>
+            <br>
+<h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial; margin-right: 558.05pt;"><span style="font-size: 10pt; font-family: Arial; color: white;">3.3.0 - 04/16/2010</span></h3>
+    <ol style="margin-top: 0in;" start="1" type="1"><li class="MsoNormal" style=""><b><i><span style="font-size: 10pt; font-family: Verdana;">General</span></i></b><i><span style="font-size: 10pt; font-family: Verdana;"> </span></i><i><span style="font-size: 10pt;"><o:p></o:p></span></i></li></ol>
+    <ul style="margin-top: 0in;" type="disc"><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Add support for <span style="font-weight: bold;">STM32F10x XL-density</span> devices.&nbsp;</span></li><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Add template project for <span style="font-weight: bold;">TrueSTUDIO</span> toolchain. </span><span style="font-size: 10pt;"><o:p></o:p></span></li></ul>
+    <ol style="margin-top: 0in;" start="2" type="1"><li class="MsoNormal" style=""><b><i><span style="font-size: 10pt; font-family: Verdana;">Libraries</span></i></b><b><i><span style="font-size: 10pt;"><o:p></o:p></span></i></b></li></ol>
+    <ul style="margin-top: 0in;" type="disc"><li class="MsoNormal" style=""><i><u><span style="font-size: 10pt; font-family: Verdana;">CMSIS</span></u></i><u><span style="font-size: 10pt;"><o:p></o:p></span></u></li></ul>
+    <ul style="margin-top: 0in;" type="disc"><ul style="margin-top: 0in;" type="circle"><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">See <a href="Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/Release_Notes.html">Release Notes for STM32F10x CMSIS</a></span></li></ul></ul>
+    <ul style="margin-top: 0in;" type="disc"><li class="MsoNormal" style=""><i><u><span style="font-size: 10pt; font-family: Verdana;">STM32F10x_StdPeriph_Drive</span></u></i><u><span style="font-size: 10pt; font-family: Verdana;">r</span></u><u><span style="font-size: 10pt;"></span></u></li></ul>
+
+    <ul style="margin-top: 0in;" type="disc"><ul style="margin-top: 0in;" type="circle"><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">See <a href="Libraries/STM32F10x_StdPeriph_Driver/Release_Notes.html">Release Notes for STM32F10x_StdPeriph_Driver</a></span><b><i><span style="font-size: 10pt; font-family: Verdana;"></span></i></b></li></ul></ul><ol start="3"><li class="MsoNormal" style=""><b><i><span style="font-size: 10pt; font-family: Verdana;">Project</span></i></b><b><i><span style="font-size: 10pt;"><o:p></o:p></span></i></b></li></ol>
+    <ul style="margin-top: 0in;" type="disc"><li class="MsoNormal" style=""><i><u><span style="font-size: 10pt; font-family: Verdana;">STM32F10x_StdPeriph_Examples</span></u></i><u><span style="font-size: 10pt;"><o:p></o:p></span></u></li></ul>
+    <ul style="margin-top: 0in;" type="disc"><ul style="margin-top: 0in;" type="circle"><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">See&nbsp;<a href="Project/STM32F10x_StdPeriph_Examples/Release_Notes.html">Release Notes for STM32F10x_StdPeriph_Examples</a></span></li></ul></ul>
+    <ul style="margin-top: 0in;" type="disc"><li class="MsoNormal" style=""><i><u><span style="font-size: 10pt; font-family: Verdana;">STM32F10x_StdPeriph_Template</span></u></i><u><span style="font-size: 10pt; font-family: Verdana;"></span></u><u><span style="font-size: 10pt;"></span></u></li></ul>
+
+    <ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">See&nbsp;<a href="Project/STM32F10x_StdPeriph_Template/Release_Notes.html">Release Notes for STM32F10x_StdPeriph_Template</a></span></li></ul></ul><ol start="4"><li class="MsoNormal" style=""><b><i><span style="font-size: 10pt; font-family: Verdana;">Utilities</span></i></b><b><i><span style="font-size: 10pt;"><o:p></o:p></span></i></b></li></ol>
+    <ul style="margin-top: 0in;" type="disc"><li class="MsoNormal" style=""><i><u><span style="font-size: 10pt; font-family: Verdana;">STM32_EVAL</span></u></i><u><span style="font-size: 10pt;"><o:p></o:p></span></u></li></ul>
+    <ul style="margin-top: 0in;" type="disc"><ul style="margin-top: 0in;" type="circle"><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">See&nbsp;<a href="Utilities/STM32_EVAL/Release_Notes.html">Release Notes_for_STM32_EVAL</a></span></li></ul></ul><h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial; margin-right: 558.05pt;"><span style="font-size: 10pt; font-family: Arial; color: white;">3.2.0 - 03/01/2010</span></h3>
+    <ol style="margin-top: 0in;" start="1" type="1"><li class="MsoNormal" style=""><b><i><span style="font-size: 10pt; font-family: Verdana;">General</span></i></b><i><span style="font-size: 10pt; font-family: Verdana;"> </span></i><i><span style="font-size: 10pt;"><o:p></o:p></span></i></li></ol>
+    <ul style="margin-top: 0in;" type="disc"><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Add support for&nbsp;<b>STM32 Low-density Value line (STM32F100x4/6) and Medium-density Value line (STM32F100x8/B) devices</b>.</span></li>
+              <li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">New <span style="font-weight: bold;">CMSIS V1.30</span> release </span><span style="font-size: 10pt;"><o:p></o:p></span></li>
+</ul>
+    <ol style="margin-top: 0in;" start="2" type="1"><li class="MsoNormal" style=""><b><i><span style="font-size: 10pt; font-family: Verdana;">Libraries</span></i></b><b><i><span style="font-size: 10pt;"><o:p></o:p></span></i></b></li></ol>
+    <ul style="margin-top: 0in;" type="disc"><li class="MsoNormal" style=""><i><u><span style="font-size: 10pt; font-family: Verdana;">CMSIS</span></u></i><u><span style="font-size: 10pt;"><o:p></o:p></span></u></li></ul>
+    <ul style="margin-top: 0in;" type="disc"><ul style="margin-top: 0in;" type="circle"><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">See <a href="Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/Release_Notes.html">Release Notes for STM32F10x CMSIS</a></span></li></ul></ul>
+    <ul style="margin-top: 0in;" type="disc"><li class="MsoNormal" style=""><i><u><span style="font-size: 10pt; font-family: Verdana;">STM32F10x_StdPeriph_Drive</span></u></i><u><span style="font-size: 10pt; font-family: Verdana;">r</span></u><u><span style="font-size: 10pt;"></span></u></li></ul>
+
+    <ul style="margin-top: 0in;" type="disc"><ul style="margin-top: 0in;" type="circle"><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">See <a href="Libraries/STM32F10x_StdPeriph_Driver/Release_Notes.html">Release Notes for STM32F10x_StdPeriph_Driver</a></span><b><i><span style="font-size: 10pt; font-family: Verdana;"></span></i></b></li></ul></ul><ol start="3"><li class="MsoNormal" style=""><b><i><span style="font-size: 10pt; font-family: Verdana;">Project</span></i></b><b><i><span style="font-size: 10pt;"><o:p></o:p></span></i></b></li></ol>
+    <ul style="margin-top: 0in;" type="disc"><li class="MsoNormal" style=""><i><u><span style="font-size: 10pt; font-family: Verdana;">STM32F10x_StdPeriph_Examples</span></u></i><u><span style="font-size: 10pt;"><o:p></o:p></span></u></li></ul>
+    <ul style="margin-top: 0in;" type="disc"><ul style="margin-top: 0in;" type="circle"><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">See&nbsp;<a href="Project/STM32F10x_StdPeriph_Examples/Release_Notes.html">Release Notes for STM32F10x_StdPeriph_Examples</a></span></li></ul></ul>
+    <ul style="margin-top: 0in;" type="disc"><li class="MsoNormal" style=""><i><u><span style="font-size: 10pt; font-family: Verdana;">STM32F10x_StdPeriph_Template</span></u></i><u><span style="font-size: 10pt; font-family: Verdana;"></span></u><u><span style="font-size: 10pt;"></span></u></li></ul>
+
+    <ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">See&nbsp;<a href="Project/STM32F10x_StdPeriph_Template/Release_Notes.html">Release Notes for STM32F10x_StdPeriph_Template</a></span></li></ul></ul><ol start="4"><li class="MsoNormal" style=""><b><i><span style="font-size: 10pt; font-family: Verdana;">Utilities</span></i></b><b><i><span style="font-size: 10pt;"><o:p></o:p></span></i></b></li></ol>
+    <ul style="margin-top: 0in;" type="disc"><li class="MsoNormal" style=""><i><u><span style="font-size: 10pt; font-family: Verdana;">STM32_EVAL</span></u></i><u><span style="font-size: 10pt;"><o:p></o:p></span></u></li></ul>
+    <ul style="margin-top: 0in;" type="disc"><ul style="margin-top: 0in;" type="circle"><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">See&nbsp;<a href="Utilities/STM32_EVAL/Release_Notes.html">Release Notes for STM32F10x_StdPeriph_Utilities</a></span></li></ul></ul>
+    <h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial; margin-right: 558.05pt;"><span style="font-size: 10pt; font-family: Arial; color: white;">V3.1.2 -
+    09/28/2009</span></h3>
+    <ol style="margin-top: 0in;" start="1" type="1"><li class="MsoNormal" style=""><b><i><span style="font-size: 10pt; font-family: Verdana;">General</span></i></b><i><span style="font-size: 10pt; font-family: Verdana;"> </span></i><i><span style="font-size: 10pt;"><o:p></o:p></span></i></li></ol>
+    <ul style="margin-top: 0in;" type="disc"><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">Add support for <b>Hitex
+         Development Tools HiTOP</b>. </span><span style="font-size: 10pt;"><o:p></o:p></span></li></ul>
+    <ol style="margin-top: 0in;" start="2" type="1"><li class="MsoNormal" style=""><b><i><span style="font-size: 10pt; font-family: Verdana;">Libraries</span></i></b><b><i><span style="font-size: 10pt;"><o:p></o:p></span></i></b></li></ol>
+    <ul style="margin-top: 0in;" type="disc"><li class="MsoNormal" style=""><i><u><span style="font-size: 10pt; font-family: Verdana;">CMSIS</span></u></i><u><span style="font-size: 10pt;"><o:p></o:p></span></u></li></ul>
+    <ul style="margin-top: 0in;" type="disc"><ul style="margin-top: 0in;" type="circle"><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">system_stm32f10x.c: <i>SetSysClockTo56()</i>
+          function, change the flash latency to 2&nbsp;instead of 1</span><span style="font-size: 10pt;"><o:p></o:p></span></li></ul></ul>
+    <ul style="margin-top: 0in;" type="disc"><li class="MsoNormal" style=""><i><u><span style="font-size: 10pt; font-family: Verdana;">STM32F10x_StdPeriph_Drive</span></u></i><u><span style="font-size: 10pt; font-family: Verdana;">r</span></u><u><span style="font-size: 10pt;"><o:p></o:p></span></u></li></ul>
+    <ul style="margin-top: 0in;" type="disc"><ul style="margin-top: 0in;" type="circle"><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_tim.c: in <i>TIM_OCxInit()</i>&nbsp;functions,
+          add new instruction to set the <i>CCxS</i> bits&nbsp;(x= 1, 2, 3, 4)
+          to 0, i.e. the channel CCx is configured as output. In the previous
+          version these functions was assuming that the<i> CCxS</i> bits are
+          reset; if a channel was previously configured in input, a call to
+          this function doesn't allow using it in output mode. This is resolved
+          with this modification.&nbsp;</span><span style="font-size: 10pt;"><o:p></o:p></span></li></ul></ul>
+    <ul style="margin-top: 0in;" type="disc"><ul style="margin-top: 0in;" type="circle"><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_spi.h: <i>I2S_InitTypeDef</i>
+          structure, change the&nbsp;type of&nbsp;<i>I2S_AudioFreq</i> field
+          to&nbsp;uint32_t instead of&nbsp;uint16_t. This modification is
+          needed to support I2S 96KHz frequency (available in&nbsp;Connectivity
+          Line devices). </span><span style="font-size: 10pt;"><o:p></o:p></span></li></ul></ul>
+    <ul style="margin-top: 0in;" type="disc"><ul style="margin-top: 0in;" type="circle"><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_flash.c: <i>FLASH_EraseOptionBytes()</i>
+          function, add&nbsp;note to clarify this function behavior.</span><span style="font-size: 10pt;"><o:p></o:p></span></li></ul></ul>
+    <ol style="margin-top: 0in;" start="3" type="1"><li class="MsoNormal" style=""><b><i><span style="font-size: 10pt; font-family: Verdana;">Project</span></i></b><i><span style="font-size: 10pt; font-family: Verdana;"> </span></i><i><span style="font-size: 10pt;"><o:p></o:p></span></i></li></ol>
+    <ul style="margin-top: 0in;" type="disc"><li class="MsoNormal" style=""><i><u><span style="font-size: 10pt; font-family: Verdana;">STM32F10x_StdPeriph_Examples</span></u></i><u><span style="font-size: 10pt; font-family: Verdana;"> </span></u><u><span style="font-size: 10pt;"><o:p></o:p></span></u></li></ul>
+    <ul style="margin-top: 0in;" type="disc"><ul style="margin-top: 0in;" type="circle"><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">I2C\EEPROM example</span><span style="font-size: 10pt;"><o:p></o:p></span></li><ul style="margin-top: 0in;" type="square"><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">i2c_ee.c: <i>I2C_EE_BufferRead()</i>
+           function, the following line was removed &nbsp; &nbsp; &nbsp; &nbsp;
+           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
+           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
+           &nbsp; &nbsp; &nbsp;</span><span style="font-size: 10pt; font-family: &quot;Courier New&quot;;"><span style=""></span><span style=""></span><span style=""></span><span style=""></span><span style=""></span><span style=""></span></span></li></ul></ul></ul><p class="MsoNormal" style="margin-left: 1.25in;"><span style="font-size: 10pt;"><span style="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="font-size: 10pt; font-family: &quot;Courier New&quot;;">/* Clear EV6 by setting
+    again the PE bit */<br>
+    &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; I2C_Cmd(I2C_EE, ENABLE);</span><span style="font-size: 10pt;"><o:p></o:p></span></p>
+    <ul style="margin-top: 0in;" type="disc"><ul style="margin-top: 0in;" type="circle"><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">RCC example</span><span style="font-size: 10pt;"><o:p></o:p></span></li><ul style="margin-top: 0in;" type="square"><li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">main.c:&nbsp;<i>SetSysClockTo56()</i>
+           function, change the flash latency to 2&nbsp;instead of 1</span><span style="font-size: 10pt;"><o:p></o:p></span></li></ul></ul></ul>
+    <ul style="margin-top: 0in;" type="disc"><li class="MsoNormal" style=""><i><u><span style="font-size: 10pt; font-family: Verdana;">Template</span></u></i><u><span style="font-size: 10pt; font-family: Verdana;"> </span></u><u><span style="font-size: 10pt;"><o:p></o:p></span></u></li></ul>
+    <ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">Add template projects
+          for <span style="font-weight: bold;">HiTOP</span> toolchain to support <span style="font-style: italic;">Medium-density</span> (Template\HiTOP\STM3210B-EVAL),
+          <span style="font-style: italic;">High-density</span> (Template\HiTOP\STM3210E-EVAL) and <span style="font-style: italic;">Connectivity line</span>
+          (Template\HiTOP\STM3210C-EVAL) devices.</span></li></ul></ul>
+<h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial; margin-right: 558.05pt;"><span style="font-size: 10pt; font-family: Arial; color: white;">V3.1.0
+- 06/19/2009</span></h3><ol style="font-style: italic;"><li><big><span style="font-size: 10pt; font-family: Verdana;"><span style="font-weight: bold;">General</span> </span></big></li></ol><ul><li><span style="font-size: 10pt; font-family: Verdana;">Update to support the additional peripherals and features embedded in the <span style="font-weight: bold;">STM32F10x Connectivity Line devices</span>. </span></li><li><span style="font-size: 10pt; font-family: Verdana;">Doxygen
+documentation enhanced to give more detail about driver function&#8217;s
+parameters: description, allowed values and required preconditions.
+This is mainly relevant for peripheral initialization structure&#8217;s
+members (PPP_InitTypeDef). </span></li><li><span style="font-size: 10pt; font-family: Verdana;">C++ support </span></li></ul><span style="font-size: 10pt; font-family: Verdana;"></span><ol style="font-weight: bold; font-style: italic;" start="2"><li><span style="font-size: 10pt; font-family: Verdana;">Libraries</span></li></ol><ul style="text-decoration: underline;"><li><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">CMSIS</span></span></li></ul><ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">stm32f10x.h</span></li></ul></ul><ul><ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">Add new define STM32F10X_CL to configure the library for Connectivity Line devices (default configuration)</span></li><li><span style="font-size: 10pt; font-family: Verdana;">Interrupt Number Definition (IRQn)</span></li><li><span style="font-size: 10pt; font-family: Verdana;">Add definition for Connectivity Line devices peripheral&#8217;s interrupts</span></li><li><span style="font-size: 10pt; font-family: Verdana;">For STM32 Low Density Devices, the SPI2_IRQn was removed since there is no SPI2 in these devices.</span></li><li><span style="font-size: 10pt; font-family: Verdana;">Add register's definitions, bits definitions and memory mapping for new peripherals (Ethernet and CAN2) </span></li><li><span style="font-size: 10pt; font-family: Verdana;">RCC, DBGMCU, EXTI, CAN, GPIO and AFIO bits definitions updated</span></li><li><span style="font-size: 10pt; font-family: Verdana;">AFIO_MAPR_SPI1 _REMAP define declaration corrected to AFIO_MAPR_SPI1_REMAP</span></li><li><span style="font-size: 10pt; font-family: Verdana;">Tailor HSE_Value to the to the selected device</span></li></ul></ul></ul><span style="font-size: 10pt; font-family: Verdana;"></span><ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">system_stm32f10x.c</span></li></ul></ul><ul><ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">Clock configuration functions updated to support Connectivity line devices</span></li><li><span style="font-size: 10pt; font-family: Verdana;">Change SetSysClockTo20 function to SetSysClockTo24</span></li></ul></ul></ul><span style="font-size: 10pt; font-family: Verdana;"></span><ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">startup</span></li></ul></ul><ul><ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">Add new startup files startup_stm32f10x_cl.s&nbsp; for Connectivity Line devices</span></li><li><span style="font-size: 10pt; font-family: Verdana;">For STM32 Low Density Devices, the SPI2_IRQHandler was removed since there is no SPI2 in these devices.</span></li><li><span style="font-size: 10pt; font-family: Verdana;">Use CMSIS Core Peripheral Access Layer V1.20</span></li></ul></ul></ul><span style="font-size: 10pt; font-family: Verdana;"></span><ul style="text-decoration: underline;"><li><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">STM32F10x_StdPeriph_Drive</span>r</span></li></ul><ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">CAN: update to support CAN2 peripheral, with no impact on the API</span></li></ul></ul><ul><ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">Add new instance CAN2 </span></li><li><span style="font-size: 10pt; font-family: Verdana;">Filter number updated</span></li><li><span style="font-size: 10pt; font-family: Verdana;">Add new function CAN_SlaveStartBank</span></li></ul></ul></ul><ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">RCC: update to support Connectivity Line devices, with no impact on the API</span></li></ul></ul><ul><ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">RCC_DeInit and RCC_GetSYSCLKSource functions updated</span></li><li><span style="font-size: 10pt; font-family: Verdana;">Function&#8217;s parameters list updated </span></li><li><span style="font-size: 10pt; font-family: Verdana;">Add new functions</span></li></ul></ul></ul><ul><ul><ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">RCC_PREDIV1Config, RCC_PREDIV2Config</span></li></ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">RCC_PLL2Config, RCC_PLL2Cmd</span></li></ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">RCC_PLL3Config, RCC_PLL3Cmd</span></li></ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">RCC_OTGFSCLKConfig </span></li></ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">RCC_I2S2CLKConfig, RCC_I2S3CLKConfig</span></li></ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">RCC_AHBPeriphResetCmd</span></li></ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">RCC_APB2Periph_ALL and RCC_APB1Periph_ALL parameters removed</span></li></ul></ul></ul></ul><ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">GPIO</span></li></ul></ul><ul><ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">Update GPIO_PinRemapConfig function with 4 new AF remap</span></li><li><span style="font-size: 10pt; font-family: Verdana;">Add new function GPIO_ETH_MediaInterfaceConfig</span></li></ul></ul></ul><ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">EXTI</span></li></ul></ul><ul><ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">Add new internal EXTI Line 19 connected to ETH wakeup</span></li></ul></ul></ul><ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">DBGMCU</span></li></ul></ul><ul><ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">Add new define DBGMCU_CAN2_STOP</span></li></ul><li><span style="font-size: 10pt; font-family: Verdana;"></span><span style="font-size: 10pt; font-family: Verdana;">DAC</span></li></ul></ul><ul><ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">Add
+new define DAC_Trigger_T3_TRGO (to be used instead of
+DAC_Trigger_T8_TRGO, since TIM8 not available in Connectivity Line
+devices)</span></li></ul></ul></ul><ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">SPI/I2S</span></li></ul></ul><ul><ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">I2S_Init function updated to support new clock scheme implemented in Connectivity Line devices</span></li><li><span style="font-size: 10pt; font-family: Verdana;">Update I2S_AudioFreq defines to support frequency up to 96 KHz</span></li></ul></ul></ul><ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">FLASH </span></li></ul></ul><ul><ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">Update FLASH_EnableWriteProtection function header and parameter list&nbsp; to support Connectivity Line devices</span></li></ul></ul></ul><ol start="3" style="font-style: italic;"><li><span style="font-size: 10pt; font-family: Verdana;"><span style="font-weight: bold;">Project</span> </span></li></ol><ul style="text-decoration: underline;"><ul><li><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">STM32F10x_StdPeriph_Examples</span> </span></li></ul></ul><ul><ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">Almost
+examples updated to run on Connectivity Line devices and
+STMicroelectronics STM3210C-EVAL evaluation board. Refer to the readme
+file provided within each example for more information on how to use
+the example with a specific board.</span></li><li><span style="font-size: 10pt; font-family: Verdana;">TIM: add new example TIM_Input_Capture</span></li><li><span style="font-size: 10pt; font-family: Verdana;">I2C: M24C08_EEPROM example renamed to EEPROM</span></li></ul></ul></ul><ul style="text-decoration: underline;"><ul><li><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">Template</span> </span></li></ul></ul><ul><ul><ul><li><span style="font-size: 10pt; font-family: Verdana;">Template
+projects for EWARMv5, RIDE and RVMDK updated to support Connectivity
+Line devices and STMicroelectronics STM3210C-EVAL evaluation board. </span></li></ul></ul></ul><span style="font-size: 10pt; font-family: Verdana;"> </span><ol start="4" style="font-style: italic;"><li><span style="font-size: 10pt; font-family: Verdana;"><span style="font-weight: bold;">Utilities</span></span></li></ol><ul><li><span style="font-size: 10pt; font-family: Verdana;">Implement
+a new abstraction layer to interact with the Human Interface resources;
+buttons, LEDs, LCD and COM ports (USARTs) available on
+STMicroelectronics STM3210C-EVAL (Connectivity line), STM3210E-EVAL
+(High-Density) and STM3210B-EVAL (Medium-Density) evaluation boards.
+The stm32_eval.c driver provides a common API to interact with buttons,
+LEDs and COM ports, while these resources hardware&nbsp; definitions is
+made in the header file of each evaluation board (stm3210x_eval.h). A
+common API is provided to manage the LCD across the supported boards,
+with a separate driver for each board stm3210x_eval_lcd.c.</span></li></ul><span style="font-size: 10pt; font-family: Verdana;"></span>
+<h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial; margin-right: 558.05pt;"><span style="font-size: 10pt; font-family: Arial; color: white;">V3.0.0
+- 04/06/2009<o:p></o:p></span></h3>
+<ol style="font-weight: bold; font-style: italic;"><li><span style="color: black;"><o:p></o:p></span><span style="font-size: 10pt; font-family: Verdana;">General</span></li></ol><ul style="margin-top: 0cm;" type="square"><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"><span class="SpellE"><span class="spelle"><span style="font-family: Verdana;"></span></span></span></span><span style="font-size: 10pt; font-family: Verdana;">STM3210x FW Library renamed to STM32F10x Standard Peripherals Library (<span style="font-weight: bold; font-style: italic;">StdPeriph_Lib</span>)</span></li><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"></span><span style="font-size: 10pt; font-family: Verdana;">STM32F10x Standard Peripherals Library is full CMSIS compliant</span></li><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"></span><span style="font-size: 10pt; font-family: Verdana;">STM32F10x Standard Peripherals Library Structure is updated.</span></li><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"></span><span style="font-size: 10pt; font-family: Verdana;">STM32F10x Standard Peripherals Package Architecture is enhanced</span></li><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"></span><span style="font-size: 10pt; font-family: Verdana;">STM32F10x Standard Peripherals Library User Manual&nbsp; with *.chm format</span></li></ul><ol style="font-weight: bold; font-style: italic;" start="2"><li><span style="font-size: 10pt; font-family: Verdana;">library</span></li></ol><ul style="margin-top: 0cm;" type="square"><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">CAN driver updated</span></li><ul><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">CAN driver was updated to support STM32F10xxx connectivity line products.</span><span style="font-size: 10pt; font-family: Verdana;"></span></li><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">CAN peripheral was renamed as CAN1. All occurrences related to CAN were also renamed as CAN1 in the different drivers.</span></li></ul><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">I2C driver</span></li><ul><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">I2C event assert macro missing in stm32f10x_i2c.h file.<br></span></li></ul><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">DBGMCU</span></li><ul><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Wrong
+defines in stm32f10x_dbgmcu.h: DBGMCU_TIM5_STOP, DBGMCU_TIM6_STOP,
+DBGMCU_TIM7_STOP and&nbsp; DBGMCU_TIM8_STOP defines values are wrong.<br><br></span></li></ul><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">FSMC</span></li><ul><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Remove the FSMC AddressLowMapping configuration</span><span style="font-size: 10pt; font-family: Verdana;"></span></li></ul></ul><ol start="3" style="font-weight: bold; font-style: italic;"><li><span style="font-size: 10pt; font-family: Verdana;">examples</span></li></ol><ul style="margin-top: 0cm;" type="square"><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"></span><span style="font-size: 10pt; font-family: Verdana;">FSMC NOR driver Timings are updated.</span></li><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Add CAN "Normal" example</span></li><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">TIM "6Steps" example wave forms updated</span></li><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">NVIC "CM3_LPModes" and "System_Handlers" examples removed<br></span></li></ul><p class="MsoNormal"></p><p class="MsoNormal"><span style="font-size: 10pt; font-family: Verdana; color: black;">For more details, please
+refer to <a href="http://www.st.com/mcu/familiesdocs-110.html" target="_blank">AN2953</a> "How to migrate from the STM32F10xxx firmware library
+V2.0.3 to the STM32F10xxx standard peripheral library V3.0.0".</span></p>
+<h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial; margin-right: 558.05pt;"><span style="font-size: 10pt; font-family: Arial; color: white;">V2.0.3
+- 09/22/2008<o:p></o:p></span></h3>
+<ol style="margin-top: 0cm; font-weight: bold; font-style: italic;" start="1" type="1">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">General</span><span style="font-size: 10pt; font-family: Verdana;"><o:p></o:p></span></li>
+</ol>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10xfwlib_contents_html
+file updated:<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Description
+of firmware library package content<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Easy-to-use
+firmware library examples: add description of how to use the project
+template to run the selected example<o:p></o:p></span></li>
+</ul>
+</ul>
+<ol style="font-weight: bold; font-style: italic;" start="2" type="1">
+<li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">library</span><span style="font-size: 10pt;"><o:p></o:p></span></li>
+</ol>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_map.h:
+add all STM32 Hardware registers bits definitions<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_conf.h:
+add a define for <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">HSEStartUp_TimeOut</span></span></span><o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_fsmc.h/.c:<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="SpellE"><span class="spelle"><span style="font-size: 10pt; font-family: Verdana;">FSMC_MemoryType_CRAM</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> is changed
+to <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">FSMC_MemoryType_PSRAM</span></span></span><o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="SpellE"><span class="spelle"><span style="font-size: 10pt; font-family: Verdana;">FSMC_AsyncWait</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> member
+removed from <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">FSMC_NORSRAMInitTypeDef</span></span></span>
+structure<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="SpellE"><span class="spelle"><span style="font-size: 10pt; font-family: Verdana;">FSMC_BusTurnAroundDuration</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> parameter
+removed in case of write configuration<o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_rcc.h/.c:<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">RCC_FLAG_HSIRDY
+define value changed to 0x21.<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="SpellE"><span class="spelle"><span style="font-size: 10pt; font-family: Verdana;">StartUpCounterand</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">HSEStatus</span></span></span>
+variables are now local for <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">RCC_WaitForHSEStartUp</span></span></span>
+function. <o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_i2c.h/.c:
+<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Add new
+event: EV8: I2C_EVENT_MASTER_BYTE_TRANSMITTING<o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_tim.c:
+<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">"=" operator
+changed to "|=" inside <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">TIM_SelectOCxM</span></span></span>
+function<o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_can.c:
+Definitions names changed<o:p></o:p></span></li>
+</ul>
+<ol style="font-style: italic; font-weight: bold;" start="3" type="1">
+<li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">examples</span><span style="font-size: 10pt;"><o:p></o:p></span></li>
+</ol>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">I2C Interrupt
+example<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Example
+updated according to I2C driver update<o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">I2C
+M24C08_EEPROM example<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">i2c_ee.c
+file: add a loop on I2C_FLAG_BUSY in I2C_EE_PageWrite and<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">I2C_EE_BufferRead
+functions<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">i2c_ee.c
+file: add STOP condition in I2C_EE_WaitEepromStandbyState function<o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">SDIO example<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Example
+updated to support SD Card V2.0 and SD High Capacity cards.<o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">USART Polling
+example<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">USART TC flag
+check changed by USART TXE flag check<o:p></o:p></span></li>
+</ul>
+</ul>
+<h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial; margin-right: 558.05pt;"><span style="font-size: 10pt; font-family: Arial; color: white;">V2.0.2
+- 07/11/2008<o:p></o:p></span></h3>
+<ol style="font-style: italic; font-weight: bold;" start="1" type="1">
+<li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">library</span><span style="font-size: 10pt;"><o:p></o:p></span></li>
+</ol>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_spi.c
+/.h<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">SPI_I2S_ClearFlag
+function: some flags are removed from the possible flags parameters
+list. This function can clear only CRCERR flag.<o:p></o:p></span></li>
+</ul>
+</ul>
+<ul style="margin-top: 0cm;" type="square">
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">SPI_I2S_ClearITPendingBit
+function: some pending bits are removed from&nbsp;the possible
+pending bits parameters list. This function can clear only CRCERR
+pending
+bit.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+&nbsp;<o:p></o:p></span></li>
+</ul>
+</ul>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_i2c.c
+/.h<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">I2C_ClearFlag
+function: some flags are removed from the possible flags parameters
+list. This function can clear only SMBALER, TIMEOUT, PECERR, OVR, AF,
+ARLO and BERR flags. The passed parameter can be any combination of
+above flags.<o:p></o:p></span></li>
+</ul>
+</ul>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">I2C_GetITStatus
+function checks on interrupt pending bit and the interrupt enable bit.<o:p></o:p></span></li>
+</ul>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">I2C_ClearITPendingBit
+function: some pending bits are removed from the possible pending bits
+parameters list. This function can clear only SMBALER, TIMEOUT, PECERR,
+OVR, AF, ARLO and BERR pending bits. The passed parameter can be any
+combination of above pending bits.&nbsp;<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">&nbsp;stm32f10x_usart.c
+/.h<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">&nbsp;<span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">USART_ClearFlag</span></span></span>
+function: some flags are removed from the possible flags parameters
+list. This function can clear only CTS, LBD, TC and RXNE
+flags.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+&nbsp;<o:p></o:p></span></li>
+</ul>
+</ul>
+<ul style="margin-top: 0cm;" type="square">
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="SpellE"><span class="spelle"><span style="font-size: 10pt; font-family: Verdana;">USART_GetITStatus</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> function:
+IS_USART_IT macro is changed to IS_USART_GET_IT<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="SpellE"><span class="spelle"><span style="font-size: 10pt; font-family: Verdana;">USART_ClearITPendingBit</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> function:
+some pending bits are removed from the possible pending bits parameters
+list. This function can clear only CTS, LBD, TC and RXNE pending
+bits.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+&nbsp;<o:p></o:p></span></li>
+</ul>
+</ul>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_tim.c<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="GramE"><span class="grame"><span style="font-size: 10pt; font-family: Verdana;">remove</span></span></span><span style="font-size: 10pt; font-family: Verdana;">
+IS_TIM_PERIPH_FLAG(<span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">TIMx</span></span></span>,
+TIM_FLAG) macro from <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">TIM_ClearFlag</span></span></span>&nbsp;function.<o:p></o:p></span></li>
+</ul>
+</ul>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_wwdg.c<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="GramE"><span class="grame"><span style="font-size: 10pt; font-family: Verdana;">use</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> register
+direct access in the <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">WWDG_GetFlagStatus</span></span></span>
+function instead of bit banding access.<o:p></o:p></span></li>
+</ul>
+</ul>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_gpio.c<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="SpellE"><span class="spelle"><span style="font-size: 10pt; font-family: Verdana;">GPIO_Init</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> function
+update.<o:p></o:p></span></li>
+</ul>
+</ul>
+<ol style="font-style: italic; font-weight: bold;" start="2" type="1">
+<li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">examples</span><span style="font-size: 10pt;"><o:p></o:p></span></li>
+</ol>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">I2C Interrupt
+example<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">The example
+is changed to provide a description of how to manage
+data&nbsp;transfer from master transmitter to slave receiver and
+from slave transmitter to master receiver using interrupts.<o:p></o:p></span></li>
+</ul>
+</ul>
+<ul style="margin-top: 0cm;" type="square">
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="GramE"><span class="grame"><span style="font-size: 10pt; font-family: Verdana;">add</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">main.h</span></span></span>
+file.<o:p></o:p></span></li>
+</ul>
+</ul>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">I2C
+10bitAddress example<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Updated
+according to the I2C driver update.<o:p></o:p></span></li>
+</ul>
+</ul>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">I2C <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">DualAddress</span></span></span>
+example<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Updated
+according to the I2C driver update.<o:p></o:p></span></li>
+</ul>
+</ul>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">I2C <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">SMBus</span></span></span>
+example<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Updated
+according to the I2C driver update<o:p></o:p></span></li>
+</ul>
+</ul>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">USART <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">DMA_Interrupt</span></span></span>
+example<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Updated
+according to the USART driver update.<o:p></o:p></span></li>
+</ul>
+</ul>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">USART
+Smartcard example<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Updated
+according to the USART driver update.<o:p></o:p></span></li>
+</ul>
+</ul>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">DAC Examples<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"><span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">GPIO_Configuration</span></span></span>
+function updated: Once the DAC channel is enabled, the corresponding
+GPIO pin is automatically connected to the DAC converter. In order to
+avoid parasitic consumption, the GPIO pin should<span class="GramE"><span class="grame"><span style="font-family: Verdana;">&nbsp;
+be</span></span></span> configured in analog.<o:p></o:p></span></li>
+</ul>
+</ul>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">RTC <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">LSI_Calib</span></span></span>
+example<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Example
+Update: add <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">main.h</span></span></span>
+file.<o:p></o:p></span></li>
+</ul>
+</ul>
+<h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial; margin-right: 558.05pt;"><span style="font-size: 10pt; font-family: Arial; color: white;">V2.0.1
+- 06/13/2008<o:p></o:p></span></h3>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Remove the
+Firmware License Agreement file.<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Update the
+source <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">files's</span></span></span>
+header to remove reference to the License.<o:p></o:p></span></li>
+</ul>
+<h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial; margin-right: 558.05pt;"><span style="font-size: 10pt; font-family: Arial; color: white;">V2.0
+- 05/23/2008<o:p></o:p></span></h3>
+<ol style="font-style: italic; font-weight: bold;" start="1" type="1">
+<li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">General</span><span style="font-size: 10pt;"><o:p></o:p></span></li>
+</ol>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">The <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">FWLib</span></span></span>
+V2.0 is an update of the V1.0 to support the extra peripherals and
+features embedded in the STM32 High-density
+devices.&nbsp;&nbsp;&nbsp; <o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Add Firmware
+License Agreement file.<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">For more
+details about the Firmware Library, please refer to the User. <span class="GramE"><span class="grame"><span style="font-family: Verdana;">manual</span></span></span>
+"UM0427 ARM-based 32-bit MCU STM32F101xx and STM32F103xx
+Firmware&nbsp; Library"&nbsp; available for download from the
+ST microcontrollers website: <a href="http://www.st.com/stm32">www.st.com/stm32</a>.
+<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Glossary<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Medium-density
+devices are STM32F101xx and STM32F103xx microcontrollers where the
+Flash memory density ranges between 32 and 128 Kbytes.<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">High-density
+devices are STM32F101xx and STM32F103xx microcontrollers where the
+Flash memory density ranges between 256 and 512
+Kbytes.&nbsp;&nbsp;&nbsp; <o:p></o:p></span></li>
+</ul>
+</ul>
+<ol style="font-style: italic; font-weight: bold;" start="2" type="1">
+<li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">library</span><span style="font-size: 10pt;"><o:p></o:p></span></li>
+</ol>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Add driver
+for new peripherals: FSMC, SDIO and DAC.&nbsp;<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_spi.c
+/.h<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="GramE"><span class="grame"><span style="font-size: 10pt; font-family: Verdana;">driver</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> update to
+support new I2S functionality.<o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Add driver
+for DBGMCU and CRC modules&nbsp;&nbsp;&nbsp;&nbsp; <o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_dma.c
+/.h<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="GramE"><span class="grame"><span style="font-size: 10pt; font-family: Verdana;">driver</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> update to
+support DMA2 channels.<o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_adc.c
+/.h<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="GramE"><span class="grame"><span style="font-size: 10pt; font-family: Verdana;">driver</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> update to
+support ADC3. <o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_usart.c
+/.h<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="GramE"><span class="grame"><span style="font-size: 10pt; font-family: Verdana;">driver</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> update to
+support UART4 and UART5.<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="GramE"><span class="grame"><span style="font-size: 10pt; font-family: Verdana;">new</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">USART_ClockInitTypeDef</span></span></span>
+structure derived from <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">USART_InitTypeDef</span></span></span>
+one (for USART synchronous parameters). <o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Timer
+peripherals driver<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_tim1.c
+/.h and stm32f10x_tim.c /.h drivers merged in one single driver:
+stm32f10x_tim.c /.h<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="GramE"><span class="grame"><span style="font-size: 10pt; font-family: Verdana;">update</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> to support
+new timer peripherals: TIM5, TIM6, TIM7 and TIM8.<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="GramE"><span class="grame"><span style="font-size: 10pt; font-family: Verdana;">add</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> new macro
+for function parameters test. <o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="SpellE"><span class="spelle"><span style="font-size: 10pt; font-family: Verdana;">TIM_TimeBaseInit</span></span></span><span style="font-size: 10pt; font-family: Verdana;">, <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">TIM_PrescalerConfig</span></span></span>
+and <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">TIM_GenerateEvent</span></span></span>
+functions updated.<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="SpellE"><span class="spelle"><span style="font-size: 10pt; font-family: Verdana;">TIM_TIxExternalClockConfig</span></span></span><span style="font-size: 10pt; font-family: Verdana;">,
+TIM_ETRClockMode1Config, TIM_ETRClockMode2Config, <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">TIM_ETRConfig</span></span></span>,
+TIM_SetIC1Prescaler, TIM_SetIC2Prescaler, TIM_SetIC3Prescaler and
+TIM_SetIC4Prescaler functions prototype update.<o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_gpio.c
+/.h<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="GramE"><span class="grame"><span style="font-size: 10pt; font-family: Verdana;">driver</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> update to
+support GPIOF and GPIOG. <o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_lib.c
+/.h, stm32f10x_map.h, stm32f10x_conf.h<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="GramE"><span class="grame"><span style="font-size: 10pt; font-family: Verdana;">update</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> to add new
+peripherals register declarations and header files inclusion.<o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_nvic.c
+/.h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">&nbsp;stm32f10x_itc.c
+/.h<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_vector.c
+/.s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="GramE"><span class="grame"><span style="font-size: 10pt; font-family: Verdana;">update</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> to support
+the new peripherals interrupt vector.<o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_rcc.c
+/.h<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="GramE"><span class="grame"><span style="font-size: 10pt; font-family: Verdana;">driver</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> update to
+support new peripherals clock &amp; reset enable/disable. <o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">HSE
+Oscillator start up timeout increased to 0x01FF.<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="SpellE"><span class="spelle"><span style="font-size: 10pt; font-family: Verdana;">RCC_DeInit</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> function
+update. <o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_bkp.c
+/.h<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="GramE"><span class="grame"><span style="font-size: 10pt; font-family: Verdana;">driver</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> update to
+support the new 32 backup registers. <o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_map.h<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_can.c
+<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">CAN register
+numbering update<o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_flash.h
+<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="GramE"><span class="grame"><span style="font-size: 10pt; font-family: Verdana;">update</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> macro
+"IS_FLASH_ADDRESS" to support memory size up to 512KB.<o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_flash.c
+<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="SpellE"><span class="spelle"><span style="font-size: 10pt; font-family: Verdana;">FLASH_EnableWriteProtection</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> function:
+update "<span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">FLASH_Pages</span></span></span>"
+<span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">paramter</span></span></span>
+values<span class="GramE"><span class="grame"><span style="font-family: Verdana;">&nbsp; description</span></span></span>.<o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_exti.c<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="SpellE"><span class="spelle"><span style="font-size: 10pt; font-family: Verdana;">EXTI_Init</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> function
+update.<o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_type.h<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">'S32_MIN'
+type corrected to "#define S32_MIN ((s32)-2147483648)".<o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_ppp.h<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="GramE"><span class="grame"><span style="font-size: 10pt; font-family: Verdana;">in</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> all macros,
+put the passed parameter between parenthesis.<o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_can.c<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="GramE"><span class="grame"><span style="font-size: 10pt; font-family: Verdana;">extended</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> ID coded in
+29-bit long.<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">CAN
+initialization acknowledge error fixed.<o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_usart.c<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="GramE"><span class="grame"><span style="font-size: 10pt; font-family: Verdana;">change</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> "&amp;="
+instead of "="&nbsp; in <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">USART_ClearITPendingBit</span></span></span>&nbsp;
+and <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">USART_ClearFlag</span></span></span>
+functions.<o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_adc.c<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="GramE"><span class="grame"><span style="font-size: 10pt; font-family: Verdana;">replace</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> "&amp;="
+by "="&nbsp; in <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">ADC_ClearITPendingBit</span></span></span>
+and <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">ADC_ClearFlag</span></span></span>
+functions.<o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_i2c.c<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="GramE"><span class="grame"><span style="font-size: 10pt; font-family: Verdana;">replace</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> "&amp;="
+by "="&nbsp; in I2C_ClearITPendingBit and I2C_ClearFlag functions. <o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_tim.c<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="GramE"><span class="grame"><span style="font-size: 10pt; font-family: Verdana;">replace</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> "&amp;="
+by "="&nbsp; in <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">TIM_ClearITPendingBit</span></span></span>
+and <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">TIM_ClearFlag</span></span></span>
+functions. <o:p></o:p></span></li>
+</ul>
+</ul>
+<ol style="font-style: italic; font-weight: bold;" start="3" type="1">
+<li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">project<o:p></o:p></span></li>
+</ol>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_it.c<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="GramE"><span class="grame"><span style="font-size: 10pt; font-family: Verdana;">update</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> file
+description. <o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Add template
+projects for EWARM v5 and <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">HiTOP</span></span></span>
+<span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">toolchains</span></span></span>.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+<o:p></o:p></span></li>
+</ul>
+<ol style="font-style: italic; font-weight: bold;" start="4" type="1">
+<li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">examples<o:p></o:p></span></li>
+</ol>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="SpellE"><span class="spelle"><span style="font-size: 10pt; font-family: Verdana;">FWLib</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> V1.0
+examples ported to run on STMicroelectronics STM3210E-EVAL evaluation
+board (in addition to STM3210B-EVAL)<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Add new
+examples for FSMC, SDIO, DAC and I2S (run only on High-density
+devices). <o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Add new
+examples for ADC, DMA and RTC peripherals.<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Add new
+example for CRC module. <o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Examples
+folder renamed, use of short name instead of <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">examplex</span></span></span>
+(x: 1 2 ...).<o:p></o:p></span></li>
+</ul>
+<h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial; margin-right: 558.05pt;"><span style="font-size: 10pt; font-family: Arial; color: white;">V1.0
+- 10/08/2007<o:p></o:p></span></h3>
+<ol style="font-style: italic; font-weight: bold;" start="1" type="1">
+<li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">library<o:p></o:p></span></li>
+</ol>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Add template
+project with RIDE <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">toolchain</span></span></span>.
+<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">In all
+stm32f10x_ppp.c and stm32f10x_conf.h files: change "assert" macro name
+to "<span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">assert_param</span></span></span>".<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">&nbsp;
+Note: If you are using the FW Library V0.3 in your application and you
+want to migrate to V1.0, you have to update your applications
+stm32f10x_conf.h file with the latest one (provided with V1.0).<o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_conf.h<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Remove '#<span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">undef</span></span></span>
+assert' <o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Change
+'#define DEBUG' by '#define DEBUG&nbsp;&nbsp;&nbsp; 1'<o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_type.h<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Add new
+types: sc32, sc16, sc8, vsc32, vsc16 and vsc8&nbsp; <o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_it.c
+<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Add basic
+fault exception handling: in "<span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">HardFaultException</span></span></span>",
+"<span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">MemManageException</span></span></span>",&nbsp;
+"<span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">BusFaultException</span></span></span>"
+and "<span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">UsageFaultException</span></span></span>"
+ISR the following code was added:<o:p></o:p></span></li>
+</ul>
+</ul>
+<div style="margin-left: 150pt;">
+<p class="MsoNormal"><span style="font-size: 10pt; font-family: Arial; color: black;">&nbsp;&nbsp;&nbsp;&nbsp;
+/* Go to infinite loop when exception occurs */<br>
+&nbsp;&nbsp;&nbsp;&nbsp; while (1)<br>
+&nbsp;&nbsp;&nbsp;&nbsp; {<br>
+&nbsp;&nbsp;&nbsp;&nbsp; }</span><span style="font-family: Arial; color: black;"><o:p></o:p></span></p>
+</div>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_rcc.c<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">"<span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">RCC_</span></span><span class="GramE"><span class="grame"><span style="font-family: Verdana;">WaitForHSEStartUp</span></span></span></span><span class="GramE"><span class="grame"><span style="font-family: Verdana;">(</span></span></span>)"
+function updated to resolve issue with high GNU compiler optimization. <o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_gpio.h<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">'#define
+GPIO_Remap1_CAN ((u32)0x001D2000)' changed to '#define GPIO_Remap1_CAN
+((u32)0x001D4000)'.<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_rtc.c/.h<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">"<span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">RTC_GetPrescaler</span></span></span>"
+function removed.<o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_bkp.c/.h<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span class="GramE"><span class="grame"><span style="font-size: 10pt; font-family: Verdana;">add</span></span></span><span style="font-size: 10pt; font-family: Verdana;"> "<span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">BKP_RTCOutputConfig</span></span></span>()"
+function to allow to select the RTC output source(<span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">Calib</span></span></span>
+clock, RTC Alarm or RTC Second) to output on Tamper pin and remove "<span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">BKP_RTCCalibrationClockOutputCmd</span></span></span>()"
+function.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_can.h<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">CAN
+synchronization jump width defines updated<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">'#define
+CAN_SJW_0tq' ==&gt; '#define CAN_SJW_1tq'<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">'#define
+CAN_SJW_1tq' ==&gt; '#define CAN_SJW_2tq'<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">'#define
+CAN_SJW_2tq' ==&gt; '#define CAN_SJW_3tq'<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">'#define
+CAN_SJW_3tq' ==&gt; '#define CAN_SJW_4tq'<o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_tim1.c/.h<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">"TIM1_OCxNPolarityConfig(u16
+TIM1_OCPolarity)" function: change parameter name to 'TIM1_OCNPolarity'
+<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">change
+'TIM1_ICSelection_TRGI' by 'TIM1_ICSelection_TRC'<o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm32f10x_tim.c/.h<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">change '<span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">TIM_ICSelection_TRGI</span></span></span>'
+by '<span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">TIM_ICSelection_TRC</span></span></span>'<o:p></o:p></span></li>
+</ul>
+</ul>
+<ol style="font-style: italic; font-weight: bold;" start="2" type="1">
+<li class="MsoNormal" style=""><span style="font-size: 10pt; font-family: Verdana;">examples<o:p></o:p></span></li>
+</ol>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">ADC examples
+3 &amp; 4 updated&nbsp;&nbsp;&nbsp; <o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">DEBUG example<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Example
+modified to support RIDE specific <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">printf</span></span></span>
+function implementation<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">I2C example5<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">i2c_ee.c: add
+the following function prototypes: "void <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">GPIO_Configuration</span></span></span>(void)"&nbsp;
+add "void I2C_Configuration(void)"<o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Add GPIO pin
+toggle example.<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">BKP, CAN,
+DMA, NVIC and I2C examples readme files updated.<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Use decimal
+(instead of hexadecimal) values constants in TIM, TIM1 and IWDG
+examples.<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">USART<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">example 12<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">USART3 ISR
+updated <o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Timeout
+define "<span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">SC_Receive_Timeout</span></span></span>"
+updated to 0x4000<o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">example 7<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Example
+modified to support RIDE specific <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">printf</span></span></span>
+function implementation<o:p></o:p></span></li>
+</ul>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">RTC example<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Example
+modified to support RIDE specific <span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">printf</span></span></span>
+function implementation<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Change "<span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">BKP_RTCCalibrationClockOutputCmd</span></span></span>()"
+function&nbsp; by "<span class="SpellE"><span class="spelle"><span style="font-family: Verdana;">RTC_ClockOutput</span></span></span>()"<o:p></o:p></span></li>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">LSI removed
+as RTC clock source<o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">IWDG example<o:p></o:p></span></li>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">LSI frequency
+value changed from 32 KHz to 40 KHz&nbsp; <o:p></o:p></span></li>
+</ul>
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Update the
+STM32F10x evaluation board name from STM32F10x-EVAL to STM3210B-EVAL <o:p></o:p></span></li>
+</ul>
+<h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial; margin-right: 558.05pt;"><span style="font-size: 10pt; font-family: Arial; color: white;">V0.3
+- 05/21/2007<o:p></o:p></span></h3>
+<ul style="margin-top: 0cm;" type="square">
+<li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Created.<o:p></o:p></span></li>
+</ul>
+<h2 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial;"><a name="License"></a><span style="font-size: 12pt; color: white;">License<o:p></o:p></span></h2>
+<p class="MsoNormal" style="margin: 4.5pt 0cm;"><span style="font-size: 10pt; font-family: Verdana; color: black;">The
+enclosed firmware and all the related documentation are not covered by
+a License Agreement, if you need such License you can contact your
+local STMicroelectronics office.<u1:p></u1:p><o:p></o:p></span></p>
+<p class="MsoNormal"><b style=""><span style="font-size: 10pt; font-family: Verdana; color: black;">THE
+PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO
+SAVE TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR
+ANY DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY
+CLAIMS ARISING FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY
+CUSTOMERS OF THE CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH
+THEIR PRODUCTS. <o:p></o:p></span></b></p>
+<p class="MsoNormal"><span style="color: black;"><o:p>&nbsp;</o:p></span></p>
+<div class="MsoNormal" style="text-align: center;" align="center"><span style="color: black;">
+<hr align="center" size="2" width="100%"></span></div>
+<p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 18pt; text-align: center;" align="center"><span style="font-size: 10pt; font-family: Verdana; color: black;">For complete documentation on </span><span style="font-size: 10pt; font-family: Verdana;">STM32(<span style="color: black;">CORTEX M3) 32-Bit Microcontrollers
+visit </span><u><span style="color: blue;"><a href="http://www.st.com/stm32" target="_blank">www.st.com/STM32</a></span></u></span><span style="color: black;"><o:p></o:p></span></p>
+</td>
+</tr>
+</tbody>
+</table>
+<p class="MsoNormal"><span style="font-size: 10pt;"><o:p></o:p></span></p>
+</td>
+</tr>
+</tbody>
+</table>
+</div>
+<p class="MsoNormal"><o:p>&nbsp;</o:p></p>
+</div>
+</body></html>
\ No newline at end of file
diff --git a/bsp/boards/vesna/nvic.c b/bsp/boards/vesna/nvic.c
new file mode 100644
index 0000000..6d92172
--- /dev/null
+++ b/bsp/boards/vesna/nvic.c
@@ -0,0 +1,127 @@
+/**
+\brief iot-lab_M3 definition of the "nvic" bsp module.
+
+\author Alaeddine Weslati <alaeddine.weslati@inria.fr>, January 2014.
+*/
+#include "stm32f10x_lib.h"
+//=========================== defines =========================================
+
+//=========================== variables =======================================
+
+//=========================== prototypes ======================================
+
+//=========================== public ==========================================
+
+void NVIC_init(void)
+{
+  #ifdef  VECT_TAB_RAM
+  /* Set the Vector Table base location at 0x20000000 */
+  NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0);
+  #else  /* VECT_TAB_FLASH  */
+  /* Set the Vector Table base location at 0x08000000 */
+  NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);
+  #endif
+}
+
+//configuration uart interrput
+void NVIC_uart(void)
+{
+  //Configure NVIC: Preemption Priority = 3 and Sub Priority = 3
+  NVIC_InitTypeDef 	NVIC_InitStructure;
+  NVIC_InitStructure.NVIC_IRQChannel                    = USART1_IRQn;
+  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority  = 3;
+  NVIC_InitStructure.NVIC_IRQChannelSubPriority         = 3;
+  NVIC_InitStructure.NVIC_IRQChannelCmd                 = ENABLE;
+  NVIC_Init(&NVIC_InitStructure);
+}
+
+//configuration spi interrput
+void NVIC_spi(void)
+{
+#ifdef SPI_IN_INTERRUPT_MODE
+  //Configure NVIC: Preemption Priority = 1 and Sub Priority = 1
+  NVIC_InitTypeDef NVIC_InitStructure;
+  NVIC_InitStructure.NVIC_IRQChannel	                   = SPI1_IRQChannel;
+  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority   = 1;
+  NVIC_InitStructure.NVIC_IRQChannelSubPriority	         = 1;
+  NVIC_InitStructure.NVIC_IRQChannelCmd	                 = ENABLE;
+  NVIC_Init(&NVIC_InitStructure);
+#endif
+}
+
+//configuration bsptimer interrput
+void NVIC_bsptimer(void)
+{
+  //Configure NVIC: Preemption Priority = 2 and Sub Priority = 1
+  NVIC_InitTypeDef NVIC_InitStructure;
+  NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;
+  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
+  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
+  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
+  NVIC_Init(&NVIC_InitStructure);
+}
+
+//configuration rtctimer interrput
+void NVIC_rtctimer(void)
+{
+  //Configure RTC global interrupt:
+  //Configure NVIC: Preemption Priority = 1 and Sub Priority = 1
+  NVIC_InitTypeDef NVIC_InitStructure;
+  NVIC_InitStructure.NVIC_IRQChannel                    = RTC_IRQn;
+  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority  = 0;
+  NVIC_InitStructure.NVIC_IRQChannelSubPriority         = 1;
+  NVIC_InitStructure.NVIC_IRQChannelCmd                 = ENABLE;
+  NVIC_Init(&NVIC_InitStructure);
+
+  //Configure RTC Alarm interrupt:
+  //Configure NVIC: Preemption Priority = 0 and Sub Priority = 1
+  NVIC_InitStructure.NVIC_IRQChannel                    = RTCAlarm_IRQn;
+  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority  = 1;
+  NVIC_InitStructure.NVIC_IRQChannelSubPriority         = 0;
+  NVIC_InitStructure.NVIC_IRQChannelCmd                 = ENABLE;
+  NVIC_Init(&NVIC_InitStructure);
+}
+
+//configuration radiotimer interrput
+void NVIC_radiotimer(void)
+{
+  //Configure RTC global interrupt:
+  //Configure NVIC: Preemption Priority = 1 and Sub Priority = 1
+  NVIC_InitTypeDef NVIC_InitStructure;
+  NVIC_InitStructure.NVIC_IRQChannel                    = RTC_IRQn;
+  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority  = 0;
+  NVIC_InitStructure.NVIC_IRQChannelSubPriority         = 1;
+  NVIC_InitStructure.NVIC_IRQChannelCmd                 = ENABLE;
+  NVIC_Init(&NVIC_InitStructure);
+
+  //Configure RTC Alarm interrupt:
+  //Configure NVIC: Preemption Priority = 0 and Sub Priority = 1
+  NVIC_InitStructure.NVIC_IRQChannel                    = RTCAlarm_IRQn;
+  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority  = 1;
+  NVIC_InitStructure.NVIC_IRQChannelSubPriority         = 0;
+  NVIC_InitStructure.NVIC_IRQChannelCmd                 = ENABLE;
+  NVIC_Init(&NVIC_InitStructure);
+}
+
+//configuration radio interrput
+void NVIC_radio(void)
+{
+   //Configure NVIC: Preemption Priority = 2 and Sub Priority = 0
+  NVIC_InitTypeDef  NVIC_InitStructure;
+  NVIC_InitStructure.NVIC_IRQChannel                     = EXTI4_IRQn;
+  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority   = 2;
+  NVIC_InitStructure.NVIC_IRQChannelSubPriority          = 0;
+  NVIC_InitStructure.NVIC_IRQChannelCmd                  = ENABLE;
+  NVIC_Init(&NVIC_InitStructure);
+}
+
+//configuration of interrupt
+void NVIC_Configuration(void)
+{
+  //Set the Vector Table base location
+  NVIC_init();
+
+  //2 bits for Preemption Priority and 2 bits for Sub Priority
+  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
+}
+
diff --git a/bsp/boards/vesna/nvic.h b/bsp/boards/vesna/nvic.h
new file mode 100644
index 0000000..ac1f292
--- /dev/null
+++ b/bsp/boards/vesna/nvic.h
@@ -0,0 +1,30 @@
+/**
+\brief openmoteSTM32 definition of the NVIC.
+
+\author Chang Tengfei <tengfei.chang@gmail.com>,  July 2012.
+*/
+
+#ifndef __NVIC_H
+#define __NVIC_H
+
+//=========================== defines =========================================
+
+//=========================== variables =======================================
+
+//=========================== prototypes ======================================
+
+//initial NVIC on openmotestm32
+void NVIC_init(void);
+
+//configuration of interrupt on openmotestm32
+void NVIC_Configuration(void);
+
+//configuration module interrput on openmotestm32
+void NVIC_uart(void);
+void NVIC_spi(void);
+void NVIC_bsptimer(void);
+void NVIC_rtctimer(void);
+void NVIC_radiotimer(void);
+void NVIC_radio(void);
+
+#endif
\ No newline at end of file
diff --git a/bsp/boards/vesna/radiotimer.c b/bsp/boards/vesna/radiotimer.c
new file mode 100644
index 0000000..2b0a9c7
--- /dev/null
+++ b/bsp/boards/vesna/radiotimer.c
@@ -0,0 +1,227 @@
+/**
+\brief openmoteSTM32 definition of the "radiotimer" bsp module.
+
+On openmoteSTM32, we use RTC for the radiotimer module.
+
+\author Thomas Watteyne <watteyne@eecs.berkeley.edu>, February 2012.
+\author Chang Tengfei <tengfei.chang@gmail.com>,  July 2012.
+*/
+
+#include "stdint.h"
+
+#include "stm32f10x_lib.h"
+#include "leds.h"
+#include "radiotimer.h"
+#include "board.h"
+
+#include "rcc.h"
+#include "nvic.h"
+
+
+//=========================== variables =======================================
+
+enum  radiotimer_irqstatus_enum{
+    RADIOTIMER_NONE     = 0x00, //alarm interrupt default status
+    RADIOTIMER_OVERFLOW = 0x01, //alarm interrupt caused by overflow
+    RADIOTIMER_COMPARE  = 0x02, //alarm interrupt caused by compare
+};
+
+typedef struct {
+   radiotimer_compare_cbt    overflow_cb;
+   radiotimer_compare_cbt    compare_cb;
+   uint8_t                   overflowORcompare;//indicate RTC alarm interrupt status
+   uint16_t                  currentSlotPeriod;
+} radiotimer_vars_t;
+
+volatile radiotimer_vars_t radiotimer_vars;
+
+//=========================== prototypes ======================================
+
+//=========================== public ==========================================
+
+//===== admin
+
+void radiotimer_init() {
+   // clear local variables
+   memset(&radiotimer_vars,0,sizeof(radiotimer_vars_t));
+}
+
+void radiotimer_setOverflowCb(radiotimer_compare_cbt cb) {
+   radiotimer_vars.overflow_cb    = cb;
+}
+
+void radiotimer_setCompareCb(radiotimer_compare_cbt cb) {
+   radiotimer_vars.compare_cb     = cb;
+}
+
+void radiotimer_setStartFrameCb(radiotimer_capture_cbt cb) {
+   while(1);
+}
+
+void radiotimer_setEndFrameCb(radiotimer_capture_cbt cb) {
+   while(1);
+}
+
+void radiotimer_start(uint16_t period) {
+    //enable BKP and PWR, Clock
+    RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP|RCC_APB1Periph_PWR , ENABLE);
+
+    // RTC clock source configuration
+    PWR_BackupAccessCmd(ENABLE);                      //Allow access to BKP Domain
+    RCC_LSEConfig(RCC_LSE_ON);                        //Enable LSE OSC
+    while(RCC_GetFlagStatus(RCC_FLAG_LSERDY)==RESET); //Wait till LSE is ready
+    RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);           //Select the RTC Clock Source
+    RCC_RTCCLKCmd(ENABLE);                            //enable RTC
+
+    // RTC configuration
+    // Wait for RTC APB registers synchronisation
+    RTC_WaitForSynchro();
+
+    RTC_SetPrescaler(1);                              //use 16KHz clock
+    RTC_WaitForLastTask();                            //Wait until last write operation on RTC registers has finished
+
+    //Set the RTC time counter to 0
+    RTC_SetCounter(0);
+    RTC_WaitForLastTask();
+
+    // Set the RTC time alarm(the length of slot)
+    RTC_SetAlarm(period);
+    RTC_WaitForLastTask();
+
+    radiotimer_vars.currentSlotPeriod = period;
+
+    //interrupt when reach alarm value
+    RTC_ClearFlag(RTC_IT_ALR);
+    RTC_ITConfig(RTC_IT_ALR, ENABLE);
+
+    //set radiotimer irpstatus
+    radiotimer_vars.overflowORcompare = RADIOTIMER_OVERFLOW;
+
+    //Configures EXTI line 17 to generate an interrupt on rising edge(alarm interrupt to wakeup board)
+    EXTI_ClearITPendingBit(EXTI_Line17);
+    EXTI_InitTypeDef  EXTI_InitStructure;
+    EXTI_InitStructure.EXTI_Line    = EXTI_Line17;
+    EXTI_InitStructure.EXTI_Mode    = EXTI_Mode_Interrupt;
+    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
+    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
+    EXTI_Init(&EXTI_InitStructure);
+
+    //Configure RTC Alarm interrupt:
+    //Configure NVIC: Preemption Priority = 1 and Sub Priority = 0
+    NVIC_InitTypeDef NVIC_InitStructure;
+    NVIC_InitStructure.NVIC_IRQChannel                    = RTCAlarm_IRQn;
+    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority  = 1;
+    NVIC_InitStructure.NVIC_IRQChannelSubPriority         = 0;
+    NVIC_InitStructure.NVIC_IRQChannelCmd                 = ENABLE;
+    NVIC_Init(&NVIC_InitStructure);
+}
+
+//===== direct access
+
+uint16_t radiotimer_getValue() {
+    RTC_WaitForSynchro();
+    uint32_t counter = RTC_GetCounter();
+    return (uint16_t)counter;
+}
+
+void radiotimer_setPeriod(uint16_t period) {
+
+    RTC_ITConfig(RTC_IT_ALR, DISABLE);
+    //need to disable radio also in case that a radio interrupt is happening when set Alarm value
+
+
+    //Reset RTC Counter to begin a new slot
+    RTC_SetAlarm(period);
+    RTC_WaitForLastTask();
+
+    radiotimer_vars.currentSlotPeriod = period;
+
+    //set radiotimer irpstatus
+    radiotimer_vars.overflowORcompare = RADIOTIMER_OVERFLOW;
+    RTC_ClearFlag(RTC_IT_ALR);
+    RTC_ITConfig(RTC_IT_ALR, ENABLE);
+}
+
+uint16_t radiotimer_getPeriod() {
+    RTC_WaitForSynchro();
+    uint32_t period = RTC_GetAlarm();
+    return (uint16_t)period;
+}
+
+//===== compare
+
+void radiotimer_schedule(uint16_t offset) {
+    RTC_ITConfig(RTC_IT_ALR, DISABLE);
+    //need to disable radio also in case that a radio interrupt is happening
+
+    // Set the RTC alarm(RTC timer will alarm at next state of slot)
+    RTC_SetAlarm(offset);
+    RTC_WaitForLastTask();
+
+    //set radiotimer irpstatus
+    radiotimer_vars.overflowORcompare = RADIOTIMER_COMPARE;
+    RTC_ClearFlag(RTC_IT_ALR);
+    RTC_ITConfig(RTC_IT_ALR, ENABLE);
+}
+
+void radiotimer_cancel() {
+    RTC_ITConfig(RTC_IT_ALR, DISABLE);
+    //need to disable radio also in case that a radio interrupt is happening
+
+
+    // set RTC alarm (slotlength)
+    RTC_SetAlarm(radiotimer_vars.currentSlotPeriod);
+    RTC_WaitForLastTask();
+
+    //set radiotimer irpstatus
+    radiotimer_vars.overflowORcompare = RADIOTIMER_OVERFLOW;
+    RTC_ClearFlag(RTC_IT_ALR);
+    RTC_ITConfig(RTC_IT_ALR, ENABLE);
+}
+
+//===== capture
+
+inline uint16_t radiotimer_getCapturedTime() {
+    RTC_WaitForSynchro();
+    uint32_t counter = RTC_GetCounter();
+    return (uint16_t)counter;
+}
+
+//=========================== private =========================================
+
+//=========================== interrupt handlers ==============================
+
+kick_scheduler_t radiotimer_isr() {
+   uint8_t taiv_temp = radiotimer_vars.overflowORcompare;
+   switch (taiv_temp) {
+      case RADIOTIMER_COMPARE:
+         if (radiotimer_vars.compare_cb!=NULL) {
+            RCC_Wakeup();
+            // call the callback
+            radiotimer_vars.compare_cb();
+            // kick the OS
+            return KICK_SCHEDULER;
+         }
+         break;
+      case RADIOTIMER_OVERFLOW: // timer overflows
+         if (radiotimer_vars.overflow_cb!=NULL) {
+
+            //Wait until last write operation on RTC registers has finished
+            RTC_WaitForLastTask();
+
+            //Set the RTC time counter to 0
+            RTC_SetCounter(0x00000000);
+            RTC_WaitForLastTask();
+            RCC_Wakeup();
+            // call the callback
+            radiotimer_vars.overflow_cb();
+            // kick the OS
+            return KICK_SCHEDULER;
+         }
+         break;
+      case RADIOTIMER_NONE:                     // this should not happen
+      default:
+         while(1);                               // this should not happen
+   }
+  return DO_NOT_KICK_SCHEDULER;
+}
diff --git a/bsp/boards/vesna/rcc.c b/bsp/boards/vesna/rcc.c
new file mode 100644
index 0000000..4f9390b
--- /dev/null
+++ b/bsp/boards/vesna/rcc.c
@@ -0,0 +1,94 @@
+/**
+\brief openmoteSTM32 definition of the RCC.
+
+\author Chang Tengfei <tengfei.chang@gmail.com>,  July 2012.
+*/
+#include "stm32f10x_lib.h"
+//=========================== defines =========================================
+
+//=========================== variables =======================================
+
+//=========================== prototypes ======================================
+
+//=========================== public ==========================================
+
+void RCC_Configuration(void)
+{
+    ErrorStatus HSEStartUpStatus;
+
+    /* RCC system reset(for debug purpose) */
+    RCC_DeInit();
+
+    /* Enable HSE */
+    RCC_HSEConfig(RCC_HSE_ON);
+
+    /* Wait till HSE is ready */
+    HSEStartUpStatus = RCC_WaitForHSEStartUp();
+
+    if(HSEStartUpStatus == SUCCESS)
+    {
+      /* Enable Prefetch Buffer */
+      FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
+
+      /* Flash 2 wait state */
+      FLASH_SetLatency(FLASH_Latency_2);
+
+      /* HCLK = SYSCLK */
+      RCC_HCLKConfig(RCC_SYSCLK_Div1);
+
+      /* PCLK2 = HCLK */
+      RCC_PCLK2Config(RCC_HCLK_Div1);
+
+      /* PCLK1 = HCLK/2 */
+      RCC_PCLK1Config(RCC_HCLK_Div2);
+
+      /* PLLCLK = 16MHz / 2 * 9 = 72 MHz */
+      RCC_PLLConfig(RCC_PLLSource_HSE_Div2, RCC_PLLMul_9);
+
+      /* Enable PLL */
+      RCC_PLLCmd(ENABLE);
+
+      /* Wait till PLL is ready */
+      while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
+      {
+      }
+
+      /* Select PLL as system clock source */
+      RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
+
+      /* Wait till PLL is used as system clock source */
+      while(RCC_GetSYSCLKSource() != 0x08)
+      {
+      }
+    }
+
+    //enable AFIO
+    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
+}
+
+//when wakeup by alarm, configure rcc
+void RCC_Wakeup(void)
+{
+    ErrorStatus HSEStartUpStatus;
+
+    //enable HSE
+    RCC_HSEConfig(RCC_HSE_ON);
+    //Wait till HSE is ready
+    HSEStartUpStatus = RCC_WaitForHSEStartUp();
+    if(HSEStartUpStatus == SUCCESS)
+    {
+      //enable PLL
+      RCC_PLLCmd(ENABLE);
+      //Wait till PLL is ready
+      while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
+      {}
+
+      // Select PLL as system clock source
+      RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
+
+      //Wait till PLL is used as system clock source
+      while(RCC_GetSYSCLKSource() != 0x08)
+      {}
+   }
+}
+
diff --git a/bsp/boards/vesna/rcc.h b/bsp/boards/vesna/rcc.h
new file mode 100644
index 0000000..a4100bd
--- /dev/null
+++ b/bsp/boards/vesna/rcc.h
@@ -0,0 +1,20 @@
+/**
+\brief openmoteSTM32 definition of the RCC.
+
+\author Chang Tengfei <tengfei.chang@gmail.com>,  July 2012.
+*/
+
+#ifndef __RCC_H
+#define __RCC_H
+
+//=========================== defines =========================================
+
+//=========================== variables =======================================
+
+//=========================== prototypes ======================================
+
+void RCC_Configuration(void);
+
+void RCC_Wakeup(void);
+
+#endif
\ No newline at end of file
diff --git a/bsp/boards/vesna/rtc_timer.c b/bsp/boards/vesna/rtc_timer.c
new file mode 100644
index 0000000..6165822
--- /dev/null
+++ b/bsp/boards/vesna/rtc_timer.c
@@ -0,0 +1,131 @@
+/**
+\brief openmoteSTM32 definition of the "rtc_timer" bsp module.
+
+\author Thomas Watteyne <watteyne@eecs.berkeley.edu>, February 2012.
+\author Chang Tengfei <tengfei.chang@gmail.com>,  July 2012.
+*/
+
+#include "stm32f10x_lib.h"
+#include "leds.h"
+#include "rtc_timer.h"
+
+#include "rcc.h"
+#include "nvic.h"
+
+//=========================== variables =======================================
+
+typedef struct {
+   rtc_timer_alarm_cbt    alarm_cb;
+} rtc_timer_vars_t;
+
+volatile rtc_timer_vars_t rtc_timer_vars;
+
+//=========================== prototypes ======================================
+
+//=========================== public ==========================================
+
+//===== admin
+
+void rtc_timer_init() {
+   // clear local variables
+   memset(&rtc_timer_vars,0,sizeof(rtc_timer_vars_t));
+}
+
+void rtc_timer_setAlarmCb(rtc_timer_alarm_cbt cb) {
+   rtc_timer_vars.alarm_cb    = cb;
+}
+
+void rtc_timer_start(u32 alarmValue)
+{
+    //enable BKP and PWR, Clock
+    RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP|RCC_APB1Periph_PWR , ENABLE);
+
+    // RTC clock source configuration
+    PWR_BackupAccessCmd(ENABLE);                      //Allow access to BKP Domain
+    RCC_LSEConfig(RCC_LSE_ON);                        //Enable LSE OSC
+    while(RCC_GetFlagStatus(RCC_FLAG_LSERDY)==RESET); //Wait till LSE is ready
+    RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);           //Select the RTC Clock Source
+    RCC_RTCCLKCmd(ENABLE);                            //enable RTC
+
+    // RTC configuration
+    // Wait for RTC APB registers synchronisation
+    RTC_WaitForSynchro();
+
+    RTC_SetPrescaler(0);                              //Set the RTC time base to 30.5us
+    RTC_WaitForLastTask();                            //Wait until last write operation on RTC registers has finished
+
+    //Set the RTC time counter to 0
+    RTC_SetCounter(0);
+    RTC_WaitForLastTask();
+
+    // Set the RTC time alarm(the length of slot)
+    RTC_SetAlarm(alarmValue);
+    RTC_WaitForLastTask();
+
+    //interrupt when reach alarm value
+    RTC_ClearFlag(RTC_IT_ALR);
+    RTC_ITConfig(RTC_IT_ALR, ENABLE);
+
+    //Configures EXTI line 17 to generate an interrupt on rising edge(alarm interrupt to wakeup board)
+    EXTI_ClearITPendingBit(EXTI_Line17);
+    EXTI_InitTypeDef  EXTI_InitStructure;
+    EXTI_InitStructure.EXTI_Line    = EXTI_Line17;
+    EXTI_InitStructure.EXTI_Mode    = EXTI_Mode_Interrupt;
+    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
+    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
+    EXTI_Init(&EXTI_InitStructure);
+
+    //Configure RTC global interrupt:
+    //Configure NVIC: Preemption Priority = 1 and Sub Priority = 1
+    NVIC_InitTypeDef NVIC_InitStructure;
+    NVIC_InitStructure.NVIC_IRQChannel                    = RTC_IRQn;
+    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority  = 1;
+    NVIC_InitStructure.NVIC_IRQChannelSubPriority         = 0;
+    NVIC_InitStructure.NVIC_IRQChannelCmd                 = ENABLE;
+    NVIC_Init(&NVIC_InitStructure);
+
+    //Configure RTC Alarm interrupt:
+    //Configure NVIC: Preemption Priority = 0 and Sub Priority = 1
+    NVIC_InitStructure.NVIC_IRQChannel                    = RTCAlarm_IRQn;
+    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority  = 0;
+    NVIC_InitStructure.NVIC_IRQChannelSubPriority         = 1;
+    NVIC_InitStructure.NVIC_IRQChannelCmd                 = ENABLE;
+    NVIC_Init(&NVIC_InitStructure);
+}
+
+//===== direct access
+
+uint16_t rtc_timer_getAlarm() {
+    uint32_t alarmValue = RTC_GetAlarm();
+    return (uint16_t)alarmValue;
+}
+
+void    rtc_timer_resetCounter() {
+    RTC_SetCounter(0);                //Set RTC Counter to begin a new slot
+    RTC_WaitForLastTask();            //Wait until last write operation on RTC registers has finished
+}
+
+//===== capture
+
+uint16_t rtc_timer_getCapturedTime()
+{
+    uint32_t counter = RTC_GetCounter();
+    return (uint16_t)counter;
+}
+
+//=========================== private =========================================
+
+//=========================== interrupt handlers ==============================
+
+
+uint8_t rtc_timer_isr()
+{
+    if (rtc_timer_vars.alarm_cb!=NULL)
+    {
+      // call the callback
+      rtc_timer_vars.alarm_cb();
+      // kick the OS
+      return 1;
+    }
+    return 0;
+}
diff --git a/bsp/boards/vesna/rtc_timer.h b/bsp/boards/vesna/rtc_timer.h
new file mode 100644
index 0000000..0f16304
--- /dev/null
+++ b/bsp/boards/vesna/rtc_timer.h
@@ -0,0 +1,38 @@
+/**
+\brief openmoteSTM32 declaration "rtctimer" bsp module.
+
+\author Chang Tengfei <tengfei.chang@gmail.com>,  July 2012.
+*/
+
+#ifndef __RTC_TIMER_H
+#define __RTC_TIMER_H
+
+#include "stdint.h"
+#include "board.h"
+
+//=========================== define ==========================================
+
+//=========================== typedef =========================================
+
+typedef void (*rtc_timer_alarm_cbt)(void);
+
+//=========================== variables =======================================
+
+//=========================== prototypes ======================================
+
+// admin
+void     rtc_timer_init(void);
+void     rtc_timer_setAlarmCb(rtc_timer_alarm_cbt cb);
+void     rtc_timer_start(u32 alarmValue);
+// direct access
+PORT_TIMER_WIDTH     rtc_timer_getAlarm(void);
+void    rtc_timer_resetCounter(void);
+//set alarm
+
+// capture
+PORT_TIMER_WIDTH rtc_timer_getCapturedTime(void);
+
+
+uint8_t  rtc_timer_isr(void);
+
+#endif
diff --git a/bsp/boards/vesna/spi.c b/bsp/boards/vesna/spi.c
new file mode 100644
index 0000000..2c6c235
--- /dev/null
+++ b/bsp/boards/vesna/spi.c
@@ -0,0 +1,256 @@
+/**
+\brief iot-lab_M3 definition of the "spi" bsp module (based on openmoteSTM32 code).
+
+\author Thomas Watteyne <watteyne@eecs.berkeley.edu>, February 2012.
+\author Chang Tengfei <tengfei.chang@gmail.com>,  July 2012.
+\author Alaeddine Weslati <alaeddine.weslati@inria.fr>, January 2014.
+*/
+#include "stm32f10x_lib.h"
+#include "stdio.h"
+#include "stdint.h"
+#include "string.h"
+#include "spi.h"
+#include "leds.h"
+
+#include "rcc.h"
+#include "nvic.h"
+
+//=========================== defines =========================================
+
+//=========================== variables =======================================
+
+typedef struct {
+   // information about the current transaction
+   uint8_t*        pNextTxByte;
+   uint8_t         numTxedBytes;
+   uint8_t         txBytesLeft;
+   spi_return_t    returnType;
+   uint8_t*        pNextRxByte;
+   uint8_t         maxRxBytes;
+   spi_first_t     isFirst;
+   spi_last_t      isLast;
+   // state of the module
+   uint8_t         busy;
+#ifdef SPI_IN_INTERRUPT_MODE
+   // callback when module done
+   spi_cbt         callback;
+#endif
+} spi_vars_t;
+
+volatile spi_vars_t spi_vars;
+
+//=========================== prototypes ======================================
+inline static void RESET_CLR(void) { GPIOC->BRR = 1<<1; }
+inline static void RESET_SET(void) { GPIOC->BSRR = 1<<1; }
+inline static void CSn_SET(void) { GPIOA->BSRR = 1<<4; }
+inline static void CSn_CLR(void) { GPIOA->BRR = 1<<4; }
+inline static void SLEEP_CLR(void) { GPIOA->BRR = 1<<2; }
+
+//=========================== public ==========================================
+
+void spi_init() {
+ // clear variables
+  memset(&spi_vars,0,sizeof(spi_vars_t));
+
+  SPI_InitTypeDef  SPI_InitStructure;
+
+  //enable SPI1, GPIOA, GPIOB and GPIOC, Clock
+  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
+  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
+  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
+
+  //Configure SPI-related pins: PA.5 as SCLK pin ,PA.6 as MISO pin, PA.7 as MOSI pin, PA.4 as /SEL pin
+  GPIO_InitTypeDef GPIO_InitStructure;
+  GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_5 | GPIO_Pin_7;
+  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;
+  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
+  GPIO_Init(GPIOA, &GPIO_InitStructure);
+
+  GPIO_InitStructure.GPIO_Pin    = GPIO_Pin_6;
+  GPIO_InitStructure.GPIO_Mode   = GPIO_Mode_IN_FLOATING;
+  GPIO_InitStructure.GPIO_Speed  = GPIO_Speed_50MHz;
+  GPIO_Init(GPIOA, &GPIO_InitStructure);
+
+  GPIO_InitStructure.GPIO_Pin     = GPIO_Pin_4 | GPIO_Pin_2;
+  GPIO_InitStructure.GPIO_Mode    = GPIO_Mode_Out_PP;
+  GPIO_Init(GPIOA, &GPIO_InitStructure);
+
+  GPIO_InitStructure.GPIO_Pin     = GPIO_Pin_1;
+  GPIO_InitStructure.GPIO_Mode    = GPIO_Mode_Out_PP;
+  GPIO_Init(GPIOC, &GPIO_InitStructure);
+
+  // force reset
+  RESET_CLR();
+  CSn_SET();
+  SLEEP_CLR();
+
+  for (uint16_t j=0;j<0xFFFF;j++); //small wait
+
+  RESET_SET();
+
+  //Configure SPI1
+  SPI_InitStructure.SPI_Direction         = SPI_Direction_2Lines_FullDuplex; //Full-duplex synchronous transfers on two lines
+  SPI_InitStructure.SPI_Mode              = SPI_Mode_Master;//Master Mode
+  SPI_InitStructure.SPI_DataSize          = SPI_DataSize_8b; //8-bit transfer frame format
+  SPI_InitStructure.SPI_CPOL              = SPI_CPOL_Low;  //the SCK pin has a low-level idle state
+  SPI_InitStructure.SPI_CPHA              = SPI_CPHA_1Edge; //the first rising edge on the SCK pin is the MSBit capture strobe,
+  SPI_InitStructure.SPI_NSS               = SPI_NSS_Soft;//Software NSS mode
+  SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_16;//BaudRate Prescaler = 8
+  SPI_InitStructure.SPI_FirstBit          = SPI_FirstBit_MSB;//data order with MSB-first
+  SPI_InitStructure.SPI_CRCPolynomial     = 7;//CRC Polynomial = 7
+  SPI_Init(SPI1, &SPI_InitStructure);
+
+  //enable SPI1
+  SPI_Cmd(SPI1, ENABLE);
+
+#ifdef SPI_IN_INTERRUPT_MODE
+  //Configure NVIC: Preemption Priority = 1 and Sub Priority = 1
+  NVIC_InitTypeDef NVIC_InitStructure;
+  NVIC_InitStructure.NVIC_IRQChannel	                  = SPI1_IRQChannel;
+  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority	= 1;
+  NVIC_InitStructure.NVIC_IRQChannelSubPriority	        = 1;
+  NVIC_InitStructure.NVIC_IRQChannelCmd	                = ENABLE;
+  NVIC_Init(&NVIC_InitStructure);
+#endif
+}
+
+#ifdef SPI_IN_INTERRUPT_MODE
+void spi_setCallback(spi_cbt cb) {
+   spi_vars.callback = cb;
+}
+#endif
+
+void spi_txrx(uint8_t*     bufTx,
+              uint8_t      lenbufTx,
+              spi_return_t returnType,
+              uint8_t*     bufRx,
+              uint8_t      maxLenBufRx,
+              spi_first_t  isFirst,
+              spi_last_t   isLast) {
+
+#ifdef SPI_IN_INTERRUPT_MODE
+   // disable interrupts
+   NVIC_RESETPRIMASK();
+#endif
+
+   // register spi frame to send
+   spi_vars.pNextTxByte      =  bufTx;
+   spi_vars.numTxedBytes     =  0;
+   spi_vars.txBytesLeft      =  lenbufTx;
+   spi_vars.returnType       =  returnType;
+   spi_vars.pNextRxByte      =  bufRx;
+   spi_vars.maxRxBytes       =  maxLenBufRx;
+   spi_vars.isFirst          =  isFirst;
+   spi_vars.isLast           =  isLast;
+
+   // SPI is now busy
+   spi_vars.busy             =  1;
+
+
+   // lower CS signal to have slave listening
+   if (spi_vars.isFirst==SPI_FIRST) {
+   GPIO_ResetBits(GPIOA, GPIO_Pin_4);
+   }
+
+#ifdef SPI_IN_INTERRUPT_MODE
+   // implementation 1. use a callback function when transaction finishes
+
+   // write first byte to TX buffer
+   SPI_I2S_SendData(SPI1,*spi_vars.pNextTxByte);
+
+   // re-enable interrupts
+   NVIC_SETPRIMASK();
+#else
+   // implementation 2. busy wait for each byte to be sent
+   // send all bytes
+   while (spi_vars.txBytesLeft>0) {
+      // write next byte to TX buffer
+   SPI_I2S_SendData(SPI1,*spi_vars.pNextTxByte);
+
+      // busy wait on the interrupt flag
+      while (SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_RXNE) == RESET);
+
+      // clear the interrupt flag
+      SPI_I2S_ClearFlag(SPI1, SPI_I2S_FLAG_RXNE);
+      // save the byte just received in the RX buffer
+      switch (spi_vars.returnType) {
+         case SPI_FIRSTBYTE:
+            if (spi_vars.numTxedBytes==0) {
+               *spi_vars.pNextRxByte   = SPI_I2S_ReceiveData(SPI1);
+            }
+            break;
+         case SPI_BUFFER:
+            *spi_vars.pNextRxByte      = SPI_I2S_ReceiveData(SPI1);
+            spi_vars.pNextRxByte++;
+            break;
+         case SPI_LASTBYTE:
+            *spi_vars.pNextRxByte      = SPI_I2S_ReceiveData(SPI1);
+            break;
+      }
+      // one byte less to go
+      spi_vars.pNextTxByte++;
+      spi_vars.numTxedBytes++;
+      spi_vars.txBytesLeft--;
+   }
+
+   // put CS signal high to signal end of transmission to slave
+   if (spi_vars.isLast==SPI_LAST) {
+   GPIO_SetBits(GPIOA, GPIO_Pin_4);
+   }
+
+   // SPI is not busy anymore
+   spi_vars.busy             =  0;
+#endif
+}
+
+//=========================== private =========================================
+
+//=========================== interrupt handlers ==============================
+
+kick_scheduler_t spi_isr() {
+#ifdef SPI_IN_INTERRUPT_MODE
+   // save the byte just received in the RX buffer
+   switch (spi_vars.returnType) {
+      case SPI_FIRSTBYTE:
+         if (spi_vars.numTxedBytes==0) {
+            *spi_vars.pNextRxByte = SPI_I2S_ReceiveData(SPI1);
+         }
+         break;
+      case SPI_BUFFER:
+         *spi_vars.pNextRxByte    = SPI_I2S_ReceiveData(SPI1);
+         spi_vars.pNextRxByte++;
+         break;
+      case SPI_LASTBYTE:
+         *spi_vars.pNextRxByte    = SPI_I2S_ReceiveData(SPI1);
+         break;
+   }
+
+   // one byte less to go
+   spi_vars.pNextTxByte++;
+   spi_vars.numTxedBytes++;
+   spi_vars.txBytesLeft--;
+
+   if (spi_vars.txBytesLeft>0) {
+      // write next byte to TX buffer
+   SPI_SendData(SPI1,*spi_vars.pNextTxByte);
+   } else {
+      // put CS signal high to signal end of transmission to slave
+      if (spi_vars.isLast==SPI_LAST) {
+   GPIO_SetBits(GPIOA, GPIO_Pin_4);
+      }
+      // SPI is not busy anymore
+      spi_vars.busy          =  0;
+
+      // SPI is done!
+      if (spi_vars.callback!=NULL) {
+         // call the callback
+         spi_vars.callback();
+         // kick the OS
+         return 1;
+      }
+   }
+#else
+   while(1);// this should never happen
+#endif
+}
+
diff --git a/bsp/boards/vesna/startup.s b/bsp/boards/vesna/startup.s
new file mode 100644
index 0000000..ce0db20
--- /dev/null
+++ b/bsp/boards/vesna/startup.s
@@ -0,0 +1,469 @@
+/**
+  ******************************************************************************
+  * @file      startup_stm32f10x_hd.s
+  * @author    MCD Application Team
+  * @version   V3.5.0
+  * @date      11-March-2011
+  * @brief     STM32F10x High Density Devices vector table for Atollic toolchain.
+  *            This module performs:
+  *                - Set the initial SP
+  *                - Set the initial PC == Reset_Handler,
+  *                - Set the vector table entries with the exceptions ISR address,
+  *                - Configure the clock system
+  *                - Configure external SRAM mounted on STM3210E-EVAL board
+  *                  to be used as data memory (optional, to be enabled by user)
+  *                - Branches to main in the C library (which eventually
+  *                  calls main()).
+  *            After Reset the Cortex-M3 processor is in Thread mode,
+  *            priority is Privileged, and the Stack is set to Main.
+  ******************************************************************************
+  * @attention
+  *
+  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
+  ******************************************************************************
+  */
+
+    .syntax unified
+	.cpu cortex-m3
+	.fpu softvfp
+	.thumb
+
+.global	g_pfnVectors
+.global	Default_Handler
+
+/* start address for the initialization values of the .data section.
+defined in linker script */
+.word	_sidata
+/* start address for the .data section. defined in linker script */
+.word	_sdata
+/* end address for the .data section. defined in linker script */
+.word	_edata
+/* start address for the .bss section. defined in linker script */
+.word	_sbss
+/* end address for the .bss section. defined in linker script */
+.word	_ebss
+
+.equ  BootRAM,        0xF1E0F85F
+/**
+ * @brief  This is the code that gets called when the processor first
+ *          starts execution following a reset event. Only the absolutely
+ *          necessary set is performed, after which the application
+ *          supplied main() routine is called.
+ * @param  None
+ * @retval : None
+*/
+
+    .section	.text.Reset_Handler
+	.weak	Reset_Handler
+	.type	Reset_Handler, %function
+Reset_Handler:
+
+/* Copy the data segment initializers from flash to SRAM */
+  movs	r1, #0
+  b	LoopCopyDataInit
+
+CopyDataInit:
+	ldr	r3, =_sidata
+	ldr	r3, [r3, r1]
+	str	r3, [r0, r1]
+	adds	r1, r1, #4
+
+LoopCopyDataInit:
+	ldr	r0, =_sdata
+	ldr	r3, =_edata
+	adds	r2, r0, r1
+	cmp	r2, r3
+	bcc	CopyDataInit
+	ldr	r2, =_sbss
+	b	LoopFillZerobss
+/* Zero fill the bss segment. */
+FillZerobss:
+	movs	r3, #0
+	str	r3, [r2], #4
+
+LoopFillZerobss:
+	ldr	r3, = _ebss
+	cmp	r2, r3
+	bcc	FillZerobss
+
+/* Call the clock system intitialization function.*/
+/*  bl  SystemInit */
+/* Call static constructors */
+/*  bl __libc_init_array */
+/* Call the application's entry point.*/
+	bl	main
+	bx	lr
+.size	Reset_Handler, .-Reset_Handler
+
+/**
+ * @brief  This is the code that gets called when the processor receives an
+ *         unexpected interrupt.  This simply enters an infinite loop, preserving
+ *         the system state for examination by a debugger.
+ *
+ * @param  None
+ * @retval : None
+*/
+    .section	.text.Default_Handler,"ax",%progbits
+Default_Handler:
+Infinite_Loop:
+	b	Infinite_Loop
+	.size	Default_Handler, .-Default_Handler
+/******************************************************************************
+*
+* The minimal vector table for a Cortex M3.  Note that the proper constructs
+* must be placed on this to ensure that it ends up at physical address
+* 0x0000.0000.
+*
+******************************************************************************/
+	.section	.isr_vector,"a",%progbits
+	.type	g_pfnVectors, %object
+	.size	g_pfnVectors, .-g_pfnVectors
+
+
+g_pfnVectors:
+	.word	_estack
+	.word	Reset_Handler
+	.word	NMI_Handler
+	.word	HardFault_Handler
+	.word	MemManage_Handler
+	.word	BusFault_Handler
+	.word	UsageFault_Handler
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	SVC_Handler
+	.word	DebugMon_Handler
+	.word	0
+	.word	PendSV_Handler
+	.word	SysTick_Handler
+	.word	WWDG_IRQHandler
+	.word	PVD_IRQHandler
+	.word	TAMPER_IRQHandler
+	.word	RTC_IRQHandler
+	.word	FLASH_IRQHandler
+	.word	RCC_IRQHandler
+	.word	EXTI0_IRQHandler
+	.word	EXTI1_IRQHandler
+	.word	EXTI2_IRQHandler
+	.word	EXTI3_IRQHandler
+	.word	EXTI4_IRQHandler
+	.word	DMA1_Channel1_IRQHandler
+	.word	DMA1_Channel2_IRQHandler
+	.word	DMA1_Channel3_IRQHandler
+	.word	DMA1_Channel4_IRQHandler
+	.word	DMA1_Channel5_IRQHandler
+	.word	DMA1_Channel6_IRQHandler
+	.word	DMA1_Channel7_IRQHandler
+	.word	ADC1_2_IRQHandler
+	.word	USB_HP_CAN1_TX_IRQHandler
+	.word	USB_LP_CAN1_RX0_IRQHandler
+	.word	CAN1_RX1_IRQHandler
+	.word	CAN1_SCE_IRQHandler
+	.word	EXTI9_5_IRQHandler
+	.word	TIM1_BRK_IRQHandler
+	.word	TIM1_UP_IRQHandler
+	.word	TIM1_TRG_COM_IRQHandler
+	.word	TIM1_CC_IRQHandler
+	.word	TIM2_IRQHandler
+	.word	TIM3_IRQHandler
+	.word	TIM4_IRQHandler
+	.word	I2C1_EV_IRQHandler
+	.word	I2C1_ER_IRQHandler
+	.word	I2C2_EV_IRQHandler
+	.word	I2C2_ER_IRQHandler
+	.word	SPI1_IRQHandler
+	.word	SPI2_IRQHandler
+	.word	USART1_IRQHandler
+	.word	USART2_IRQHandler
+	.word	USART3_IRQHandler
+	.word	EXTI15_10_IRQHandler
+	.word	RTCAlarm_IRQHandler
+	.word	USBWakeUp_IRQHandler
+	.word	TIM8_BRK_IRQHandler
+	.word	TIM8_UP_IRQHandler
+	.word	TIM8_TRG_COM_IRQHandler
+	.word	TIM8_CC_IRQHandler
+	.word	ADC3_IRQHandler
+	.word	FSMC_IRQHandler
+	.word	SDIO_IRQHandler
+	.word	TIM5_IRQHandler
+	.word	SPI3_IRQHandler
+	.word	UART4_IRQHandler
+	.word	UART5_IRQHandler
+	.word	TIM6_IRQHandler
+	.word	TIM7_IRQHandler
+	.word	DMA2_Channel1_IRQHandler
+	.word	DMA2_Channel2_IRQHandler
+	.word	DMA2_Channel3_IRQHandler
+	.word	DMA2_Channel4_5_IRQHandler
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	0
+	.word	BootRAM       /* @0x1E0. This is for boot in RAM mode for
+                         STM32F10x High Density devices. */
+
+/*******************************************************************************
+*
+* Provide weak aliases for each Exception handler to the Default_Handler.
+* As they are weak aliases, any function with the same name will override
+* this definition.
+*
+*******************************************************************************/
+
+  .weak	NMI_Handler
+	.thumb_set NMI_Handler,Default_Handler
+
+  .weak	HardFault_Handler
+	.thumb_set HardFault_Handler,Default_Handler
+
+  .weak	MemManage_Handler
+	.thumb_set MemManage_Handler,Default_Handler
+
+  .weak	BusFault_Handler
+	.thumb_set BusFault_Handler,Default_Handler
+
+	.weak	UsageFault_Handler
+	.thumb_set UsageFault_Handler,Default_Handler
+
+	.weak	SVC_Handler
+	.thumb_set SVC_Handler,Default_Handler
+
+	.weak	DebugMon_Handler
+	.thumb_set DebugMon_Handler,Default_Handler
+
+	.weak	PendSV_Handler
+	.thumb_set PendSV_Handler,Default_Handler
+
+	.weak	SysTick_Handler
+	.thumb_set SysTick_Handler,Default_Handler
+
+	.weak	WWDG_IRQHandler
+	.thumb_set WWDG_IRQHandler,Default_Handler
+
+	.weak	PVD_IRQHandler
+	.thumb_set PVD_IRQHandler,Default_Handler
+
+	.weak	TAMPER_IRQHandler
+	.thumb_set TAMPER_IRQHandler,Default_Handler
+
+	.weak	RTC_IRQHandler
+	.thumb_set RTC_IRQHandler,Default_Handler
+
+	.weak	FLASH_IRQHandler
+	.thumb_set FLASH_IRQHandler,Default_Handler
+
+	.weak	RCC_IRQHandler
+	.thumb_set RCC_IRQHandler,Default_Handler
+
+	.weak	EXTI0_IRQHandler
+	.thumb_set EXTI0_IRQHandler,Default_Handler
+
+	.weak	EXTI1_IRQHandler
+	.thumb_set EXTI1_IRQHandler,Default_Handler
+
+	.weak	EXTI2_IRQHandler
+	.thumb_set EXTI2_IRQHandler,Default_Handler
+
+	.weak	EXTI3_IRQHandler
+	.thumb_set EXTI3_IRQHandler,Default_Handler
+
+	.weak	EXTI4_IRQHandler
+	.thumb_set EXTI4_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel1_IRQHandler
+	.thumb_set DMA1_Channel1_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel2_IRQHandler
+	.thumb_set DMA1_Channel2_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel3_IRQHandler
+	.thumb_set DMA1_Channel3_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel4_IRQHandler
+	.thumb_set DMA1_Channel4_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel5_IRQHandler
+	.thumb_set DMA1_Channel5_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel6_IRQHandler
+	.thumb_set DMA1_Channel6_IRQHandler,Default_Handler
+
+	.weak	DMA1_Channel7_IRQHandler
+	.thumb_set DMA1_Channel7_IRQHandler,Default_Handler
+
+	.weak	ADC1_2_IRQHandler
+	.thumb_set ADC1_2_IRQHandler,Default_Handler
+
+	.weak	USB_HP_CAN1_TX_IRQHandler
+	.thumb_set USB_HP_CAN1_TX_IRQHandler,Default_Handler
+
+	.weak	USB_LP_CAN1_RX0_IRQHandler
+	.thumb_set USB_LP_CAN1_RX0_IRQHandler,Default_Handler
+
+	.weak	CAN1_RX1_IRQHandler
+	.thumb_set CAN1_RX1_IRQHandler,Default_Handler
+
+	.weak	CAN1_SCE_IRQHandler
+	.thumb_set CAN1_SCE_IRQHandler,Default_Handler
+
+	.weak	EXTI9_5_IRQHandler
+	.thumb_set EXTI9_5_IRQHandler,Default_Handler
+
+	.weak	TIM1_BRK_IRQHandler
+	.thumb_set TIM1_BRK_IRQHandler,Default_Handler
+
+	.weak	TIM1_UP_IRQHandler
+	.thumb_set TIM1_UP_IRQHandler,Default_Handler
+
+	.weak	TIM1_TRG_COM_IRQHandler
+	.thumb_set TIM1_TRG_COM_IRQHandler,Default_Handler
+
+	.weak	TIM1_CC_IRQHandler
+	.thumb_set TIM1_CC_IRQHandler,Default_Handler
+
+	.weak	TIM2_IRQHandler
+	.thumb_set TIM2_IRQHandler,Default_Handler
+
+	.weak	TIM3_IRQHandler
+	.thumb_set TIM3_IRQHandler,Default_Handler
+
+	.weak	TIM4_IRQHandler
+	.thumb_set TIM4_IRQHandler,Default_Handler
+
+	.weak	I2C1_EV_IRQHandler
+	.thumb_set I2C1_EV_IRQHandler,Default_Handler
+
+	.weak	I2C1_ER_IRQHandler
+	.thumb_set I2C1_ER_IRQHandler,Default_Handler
+
+	.weak	I2C2_EV_IRQHandler
+	.thumb_set I2C2_EV_IRQHandler,Default_Handler
+
+	.weak	I2C2_ER_IRQHandler
+	.thumb_set I2C2_ER_IRQHandler,Default_Handler
+
+	.weak	SPI1_IRQHandler
+	.thumb_set SPI1_IRQHandler,Default_Handler
+
+	.weak	SPI2_IRQHandler
+	.thumb_set SPI2_IRQHandler,Default_Handler
+
+	.weak	USART1_IRQHandler
+	.thumb_set USART1_IRQHandler,Default_Handler
+
+	.weak	USART2_IRQHandler
+	.thumb_set USART2_IRQHandler,Default_Handler
+
+	.weak	USART3_IRQHandler
+	.thumb_set USART3_IRQHandler,Default_Handler
+
+	.weak	EXTI15_10_IRQHandler
+	.thumb_set EXTI15_10_IRQHandler,Default_Handler
+
+	.weak	RTCAlarm_IRQHandler
+	.thumb_set RTCAlarm_IRQHandler,Default_Handler
+
+	.weak	USBWakeUp_IRQHandler
+	.thumb_set USBWakeUp_IRQHandler,Default_Handler
+
+	.weak	TIM8_BRK_IRQHandler
+	.thumb_set TIM8_BRK_IRQHandler,Default_Handler
+
+	.weak	TIM8_UP_IRQHandler
+	.thumb_set TIM8_UP_IRQHandler,Default_Handler
+
+	.weak	TIM8_TRG_COM_IRQHandler
+	.thumb_set TIM8_TRG_COM_IRQHandler,Default_Handler
+
+	.weak	TIM8_CC_IRQHandler
+	.thumb_set TIM8_CC_IRQHandler,Default_Handler
+
+	.weak	ADC3_IRQHandler
+	.thumb_set ADC3_IRQHandler,Default_Handler
+
+	.weak	FSMC_IRQHandler
+	.thumb_set FSMC_IRQHandler,Default_Handler
+
+	.weak	SDIO_IRQHandler
+	.thumb_set SDIO_IRQHandler,Default_Handler
+
+	.weak	TIM5_IRQHandler
+	.thumb_set TIM5_IRQHandler,Default_Handler
+
+	.weak	SPI3_IRQHandler
+	.thumb_set SPI3_IRQHandler,Default_Handler
+
+	.weak	UART4_IRQHandler
+	.thumb_set UART4_IRQHandler,Default_Handler
+
+	.weak	UART5_IRQHandler
+	.thumb_set UART5_IRQHandler,Default_Handler
+
+	.weak	TIM6_IRQHandler
+	.thumb_set TIM6_IRQHandler,Default_Handler
+
+	.weak	TIM7_IRQHandler
+	.thumb_set TIM7_IRQHandler,Default_Handler
+
+	.weak	DMA2_Channel1_IRQHandler
+	.thumb_set DMA2_Channel1_IRQHandler,Default_Handler
+
+	.weak	DMA2_Channel2_IRQHandler
+	.thumb_set DMA2_Channel2_IRQHandler,Default_Handler
+
+	.weak	DMA2_Channel3_IRQHandler
+	.thumb_set DMA2_Channel3_IRQHandler,Default_Handler
+
+	.weak	DMA2_Channel4_5_IRQHandler
+	.thumb_set DMA2_Channel4_5_IRQHandler,Default_Handler
+
+/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/bsp/boards/vesna/stm32_flash.ld b/bsp/boards/vesna/stm32_flash.ld
new file mode 100644
index 0000000..67d9dda
--- /dev/null
+++ b/bsp/boards/vesna/stm32_flash.ld
@@ -0,0 +1,185 @@
+/*
+*****************************************************************************
+**
+**  File        : stm32_flash.ld
+**
+**  Abstract    : Linker script for STM32F103ZE Device with
+**                512KByte FLASH, 64KByte RAM
+**
+**                Set heap size, stack size and stack location according
+**                to application requirements.
+**
+**                Set memory bank area and size if external memory is used.
+**
+**  Target      : STMicroelectronics STM32
+**
+**  Environment : Atollic TrueSTUDIO(R)
+**
+**  Distribution: The file is distributed as is, without any warranty
+**                of any kind.
+**
+**  (c)Copyright Atollic AB.
+**  You may use this file as-is or modify it according to the needs of your
+**  project. Distribution of this file (unmodified or modified) is not
+**  permitted. Atollic AB permit registered Atollic TrueSTUDIO(R) users the
+**  rights to distribute the assembled, compiled & linked contents of this
+**  file as part of an application binary file, provided that it is built
+**  using the Atollic TrueSTUDIO(R) toolchain.
+**
+*****************************************************************************
+*/
+
+/* Entry Point */
+/* ENTRY(Reset_Handler) */
+
+/* Highest address of the user mode stack */
+_estack = 0x20010000;    /* end of 64K RAM */
+
+/* Generate a link error if heap and stack don't fit into RAM */
+_Min_Heap_Size = 0;      /* required amount of heap  */
+_Min_Stack_Size = 0x200; /* required amount of stack */
+
+/* Specify the memory areas */
+MEMORY
+{
+  FLASH (rx)      : ORIGIN = 0x08000000, LENGTH = 512K
+  RAM (xrw)       : ORIGIN = 0x20000000, LENGTH = 64K
+  /*MEMORY_B1 (rx)  : ORIGIN = 0x60000000, LENGTH = 0K*/
+}
+
+/* Define output sections */
+SECTIONS
+{
+  /* The startup code goes first into FLASH */
+  .isr_vector :
+  {
+    . = ALIGN(4);
+    KEEP(*(.isr_vector)) /* Startup code */
+    . = ALIGN(4);
+  } >FLASH
+
+  /* The program code and other data goes into FLASH */
+  .text :
+  {
+    . = ALIGN(4);
+    *(.text)           /* .text sections (code) */
+    *(.text*)          /* .text* sections (code) */
+    *(.rodata)         /* .rodata sections (constants, strings, etc.) */
+    *(.rodata*)        /* .rodata* sections (constants, strings, etc.) */
+    *(.glue_7)         /* glue arm to thumb code */
+    *(.glue_7t)        /* glue thumb to arm code */
+
+    KEEP (*(.init))
+    KEEP (*(.fini))
+
+    . = ALIGN(4);
+    _etext = .;        /* define a global symbols at end of code */
+  } >FLASH
+
+
+   .ARM.extab   : { *(.ARM.extab* .gnu.linkonce.armextab.*) } >FLASH
+    .ARM : {
+    __exidx_start = .;
+      *(.ARM.exidx*)
+      __exidx_end = .;
+    } >FLASH
+
+  .ARM.attributes : { *(.ARM.attributes) } > FLASH
+
+  .preinit_array     :
+  {
+    PROVIDE_HIDDEN (__preinit_array_start = .);
+    KEEP (*(.preinit_array*))
+    PROVIDE_HIDDEN (__preinit_array_end = .);
+  } >FLASH
+  .init_array :
+  {
+    PROVIDE_HIDDEN (__init_array_start = .);
+    KEEP (*(SORT(.init_array.*)))
+    KEEP (*(.init_array*))
+    PROVIDE_HIDDEN (__init_array_end = .);
+  } >FLASH
+  .fini_array :
+  {
+    PROVIDE_HIDDEN (__fini_array_start = .);
+    KEEP (*(.fini_array*))
+    KEEP (*(SORT(.fini_array.*)))
+    PROVIDE_HIDDEN (__fini_array_end = .);
+  } >FLASH
+
+  /* used by the startup to initialize data */
+  _sidata = .;
+
+  /* Initialized data sections goes into RAM, load LMA copy after code */
+  .data : AT ( _sidata )
+  {
+    . = ALIGN(4);
+    _sdata = .;        /* create a global symbol at data start */
+    *(.data)           /* .data sections */
+    *(.data*)          /* .data* sections */
+
+    . = ALIGN(4);
+    _edata = .;        /* define a global symbol at data end */
+  } >RAM
+
+  /* Uninitialized data section */
+  . = ALIGN(4);
+  .bss :
+  {
+    /* This is used by the startup in order to initialize the .bss secion */
+    _sbss = .;         /* define a global symbol at bss start */
+    __bss_start__ = _sbss;
+    *(.bss)
+    *(.bss*)
+    *(COMMON)
+
+    . = ALIGN(4);
+    _ebss = .;         /* define a global symbol at bss end */
+    __bss_end__ = _ebss;
+  } >RAM
+
+
+  /* User_heap_stack section, used to check that there is enough RAM left */
+  __heap1_size = ORIGIN(RAM) + LENGTH(RAM) - . ;/*- __stack_size;*/
+	.heap1 (NOLOAD) :
+	{
+		PROVIDE(__heap1_start = .);
+		. = . + __heap1_size;
+		PROVIDE(__heap1_max = .);
+	} > RAM
+
+  /*
+  PROVIDE ( end = _ebss );
+  PROVIDE ( _end = _ebss );
+  */
+  /* User_heap_stack section, used to check that there is enough RAM left */
+  /*
+  ._user_heap_stack :
+  {
+    . = ALIGN(4);
+    . = . + _Min_Heap_Size;
+    . = . + _Min_Stack_Size;
+    . = ALIGN(4);
+  } >RAM
+  */
+
+  /* MEMORY_bank1 section, code must be located here explicitly            */
+  /* Example: extern int foo(void) __attribute__ ((section (".mb1text"))); */
+  /*
+  .memory_b1_text :
+  {
+    *(.mb1text)        /* .mb1text sections (code) /
+    *(.mb1text*)       /* .mb1text* sections (code)  /
+    *(.mb1rodata)      /* read-only data (constants) /
+    *(.mb1rodata*)
+  } >MEMORY_B1
+  */
+
+  /* Remove information from the standard libraries */
+  /DISCARD/ :
+  {
+    libc.a ( * )
+    libm.a ( * )
+    libgcc.a ( * )
+  }
+}
diff --git a/bsp/boards/vesna/tools/debug.sh b/bsp/boards/vesna/tools/debug.sh
new file mode 100755
index 0000000..247a504
--- /dev/null
+++ b/bsp/boards/vesna/tools/debug.sh
@@ -0,0 +1,13 @@
+#!/bin/bash
+
+FILE=$(readlink -f "$0")
+BIN_FOLDER=$(dirname "${FILE}")
+
+openocd -f "${BIN_FOLDER}/vesna_jtag.cfg" \
+	-f "target/stm32f1x.cfg" \
+  -c "tcl_port 6333"
+  -c "telnet_port 4444"
+	-c "init" \
+	-c "targets" \
+	-c "reset halt"
+
diff --git a/bsp/boards/vesna/tools/flash.sh b/bsp/boards/vesna/tools/flash.sh
new file mode 100755
index 0000000..d471e93
--- /dev/null
+++ b/bsp/boards/vesna/tools/flash.sh
@@ -0,0 +1,15 @@
+#!/bin/bash
+
+FILE=$(readlink -f "$0")
+BIN_FOLDER=$(dirname "${FILE}")
+
+openocd -f "${BIN_FOLDER}/vesna_jtag.cfg" \
+	-f "target/stm32f1x.cfg" \
+	-c "init" \
+	-c "targets" \
+	-c "reset halt" \
+	-c "reset init" \
+	-c "flash write_image erase $1" \
+	-c "verify_image $1" \
+	-c "reset run"\
+	-c "shutdown"
diff --git a/bsp/boards/vesna/tools/openocd.cfg b/bsp/boards/vesna/tools/openocd.cfg
new file mode 100644
index 0000000..10dcf79
--- /dev/null
+++ b/bsp/boards/vesna/tools/openocd.cfg
@@ -0,0 +1,4 @@
+# openocd.cfg file for STM32F4Discovery board via integrated ST-Link/V2.
+source [find interface/stlink-v2.cfg]
+source [find target/stm32f4x_stlink.cfg]
+reset_config srst_only srst_nogate
diff --git a/bsp/boards/vesna/tools/vesna_jtag.cfg b/bsp/boards/vesna/tools/vesna_jtag.cfg
new file mode 100644
index 0000000..a74b032
--- /dev/null
+++ b/bsp/boards/vesna/tools/vesna_jtag.cfg
@@ -0,0 +1,13 @@
+jtag_khz 1000
+
+# comstick ftdi device
+interface ft2232
+ft2232_layout "usbjtag"
+ft2232_device_desc "FITECO M3"
+ft2232_vid_pid 0x0403 0x6010
+
+jtag_nsrst_delay 100
+jtag_ntrst_delay 100
+
+# use combined on interfaces or targets that can't set TRST/SRST separately
+reset_config trst_and_srst
diff --git a/bsp/boards/vesna/uart.c b/bsp/boards/vesna/uart.c
new file mode 100644
index 0000000..32fd4d2
--- /dev/null
+++ b/bsp/boards/vesna/uart.c
@@ -0,0 +1,142 @@
+/**
+\brief iot-lab_M3 definition of the "uart" bsp module (based on openmoteSTM32 code).
+
+\author Chang Tengfei <tengfei.chang@gmail.com>,  July 2012.
+\author Alaeddine Weslati <alaeddine.weslati@inria.fr>,  January 2014.
+*/
+
+#include "stm32f10x_lib.h"
+#include "stdio.h"
+#include "stdint.h"
+#include "string.h"
+#include "uart.h"
+#include "leds.h"
+
+#include "rcc.h"
+#include "nvic.h"
+
+//=========================== defines =========================================
+
+//=========================== variables =======================================
+
+typedef struct {
+   uart_tx_cbt txCb;
+   uart_rx_cbt rxCb;
+   uint8_t     startOrend;
+   uint8_t     flagByte;
+} uart_vars_t;
+
+volatile uart_vars_t uart_vars;
+
+//=========================== prototypes ======================================
+
+//=========================== public ==========================================
+
+void uart_init()
+{
+  // reset local variables
+  memset(&uart_vars,0,sizeof(uart_vars_t));
+
+  //when this value is 0, we are send the first data
+  uart_vars.startOrend = 0;
+  //flag byte for start byte and end byte
+  uart_vars.flagByte = 0x7E;
+
+  GPIO_InitTypeDef GPIO_InitStructure;
+  USART_InitTypeDef USART_InitStructure;
+
+  /* Enable GPIO clock */
+  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
+
+  RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
+
+  /* Configure USART Tx as alternate function push-pull */
+  GPIO_InitStructure.GPIO_Mode            = GPIO_Mode_AF_PP;
+  GPIO_InitStructure.GPIO_Pin             = GPIO_Pin_9;
+  GPIO_InitStructure.GPIO_Speed           = GPIO_Speed_50MHz;
+  GPIO_Init(GPIOA, &GPIO_InitStructure);
+
+  /* Configure USART Rx as input floating */
+  GPIO_InitStructure.GPIO_Mode            = GPIO_Mode_IN_FLOATING;
+  GPIO_InitStructure.GPIO_Pin             = GPIO_Pin_10;
+  GPIO_Init(GPIOA, &GPIO_InitStructure);
+
+  USART_InitStructure.USART_BaudRate              = 500000;
+  USART_InitStructure.USART_WordLength            = USART_WordLength_8b;
+  USART_InitStructure.USART_StopBits              = USART_StopBits_1;
+  USART_InitStructure.USART_Parity                = USART_Parity_No;
+  USART_InitStructure.USART_HardwareFlowControl   = USART_HardwareFlowControl_None;
+  USART_InitStructure.USART_Mode                  = USART_Mode_Rx | USART_Mode_Tx;
+  USART_Init(USART1, &USART_InitStructure);
+
+  USART_Cmd(USART1, ENABLE); // enable USART1
+}
+
+void uart_setCallbacks(uart_tx_cbt txCb, uart_rx_cbt rxCb)
+{
+  uart_vars.txCb = txCb;
+  uart_vars.rxCb = rxCb;
+
+  //enable nvic uart.
+  NVIC_uart();
+}
+
+void uart_enableInterrupts()
+{
+  USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
+}
+
+void uart_disableInterrupts()
+{
+  USART_ITConfig(USART1, USART_IT_TXE, DISABLE);
+  USART_ITConfig(USART1, USART_IT_RXNE, DISABLE);
+}
+
+void uart_clearRxInterrupts()
+{
+  USART_ClearFlag(USART1, USART_FLAG_RXNE);
+}
+
+void uart_clearTxInterrupts()
+{
+  USART_ClearFlag(USART1, USART_FLAG_TXE);
+}
+
+void uart_writeByte(uint8_t byteToWrite)
+{
+  USART_SendData(USART1, byteToWrite);
+  while(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
+
+  //start or end byte?
+  if(byteToWrite == uart_vars.flagByte) {
+    uart_vars.startOrend = (uart_vars.startOrend == 0)?1:0;
+    //start byte
+    if(uart_vars.startOrend == 1) {
+      USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
+    } else {
+      USART_ITConfig(USART1, USART_IT_TXE, DISABLE);
+    }
+  }
+}
+
+uint8_t uart_readByte()
+{
+  uint16_t temp;
+  temp = USART_ReceiveData(USART1);
+  return (uint8_t)temp;
+}
+
+//=========================== interrupt handlers ==============================
+
+kick_scheduler_t uart_tx_isr()
+{
+  uart_vars.txCb();
+  return DO_NOT_KICK_SCHEDULER;
+}
+
+kick_scheduler_t uart_rx_isr()
+{
+  uart_vars.rxCb();
+  return DO_NOT_KICK_SCHEDULER;
+}
+
diff --git a/projects/vesna/.gitignore b/projects/vesna/.gitignore
new file mode 100644
index 0000000..5c644e1
--- /dev/null
+++ b/projects/vesna/.gitignore
@@ -0,0 +1 @@
+*/build
diff --git a/projects/vesna/01bsp_bsp_timer/Makefile b/projects/vesna/01bsp_bsp_timer/Makefile
new file mode 100644
index 0000000..a40a069
--- /dev/null
+++ b/projects/vesna/01bsp_bsp_timer/Makefile
@@ -0,0 +1,50 @@
+PROJECT		:= 01bsp_bsp_timer
+#===============================================================================
+
+OPENOS_DIR	:= ../../../
+BSP_DIR		:= $(OPENOS_DIR)/bsp/boards/vesna/
+
+#===============================================================================
+
+SRC_DIRS	= $(OPENOS_DIR)/projects/common/01bsp_bsp_timer
+
+#===============================================================================
+
+SRC_DIRS	+= $(OPENOS_DIR)/drivers/common
+
+SRC_DIRS	+= $(OPENOS_DIR)/kernel/openos
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn
+
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/cross-layers
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/02a-MAClow
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/02b-MAChigh
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/03a-IPHC
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/03b-IPv6
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/04-TRAN
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/rreg
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/rwellknown
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/rinfo
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/rleds
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/r6t
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/tcpinject
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udpinject
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/ohlone
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/tcpecho
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/tcpprint
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udpecho
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udpprint
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/tcprand
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udprand
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udpstorm
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udplatency
+
+#===============================================================================
+
+include $(BSP_DIR)/Makefile
diff --git a/projects/vesna/01bsp_leds/Makefile b/projects/vesna/01bsp_leds/Makefile
new file mode 100644
index 0000000..fb8c0db
--- /dev/null
+++ b/projects/vesna/01bsp_leds/Makefile
@@ -0,0 +1,50 @@
+PROJECT		:= 01bsp_leds
+#===============================================================================
+
+OPENOS_DIR	:= ../../../
+BSP_DIR		:= $(OPENOS_DIR)/bsp/boards/vesna/
+
+#===============================================================================
+
+SRC_DIRS	= $(OPENOS_DIR)/projects/common/01bsp_leds
+
+#===============================================================================
+
+SRC_DIRS	+= $(OPENOS_DIR)/drivers/common
+
+SRC_DIRS 	+= $(OPENOS_DIR)/kernel/openos
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn
+
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/cross-layers
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/02a-MAClow
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/02b-MAChigh
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/03a-IPHC
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/03b-IPv6
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/04-TRAN
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/rreg
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/rwellknown
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/rinfo
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/rleds
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/r6t
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/tcpinject
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udpinject
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/ohlone
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/tcpecho
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/tcpprint
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udpecho
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udpprint
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/tcprand
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udprand
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udpstorm
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udplatency
+
+#===============================================================================
+
+include $(BSP_DIR)/Makefile
diff --git a/projects/vesna/01bsp_radio_tx/Makefile b/projects/vesna/01bsp_radio_tx/Makefile
new file mode 100644
index 0000000..639084d
--- /dev/null
+++ b/projects/vesna/01bsp_radio_tx/Makefile
@@ -0,0 +1,46 @@
+PROJECT		:= 01bsp_radio_tx
+#===============================================================================
+
+OPENOS_DIR	:= ../../../
+BSP_DIR		:= $(OPENOS_DIR)/bsp/boards/vesna/
+
+#===============================================================================
+
+SRC_DIRS	= $(OPENOS_DIR)/projects/common/01bsp_radio_tx
+
+SRC_DIRS	+= $(OPENOS_DIR)/drivers/common
+SRC_DIRS	+= $(OPENOS_DIR)/kernel/openos
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/cross-layers
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/02a-MAClow
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/02b-MAChigh
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/03a-IPHC
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/03b-IPv6
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/04-TRAN
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/rreg
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/rwellknown
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/rinfo
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/rleds
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/r6t
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/tcpinject
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udpinject
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/ohlone
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/tcpecho
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/tcpprint
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udpecho
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udpprint
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/tcprand
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udprand
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udpstorm
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udplatency
+
+#===============================================================================
+
+include $(BSP_DIR)/Makefile
diff --git a/projects/vesna/01bsp_radiotimer/Makefile b/projects/vesna/01bsp_radiotimer/Makefile
new file mode 100644
index 0000000..1c6ad4d
--- /dev/null
+++ b/projects/vesna/01bsp_radiotimer/Makefile
@@ -0,0 +1,50 @@
+PROJECT		:= 01bsp_radiotimer
+#===============================================================================
+
+OPENOS_DIR	:= ../../../
+BSP_DIR		:= $(OPENOS_DIR)/bsp/boards/vesna/
+
+#===============================================================================
+
+SRC_DIRS	= $(OPENOS_DIR)/projects/common/01bsp_radiotimer
+
+#===============================================================================
+
+SRC_DIRS	+= $(OPENOS_DIR)/drivers/common
+
+SRC_DIRS	+= $(OPENOS_DIR)/kernel/openos
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn
+
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/cross-layers
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/02a-MAClow
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/02b-MAChigh
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/03a-IPHC
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/03b-IPv6
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/04-TRAN
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/rreg
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/rwellknown
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/rinfo
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/rleds
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/r6t
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/tcpinject
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udpinject
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/ohlone
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/tcpecho
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/tcpprint
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udpecho
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udpprint
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/tcprand
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udprand
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udpstorm
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udplatency
+
+#===============================================================================
+
+include $(BSP_DIR)/Makefile
diff --git a/projects/vesna/01bsp_uart/Makefile b/projects/vesna/01bsp_uart/Makefile
new file mode 100644
index 0000000..9673fd0
--- /dev/null
+++ b/projects/vesna/01bsp_uart/Makefile
@@ -0,0 +1,13 @@
+PROJECT		:= 01bsp_uart
+#===============================================================================
+
+OPENOS_DIR	:= ../../../
+BSP_DIR		:= $(OPENOS_DIR)/bsp/boards/vesna/
+
+#===============================================================================
+
+SRC_DIRS	= $(OPENOS_DIR)/projects/common/01bsp_uart
+
+#===============================================================================
+
+include $(BSP_DIR)/Makefile
diff --git a/projects/vesna/02drv_opentimers/Makefile b/projects/vesna/02drv_opentimers/Makefile
new file mode 100644
index 0000000..81a2008
--- /dev/null
+++ b/projects/vesna/02drv_opentimers/Makefile
@@ -0,0 +1,49 @@
+PROJECT		:= 02drv_opentimers
+#===============================================================================
+
+OPENOS_DIR	:= ../../../
+BSP_DIR		:= $(OPENOS_DIR)/bsp/boards/vesna/
+
+#===============================================================================
+
+SRC_DIRS	= $(OPENOS_DIR)/projects/common/02drv_opentimers
+
+#===============================================================================
+
+SRC_DIRS	+= $(OPENOS_DIR)/drivers/common
+
+SRC_DIRS	+= $(OPENOS_DIR)/kernel/openos
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/cross-layers
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/02a-MAClow
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/02b-MAChigh
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/03a-IPHC
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/03b-IPv6
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/04-TRAN
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/rreg
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/rwellknown
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/rinfo
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/rleds
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/r6t
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/tcpinject
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udpinject
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/ohlone
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/tcpecho
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/tcpprint
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udpecho
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udpprint
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/tcprand
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udprand
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udpstorm
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udplatency
+
+#===============================================================================
+
+include $(BSP_DIR)/Makefile
diff --git a/projects/vesna/03oos_openwsn/Makefile b/projects/vesna/03oos_openwsn/Makefile
new file mode 100644
index 0000000..bc43417
--- /dev/null
+++ b/projects/vesna/03oos_openwsn/Makefile
@@ -0,0 +1,47 @@
+PROJECT		:= 03oos_openwsn
+#===============================================================================
+
+OPENOS_DIR	:= ../../../
+BSP_DIR		:= $(OPENOS_DIR)/bsp/boards/vesna/
+
+#===============================================================================
+
+SRC_DIRS	= $(OPENOS_DIR)/projects/common/03oos_openwsn
+
+SRC_DIRS	+= $(OPENOS_DIR)/drivers/common
+
+SRC_DIRS	+= $(OPENOS_DIR)/kernel/openos
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/cross-layers
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/02a-MAClow
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/02b-MAChigh
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/03a-IPHC
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/03b-IPv6
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/04-TRAN
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/rreg
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/rwellknown
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/rinfo
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/rleds
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/r6t
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/tcpinject
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udpinject
+
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/ohlone
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/tcpecho
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/tcpprint
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udpecho
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udpprint
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/tcprand
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udprand
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udpstorm
+SRC_DIRS 	+= $(OPENOS_DIR)/openwsn/07-App/udplatency
+
+#===============================================================================
+
+include $(BSP_DIR)/Makefile
diff --git a/projects/vesna/SConscript b/projects/vesna/SConscript
new file mode 100644
index 0000000..c153947
--- /dev/null
+++ b/projects/vesna/SConscript
@@ -0,0 +1,5 @@
+import os
+
+Import('env')
+
+env.SconscriptScanner()
diff --git a/projects/vesna/SConscript.env b/projects/vesna/SConscript.env
new file mode 100644
index 0000000..6f73ecb
--- /dev/null
+++ b/projects/vesna/SConscript.env
@@ -0,0 +1,29 @@
+import os
+
+Import('env')
+
+# create build environment
+buildEnv = env.Clone()
+
+# inherit environment from user (PATH, etc)
+buildEnv['ENV'] = os.environ
+
+# choose bsp. Normally this would be the same as the board name,
+# however, there are cases where one might want to make separate build
+# configuration for the same board.
+buildEnv['BSP'] = buildEnv['board']
+
+bsp_dir = os.path.join('#','bsp','boards',buildEnv['board'])
+
+# include board/bsp-specific directories
+buildEnv.Append(
+   CPPPATH = [
+      bsp_dir,
+      os.path.join(bsp_dir,'library','STM32F10x_StdPeriph_Lib_V3.5.0','Libraries','STM32F10x_StdPeriph_Driver','inc'),
+      os.path.join(bsp_dir,'library','STM32F10x_StdPeriph_Lib_V3.5.0','Libraries','CMSIS','CM3','DeviceSupport','ST','STM32F10x'),
+      os.path.join(bsp_dir,'library','STM32F10x_StdPeriph_Lib_V3.5.0','Libraries','CMSIS','CM3','CoreSupport'),
+      os.path.join(bsp_dir,'configure'),
+   ]
+)
+
+Return('buildEnv')
--
1.9.3 (Apple Git-50)

